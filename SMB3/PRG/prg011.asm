; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
PRG011_A000:
	.byte $00, $01, $02, $03, $04, $05, $06, $07

Map_Unused7EEA_Vals:
	; LUT indexed by world number with no apparent use?
	.byte $02, $04, $03, $FF, $03, $04, $03, $05

	; This sets up the world map objects


PRG011_A1C8:
	.byte $03, $04, $05, $01, $03, $05, $01, $01
	.byte $00, $00, $00, $00, $00, $00, $00, $00

Check_Save:
	JSR Generate_SaveChecksum
	LDA <Temp_Var1
	ORA <Temp_Var2
	BEQ Checksum_Invalid

	LDA <Temp_Var1
	CMP Save_Ram_CheckSum
	BNE Checksum_Invalid

	LDA <Temp_Var2
	CMP Save_Ram_CheckSum + 1
	BNE Checksum_Invalid
 
	LDY #(Player_Stats_Boundary_End - Player_Stats_Boundary_Start)

LoadSave_Loop:
	LDA Save_Ram_Boundary_Start, Y
	STA Player_Stats_Boundary_Start, Y
	DEY
	BPL LoadSave_Loop

	SEC
	RTS

Checksum_Invalid:
	CLC
	RTS


Load_Save:
	JSR Check_Save
	BCS Map_Init
	
	LDX #$00

	LDA #$01
	STA World_Num

	LDA #$90
	STA Map_Entered_Y
	STA Map_Previous_Y
	
	LDA #$00
	STA Map_Entered_XHi

	; Set starting X position (forced to $20!)
	LDA #$20
	STA Map_Entered_X
	STA Map_Previous_X

	LDA #$FF
	STA SecondQuest

	LDA #$01
	STA Map_Previous_Dir

	LDA #$00
	STA Map_Prev_XOff2
	STA Map_Prev_XHi2
	STA Map_Prev_XOff
	STA Map_Prev_XHi

Map_Init:
	JSR World_Override
	RTS		 ; Return

World_Start_X:
	.byte $00, $20, $20, $30, $10, $20, $20, $30

World_Start_Y:
	.byte $00, $90, $40, $60, $70, $50, $50, $90

World_Start_Num:
	.byte $00, $10, $20, $30, $40, $50, $60, $70

World_Override:
	STA Debug_Snap
	LDX World_Start
	BEQ World_OverrideRTS

	LDA World_Start_X, X
	STA Map_Entered_X
	STA Map_Previous_X

	LDA World_Start_Y, X
	STA Map_Entered_Y
	STA Map_Previous_Y

	LDA #$00
	STA Map_Entered_XHi
	STA Map_Previous_XHi

	STX World_Num

World_OverrideRTS:
	RTS

Map_Airship_Travel_BaseIdx:
	; Base index value, per-world
	;      W1   W2   W3   W4   W5   W6   W7   W8
	.byte $00, $03, $06, $09, $0C, $0F, $12, $15

Map_Airship_Travel_Random:
	; Randomly selected offsets
	.byte $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00


	; At the beginning of the world, this randomly selects a set of travel destinations the airship will take, six defined per set.
Map_Airship_Pick_Travel:
	LDY World_Num		; Y = World_Num
	LDA RandomN		; A = random
	AND #$0f		; Capped 0-15
	TAX			; X = random number 0-15
	LDA Map_Airship_Travel_Random,X		; Get initial random offset value (essentially amounts to a random value of 0 to 2)
	ADD Map_Airship_Travel_BaseIdx,Y	; Apply base index (Adds 3x World_Num)
	STA Map_Airship_Trav	; Store as the Map_Airship_Trav value
	RTS		 	; Return


	; Offset to Player-specific inventory items


PRG011_A2C8:
	LDX Map_Unused738	 ; X = Map_Unused738

	; Seems Map_Unused7DC6 was pretty interesting once?
	;LDA Map_Unused7DC6,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_B74A		; 0
	.word WorldMap_UpdateAndDrawInd	; 1
	.word WorldMap_UpdateAndDrawInd	; 2
	.word WorldMap_UpdateAndDrawInd	; 3
	.word WorldMap_UpdateAndDrawInd	; 4
	.word PRG011_B74A		; 5
	.word WorldMap_UpdateAndDrawInd	; 6
	.word Map_DoMap_WarpWind_FX	; 7
	.word WorldMap_UpdateAndDrawInd	; 8
	.word WorldMap_UpdateAndDrawInd	; 9
	.word PRG011_B74A		; 10
	.word PRG011_B74A		; 11
	.word PRG011_B74A		; 12
	.word PRG011_B74A		; 13
	.word PRG011_B74A		; 14
	.word PRG011_B74A		; 15

WorldMap_UpdateAndDrawInd:
	JMP WorldMap_UpdateAndDraw

Map_WW_StartX:	.byte 0, 240	; Map warp wind starting X position, depending which direction it comes from
Map_WW_DeltaX:	.byte 2, -2	; Position change depending on the direction of travel
Map_WW_TargetX:	.byte 240, 0	; The ending position, depending on direction of travel

	; Starting Y position depending on what world you came from
Map_WW_IslandY:
	.byte $50, $70, $70	; World 1 - 3
	.byte $70, $70, $70	; World 4 - 6
	.byte $90, $90, $90	; World 7 - 9

	; Unused?  Guessing this was possible X Hi init values,
	; though always zero (maybe there would've been multiple
	; islands?  Per group of worlds?)
	.byte $00, $00, $00	; World 1 - 3
	.byte $00, $00, $00	; World 4 - 6
	.byte $00, $00, $00	; World 7 - 9

	; Starting X position depending on what world you came from
Map_WW_IslandX:
	.byte $40, $40, $40	; World 1 - 3
	.byte $40, $40, $40	; World 4 - 6
	.byte $80, $80, $80  	; World 7 - 9


Map_DoMap_WarpWind_FX:

	; Note: In original Japanese version, you could warp from a canoe and then
	; sail yourself off the warp island (but never get back on!)  This fixes 
	; that bug with a vengeance, since it will be called several times :)
	LDA #$00	 	
	STA Map_InCanoe_Flag	; Map_InCanoe_Flag = 0 (not in canoe)

	; NOTE: If Map_WarpWind_FX = 0,  Map_DoMap_WarpWind_FX is never called,
	; so state 0 is technically never used... that's okay, it actually
	; contains a "bug", which might just be unmaintained legacy code..

	; Dynamic jump based on current map special effect occurring..
	LDA <Map_WarpWind_FX	
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word WWFX_WarpWhistleInit	; 0 - Initializes the warp whistle (NEVER USED, Inv_UseItem_WarpWhistle does this instead)
	.word WWFX_WarpWhistleFlash	; 1 - Does the "flash" effect of the whistle
	.word WWFX_WarpDoWind		; 2 - Does the wind effect, catches the Player, sets World_Num = 8 (World 9), and clears map objects
	.word WWFX_WarpIslandInit	; 3 - Initialize stuff for the warp island, including setting proper Player X/Y position
	.word WWFX_WarpLanding		; 4 - Does the wind effect, drops Player off
	.word WWFX_WarpWhistleFlash	; 5 - UNUSED; same as State 1, except it will crash by trying to go to undefined "State 6"!

WarpWhistle_Flash:
	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A333	 	; If Map_WWOrHT_Cnt <> 0, jump to PRG011_A333

	LDA #$20	 
	STA <Map_WWOrHT_Cnt	; Otherwise, Map_WWOrHT_Cnt = $20


PRG011_A333:

	; Basically here's what does the white flashing effect
	LDY #%00011000		; Show BG + Sprites
	DEC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt--
	AND #$04	 
	BEQ PRG011_A33D	 	; Every 4 ticks, toggle mono effect
	LDY #%00011001		; Show BG + Sprites + Mono

PRG011_A33D:
	STY <PPU_CTL2_Copy	; Update
	RTS		 	; Return...

WWFX_WarpWhistleInit:

	; *** WWFX_WarpWhistleInit is NEVER USED, Inv_UseItem_WarpWhistle does this instead!

	LDY Player_Current	; Y = Player_Current
	LDX #$00	 	; X = 0 (come from left)
	LDA World_Map_X,Y	; Get Player's world map X coordinate
	SUB <Horz_Scroll
	CMP #$80	 	
	BGE PRG011_A351	 	; If map is scrolled halfway across, jump to PRG011_A351
	LDX #$01	 	; Otherwise X = 1 (come from right)

PRG011_A351:
	STX <Map_WWOrHT_Dir	; Store 'X' as direction of warp wind travel

	LDA Map_WW_StartX,X
	STA <Map_WWOrHT_X	; Set appropriate starting X position

	LDA World_Map_Y,Y	
	STA <Map_WWOrHT_Y	; Set Y position equal to Player
	STA Map_PlyrSprOvrY	; Set Map_PlyrSprOvrY 

	LDX #$05	 	; X = 5 NOTE: This is broken (and seems unused anyway); see NOTE @ PRG011_A381

	LDA Map_WW_Backup_Y	; Load the backed up Y position
	BNE PRG011_A381	 	; If its non-zero, jump to PRG011_A381

	; Otherwise, we need to back up everything!  (Y is the only one that absolutely could not be zero)
	; But I don't know why?
	LDA World_Map_Y,Y
	STA Map_WW_Backup_Y	; Store Player's map Y position

	LDA World_Map_X,Y	
	STA Map_WW_Backup_X	; Store Player's map X position

	LDA World_Map_XHi,Y	
	STA Map_WW_Backup_XH	; Store Player's map X Hi position

	LDA Map_UnusedPlayerVal2,Y	
	STA Map_WW_Backup_UPV2	; Store Player's Map_WW_Backup_UPV2

	LDX #$01	 	; X = 1

PRG011_A381:
	; NOTE: There's an alternate state 5 here that by the jump table is the same
	; as state 1, in theory if it flashes after the backup has already been performed.
	; Couple of problems: Why the backup already be performed?  And the other
	; problem is there's nothing after state 5, yet the state code will blindly
	; increment the state when it finishes, resulting in a crash!
	; I'm thinking that's some kind of lost state for something else?

	; But that's okay, because technically this routine isn't used anyway! :X

	STX <Map_WarpWind_FX		; Map_WarpWind_FX = ... 5 if backup already performed, 1 if not 
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


WWFX_WarpWhistleFlash:
	LDA Sound_QMusic2
	CMP #MUS2A_WARPWHISTLE	 
	BEQ PRG011_A396	 		; If Sound_QMusic2 <> MUS2A_WARPWHISTLE, jump to PRG011_A396

	JSR WarpWhistle_Flash		; Do the "flash" effect of the warp whistle

	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A396	 		; If the counter isn't zero yet, jump to PRG011_A396

	INC <Map_WarpWind_FX		; Otherwise, next state!

PRG011_A396:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


WWFX_WarpDoWind:
	INC <Map_WWOrHT_Cnt		; Map_WWOrHT_Cnt++

	LDY Player_Current	 	; Y = Player_Current
	LDX <Map_WWOrHT_Dir		; X = Map_WWOrHT_Dir

	LDA <Map_WWOrHT_X
	ADD Map_WW_DeltaX,X
	STA <Map_WWOrHT_X		; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

	LDA World_Map_X,Y
	SUB <Horz_Scroll
	CMP <Map_WWOrHT_X
	BNE PRG011_A3BA	 		; If warp wind hasn't hit the Player yet, jump to PRG011_A3BA

	LDA #$f8
	STA Map_PlyrSprOvrY	 	; Map_PlyrSprOvrY = $F8 (will erase Player's map sprite)
	JMP PRG011_A3D9	 		; Jump to PRG011_A3D9...

PRG011_A3BA:
	; Haven't hit the Player yet...
	LDA <Map_WWOrHT_X		
	CMP Map_WW_TargetX,X
	BNE PRG011_A3D9	 		; If Warp Wind hasn't reached its target edge yet, jump to PRG011_A3D9

	LDA World_Num	 	
	STA Map_Warp_PrevWorld	 	; Map_Warp_PrevWorld = World_Num (where you're coming FROM)

	LDA #$08	 
	STA World_Num	 		; World_Num = 8 (World 9)

	; Clears out map objects 
	LDY #(MAPOBJ_TOTAL-1) ; Y = (MAPOBJ_TOTAL-1)
	LDA #MAPOBJ_EMPTY ; A = MAPOBJ_EMPTY
PRG011_A3D0:
	STA Map_Objects_IDs,Y
	DEY		 ; Y--
	BPL PRG011_A3D0	 ; If Y >= 0, loop..

	INC <Map_WarpWind_FX		; Next state...
	RTS		 ; Return

PRG011_A3D9:
	JSR WorldMap_UpdateAndDraw	; Update and draw map

	LDA <Map_WWOrHT_X
	STA <Temp_Var2			; Temp_Var2 = Map_WWOrHT_X

	LDA #$01
	STA <Temp_Var3		 	; Temp_Var3 = 1 (uses palette 1, the white color; otherwise would use hand trap stuff)

	JMP WarpWindHandTrap_Draw	 		; Jump to WarpWindHandTrap_Draw...


WWFX_WarpIslandInit:
	LDA #$00
	STA <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt = 0

	LDA #248
	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248 (overwritten further down... oops?)
	INC <Map_WarpWind_FX	; Next state...

	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld
	LDX Player_Current	; X = Map_Warp_PrevWorld

	; Clears all map X related variables
	LDA #$00
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X
	STA <World_Map_XHi,X

	LDA Map_WW_IslandX,Y
	STA <World_Map_X,X	; Store appropriate X coordinate based on world you came from

	LDA #240
LT0:	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 240 (oops, reassigned?)

	LDA Map_WW_IslandY,Y
	STA <Map_WWOrHT_Y	; Store appropriate Y coordinate based on world you came from

	LDA #$80	 
	STA Map_Intro_Tick	; Map_Intro_Tick = $80

	LDA #$01	
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 3 (??)

	RTS		 ; Return

WWFX_WarpLanding:
	LDA #$00	 
	STA Map_ReturnStatus 	; Map_ReturnStatus = 0 (was just set to 3?)

	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (reassigned not two instructions later!)
	LDX Player_Current	; X = Player_Current

	INC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt++

	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (assigned again??)
	LDX <Map_WWOrHT_Dir	; X = Map_WWOrHT_Dir

	LDA <Map_WWOrHT_X
	ADD Map_WW_DeltaX,X	; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

	STA <Map_WWOrHT_X
	CMP Map_WW_IslandX,Y
	BNE PRG011_A44C	 	; If wind hasn't reached your landing point, jump to PRG011_A44C

	LDX Player_Current	; X = Player_Current

	LDA Map_WW_IslandY,Y
	STA Map_PlyrSprOvrY	; Map_PlyrSprOvrY = Map_WW_IslandY[Y] (target Y) (restore map sprite)
	STA <World_Map_Y,X	; World_Map_Y = Map_WW_IslandY[Y] (target Y)

	JMP PRG011_A45B	 	; Jump to PRG011_A45B

PRG011_A44C:
	; Wind hasn't reached landing point... (or is passed it already, as the case may be)

	CMP Map_WW_TargetX,X
	BNE PRG011_A45B	 	; If warp wind hasn't hit the appropriate edge, jump to PRG011_A45B

	; Otherwise, shut it down!
	LDA #$00	 
	STA <Map_WWOrHT_Cnt
	STA <Map_WarpWind_FX

	LDA #248
	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248

PRG011_A45B:
	JMP PRG011_A3D9	 ; Jump to PRG011_A3D9


MO_HandTrap:
	LDA Map_HandState
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word HT_Init
	.word HT_Flash
	.word HT_GrabPlayer

HT_Init:
	LDX Player_Current
	LDA <World_Map_Y,X
	STA Map_PlyrSprOvrY	; Reset Map_PlyrSprOvrY to the Player's current Y

	ADD #16
	STA <Map_WWOrHT_Y	; Start 16 pixels beneath Player

	; Match Player's X
	LDA <World_Map_XHi,X	 
	STA <Map_HandTrap_XHi	
	LDA <World_Map_X,X
	STA <Map_WWOrHT_X

	INC Map_HandState		; Next state...
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

HT_Flash:
	JSR WarpWhistle_Flash	 	; Reused flashing effect

	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A494	 		; If Map_WWOrHT_Cnt <> 0, the effect is not over, jump to PRG011_A494

	INC Map_HandState	 	; Next state...

	LDA #SND_LEVELRISE	 
	STA Sound_QLevel1		; "Rising" sound

PRG011_A494:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


HT_GrabPlayer:
	LDA #$01
	STA <Temp_Var1			; Temp_Var1 = 1

	JSR HT_DoRaiseAndFall	 	; Raise hand, take Player down with it

	LDA <Map_WWOrHT_Cnt
	CMP #32 
	BNE PRG011_A4B8	 		; If Map_WWOrHT_Cnt <> 32, jump to PRG011_A4B8

	LDA #$10
	STA Map_Operation	 	; Map_Operation = $10 (enter level)

	LDX Player_Current
	LDA #$00	 
	STA Map_Player_SkidBack,X	; Map_Player_SkidBack = 0
	STA World_EnterState		; World_EnterState = 0
	STA Map_HandState	 	; The multipurpose state variable is reset
	RTS		 		; Return...


PRG011_A4B8:
	JSR WorldMap_UpdateAndDraw	; Do WorldMap_UpdateAndDraw

	LDX Player_Current
	LDA <World_Map_Y,X
	ADD #16
	STA <Temp_Var1		 	; Temp_Var1 = Player's map Y + 16

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	STA <Temp_Var2		 	; Temp_Var2 = Player's map X - Horz_Scroll

	LDA #$00
	STA <Temp_Var3		 	; Temp_Var3 = 0
	JMP PRG011_A503	 		; Jump to PRG011_A503

	; Hand Trap raises for 16 ticks (-1), then falls (1)
HT_RaiseFall:	.byte -1, 1

HT_DoRaiseAndFall:
	LDA <Counter_1
	AND #$01	
	BNE PRG011_A4FC	 	; Every other tic, jump to PRG011_A4FC

	; More specifically, 16 tics for the hand to come up, 16
	; tics for the hand to go down...
	LDA <Map_WWOrHT_Cnt
	AND #$10	 	; Every 16 counter tics...
	LSR A	
	LSR A	
	LSR A	
	LSR A		 	; Amounts to 0/1 every 16 tics
	TAY		 	; Y = 0 or 1
	LDX Player_Current	; X = Player_Current

	LDA <Map_WWOrHT_Y
	ADD HT_RaiseFall,Y
	STA <Map_WWOrHT_Y	; Hand trap's Y += HT_RaiseFall[Y]

	INC <Map_WWOrHT_Cnt
	LDA <Map_WWOrHT_Cnt
	AND #$10
	BEQ PRG011_A4FC	 	; If hand is still raising (pre 16 ticks), jump to PRG011_A4FC

	; As hand falls, it takes Player down with it!
	LDA <Map_WWOrHT_Y	
	STA Map_PlyrSprOvrY	

PRG011_A4FC:
	RTS		 	; Return...

	; NOTE: These values are shared with the HAND TRAP of World 8
Map_WW_Pal:	.byte $01, $03	; The former is a BROWN color (hand trap), the latter is its white color
Map_WW_Pattern:
	.byte $59, $51	; Frame 0 (Hand, Wind)
	.byte $5D, $55	; Frame 1 (Hand, Wind)

PRG011_A503:

	; This masks the bottom of the hand by deliberately drawing 8 junk sprites
	; 16 pixels beneath it to force the hardware to stop drawing at that 
	; scanline; it's dirty, but effective -- so long as no other sprites
	; are on that scanline to be noticeably effected :)
	LDX #$07	 ; X = 7
PRG011_A505:
	TXA		 
	ASL A		 
	ASL A		 
	TAY		 	; Y = X << 2 (* 4, or for 7 sprites...)

	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y	; Store Y

	LDA #$27	 
	STA Sprite_RAM+$01,Y	; Pattern

	LDA #%00100011
	STA Sprite_RAM+$02,Y	; Place sprite behind BG, flipped horizontally and vertically

	LDA #$00	 
	STA Sprite_RAM+$03,Y	; X = 0

	DEX		 	; X--
	BPL PRG011_A505	 	; While X >= 0, loop!

WarpWindHandTrap_Draw:
	LDX <Temp_Var3		; X = Temp_Var3 (warp wind palette)

	; The warp wind sprite Y
	LDA <Map_WWOrHT_Y	; A = Map_WWOrHT_Y
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64

	LDA <Temp_Var3		; A = Temp_Var3
	BEQ PRG011_A544	 	; If Temp_Var3 = 0, jump to PRG011_A544 (AFAIK, this is never the case)

	LDA Map_PlyrSprOvrY
	CMP #$f8
	BNE PRG011_A56B	 	; If Map_PlyrSprOvrY <> $f8, jump to PRG011_A56B

	; Disable Player map sprite!
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90

	JMP PRG011_A56B	 	; Jump to PRG011_A56B...

PRG011_A544:
	; Otherwise, not disabling Player map sprite...

	LDA <Map_WWOrHT_Cnt
	AND #$10
	BEQ PRG011_A56B

	; Restore Player's map sprite Y
	LDA Map_PlyrSprOvrY
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90
	SUB #16
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

	LDA Sprite_RAM+$85
	CMP #$27	 
	BNE PRG011_A56B	 	; If the pattern in use is not $27, jump to PRG011_A56B

	; Otherwise, disable half the sprite
	LDA #$f8	 
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

PRG011_A56B:
	; Set the warp wind's attributes (white palette)
	LDA Map_WW_Pal,X
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	; Set the warp wind's X
	LDA <Temp_Var2		; Map_WWOrHT_X
	STA Sprite_RAM+$63
	ADD #$08	 
	STA Sprite_RAM+$67	; Map_WWOrHT_X + 8

	LDY Map_WW_Pattern,X	; Get the pattern for the wind/hand

	LDA <Map_WWOrHT_Cnt
	AND #$10	 
	BEQ PRG011_A58B	 
	LDY Map_WW_Pattern+2,X	; Every 16 tics, use the second frame

PRG011_A58B:
	; Store the pattern for the first sprite
	STY Sprite_RAM+$61

	INY	
	INY			; Pattern += 2
	STY Sprite_RAM+$65	; Store the pattern for the second sprite

	LDA <Map_WWOrHT_Dir
	BEQ PRG011_A5AA	 	; If Map_WWOrHT_Dir = 0, jump to PRG011_A5AA

	; Flip the wind patterns!
	STY Sprite_RAM+$61
	DEY		
	DEY		
	STY Sprite_RAM+$65

	; Set the flip attribute
	LDA Sprite_RAM+$62	; Get old attributes
	ORA #$40	 	; H-Flip attr
	STA Sprite_RAM+$62	
	STA Sprite_RAM+$66	

PRG011_A5AA:

	; This draw a couple high-priority sprites at the border's edge 
	; using border patterns to clip the warp wind sprite!

	; Sprite set to Y
	LDA <Map_WWOrHT_Y
	STA Sprite_RAM+$00
	STA Sprite_RAM+$04

	; Pattern 1
	LDA #$01	 
	STA Sprite_RAM+$01

	; Pattern $B
	LDA #$0b	 
	STA Sprite_RAM+$05

	; Attributes
	LDA #$01	 
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	; And X = 1
	STA Sprite_RAM+$07

	; And X = 8
	LDA #$08	 
	STA Sprite_RAM+$03

	LDA <Temp_Var2	 ; MapWWOrHT_X
	AND #$80	 
	BEQ PRG011_A5DC	 ; If MapWWOrHT_X is not in the right half of the screen, jump to PRG011_A5DC (RTS)

	; Otherwise, put the border patch on the RIGHT side!
	LDA #$f0	
	STA Sprite_RAM+$03
	LDA #$f8	 
	STA Sprite_RAM+$07

PRG011_A5DC:
	RTS		 ; Return

GameOver_TwirlToStart:
	LDX Player_Current	 

	LDA <Map_SkidBack
	BNE PRG011_A63D	 ; If Map_SkidBack is set, jump to PRG011_A63D

	LDY World_Num	 ; Y = World_Num

	LDA <World_Map_Y,X
	SUB Map_Y_Starts,Y
	STA <Map_Skid_DeltaY

	LDA <World_Map_X,X
	SUB #$20
	STA <Map_Skid_DeltaX

	LDA #$00
	STA <Map_Skid_TravDirs
	STA <Map_Skid_DeltaFracX
	STA <Map_Skid_DeltaFracY

	LDA <World_Map_X,X
	CMP #32
	BGE PRG011_A610	 ; If Player's Map X >= 32 (the common start X of all maps), jump to PRG011_A610

	; Player's Map X < 32...

	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
	LDA #$01
	STA <Map_Skid_TravDirs

	; Negate Map_Skid_DeltaX
	LDA #$ff
	EOR <Map_Skid_DeltaX
	TAY
	INY
	STY <Map_Skid_DeltaX

PRG011_A610:
	LDY World_Num	 ; Y = World_Num

	LDA <World_Map_Y,X
	CMP Map_Y_Starts,Y
	BGE PRG011_A628	 ; If Player's Map Y >= the starting Y of the map, jump to PRG011_A628

	; Player's Map Y < the starting Y of the map...

	; Negate Map_Skid_DeltaY
	LDA #$ff
	EOR <Map_Skid_DeltaY
	TAY
	INY
	STY <Map_Skid_DeltaY

	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
	LDA <Map_Skid_TravDirs
	ORA #$02
	STA <Map_Skid_TravDirs

PRG011_A628:

	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
	LDY #$04	 ; Y = 4
PRG011_A62A:
	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
	ROR <Map_Skid_DeltaFracY		; Set as bit 7 of Map_Skid_DeltaFracY

	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
	ROR <Map_Skid_DeltaFracX		; Set as bit 7 of Map_Skid_DeltaFracX

	DEY			; Y--
	BPL PRG011_A62A		; While Y >= 0, loop!

	; Map_Skid_Counter = $20
	LDA #$20
	STA <Map_Skid_Counter

	INC <Map_SkidBack		 ; Set Map_SkidBack

PRG011_A63D:

	; Skid sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A65E	 ; If Player is traveling left, jump to PRG011_A65E

	; Traveling to the right...

	; Map_Skid_FracX += Map_Skid_DeltaFracX
	LDA <Map_Skid_FracX
	ADD <Map_Skid_DeltaFracX
	STA <Map_Skid_FracX

	; Add and carry into the full X
	LDA <World_Map_X,X
	ADC <Map_Skid_DeltaX
	STA <World_Map_X,X

	; Any additional carry into Map XHi
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	JMP PRG011_A671	 ; Jump to PRG011_A671

PRG011_A65E:

	; Traveling to the left

	; Map_Skid_FracX -= Map_Skid_DeltaFracX
	LDA <Map_Skid_FracX
	SUB <Map_Skid_DeltaFracX
	STA <Map_Skid_FracX

	; Subtract and carry into the full X
	LDA <World_Map_X,X
	SBC <Map_Skid_DeltaX
	STA <World_Map_X,X

	; Any additional carry into Map XHi
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

PRG011_A671:
	LDA <Map_Skid_TravDirs
	AND #$02
	BEQ PRG011_A687	 ; If Player is traveling up, jump to PRG011_A65E

	; Traveling downward

	; Map_Skid_FracY += Map_Skid_DeltaFracY
	LDA <Map_Skid_FracY
	ADD <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	; Add and carry into the full Y
	LDA <World_Map_Y,X
	ADC <Map_Skid_DeltaY
	STA <World_Map_Y,X

	JMP PRG011_A694	 ; Jump to PRG011_A694

PRG011_A687:

	; Traveling downward

	; Map_Skid_FracY -= Map_Skid_DeltaFracY
	LDA <Map_Skid_FracY
	SUB <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	; Subtract and carry into the full Y
	LDA <World_Map_Y,X
	SBC <Map_Skid_DeltaY
	STA <World_Map_Y,X

PRG011_A694:
	DEC <Map_Skid_Counter	; Map_Skid_Counter--
	BNE PRG011_A6BC	 ; If Map_Skid_Counter <> 0, jump to PRG011_A6BC

PRG011_A698:
	; GameOver_State = 8 (we've landed, we're done)
	LDA #$08
	STA GameOver_State

	LDX Player_Current	 ; X = Player_Current

	LDA #$00
	STA <Map_SkidBack
	STA World_Map_Twirl,X	 ; Twirling is done
	STA Map_Prev_XOff2,X
	STA Map_Prev_XHi2,X

	; Set the previous values at the twirl landing spot

	; Map_Previous_Y = World_Map_Y
	LDA <World_Map_Y,X
	STA Map_Previous_Y,X

	; Map_Previous_X/Hi = Map_Previous_X/Hi
	LDA <World_Map_XHi,X
	STA Map_Previous_XHi,X
	LDA <World_Map_X,X
	STA Map_Previous_X,X

PRG011_A6BC:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


GameOver_TwirlFromAfar:
	LDX Player_Current	 ; X = Player_Current

	; Map X -= 2 (Player flying from way off goes directly left)
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	BNE PRG011_A6E4	 ; If Player Map X <> Horz_Scroll, jump to PRG011_A6E4

	LDA #$00
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X
	STA Map_Entered_XHi,X

	INC GameOver_State	 ; GameOver_State++

PRG011_A6E4:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JSR Map_DrawBorderForPlayer	 ; Draw border sprites to cover twirling Player

	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


Map_DrawBorderForPlayer:
	LDX Player_Current	; X = Player_Current

	; Set Map Border Sprite Y
	LDA <World_Map_Y,X
	STA Sprite_RAM+$00
	STA Sprite_RAM+$04

	; Set Map Border Sprite left Pattern
	LDA #$01
	STA Sprite_RAM+$01

	; Set Map Border Sprite right Pattern
	LDA #$0b
	STA Sprite_RAM+$05

	; Set Map Border Sprite attributes
	LDA #SPR_PAL0
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	; Set Map Border left Sprite X
	STA Sprite_RAM+$07

	; Set Map Border right Sprite X
	LDA #$08
	STA Sprite_RAM+$03

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	AND #$80
	BEQ PRG011_A727	 ; If difference is positive, jump to PRG011_A727 (RTS)

	; Set Map Border Sprite X
	LDA #240
	STA Sprite_RAM+$03
	LDA #248
	STA Sprite_RAM+$07

PRG011_A727:
	RTS		 ; Return


GameOver_AlignToStartY
	LDX Player_Current	 ; X = Player_Current

	; Enter from right side
	LDA #240
	STA <World_Map_X,X

	LDY World_Num		 ; Y = World_Num
	LDA Map_Y_Starts,Y	 ; Get start Y
	STA <World_Map_Y,X	 ; Set Player at start Y

	INC GameOver_State	 ; GameOver_State++
	JMP PRG011_A6E4	 	; Jump to PRG011_A6E4

GameOver_ReturnToStartX:
	LDX Player_Current	 ; X = Player_Current

	; Player's Map X -= 2 (skidding towards Start panel)
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X

	CMP #$20
	BNE PRG011_A74E	 ; If Player is not at $20 (fixed start point X), jump to PRG011_A74E

	JMP PRG011_A698	 ; Jump to PRG011_A698

PRG011_A74E:

	; Play skidding sound (actually pointless from where it jumps)
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JMP PRG011_A6E4	 ; Jump to PRG011_A6E4

MO_SkidToPrev:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_SkidBack
	BEQ PRG011_A760	 ; If Map_SkidBack is not set, jump to PRG011_A760

	JMP PRG011_A834	 ; Jump to PRG011_A834

PRG011_A760:

	; Checks all map objects to see if Player has died while in a map object

	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1)
PRG011_A762:
	LDA Map_Objects_IDs,Y
	BNE PRG011_A76D	 ; If this map object slot is not empty, jump to PRG011_A76D

PRG011_A767:
	DEY		 ; Y--
	BNE PRG011_A762	 ; While Y > 0, loop!  (Ignores the HELP bubble)
	JMP PRG011_A79D	 ; Jump to PRG011_A79D

PRG011_A76D:

	; If Player is not on top of the airship, jump to PRG011_A767
	LDA <World_Map_Y,X
	CMP Map_Objects_Y,Y
	BNE PRG011_A767

	LDA <World_Map_XHi,X
	CMP Map_Objects_XHi,Y
	BNE PRG011_A767

	LDA <World_Map_X,X
	CMP Map_Objects_XLo,Y
	BNE PRG011_A767

	JMP PRG011_A791

	; Player is on top of the airship
	; NOTE: Assumes Index 1 is the Airship!

	; Set airship count = $20 (orders it to scurry away)
	LDA #$20
	STA Map_March_Count+1

	JMP PRG011_A767	 ; Jump to PRG011_A767

PRG011_A791:
	JMP PRG011_A767	 ; If this is NOT a Coin Ship, jump to PRG011_A767


	JMP PRG011_A767	 ; Jump to PRG011_A767

PRG011_A79D:

	; Player died on top of something not an Airship or a Coin ship...

	LDA Map_Previous_Y,X
	SUB <World_Map_Y,X
	STA <Map_Skid_DeltaY

	LDA Map_Previous_XHi,X
	CMP <World_Map_XHi,X
	BEQ PRG011_A7B0	 ; If Player is on the same map screen as he was before, jump to PRG011_A7B0
	BGE PRG011_A7B7	 ; If Player is on a map screen to the right, jump to PRG011_A7B7
	BLT PRG011_A7CB	 ; If Player is on a map screen to the left, jump to PRG011_A7CB

PRG011_A7B0:

	; Player is on the same map screen he was previously...

	LDA Map_Previous_X,X
	CMP <World_Map_X,X
	BLT PRG011_A7CB	 ; If Player is to the left from where he was, jump to PRG011_A7CB

PRG011_A7B7:

	; Player is to the right from where he was...

	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
	LDA Map_Previous_X,X
	SUB <World_Map_X,X
	STA <Map_Skid_DeltaFracX

	; Map_Skid_DeltaX starts as straight difference in X Hi
	LDA Map_Previous_XHi,X
	SBC <World_Map_XHi,X	
	STA <Map_Skid_DeltaX

	; Do not set bit 0 on Map_Skid_TravDirs (travel left instead of right)
	LDY #$00	 ; Y = 0

	JMP PRG011_A7DC	 ; Jump to PRG011_A7DC

PRG011_A7CB:

	; Player is to the left from where he was

	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
	LDA <World_Map_X,X
	SUB Map_Previous_X,X
	STA <Map_Skid_DeltaFracX

	; Map_Skid_DeltaX starts as straight difference in X Hi
	LDA <World_Map_XHi,X
	SBC Map_Previous_XHi,X
	STA <Map_Skid_DeltaX

	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
	LDY #$01	 ; Y = 1

PRG011_A7DC:
	STY <Map_Skid_TravDirs	 ; Set Map_Skid_TravDirs

	LDA #$00
	STA <Map_Skid_FracX
	STA <Map_Skid_DeltaFracY

	LDA Map_Previous_Y,X
	CMP <World_Map_Y,X
	BGE PRG011_A7F9	 ; If Player is lower than he was before, jump to PRG011_A7F9

	; Player was higher than before... negate Map_Skid_DeltaY
	LDA #$ff
	EOR <Map_Skid_DeltaY
	TAY
	INY
	STY <Map_Skid_DeltaY

	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
	LDA <Map_Skid_TravDirs
	ORA #$02
	STA <Map_Skid_TravDirs

PRG011_A7F9:
	LDA <Map_Skid_DeltaX
	BNE PRG011_A817	 ; If Player is left/right of where he was before, jump to PRG011_A817

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	TAY

	LDA <Map_Skid_TravDirs
	AND #$01
	BNE PRG011_A811	 ; If Player is traveling right, jump to PRG011_A811

	TYA
	ADD <Map_Skid_DeltaFracX
	BCC PRG011_A81D	 ; If no carry, jump to PRG011_A81D
	BCS PRG011_A817	 ; Otherwise, jump to PRG011_A817

PRG011_A811:
	TYA
	SUB <Map_Skid_DeltaFracX
	BCS PRG011_A81D	 ; If carry set, jump to PRG011_A81D

PRG011_A817:
	INC Map_Operation	 ; Map_Operation++ (go to the "twirl from afar" state)
	JMP MO_SkidToPrevAfar	 ; Jump to MO_SkidToPrevAfar

PRG011_A81D:

	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
	LDY #$04	 ; Y = 4
PRG011_A81F:
	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
	ROR <Map_Skid_DeltaFracY	; Set as bit 7 of Map_Skid_DeltaFracY

	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
	ROR <Map_Skid_DeltaFracX	; Set as bit 7 of Map_Skid_DeltaFracX; Bit 0 -> Carry
	ROR <Map_Skid_FracX		; Set as bit 7 of <Map_Skid_FracX

	DEY			; Y--
	BPL PRG011_A81F		; While Y >= 0, loop!

	; Map_Skid_Counter = $20
	LDA #$20
	STA <Map_Skid_Counter

	INC <Map_SkidBack		 ; Set Map_SkidBack

PRG011_A834:
	LDA <Map_Skid_Counter
	BEQ PRG011_A891	 ; If Map_Skid_Counter = 0, jump to PRG011_A891

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA <Map_Skid_TravDirs
	AND #$01
	BNE PRG011_A859	 ; If Player is traveling right, jump to PRG011_A859

	LDA <Map_Skid_FracCarry
	ADD <Map_Skid_FracX
	STA <Map_Skid_FracCarry

	LDA <World_Map_X,X
	ADC <Map_Skid_DeltaFracX
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	ADC <Map_Skid_DeltaX
	STA <World_Map_XHi,X

	JMP PRG011_A86C	 ; Jump to PRG011_A86C

PRG011_A859:
	LDA <Map_Skid_FracCarry
	SUB <Map_Skid_FracX
	STA <Map_Skid_FracCarry

	LDA <World_Map_X,X
	SBC <Map_Skid_DeltaFracX
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	SBC <Map_Skid_DeltaX
	STA <World_Map_XHi,X

PRG011_A86C:
	LDA <Map_Skid_TravDirs
	AND #$02
	BNE PRG011_A882	 ; If Player is traveling down, jump to PRG011_A882

	LDA <Map_Skid_FracY
	ADD <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	LDA <World_Map_Y,X
	ADC <Map_Skid_DeltaY
	STA <World_Map_Y,X

	JMP PRG011_A88F	 ; Jump to PRG011_A88F

PRG011_A882:
	LDA <Map_Skid_FracY
	SUB <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	LDA <World_Map_Y,X
	SBC <Map_Skid_DeltaY
	STA <World_Map_Y,X

PRG011_A88F:
	DEC <Map_Skid_Counter		 ; Map_Skid_Counter--

PRG011_A891:
	JSR WorldMap_UpdateAndDraw	 ; Update and draw map

	LDA <Map_Skid_Counter
	ORA Map_March_Count+1	; <--- Airship's movement counter
	ORA Map_Pan_Count
	BNE PRG011_A8C8	 ; If skidding, the airship is moving, or the map is panning, jump to PRG011_A8C8 (RTS)

	; Map_Operation = $0B (Hammer bros march around)
	LDA #$0b
	STA Map_Operation

	LDX Player_Current	 ; X = Player_Current

	; Ensure Player is precisely at his previous position
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff,X

	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi,X

	; Clear skid vars
	LDA #$00
	STA <Map_SkidBack
	STA Map_Player_SkidBack,X

PRG011_A8C8:
	RTS		 ; Return

MO_SkidToPrevAfar:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A8E9	 ; If Player is traveling left, jump to PRG011_A8E9

	; Far away Player skidding directly to the left; Map X -= 2
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	BEQ PRG011_A8FF	 ; If Player hit left edge, jump to PRG011_A8FF

	JMP PRG011_A90E	 ; Jump to PRG011_A90E

PRG011_A8E9:

	; Far away Player skidding directly to the right; Map X += 2
	LDA <World_Map_X,X
	ADD #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	CMP #240
	BNE PRG011_A90E	 ; If Player has not hit right edge, jump to PRG011_A90E

PRG011_A8FF:

	; Player hit edge of the screen

	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff,X

	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi,X

	INC Map_Operation	 ; Map_Operation++

PRG011_A90E:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JSR Map_DrawBorderForPlayer	 ; Draw border to block Player sprite

	JMP WorldMap_UpdateAndDraw	 ; Update and draw map and don't come back!

MO_SkidAfarPrep:
	LDX Player_Current	 ; X = Player_Current

	; Set Player's Y and XHi to their previous values
	LDA Map_Previous_Y,X
	STA <World_Map_Y,X
	LDA Map_Previous_XHi,X
	STA <World_Map_XHi,X

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A946	 ; If Player is traveling left, jump to PRG011_A946

	; Traveling rightward

	LDY #240	 ; Y = 240

	LDA <Horz_Scroll
	BEQ PRG011_A941		; If horizontal scroll = 0, jump to PRG011_A941

	LDA Map_Previous_X,X
	ADD <Horz_Scroll
	
	LDA Map_Previous_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDY #112	 ; Y = 112

PRG011_A941:
	STY <World_Map_X,X ; Set proper World Map X to begin skidding from

	JMP PRG011_A95B	 ; Jump to PRG011_A95B

PRG011_A946:

	; Traveling leftward

	LDA <Horz_Scroll
	BEQ PRG011_A957	 ; If Horz_Scroll = 0, jump to PRG011_A957

	LDA Map_Previous_X,X
	SUB <Horz_Scroll
	LDA Map_Previous_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

PRG011_A957:
	LDA <Horz_Scroll
	STA <World_Map_X,X

PRG011_A95B:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	INC Map_Operation	 ; Map_Operation++

	JMP PRG011_A90E	 ; Jump to PRG011_A90E

MO_SkidAfarFinish:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A986	 ; If Player is traveling left, jump to PRG011_A946

	; Player traveling left

	; Map X -= 2
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	CMP Map_Previous_X,X
	BEQ PRG011_A99A	 ; If Player Map X is at his previous X, jump to PRG011_A99A

	JMP PRG011_A9B5	 ; Otherwise, jump to PRG011_A9B5 (indirect to PRG011_A90E)

PRG011_A986:

	; Player traveling right

	; Map X += 2
	LDA <World_Map_X,X
	ADD #$02
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	CMP Map_Previous_X,X
	BNE PRG011_A9B5	 ; If Player Map X is not at his previous X, jump to PRG011_A9B5 (indirect to PRG011_A90E)

PRG011_A99A:

	; Player has finally arrived at his "previous" position, completing the skid back from afar

	; Map_Operation = $0B (Hammer bros march around)
	LDA #$0b
	STA Map_Operation

	; Ensure Player is precisely at his previous position
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA #$00
	STA <Map_SkidBack
	STA Map_Player_SkidBack,X

PRG011_A9B5:
	JMP PRG011_A90E	 ; Jump to PRG011_A90E

	; Indexed by Map_ClearLevelFXCnt * 2
Map_ClearLevelFXPatterns:

	; "Poof" effect
	.byte $45, $47	; 0
	.byte $45, $47	; 1
	.byte $49, $31	; 2
	.byte $49, $35	; 3
	.byte $49, $39	; 4
	.byte $49, $41	; 5

	; "Flip" effect
	.byte $B5, $B5	; 6
	.byte $A1, $A1	; 7
	.byte $B5, $B5	; 8

	; Indexed by Player and tile quadrant (except the last three which are hardcoded specific)

	; This just forces "poof" completion on the following tiles (in quadrant zero, since all other
	; quadrants always "poof" except fortress tiles)

Map_PanelCompletePats:
	.byte $88, $89, $8A, $8B	; Mario Complete panel patterns
	.byte $DC, $DD, $DE, $DF	; Luigi Complete panel patterns
	.byte $68, $BB, $69, $BD	; Fortress rubble panel patterns

	; These are the select few tiles that "completing" their associated area
	; will not cause the Player to end their turn (in a 2P game)
Map_NoLoseTurnTiles:
	.byte TILE_TOADHOUSE, TILE_ALTTOADHOUSE, TILE_SPADEBONUS, TILE_PIPE, TILE_SPIRAL
Map_NoLoseTurnTiles_End

MO_DoLevelClear:
	JSR Map_GetTile	 	; Get current tile Player is standing on
	CMP #MAP_PROP_COMPLETABLE
	BCS PRG011_AA19

DoNotClear:
	LDA #$0D
	STA Map_Operation
	RTS

PRG011_AA19:
	LDA <Map_ClearLevelFXCnt
	BEQ PRG011_AA29	 ; If "map poof" is not currently in use, jump to PRG011_AA29

	LDA <Counter_1
	AND #$03
	BEQ PRG011_AA4C	 ; 1:4 ticks jump to PRG011_AA4C

PRG011_AA23:
	JMP PRG011_AB1B	 ; Otherwise, jump to PRG011_AB1B

PRG011_AA26:
	JMP PRG011_AB61	 ; Jump to PRG011_AB61

PRG011_AA29:
PRG011_AA39:

	; Play the "poof" sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

	; "Poof" effect starts Map_ClearLevelFXCnt at 1, which it will be shortly...

PRG011_AA4C:

	; Updating whatever effect we're performing

	INC <Map_ClearLevelFXCnt	 ; Map_ClearLevelFXCnt++

	; Remember these compares are immediately following the INC...
	LDA <Map_ClearLevelFXCnt
	CMP #$07
	BEQ PRG011_AA58	 ; If Map_ClearLevelFXCnt = $07 (end of Fortress "poof" effect), jump to PRG011_AA58

	CMP #$0a
	BNE PRG011_AA23	 ; If Map_ClearLevelFXCnt <> $0A (end of completed level panel flip), jump to PRG011_AA23 (PRG011_AB1B)

PRG011_AA58:

	; Map_ClearLevelFXCnt = 0 (effect over)
	LDA #$00
	STA <Map_ClearLevelFXCnt

	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_XHi,X
	ASL A		 ; 2 byte index
	TAY		 ; -> Y
	LDA Tile_Mem_Addr,Y	; Get tile address low for this map screen
	ADD #$f0	 	; Base map offset
	STA <Map_Tile_AddrL	; -> Map_Tile_AddrL

	LDA Tile_Mem_Addr+1,Y	; Get tile address high for this map screen
	ADC #$00	 	; Apply carry
	STA <Map_Tile_AddrH	; -> Map_Tile_AddrH

	; Calculate a row/column offset
	LDA <World_Map_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <World_Map_Y,X
	TAY		 ; -> 'Y'
	
	LDA [Map_Tile_AddrL], Y
	STA Old_World_Map_Tile
	ORA #$0F
	STA [Map_Tile_AddrL],Y	 ; Get the tile here
	STA <World_Map_Tile	; ... as well as the tile detected

	JSR Map_MarkLevelComplete	 ; Mark this level as complete!

	LDY Player_Current	 ; Y = Player_Current
	LDX <World_Map_X,Y	 ; X = Player Map X
	LDA World_Map_Y,Y	 ; A = Player Map Y
	JSR Map_Calc_NT2Addr_By_XY	 ; Nametable 2 Offset -> Temp_Var15

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	; Set high byte of video address
	LDA <Temp_Var15
	STA Graphics_Buffer+$00,X
	STA Graphics_Buffer+$05,X

	; Set low byte of video address for first row of level panel change
	LDA <Temp_Var16
	STA Graphics_Buffer+$01,X

	; Set low byte of video address for second row of level panel change
	ADD #32		; +32 for next row
	STA Graphics_Buffer+$06,X

	; Run length of 2 for both
	LDA #$02
	STA Graphics_Buffer+$02,X
	STA Graphics_Buffer+$07,X

	LDY #$08	 ; Y = 8 (Fortress Rubble)


PRG011_AAEF:
	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	LDA Old_World_Map_Tile
	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A
	TAY
	; Add in the four replacement patterns to cover over the completed level
	LDA Map_ClearTiles1, Y
	STA Graphics_Buffer+$03,X
	LDA Map_ClearTiles3, Y
	STA Graphics_Buffer+$08,X
	LDA Map_ClearTiles2, Y
	STA Graphics_Buffer+$04,X
	LDA Map_ClearTiles4, Y
	STA Graphics_Buffer+$09,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$0A,X

	; Graphics_BufCnt += 10
	LDA Graphics_BufCnt
	ADD #10
	STA Graphics_BufCnt

	JMP PRG011_AB61	 ; Jump to PRG011_AB61

PRG011_AB1B:
	LDX Player_Current	 ; X = Player_Current

	; Copy Player's Map Y/X -> Temp_Var1/2
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDY <Map_ClearLevelFXCnt
	CPY #$07
	BLT PRG011_AB5B	 ; If Map_ClearLevelFXCnt < 7 (doing Fortress poof rather than panel flip), jump to PRG011_AB5B

	; Set "flip" sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64

	DEY		 ; Y--

	; Y *= 2 (two patterns per count)
	TYA
	ASL A
	TAY

	; Set the two patterns for the panel flip sprites
	LDA Map_ClearLevelFXPatterns,Y
	STA Sprite_RAM+$61
	STA Sprite_RAM+$65

	; Set left panel flip sprite attribute
	LDA #SPR_PAL3
	STA Sprite_RAM+$62

	; Set right panel flip sprite attribute
	LDA #(SPR_PAL3 | SPR_HFLIP)
	STA Sprite_RAM+$66

	; Set left panel flip sprite X
	LDA <Temp_Var2
	SUB <Horz_Scroll
	STA Sprite_RAM+$63

	; Set right panel flip sprite X
	ORA #$08
	STA Sprite_RAM+$67

PRG011_AB58:
	JMP PRG011_ABBE	 ; Jump to PRG011_ABBE

PRG011_AB5B:
	JSR Map_DrawClearLevelPoof	 ; Draw the "poof"
	JMP PRG011_ABCC	 ; Jump to PRG011_ABCC (MapObjects_UpdateDrawEnter)

PRG011_AB61:
	
	; Here we check if Player was on top of a map object, thus assumed to be the cause of level entry, thus needs to be "completed."

	LDY #(MAPOBJ_TOTAL - 1)	 ; Y = (MAPOBJ_TOTAL - 1) (For all map objects)
	LDX Player_Current	 ; X = Player_Current
PRG011_AB6B:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_AB89	 	; If this map object slot is empty, jump to PRG011_AB89

	LDA Map_Objects_Y,Y
	STA <Temp_Var1		; Temp_Var1 = this map object's Y
	CMP <World_Map_Y,X
	BNE PRG011_AB89	 	; If Player is not on this map object vertically, jump to PRG011_AB89

	LDA Map_Objects_XHi,Y
	CMP <World_Map_XHi,X
	BNE PRG011_AB89	 	; If Player is not on the same screen as this map object, jump to PRG011_AB89

	LDA Map_Objects_XLo,Y
	STA <Temp_Var2		; Temp_Var2 = this map object's X

	CMP <World_Map_X,X
	BEQ PRG011_AB8F 	; If Player is definitely on top of this map object, jump to PRG011_AB8F

PRG011_AB89:
	DEY		 	; Y--
	BPL PRG011_AB6B		; While Y >= 0, loop

	JMP PRG011_ABBE	 ; Jump to PRG011_ABBE

PRG011_AB8F:
	STY <Map_HideObj	; Index of map object Player is standing on -> Map_HideObj (hide this object and can't re-enter it)

	JMP PRG011_AB9E	 	; If Player is NOT on the airship, jump to PRG011_AB9E

	; Player is on the airship...

	; NOTE: Actually this is never used, this allows for the Airship to be "completed"
	; although by the way this is done it just disappears rather than "poofs" away...
	; If you remove this exception you can actually make the Airship "completable"

	INC Map_Operation	; Map_Operation++
	JMP PRG011_ABCC	 	; Jump to PRG011_ABCC (MapObjects_UpdateDrawEnter)

PRG011_AB9E:
	LDA <Map_ClearLevelFXCnt
	BNE PRG011_ABA7	 ; If Map_ClearLevelFXCnt <> 0, jump to  PRG011_ABA7

	; "Poof" sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

PRG011_ABA7:
	LDA <Counter_1
	AND #$03
	BNE PRG011_AB5B	 ; 1:4 ticks proceed, otherwise jump to PRG011_AB5B

	INC <Map_ClearLevelFXCnt	; Map_ClearLevelFXCnt++

	LDA <Map_ClearLevelFXCnt
	CMP #$07
	BNE PRG011_AB5B	 ; If Map_ClearLevelFXCnt = 7 (end of "poof" effect), jump to  PRG011_AB5B

	; Map object will now disappear!
	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs,Y		; Empty the slot
	STA <Map_ClearLevelFXCnt	; Stop the clear effect (poof)
	STA <Map_HideObj		; Clear the hidden object index

PRG011_ABBE:
	LDA <Map_ClearLevelFXCnt
	BNE PRG011_ABCC	 ; If Map_ClearLevelFXCnt <> 0, jump to PRG011_ABCC

	; Level clearing effect is over...

	; Map_Operation = 8
	LDA #$08
	STA Map_Operation

PRG011_ABCC:
	JMP MapObjects_UpdateDrawEnter	 ; Jump to MapObjects_UpdateDrawEnter

Map_ClearTiles1:
	.byte $FE, $FE, $82, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE
Map_ClearTiles2:
	.byte $FE, $FE, $83, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE
Map_ClearTiles3:
	.byte $FE, $FE, $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE
Map_ClearTiles4:
	.byte $FE, $FE, $93, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	; Draws the "Poof" effect that occurs after a Fortress is completed
Map_DrawClearLevelPoof:
	; Temp_Var1 = Y
	; Temp_Var2 = X

	; Set poof top Y 8 pixels above (centered over point)
	LDA <Temp_Var1
	SUB #$08	
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64
	STA Sprite_RAM+$68
	STA Sprite_RAM+$6C

	; Set poof bottom Y 8 pixels below (centered over point)
	ADD #16
	STA Sprite_RAM+$70
	STA Sprite_RAM+$74
	STA Sprite_RAM+$78
	STA Sprite_RAM+$7C

	LDY #$00	 ; Y = 0
	LDA <Temp_Var2	 
	SUB <Horz_Scroll 
	SUB #$08	 ; Set X coordinate relative to screen scroll - 8
PRG011_ABF9:
	; Set poof X coordinates
	STA Sprite_RAM+$63,Y	; Top
	STA Sprite_RAM+$73,Y	; Bottom

	ADD #$08	 ; X += 8

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	CPY #$10	 
	BNE PRG011_ABF9	 ; If 'Y' <> $10, jump to PRG011_ABF9

	; Palette select 3 
	LDA #$03
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	; Palette select 3 and horizontal flip
	LDA #$43
	STA Sprite_RAM+$6A
	STA Sprite_RAM+$6E

	; Palette select 3 and vertical flip
	LDA #$83
	STA Sprite_RAM+$72
	STA Sprite_RAM+$76

	; Palette select 3 and both flip
	LDA #$c3
	STA Sprite_RAM+$7A
	STA Sprite_RAM+$7E

	LDX <Map_ClearLevelFXCnt	 ; X = Map_ClearLevelFXCnt
	DEX		 ; X-- (off by 1)
	TXA
	ASL A
	TAX		 ; X *= 2

	; Set pattern
	LDA Map_ClearLevelFXPatterns,X
	STA Sprite_RAM+$61
	STA Sprite_RAM+$6D
	STA Sprite_RAM+$71
	STA Sprite_RAM+$7D

	; Set pattern
	LDA Map_ClearLevelFXPatterns+1,X
	STA Sprite_RAM+$65
	STA Sprite_RAM+$69
	STA Sprite_RAM+$75
	STA Sprite_RAM+$79

	RTS		 ; Return


Map_WhiteObjects:
	.byte MAPOBJ_NSPADE, MAPOBJ_WHITETOADHOUSE, MAPOBJ_COINSHIP, MAPOBJ_UNK0C 
Map_WhiteObjects_End

MO_CheckForBonus:
	RTS

	; Temp_Var16 is our loop counter
	LDA #(Map_WhiteObjects_End - Map_WhiteObjects - 1)
	STA <Temp_Var16

PRG011_AC57:
	LDY <Temp_Var16	 	; Y = Temp_Var16
	LDX #(MAPOBJ_TOTAL-1)	; X = (MAPOBJ_TOTAL-1)

	LDA Map_WhiteObjects,Y
PRG011_AC5E:
	CMP Map_Objects_IDs,X
	BEQ PRG011_AC69	 ; If this is the "white" bonus object we're looking for, jump to PRG011_AC69 (we already have one, can't have more)

	DEX		 ; X-- (previous "white" bonus object to consider)
	BPL PRG011_AC5E	 ; While X >= 0, loop!


PRG011_AC69:
	DEC <Temp_Var16	 ; Temp_Var16--
	BPL PRG011_AC57	 ; While Temp_Var16 >= 0, loop!

	INC Map_Operation	 ; Map_Operation++
	JMP WorldMap_UpdateAndDraw	 ; Update and draw map, and don't come back!

MO_CheckForBonusRules:
	LDA <Temp_Var16
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word MapBonusChk_NSpade		; Check if an N-Spade should appear
	.word MapBonusChk_NSpade	; Check if a White Toad House should appear
	.word MapBonusChk_CoinShip		; Check if a Coin Ship should appear
	.word MapBonusChk_MAPOBJ_UNK0C		; Check if the UNKNOWN MAPOBJ_UNK0C should appear


; N-Spade will appear on the map every 80,000 points you earn
MapBonusChk_NSpade:
	RTS
	RTS		 ; Return


; The old Coin Ship ruleset:
; 1.) End the stage with an even number on the clock.
; 2.) Coins must be a Multiple of 11.
; 3.) The 10â€²s digit of your score must be the multiple of 11 that corresponds to your coins.
; 4.) Finally it must be in World 1, 3, 5, and 6.
;	NOTE: The worlds that don't count are literally because there's no "Hammer Bro"
;	map objects there; the code doesn't actually care about the world number!

MapBonusChk_CoinShip:
	RTS

	; This will always appear at the same location!!
MAPOBJ_UNK0C_Y:	.byte $60
MAPOBJ_UNK0C_X:	.byte $60

MapBonusChk_MAPOBJ_UNK0C:
	RTS		 ; Return


	; This looks for an empty map object slot and returns the index in 'Y'
	; Assumes that the first two slots are always occupied...
	; NOTE: Dangerous!  If all slots are filled, this could loop for eternity
	; or return a bad index!  There's just an assumption of a free slot!
	;
	; A better implemention per what the rest of the engine would do is make
	; sure we don't loop beyond the last object ((MAPOBJ_TOTAL-1)) and in failure
	; "Do Not Return to Caller" (double PLA instruction), but oh well...
Map_FindEmptyObjectSlot:
	LDY #$02	 ; Y = 2
	
PRG011_AD9F:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADA8	 ; If this map object slot is empty, jump to PRG011_ADA8 (RTS)

	INY		 ; Y++
	JMP PRG011_AD9F	 ; Loop

PRG011_ADA8:
	RTS		 ; Return

Map_March_InitValues:
	; Initializes Map_March_Count values per Map_Object_ID
	; Generally the value is $20 (Marching time amount) and $00 (Don't march)
	; There's some restriction on these values because of internal ANDings.

	; Also, an object won't actually march unless it is tied into the march
	; function (check function pointer list @ PRG011_AE0B), but if it uses 
	; the Map_Object_Stationary function, it will briefly animate slightly
	; faster (as does a Hammer Brother marching around) due to a jump it
	; makes; this is used to make the World 7 Plant look ferocious (I suppose)
	; and would happen with World 8 stuff too, but they use $00 values so
	; the net effect is absolutely nothing.
	.byte $00	; None
	.byte $00	; HELP
	.byte $00	; Airship
	.byte $20	; Hammer Bro
	.byte $20	; Boomerang Bro
	.byte $20	; Heavy Bro
	.byte $20	; Fire Bro
	.byte $20	; World 7 Plant (doesn't really "go" anywhere, though!)
	.byte $20	; Unknown/unused marching glitch object
	.byte $00	; N-Spade
	.byte $00	; White Toad House
	.byte $20	; Coin Ship (does "sail" around the map)
	.byte $00	; Unknown white colorization of $0F (goes to World 7 level??)
	.byte $00	; World 8 Battleship
	.byte $00	; World 8 Tank
	.byte $00	; World 8 Airship
	.byte $00	; Canoe

	.byte $00, $00, $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Object_Do_All
;
; Runs update code on all map objects, e.g. what makes a 
; Hammer Brother march, an airship fly, etc.  Does NOT have
; anything to do with the interaction of the object, except
; for the canoe, which simply sets the "In Canoe" flag if
; the Player is standing in it.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Object_Do_All:

	LDY #(MAPOBJ_TOTAL-1) 	; Total map objects which may exist on the map (only 8 are defined at start)
	STY <Temp_Var13		; Temp_Var13 = $0D

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_ADE6	 	; If Map_Operation <> $0B (Hammer Bro marching around), jump to PRG011_ADE6

	LDA Map_MarchInit
	BNE PRG011_ADE6	 	; If Map_MarchInit is set, jump to PRG011_ADE6

PRG011_ADD2:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADDE	 	; If the object ID is zero, nothing to do, jump to PRG011_ADDE
	TAX		 	; X = A

	; Initialize all the map march values
	LDA Map_March_InitValues,X	; For this object's ID, get the init value
	STA Map_March_Count,Y	 	; Store it in this object's slot

PRG011_ADDE:
	DEY		 ; Y--
	CPY #$01	 
	BNE PRG011_ADD2	 ; While Y <> 1, loop!


	INC Map_MarchInit	 ; Set Map_MarchInit (March initialization complete!)

PRG011_ADE6:
	LDX <Temp_Var13		; X = Temp_Var13

	LDA Map_Objects_IDs,X
	BEQ PRG011_ADF0	 	; If the object ID is zero, nothing to do, jump to PRG011_ADF0

	JSR Map_Object_Do 	; Process this map object!

PRG011_ADF0:
	DEC <Temp_Var13		; Temp_Var13--
	BPL PRG011_ADE6	 	; While Temp_Var13 >= 0, loop!

PRG011_ADF4:
	RTS		 ; Return


Map_Object_Do:
	; Map object to do...
	JSR Map_Object_CheckVisibility	 ; Check and store if this object is visible

	LDA Map_Objects_IDs,X	; Get the ID

PRG011_AE0B:
	RTS
	; Based on the ID, jump to proper routine for how it should act on the map
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; None (Just RTS)
	.word PRG011_ADF4		; HELP (Just RTS)
	.word Map_Object_Airship	; Airship
	.word Map_Object_March		; Hammer Bro
	.word Map_Object_March		; Boomerang Bro
	.word Map_Object_March		; Heavy Bro
	.word Map_Object_March		; Fire Bro
	.word Map_Object_Stationary	; World 7 Plant
	.word Map_Object_March		; Unknown marching glitch object
	.word Map_Object_March		; N-Spade
	.word Map_Object_March		; White Toad House
	.word Map_Object_March		; Coin Ship
	.word Map_Object_Stationary	; Unknown white colorization of 15 (goes to World 7 level??)
	.word Map_Object_Stationary	; World 8 Battleship
	.word Map_Object_Stationary	; World 8 Tank
	.word Map_Object_Stationary	; World 8 Airship
	.word Map_Object_Canoe		; Canoe

	; Based on march travel direction, these are the movements
Map_Object_Travel_Y:	.byte 0, 0, 1, -1
Map_Object_Travel_X:	.byte 1, -1, 0, 0
Map_Object_Travel_XHi:	.byte 0, -1, 0, 0

Map_Object_March_Offset:
	; For a 32 position march, offset to the object's X coordinate
	.byte -8, -7, -6, -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7
	.byte  8,  7,  6,  5,  4,  3,  2,  1,  0, -1, -2, -3, -4, -5, -6, -7

Map_Object_March_OffsetXHi:
	; For a 32 position march, offset to the object's X Hi coordinate
	.byte -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0
	.byte  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1

Map_Object_March:
	RTS
	; For all map objects which "march" back and forth (includes Hammer/etc. Brothers, and bonuses...)
	LDA Map_Operation
	CMP #$0d	 	
	BNE Map_Object_March_NonNormal	 	; If Map_Operation <> $0D (Normal operation), jump to Map_Object_March_NonNormal

	; Normal operation, objects just "marching" around...
	LDA Map_Objects_IDs,X	; A = object's ID
	;CMP #MAPOBJ_NSPADE
	BLT Map_Object_MusicBoxCheck ; If object ID < MAPOBJ_NSPADE (includes hammer brother types and the world 7 plant), jump to Map_Object_MusicBoxCheck

	CMP #MAPOBJ_BATTLESHIP
	BLT PRG011_AE93	 	; If object ID < MAPOBJ_BATTLESHIP (includes bonus items), jump to PRG011_AE93 (they don't "sleep")

Map_Object_MusicBoxCheck:
	LDA #$00
	BNE PRG011_AED1	 	; If music box is active, jump to PRG011_AED1

PRG011_AE93:
	TXA
	AND #$01
	STA <Temp_Var16	; Temp_Var16 = object's index AND'ed 1 (mixes up the marching a little; left/right swap)

	LDA Map_March_Count
	AND #$10
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = (Map_March_Count & $10) >> 4
	STA Map_Object_Data,X	; Data in the context of a "marcher" is 0/1 depending which direction they're walking (every 16 tics, reverse direction)

	LDA <Temp_Var16	; Get the march flip
	BEQ PRG011_AEAE	 	; If no flip needed, jump to PRG011_AEAE

	; Flip the march direction
	EOR Map_Object_Data,X
	STA Map_Object_Data,X

PRG011_AEAE:
	LDA <Temp_Var16
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var16	; Temp_Var16 <<= 4

	LDA Map_March_Count
	AND #$1f	 	; March count is basically 0-31, flipping at 16
	EOR <Temp_Var16	; Flip the upper bit as appropriate

	TAY		 		; Y = A (the adjusted march)
	LDA Map_Objects_XLo,X		; A = object's X coordinate (low part)
	ADD Map_Object_March_Offset,Y	; Add the proper offset in their march
	STA Map_Object_ActX,X	 	; Store this as their display X

	; X Hi offset as needed
	LDA Map_Object_ActXH,X	
	ADC Map_Object_March_OffsetXHi,Y
	STA Map_Object_ActXH,X	 

PRG011_AED1:
	RTS		 ; Return

Map_Object_March_NonNormal:
	RTS
	; For marchers when Map_Operation <> $0D ...

	CMP #$0b	 
	BNE PRG011_AED1	 	; If Map_Operation <> $0B (Hammer Brothers march around), jump to PRG011_AED1 (RTS)

	LDA #$00
	BNE PRG011_AF46	 	; If music box is active, jump to PRG011_AF46

	; Hammer brothers need to march about...
	LDY <Temp_Var13		; Y = Temp_Var13 (current object we're working on)
	LDX #$01	 	; X = 1

	; For both players...
PRG011_AEDF:

	; Check if Player is standing on map object
	LDA <World_Map_Y,X
	CMP Map_Object_ActY,Y
	BNE PRG011_AEFA	 	; If Player's Y is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA <World_Map_XHi,X
	CMP Map_Object_ActXH,Y
	BNE PRG011_AEFA	 	; If Player's X Hi is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA <World_Map_X,X
	CMP Map_Object_ActX,Y
	BNE PRG011_AEFA	 	; If Player's X Lo is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA #$00
	STA Map_March_Count,Y	; Clear Map_March_Count for this object (why??)
	RTS		 	; Return...

PRG011_AEFA:
	DEX		 ; X--
	BPL PRG011_AEDF	 ; If X >= 0, loop!

	LDA Map_March_Count,Y
	AND #$1f	 	; Cap Map_March_Count to $00-$1F
	BNE PRG011_AF0C	 	; If Map_March_Count value is not zero, jump to PRG011_AF0C

	LDA RandomN,Y	 	; Pulls a random number from the pool (NOTE: This only works for first 7 objects, after that not random)
	AND #$03	 	; Cap value 0-3
	JSR Map_MarchValidateTravel	; Validates traveling in this direction OR does not return here!

PRG011_AF0C:
	LDY <Temp_Var13		; Y = Index of current object we're working with

PRG011_AF46:
	; Jumps here if music box is active
	LDX <Temp_Var13			; X = Temp_Var13
	JSR Map_Object_March_UpdateXs	; Copy updated X's to the map RAM

	DEC Map_March_Count,X	 	; Decrement the march counter
	BNE PRG011_AF84	 		; If not zero, jump to PRG011_AF84 (RTS)

	LDA #$00
	BNE PRG011_AF84	 		; If music box active, jump to PRG011_AF84

	; This is going to loop through all OTHER objects...
	; Basically to make sure this object didn't land on top of another
	LDY #$0d	 
PRG011_AF57:
	CPY <Temp_Var13
	BEQ PRG011_AF81		; If this is the object we're working with, skip this loop!

	LDA Map_Objects_IDs,Y 	; Get this object ID
	BEQ PRG011_AF81	 	; If 0 (no object here), jump to PRG011_AF81
	CMP #MAPOBJ_CANOE
	BGE PRG011_AF81	 	; If ID >= MAPOBJ_CANOE (canoe), jump to PRG011_AF81

	LDA Map_March_Count,Y
	BNE PRG011_AF81

	LDA Map_Object_ActY,Y
	CMP Map_Object_ActY,X
	BNE PRG011_AF81		; Y's are different, OK

	LDA Map_Object_ActXH,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_AF81		; X hi's are different, OK

	LDA Map_Object_ActX,Y
	CMP Map_Object_ActX,X
	BEQ PRG011_AF85		; Gah, everything matched!  I'm standing on something, jump to PRG011_AF85

PRG011_AF81:
	DEY		 ; Y--
	BNE PRG011_AF57	 ; While Y >= 0, loop!

PRG011_AF84:
	RTS		 ; Return

PRG011_AF85:
	; I landed on something, so I gotta re-march
	LDA #$20
	STA Map_March_Count,X	; Redo march

	CPY #$01
	BEQ PRG011_AF93

	LDA #$20	
	STA Map_March_Count,Y

PRG011_AF93:
	RTS		 ; Return


Map_Object_Stationary:
	; For objects like the World 7 plant or World 8 artillery
	; that don't go anywhere ever...

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_AF93	 ; If Map_Operation <> $0B (March Around time), jump to PRG011_AF93 (RTS)
	JMP PRG011_AF46	 ; During the would-be marching period, just animate faster (but no movement)



	; These tables define the possible places that an Airship may
	; travel on the world map; note there are three sets of six
	; possible destinations per world.  And yes, there is space
	; for World 8, though it is unused (zeroed out)

Map_Airship_Dest_YSets:
	.word MAT_Y_W1A, MAT_Y_W1B, MAT_Y_W1C	; World 1 Airship Y Sets
	.word MAT_Y_W2A, MAT_Y_W2B, MAT_Y_W2C	; World 2 Airship Y Sets
	.word MAT_Y_W3A, MAT_Y_W3B, MAT_Y_W3C	; World 3 Airship Y Sets
	.word MAT_Y_W4A, MAT_Y_W4B, MAT_Y_W4C	; World 4 Airship Y Sets
	.word MAT_Y_W5A, MAT_Y_W5B, MAT_Y_W5C	; World 5 Airship Y Sets
	.word MAT_Y_W6A, MAT_Y_W6B, MAT_Y_W6C	; World 6 Airship Y Sets
	.word MAT_Y_W7A, MAT_Y_W7B, MAT_Y_W7C	; World 7 Airship Y Sets
	.word MAT_Y_W8A, MAT_Y_W8B, MAT_Y_W8C	; World 8 Airship Y Sets

Map_Airship_Dest_XSets:
	.word MAT_X_W1A, MAT_X_W1B, MAT_X_W1C	; World 1 Airship X Sets
	.word MAT_X_W2A, MAT_X_W2B, MAT_X_W2C	; World 2 Airship X Sets
	.word MAT_X_W3A, MAT_X_W3B, MAT_X_W3C	; World 3 Airship X Sets
	.word MAT_X_W4A, MAT_X_W4B, MAT_X_W4C	; World 4 Airship X Sets
	.word MAT_X_W5A, MAT_X_W5B, MAT_X_W5C	; World 5 Airship X Sets
	.word MAT_X_W6A, MAT_X_W6B, MAT_X_W6C	; World 6 Airship X Sets
	.word MAT_X_W7A, MAT_X_W7B, MAT_X_W7C	; World 7 Airship X Sets
	.word MAT_X_W8A, MAT_X_W8B, MAT_X_W8C	; World 8 Airship X Sets

	; Map_Airship_Trav selects which world/set to use
	; Map_Airship_Dest selects shich index within to use (0-5)
MAT_Y_W1A:	.byte $A0, $20, $20, $A0, $20, $20	; World 1 Airship Y Set 0
MAT_Y_W1B:	.byte $20, $20, $A0, $A0, $20, $20	;                   Set 1
MAT_Y_W1C:	.byte $20, $20, $A0, $A0, $A0, $A0	;                   Set 2
MAT_Y_W2A:	.byte $20, $60, $20, $40, $40, $40	; World 2 Airship Y Set 0
MAT_Y_W2B:	.byte $60, $40, $20, $20, $60, $20	;                   Set 1
MAT_Y_W2C:	.byte $20, $20, $60, $40, $20, $60	;                   Set 2
MAT_Y_W3A:	.byte $80, $80, $60, $20, $60, $60	; World 3 Airship Y Set 0
MAT_Y_W3B:	.byte $80, $20, $60, $60, $20, $60	;                   Set 1
MAT_Y_W3C:	.byte $60, $20, $60, $60, $60, $20	;                   Set 2
MAT_Y_W4A:	.byte $80, $60, $40, $60, $60, $40	; World 4 Airship Y Set 0
MAT_Y_W4B:	.byte $80, $40, $60, $60, $40, $60	;                   Set 1
MAT_Y_W4C:	.byte $60, $80, $40, $60, $60, $40	;                   Set 2
MAT_Y_W5A:	.byte $80, $80, $40, $80, $40, $80	; World 5 Airship Y Set 0
MAT_Y_W5B:	.byte $40, $80, $80, $60, $40, $20	;                   Set 1
MAT_Y_W5C:	.byte $60, $40, $20, $60, $40, $20	;                   Set 2
MAT_Y_W6A:	.byte $80, $A0, $40, $40, $80, $80	; World 6 Airship Y Set 0
MAT_Y_W6B:	.byte $A0, $40, $40, $80, $80, $80	;                   Set 1
MAT_Y_W6C:	.byte $80, $80, $A0, $A0, $40, $40	;                   Set 2
MAT_Y_W7A:	.byte $90, $70, $30, $90, $70, $30	; World 7 Airship Y Set 0
MAT_Y_W7B:	.byte $70, $30, $90, $50, $30, $90	;                   Set 1
MAT_Y_W7C:	.byte $50, $50, $30, $30, $30, $30	;                   Set 2
MAT_Y_W8A:	.byte $00, $00, $00, $00, $00, $00	; World 8 Airship Y Set 0
MAT_Y_W8B:	.byte $00, $00, $00, $00, $00, $00	;                   Set 1
MAT_Y_W8C:	.byte $00, $00, $00, $00, $00, $00 	;                   Set 2

	; NOTE: To specify a high 'X' (i.e. which map screen of the world
	; the airship is traveling to) you specify it in the LOWER 4 bits.
	; So $A2 equates to coordinate $A0 on the third screen of the map.
MAT_X_W1A:	.byte $60, $60, $C0, $60, $60, $C0	; World 1 Airship X Set 0
MAT_X_W1B:	.byte $C0, $C0, $60, $60, $60, $60	;                   Set 1
MAT_X_W1C: 	.byte $60, $C0, $60, $60, $60, $60	;                   Set 2
MAT_X_W2A:	.byte $A0, $01, $01, $80, $80, $80	; World 2 Airship X Set 0
MAT_X_W2B:	.byte $01, $80, $01, $A0, $01, $01	;                   Set 1
MAT_X_W2C:	.byte $01, $A0, $01, $80, $01, $01	;                   Set 2
MAT_X_W3A:	.byte $B2, $B2, $01, $21, $01, $A0	; World 3 Airship X Set 0
MAT_X_W3B:	.byte $B2, $21, $01, $A0, $40, $A0	;                   Set 1
MAT_X_W3C:	.byte $01, $21, $E0, $A0, $A0, $40	;                   Set 2
MAT_X_W4A:	.byte $E0, $21, $A1, $41, $C1, $01	; World 4 Airship X Set 0
MAT_X_W4B:	.byte $E0, $01, $21, $41, $A1, $C1	;                   Set 1
MAT_X_W4C:	.byte $21, $E0, $A1, $C1, $41, $01	;                   Set 2
MAT_X_W5A:	.byte $A1, $61, $C1, $A1, $C1, $61	; World 5 Airship X Set 0
MAT_X_W5B:	.byte $C1, $61, $A1, $80, $80, $20	;                   Set 1
MAT_X_W5C:	.byte $80, $80, $20, $80, $80, $20	;                   Set 2
MAT_X_W6A:	.byte $02, $61, $C1, $C0, $A0, $21	; World 6 Airship X Set 0
MAT_X_W6B:	.byte $61, $C1, $C0, $02, $21, $A0	;                   Set 1
MAT_X_W6C:	.byte $02, $02, $61, $61, $C0, $C1	;                   Set 2
MAT_X_W7A:	.byte $A1, $A1, $81, $A1, $A1, $81	; World 7 Airship X Set 0
MAT_X_W7B:	.byte $A1, $81, $A1, $F0, $81, $A1	;                   Set 1
MAT_X_W7C:	.byte $F0, $F0, $40, $40, $81, $81	;                   Set 2
MAT_X_W8A:	.byte $00, $00, $00, $00, $00, $00	; World 8 Airship X Set 0
MAT_X_W8B:	.byte $00, $00, $00, $00, $00, $00	;                   Set 1
MAT_X_W8C:	.byte $00, $00, $00, $00, $00, $00	;                   Set 2


PRG011_B11E:
	.byte $03, $04, $05, $00, $00, $05, $00, $00



Map_Object_Airship:
	LDA Map_Operation
	CMP #$0d
	BNE Map_Airship_Travel_To	; If Map_Operation <> $0D (normal), jump to Map_Airship_Travel_To

	LDA #$00
	STA <Temp_Var15		; Temp_Var15 = 0 (Airship facing to the right)
	LDY Player_Current	; Y = Player_Current

	LDA World_Map_XHi,Y	; A = Player's X Hi byte
	CMP Map_Object_ActXH+1	; Airship's X Hi byte
	BEQ PRG011_B140	 	; If they're equal (we're on the same screen), jump to PRG011_B140

	BGE PRG011_B14C	 	; If the airship's X Hi is greater, jump to PRG011_B14C
	BLT PRG011_B148	 	; If the airship's X Hi is lesser, jump to PRG011_B148

PRG011_B140:
	LDA World_Map_X,Y	; Get Player's X
	CMP Map_Object_ActX+1	; Airship's X byte
	BGE PRG011_B14C	 	; If Airship's X >= Player's X, jump to PRG011_B14C

PRG011_B148:
	LDA #$01	 	
	STA <Temp_Var15		; Temp_Var15 = 1 (Airship facing to the left)

PRG011_B14C:
	LDA <Temp_Var15	
	STA Map_Object_Data+1	; Store facing direction into Airship's data
PRG011_B151:
	RTS		 	; Return...

Map_Airship_Travel_To:
	LDA Map_Airship_Trav	
	ASL A		 	
	TAY		 	; Y = Map_Airship_Trav << 1 (indexing...)

	; Based on Map_Airship_Trav, a different base offset into the Tables
	; is selected; provides a little variance on where the Airship will
	; go each time...

	; Get address into Map_Airship_Dest_YSets
	LDA Map_Airship_Dest_YSets,Y
	STA <Temp_Var1		 
	LDA Map_Airship_Dest_YSets+1,Y
	STA <Temp_Var2		 

	; Get address into Map_Airship_Dest_XSets
	LDA Map_Airship_Dest_XSets,Y
	STA <Temp_Var3	
	LDA Map_Airship_Dest_XSets+1,Y
	STA <Temp_Var4	

	LDA Map_Operation
	CMP #$04
	BNE PRG011_B1A7	 ; If Map_Operation <> 4, jump to PRG011_B1A7

PRG011_B17A:
	LDA #$00
	STA Map_March_Count+1	; Clear Airship's counter

	LDY Map_Airship_Dest
	CPY #$06	 
	BGE PRG011_B1A2	 	; If Map_Airship_Dest >= 6, jump to PRG011_B1A2

	; Get and set the destination Y of the Airship travel
	LDA [Temp_Var1],Y	; Get the Y from the table
	STA Map_Object_ActY+1
	STA Map_Objects_Y+1

	; Get and set the destination X of the Airship travel
	LDA [Temp_Var3],Y	; Get the X from the table
	PHA		 	; Save 'A'

	; High part
	AND #$0f	 	; Get only the low bits (this is used to specify the "high" part, funny enough)
	STA Map_Object_ActXH+1
	STA Map_Objects_XHi+1

	; Low part
	PLA		 	; Restore 'A"
	AND #$f0	 	; Only the high bits specify the low X byte
	STA Map_Object_ActX+1
	STA Map_Objects_XLo+1

PRG011_B1A2:
	LDX #$01	 		; X = 1 (the Airship's object index)
	JMP Map_Object_March_UpdateXs	; Update changed X coordinates

PRG011_B1A7:
	; Airship when Map_Operation <> 4

	LDA Map_March_Count+1	; Airship's "March count"
	BEQ PRG011_B151	 	; If zero, jump to PRG011_B151 (RTS)

	LDA <Map_Airship_DC
	BEQ PRG011_B1B3	 	; If Map_Airship_DC = 0 (deltas not yet computed), jump to PRG011_B1B3
	JMP PRG011_B2B8	 	; Otherwise, jump to PRG011_B2B8...

PRG011_B1B3:
	LDY Map_Airship_Dest	; Y = Map_Airship_Dest
	CPY #$06	 
	BLT PRG011_B1BD	 	; If Airship still has moves left, jump to PRG011_B1BD
	JMP PRG011_B221	 	; Otherwise, jump to PRG011_B221

PRG011_B1BD:
	LDA Map_Object_ActXH+1	
	ORA Map_Object_ActX+1	; A = Airship's current X with XHi OR'd into the low bits
	CMP [Temp_Var3],Y	; Check if airship is at X destination yet
	BNE PRG011_B1CE	 	; If not, jump to PRG011_B1CE

	LDA Map_Object_ActY+1	; A = Airship's Y
	CMP [Temp_Var1],Y	; Check if airship is at Y destination yet
	BEQ PRG011_B21B	 	; If it is, jump to PRG011_B21B

PRG011_B1CE:
	LDA [Temp_Var1],Y	; Get Y destination from table
	STA <Temp_Var5		; Store into Temp_Var5

	LDA [Temp_Var3],Y	; Get X destination from table
	AND #$0f	 	; Only keep lower part (XHi)
	STA <Temp_Var7		; Store into Temp_Var7

	LDA [Temp_Var3],Y	; Get X destination from table
	AND #$f0	 	; Only keep higher part (X lo)
	STA <Temp_Var6		; Store into Temp_Var6

	LDA <Temp_Var5
	SUB #32	
	STA <Temp_Var5		; Temp_Var5 (Y destination) -= 32

	LDA <Temp_Var6
	SUB #32
	STA <Temp_Var6		; Temp_Var6 (X lo destination) -= 32
	LDA <Temp_Var7	
	SBC #$00
	STA <Temp_Var7		; Temp_Var7 (X hi destination) applies carry as appropriate

	LDX Total_Players
	DEX			; X = 0 for 1P mode, 1 for 2P mode

PRG011_B1F6:
	; The following are calculating differences between the Airship and players, but I'm not sure for what purpose
	; Maybe to keep the airship from landing directly on top of a Player?
	; This may be troublesome...
	LDA Map_Previous_Y,X	; Get previous Y position for Player
	SUB <Temp_Var5		; Subtract the Y destination 
	CMP #$41	 
	BGE PRG011_B215	 	; If result >= $41, jump to PRG011_B215 (What is this for??)

	LDA Map_Previous_X,X	; Get previous X position for Player
	SUB <Temp_Var6		; Subtract the X lo destination 
	STA <Temp_Var6		; And update Temp_Var6

	LDA Map_Previous_XHi,X 	; Get previous X Hi position for Player
	SBC <Temp_Var7		; Subtract carry from Temp_Var7
	BNE PRG011_B215	 	; If greater than zero, jump to PRG011_B215

	LDA <Temp_Var6		; Get adjusted result
	CMP #$41	 	; 
	BLT PRG011_B21B	 	; If result < $41, jump to PRG011_B21B (stops Airship)

PRG011_B215:
	DEX		 
	BPL PRG011_B1F6	 	; If 2P mode, jump to PRG011_B1F6 (do it again for other Player)
	JMP PRG011_B229	 	; Otherwise, jump to PRG011_B229

PRG011_B21B:
	; Airship's at destination!
	INC Map_Airship_Dest	; Use next destination if it has to travel again...
	JMP PRG011_B1B3	 	; Jump to PRG011_B1B3 (verifies Airship has no moves left; it apparently can change course if needed?)

PRG011_B221:
	; Airship has no moves left..
	LDX <Temp_Var13		; Retores index of object we were processing 
	LDA #$00	 	
	STA Map_March_Count+1	; Clear moves
	RTS			; Return...

PRG011_B229:
	; After Player difference statements...
	LDX <Temp_Var13		; X = Object we were processing
	LDY Map_Airship_Dest	; Y = Current Airship destination index (0-5)
	LDA #$00	 
	STA Map_Object_Data+1	; Airship's data = 0 (facing direction)
	STA <Map_Airship_Dir	; Map_Airship_Dir = 0

	LDA [Temp_Var1],Y	; A = Airship Y destination
	SUB Map_Object_ActY+1	; Difference against its current Y
	STA <Map_Airship_DY	; Store into Map_Airship_DY

	LDA [Temp_Var3],Y	; A = Airship X destination
	AND #$f0	 	; Just the X Lo part
	SUB Map_Object_ActX+1	; Difference to its current X Lo
	STA <Map_Airship_DX	; Store into Map_Airship_DX

	LDA [Temp_Var3],Y	; A = Airship X destination
	AND #$0f	 	; Just the X Hi part 
	SBC Map_Object_ActXH+1	; Difference to its current X Hi (taking into account the low too)
	STA <Map_Airship_DXHi	; Store into Map_Airship_DXHi


	LDA [Temp_Var3],Y	; Get airship X target
	AND #$0f	 	; Only lower bits (hi part)
	CMP Map_Object_ActXH+1	; Compare against its current X hi...

	BEQ PRG011_B25D	 	; If the same, jump to PRG011_B25D
	BPL PRG011_B27D	 	; Airship X Hi > target X Hi, jump to PRG011_B27D
	BMI PRG011_B266	 	; Airship X Hi < target X Hi, jump to PRG011_B266
PRG011_B25D:
	; Airship X achieved
	LDA [Temp_Var3],Y
	AND #$f0
	CMP Map_Object_ActX+1
	BGE PRG011_B27D	 ; If target X (aligned to grid) >= airship X , jump to PRG011_B27D

PRG011_B266:
	; Airship X Hi < target X Hi
	LDA #$01	 	
	STA <Map_Airship_Dir	; Map_Airship_Dir = 1 (H negation active)

	; Negate Map_Airship_DXHi
	LDA #$ff	 	
	EOR <Map_Airship_DXHi	
	STA <Map_Airship_DXHi

	; Negate Map_Airship_DX
	LDA #$ff	 	
	EOR <Map_Airship_DX
	STA <Map_Airship_DX
	INC <Map_Airship_DX

	LDA #$01	 
	STA Map_Object_Data+1	; Airship's data = 1 (facing direction)

PRG011_B27D:
	; Airship Hi > target X Hi or coming in from above...

	LDA [Temp_Var1],Y	
	CMP Map_Object_ActY+1	
	BGE PRG011_B292	 	; If target Y >= current Y, jump to PRG011_B292

	; Otherwise, negate Map_Airship_DY
	LDA #$ff	
	EOR <Map_Airship_DY
	STA <Map_Airship_DY
	INC <Map_Airship_DY

	; Set V negation active bit in Map_Airship_Dir
	LDA <Map_Airship_Dir
	ORA #$02	 	
	STA <Map_Airship_Dir	

PRG011_B292:


	; This loop shifts Map_Airship_DY and Map_Airship_DXHi/Map_Airship_DX to the right four bits,
	; and stores the shifted out lower 4 bits as high bits to a new variable.
	; The resulting Map_Airship_DY / Map_Airship_DX are map row/col values instead
	LDY #$04	 	; Y = 4
PRG011_B294:
	CLC		 	; Clear carry
	LSR <Map_Airship_DY	; Map_Airship_DY >> 1 
	ROR <Map_Airship_YNib	; Accumulating the pushed out bits

	CLC			; Clear carry
	LSR <Map_Airship_DXHi	; Map_Airship_DXHi >> 1
	ROR <Map_Airship_DX	; Bit from above pushed into Map_Airship_DX as topmost bit, carry out
	ROR <Map_Airship_XNib	; Accumulating the pushed out bits

	DEY		 	; Y--
	BPL PRG011_B294	 	; While Y >= 0, loop!

	; The end result here is actually a 16-bit shift to the LEFT
	; for Map_Airship_DXHi/Map_Airship_DX
	LDA <Map_Airship_DX
	STA <Map_Airship_DXHi	; Map_Airship_DXHi = Map_Airship_DX
	LDA <Map_Airship_XNib
	STA <Map_Airship_DX	; Map_Airship_DX = Map_Airship_XNib

	; Clear Map_Airship_XNib for next time
	LDA #$00
	STA <Map_Airship_XNib	; Map_Airship_XNib = 0

	LDA #$01	 
	STA <Map_Airship_DC	; Map_Airship_DC = 1 (deltas computed!)

	LDA #32
	STA Map_Intro_Tick	; Map_Intro_Tick = 32

PRG011_B2B8:
	; Deltas are computed and we're going...
	; Do a 32 tick "flash" effect first before moving...
	LDA Map_Intro_Tick
	BEQ PRG011_B2C0	 		; If ticks = 0, jump to PRG011_B2C0
	JMP FX_MonoFlash_By_MapTick	; Otherwise, jump to FX_MonoFlash_By_MapTick (on Page 10)

PRG011_B2C0:
	; LDA Map_Anchored
	; BEQ PRG011_B2D0	 	; If Map_Anchored = 0 (Airship not anchorned), jump to PRG011_B2D0

	; ; Airship's anchored!
	; LDA #$00	 
	; STA Map_March_Count+1		; Stop Airship
	; STA Map_Airship_Dest		; Reset destination index
	; JMP Map_Object_March_UpdateXs	; And that's it...

PRG011_B2D0:
	LDA SndCur_Level2	
	AND #$08	 	
	BNE PRG011_B2DF	 	; If Airship sound effect is playing, jump to PRG011_B2DF

	; Otherwise, re-queue it (effective loop)
	LDA Sound_QLevel2
	ORA #SND_LEVELAIRSHIP
	STA Sound_QLevel2

PRG011_B2DF:
	LDX #$01	 		; X = 1 (the Airship index)

	; This ultimately controls how fast the Airship flies on the map
	; You should see it fly with no delay :)
	LDA <Counter_1			
	AND #$03
	BNE Map_Object_March_UpdateXs	; Basically only do something once every 4 ticks

	; For the 1:4 tick...
	LDA <Map_Airship_Dir
	AND #$01	 
	BNE PRG011_B307	 	; If Map_Airship_Dir = 1 (to the right), jump to PRG011_B307

	; Reuse of Map_Airship_XNib...
	LDA <Map_Airship_XNib	
	ADD <Map_Airship_DX	
	STA <Map_Airship_XNib	; Map_Airship_XNib += Map_Airship_XNib

	; Advances Airship's X Hi / X, positive
	LDA Map_Object_ActX+1
	ADC <Map_Airship_DXHi
	STA Map_Object_ActX+1
	LDA Map_Object_ActXH+1
	ADC #$00	
	STA Map_Object_ActXH+1

	JMP PRG011_B31E

PRG011_B307:
	LDA <Map_Airship_XNib
	SUB <Map_Airship_DX
	STA <Map_Airship_XNib	; Map_Airship_XNib -= Map_Airship_XNib

	; Advances Airship's X Hi / X, negative
	LDA Map_Object_ActX+1
	SBC <Map_Airship_DXHi
	STA Map_Object_ActX+1
	LDA Map_Object_ActXH+1
	SBC #$00
	STA Map_Object_ActXH+1

PRG011_B31E:
	LDA <Map_Airship_Dir
	AND #$02	 
	BNE PRG011_B336	 	; If traveling upward, jump to PRG011_B336

	; Positive advancement of Y
	LDA <Map_Airship_YAcc
	ADD <Map_Airship_YNib
	STA <Map_Airship_YAcc
	LDA Map_Object_ActY+1
	ADC <Map_Airship_DY
	STA Map_Object_ActY+1

	JMP PRG011_B345	 	; Jump to PRG011_B345

PRG011_B336:

	; Negative advancement of Y
	LDA <Map_Airship_YAcc
	SUB <Map_Airship_YNib
	STA <Map_Airship_YAcc
	LDA Map_Object_ActY+1
	SBC <Map_Airship_DY
	STA Map_Object_ActY+1

PRG011_B345:
	LDX #$01	 		; The Airship's index
	DEC Map_March_Count+1	
	BNE Map_Object_March_UpdateXs	; While more moves to go, just update

	; Out of moves; Airship has stopped!
	; Make sure it's right where it should be!
	LDA Map_Object_ActY+1	
	STA Map_Objects_Y+1	
	LDA Map_Object_ActXH+1	
	STA Map_Objects_XHi+1	
	LDA Map_Object_ActX+1	
	STA Map_Objects_XLo+1	

	LDX #$01	 	; X = 1 (Airship's index)
	INC Map_Airship_Dest	; Use next destination next time

Map_Object_March_UpdateXs:
	; Copy the object's moved X lo & hi to the stored map versions
	LDA Map_Object_ActX,X
	STA Map_Objects_XLo,X
	LDA Map_Object_ActXH,X
	STA Map_Objects_XHi,X
	RTS		 	; Return


	; Travel directions:
	; 0 = Right, 1 = Left, 2 = Down, 3 = Up
Map_Object_March_YOffByDir:	.byte 0, 0, 16, -16	; Travel direction Y offsets for marching map brother
				.byte 0, 0, 32, -32	; Next tile over; if the first tile is OK, see if the destination is OK too

Map_Object_March_XOffByDir:	.byte 16, -16, 0, 0	; Travel direction X offsets for marching map brother
				.byte 32, -32, 0, 0	; Next tile over; if the first tile is OK, see if the destination is OK too

Map_Object_March_XHiOffByDir:	.byte 0, -1, 0, 0	; Travel direction X Hi offsets for marching map brother
				.byte 0, -1, 0, 0	; Next tile over; if the first tile is OK, see if the destination is OK too

	; Tiles that are forbidden for the marching object to "land" on
Map_Object_Forbid_LandingTiles:
	.byte TILE_MARIOCOMP_O, TILE_LUIGICOMP_O, TILE_MARIOCOMP_P, TILE_LUIGICOMP_P
	.byte TILE_DANCINGPALM, TILE_DANCINGBUSH, TILE_PIPE,        TILE_SPADEBONUS 
	.byte TILE_SPIRAL,      TILE_ALTSPIRAL,   TILE_FORTRUBBLE,  TILE_MARIOCOMP_G
	.byte TILE_LUIGICOMP_G, TILE_MARIOCOMP_R, TILE_LUIGICOMP_R, TILE_ALTRUBBLE
	.byte TILE_START
Map_Object_Forbid_LT_End

	; This makes it safe to expand the above
	; There's a mistake in here somewhere, I think Nintendo did their loop/indexing wrong
	; See notes at PRG011_B406
MOV_Landings2Check = (Map_Object_Forbid_LT_End - Map_Object_Forbid_LandingTiles) + 1


	; Extra tiles that a hammer bro is forbidden from stepping on
	; I don't know why these are split from the above?
Map_MarchXtraForbidTiles:
	.byte TILE_TOADHOUSE, TILE_ALTTOADHOUSE, TILE_CASTLEBOTTOM, TILE_PATHANDNUB	; <-- Last one is weird "enterable"!
Map_MarchXtraForbidTiles_End


Map_MarchValidateTravel:
	; A = pseudo-random value, 0-3
	STA <Temp_Var1		; Temp_Var1 = random val 0-3
	LDA #$04
	STA <Temp_Var2		; Temp_Var2 = 4

PRG011_B3A3:
	LDY <Temp_Var13		; Y = Temp_Var13 (Current object we're working on)
	DEC <Temp_Var1		; Temp_Var1--

	LDA RandomN,Y	 	; Get the full random value
	ASL A		 	; A << 1
	BCC PRG011_B3B1	 	; If the bit 7 was not set, carry is clear, and jump to PRG011_B3B1

	INC <Temp_Var1
	INC <Temp_Var1		; Otherwise, Temp_Var1 (the 0-3 input) += 2

PRG011_B3B1:
	LDA <Temp_Var1		; A = Temp_Var1 (0-5 now)
	AND #$03	 
	STA <Temp_Var1		; Enforcing 0-3 cap on Temp_Var1

	; Temp_Var1 is a value from 0-3 that specifies a travel direction

	EOR Map_Object_Data,Y	; March direction possible invert
	CMP #$01	 
	BEQ PRG011_B3A3	 	; If current result = 1, jump to PRG011_B3A3

	DEC <Temp_Var2		; Temp_Var2--
	BPL PRG011_B3CA	 	; If Temp_Var2 >= 0, jump to PRG011_B3CA

	LDA #$00
	STA Map_March_Count,Y	; Clear Map_March_Count value

	; ******!!!
	; NOTE: Don't actually return to caller; return to caller's caller!
	PLA		 
	PLA
	RTS		 ; Return

LT0B:
PRG011_B3CA:
	BNE PRG011_B3D3	 	; If Temp_Var2 <> 0, jump to PRG011_B3D3

	; When Temp_Var2 = 0...
	LDA Map_Object_Data,Y	; Get march direction
	EOR #$01	 	; Flip it
	STA <Temp_Var1		; Store that to Temp_Var1

PRG011_B3D3:
	LDX <Temp_Var1		; X = Temp_Var1 (0-3)
	JSR Map_Object_March_PickTravel	; Sets Map_Tile_Addr, figures travel destination in Temp_Var3 (upper 4 containing target row, lower 4 containing target column)

	LDA <Temp_Var1		; A = Temp_Var1 (0-3) travel dir
	ASL A		 	; A << 1 (index)
	TAX		 	; X = A

	; Get address Map_Object_Valid_Tiles (on page 10), store into Temp_Var15
	; This lists valid tiles the object may travel over...
	LDA Map_Object_Valid_Tiles,X
	STA <Temp_Var15	
	LDA Map_Object_Valid_Tiles+1,X
	STA <Temp_Var16

	LDY <Temp_Var3		; Y = Temp_Var3 (travel target)
	LDA [Map_Tile_AddrL],Y	; Get tile here

	LDY #(Map_Object_Valid_Tiles2Check-1)	; Check all possible travel-over tiles
PRG011_B3EC:
	CMP [Temp_Var15],Y
	BEQ PRG011_B3F5	 	; If this tile is valid to travel over, jump to PRG011_B3F5
	DEY		 ; Y--
	BPL PRG011_B3EC	 ; While Y >= 0, loop!
	BMI PRG011_B3A3	 ; If we couldn't find a tile valid to travel over, jump to PRG011_B3A3 to choose anew...

PRG011_B3F5:
	; Valid tile in front of us, now check if we can move one more!
	; (Moves are in two tiles, not one; make sure "landing zone" is safe)
	LDY <Temp_Var13	 ; Y = Temp_Var13 (object we're working on)
	LDA <Temp_Var1	 ; A = Temp_Var1
	ADD #$04	 ; Offset the travel dir +4; check next tile over (since moves are made by 2 tiles, not 1)

	TAX		 ; X = A (travel dir)
	JSR Map_Object_March_PickTravel	 ; Get next tile over, "landing zone"

	LDY <Temp_Var3			; Y = Temp_Var3 (travel target)
	LDA [Map_Tile_AddrL],Y		; Get tile here

	LDY #(MOV_Landings2Check-1)
PRG011_B406:
	; NOTE: For some reason, they were checking one byte prior to the actual
	; LUT, but then they won't decrement 'Y' down to zero (so it stays within
	; the LUT); there must have been a mistake here somewhere? :)
	CMP Map_Object_Forbid_LandingTiles-1,Y
	BNE PRG011_B40E	 ; If this is not a forbidden landing tile, jump to PRG011_B40E
	JMP PRG011_B3A3	 ; Otherwise, jump to PRG011_B3A3

PRG011_B40E:
	DEY		 ; Y--
	BNE PRG011_B406	 ; While Y > 0, loop!

	LDX <Temp_Var13		 	; X = Temp_Var13
	LDY #(Map_MarchXtraForbidTiles_End - Map_MarchXtraForbidTiles)	
PRG011_B415:
	; NOTE: Like PRG011_B406, this loop doesn't hit index 0.  Wonder why??
	CMP Map_MarchXtraForbidTiles-1,Y
	BEQ PRG011_B42A	 ; If tile is one of the additional forbidden tiles, jump to PRG011_B42A

	DEY		 ; Y--
	BNE PRG011_B415	 ; While Y <> 0, loop!

	PHA		 ; Save tile

	; Calculate tile quadrant
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY	; -> 'Y'

	PLA		 ; Restore tile

	;CMP Tile_AttrTable+4,Y
	BLT PRG011_B435	 ; If this tile is not enterable, jump to PRG011_B435 (safe landing)

PRG011_B42A:

	LDA #$20
	CMP Map_March_Count,X
	BNE PRG011_B435	 ; If March counter <> $20, jump to PRG011_B435

	; More time to march
	ASL A		 ; A = $40
	STA Map_March_Count,X	 ; -> March counter

PRG011_B435:
	; Safe landing!
	LDA <Temp_Var1
	STA Map_Object_Data,X

	RTS		 ; Return

Map_Object_March_PickTravel:
	; Sets Map_Tile_Addr, figures travel destination in Temp_Var3 (upper 4 containing target row, lower 4 containing target column)

	LDA Map_Object_ActY,Y	 ; A = Map object's Y
	ADD Map_Object_March_YOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the Y coordinate
	STA <Temp_Var3		 ; Result into Temp_Var3

	LDA Map_Object_ActX,Y	 ; A = Map object's X
	ADD Map_Object_March_XOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the X coordinate
	STA <Temp_Var4		 ; Result into Temp_Var4

	LDA Map_Object_ActXH,Y	 ; A = Map object's X hi byte
	ADC Map_Object_March_XHiOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the X Hi
	ASL A		 	; Index into Tile_Mem_Addr
	TAX		 	; X = A

	; Get to proper offset for where object stands, +$F0
	LDA Tile_Mem_Addr,X
	ADD #$f0
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	ADC #$00
	STA <Map_Tile_AddrH

	LDA <Temp_Var4	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	ORA <Temp_Var3	; Makes an assumption that the object's Y value is row-aligned (which it generally is)
	STA <Temp_Var3	; Temp_Var3 = (Temp_Var4 >> 4) | Temp_Var3
	RTS		; Return

	; First column is for when the object is sleeping by Music Box (if applicable)
	; The other two are the animation...

MapObject_LeftTile:
	.byte $0D, $11, $15, $19	; 01=Rain
	.byte $2D, $31, $35, $39	; 02=Snow
	.byte $21, $21, $41, $41	; 03=Ship
	.byte $47, $47, $47, $47	; 04=wrecked Ship
	.byte $4D, $4D, $4D, $4D	; 05=Boo
	.byte $51, $51, $51, $51	; Red mushroom
	.byte $11, $11, $11, $11	;
	.byte $51, $51, $51, $51	; Green Mushroom
	.byte $51, $51, $51, $51	; Orange Mushroom
	.byte $11, $11, $11, $11	;
	.byte $13, $13, $13, $13	;
	.byte $17, $17, $17, $17	;
	.byte $FD, $1B, $FD, $1B	;
	.byte $F5, $F9, $F5, $F9	;
	.byte $E5, $E9, $E5, $E9	;
	.byte $FD, $1B, $FD, $1B	;
	.byte $71, $75, $71, $75	;

MapObject_RightTile:
	.byte $0F, $13, $17, $1B	; 01=Rain
	.byte $2F, $33, $37, $3B	; 02=Snow
	.byte $23, $23, $43, $43	; 03=Ship
	.byte $49, $49, $49, $49	; 04=wrecked Ship
	.byte $4F, $4F, $4F, $4F	; 05=Boo
	.byte $53, $53, $53, $53	; Red mushroom
	.byte $11, $11, $11, $11	; None
	.byte $53, $53, $53, $53	; Blue Mushroom
	.byte $53, $53, $53, $53	; Orange Mushroom
	.byte $21, $21, $21, $21	; 
	.byte $15, $15, $15, $15	; 
	.byte $19, $19, $19, $19	; 
	.byte $FF, $BB, $FF, $BB	; 
	.byte $F7, $FB, $F7, $FB	; 
	.byte $E7, $EB, $E7, $EB	; 
	.byte $FF, $BB, $FF, $BB	; 
	.byte $73, $77, $73, $77	; 

MapObject_AttrLeft:
	.byte $02, $02, $02, $02	; 01=Rain Cloud
	.byte $02, $02, $02, $02	; 02=Snow
	.byte $03, $03, $03, $03	; 03=Ship
	.byte $03, $03, $03, $03	; 04=wrecked Ship
	.byte $02, $02, $02, $02	; 05=Boo
	.byte $01, $01, $01, $01	; Red Mushroom
	.byte $02, $02, $02, $02	; None
	.byte $02, $02, $02, $02	; Blue Mushroom
	.byte $03, $03, $03, $03	; Orange Mushroom
	.byte $03, $03, $03, $03	; 
	.byte $03, $03, $03, $03	; 
	.byte $03, $03, $03, $03	; 
	.byte $03, $03, $03, $03	; 
	.byte $02, $02, $02, $02	; 
	.byte $02, $02, $02, $02	; 
	.byte $01, $01, $01, $01	; 
	.byte $02, $02, $02, $02	; 

MapObject_AttrRight:
	.byte $02, $02, $02, $02	; 01=Rain Cloud
	.byte $02, $02, $02, $02	; 02=Snow
	.byte $03, $03, $03, $03	; 03=Ship
	.byte $03, $03, $03, $03	; 04=wrecked Ship
	.byte $02, $02, $02, $02	; 05=Boo
	.byte $01, $01, $01, $01	; Red Mushroom
	.byte $02, $02, $02, $02	; None
	.byte $02, $02, $02, $02	; Blue Mushroom
	.byte $03, $03, $03, $03	; Orange Mushroom
	.byte $03, $03, $03, $03	; 
	.byte $03, $03, $03, $03	; 
	.byte $03, $03, $03, $03	; 
	.byte $03, $03, $03, $03	; 
	.byte $02, $02, $02, $02	; 
	.byte $02, $02, $02, $02	; 
	.byte $01, $01, $01, $01	; 
	.byte $02, $02, $02, $02	; 

	; This is a rotated array of Sprite_RAM offsets, helps distribute
	; the map object display so even if there's scanline overflows,
	; there will be at least some visibility of all objects.
Map_SpriteRAM_Offset:
	.byte $08, $10, $18, $20, $28, $30, $38, $40


MapObjects_UpdateDrawEnter:
	JSR Map_Object_Do_All	 ; Runs update code for all map objects

	; Temp_Var13 = $0D
	LDA #$07	 	; Total map objects which may exist on the map (only 8 are defined at start)
	STA <Temp_Var13

	; Map_SprRAMOffDistr runs from $00 to $0A, inclusive
	INC Map_SprRAMOffDistr

	LDA Map_SprRAMOffDistr
	AND #$07
	STA Map_SprRAMOffDistr

PRG011_B554:

	; Temp_Var6 = 0
	LDA #$00
	STA <Temp_Var6

	LDY <Temp_Var13	 ; Y = Temp_Var13 (current map slot index)
	LDA Map_SpriteRAM_Offset, Y	 ; A = Map_SprRAMOffDistr + Temp_Var13

PRG011_B568:
	STA <Temp_Var6		 	; -> Temp_Var6

PRG011_B56E:
	LDX <Temp_Var13		 ; X = Temp_Var13

	LDA Map_Objects_Vis,X
	BEQ PRG011_B578	 ; If this object isn't visible, jump to PRG011_B578

	JSR MapObject_DrawSleepEnter	 ; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered

PRG011_B578:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG011_B554	 ; While Temp_Var13 >= 0, loop!

PRG011_B57C:
	LDA Map_Operation
	CMP #$0d
	BNE PRG011_B58C	 ; If the map operation <> $0D (normal), jump to PRG011_B58C (RTS)

	LDA <Counter_1
	AND #$03
	BNE PRG011_B58C

	INC Map_March_Count	; Increment Map_March_Count every 4 ticks

PRG011_B58C:
	RTS		 ; Return


	; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered
MapObject_DrawSleepEnter:
	LDA Map_Objects_IDs,X
	; Map object slot 0 (typ. HELP bubble) or any object that is not in the Map_HideObj override slot

	; Jump by the Map Object ID (this is largely wasted here...)
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; 00=None (RTS)
	.word MapObj_DrawAndEnter	; 01=HELP
	.word MapObj_DrawAndEnter	; 02=Airship
	.word MapObj_DrawAndEnter	; 03=Hammer Bro
	.word MapObj_DrawAndEnter	; 04=Boomerang Bro
	.word MapObj_DrawAndEnter	; 05=Heavy Bro
	.word MapObj_DrawAndEnter	; 06=Fire Bro
	.word MapObj_DrawAndEnter	; 07=World 7 Plant
	.word MapObj_DrawAndEnter	; 08=Unknown marching glitch object
	.word MapObj_DrawAndEnter	; 09=N-Spade
	.word MapObj_DrawAndEnter	; 0A=White Toad House
	.word MapObj_DrawAndEnter	; 0B=Coin Ship
	.word MapObj_DrawAndEnter	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.word MapObj_DrawAndEnter	; 0D=World 8 Battleship
	.word MapObj_DrawAndEnter	; 0E=World 8 Tank
	.word MapObj_DrawAndEnter	; 0F=World 8 Airship
	.word MapObj_DrawAndEnter	; 10=Canoe

MapObj_DrawAndEnter:
	LDA <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)
	ADD #$90
	STA <Temp_Var6
	TAY

	LDA #$00	 ; A = 0 (no offset on map sprite)

	; Set Y for map object sprite
	ADD Map_Object_ActY,X
	STA Sprite_RAMY,Y
	STA Sprite_RAMY + 4,Y

	; Set X for map object sprite
	LDA Map_Object_ActX,X
	SUB <Horz_Scroll
	STA Sprite_RAMX,Y

	; Right half
	ADD #$08
	STA Sprite_RAMX + 4,Y

	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	; Map object ID -> Temp_Var8
	LDA Map_Objects_IDs,X
	STA <Temp_Var8

	LDA <Counter_1	 ; X = 8 (masking value against Counter_1 for animation)
	AND #$30
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var9	 ; -> Temp_Var9 (masking value for animation)

	LDA <Temp_Var8	 ; A = map object ID
	ASL A		 ; Multiply by 2
	ASL A		 ; Multiply by 4
	ADD <Temp_Var9
	TAX

PRG011_B630:
	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Load the patterns of the map object
	LDA MapObject_LeftTile-4,X
	STA Sprite_RAMTile,Y

	LDA MapObject_RightTile-4,X	
	STA Sprite_RAMTile + 4,Y	

	
	; Load the attributes of the map object
	LDA MapObject_AttrLeft-4,X	
	STA Sprite_RAMAttr,Y	

	LDA MapObject_AttrRight-4,X	
	STA Sprite_RAMAttr + 4,Y	

	RTS

;	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)
;
;	LDA Map_Objects_IDs,X
;	LDY <Temp_Var13		 ; Y = Temp_Var13 (the map object slot index)
;
;	; HELP bubble was already eliminated
;
;	; Map Object ID $03-$08  all jump to PRG011_B69C
;	; Otherwise, jump to PRG011_B6A1
;	LDA Map_Objects_IDs,Y
;	LDA Map_DrawPanState
;	BNE PRG011_B6F5	 ; If some kind of map drawing/panning activity is occurring, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Pan_Count
;	BNE PRG011_B6F5	 ; If the map is panning, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Operation
;	CMP #$0D
;	BNE PRG011_B6F5	 ; If Map_Operation <> $0D (something is going on), jump to PRG011_B6F5 (RTS)
;
;	LDX Player_Current	 ; X = Player_Current
;
;	; If the Player is not perfectly situated on top of the map object, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Objects_Y,Y
;	CMP <World_Map_Y,X
;	BNE PRG011_B6F5
;
;	LDA Map_Objects_XHi,Y
;	CMP <World_Map_XHi,X
;	BNE PRG011_B6F5
;
;	LDA Map_Objects_XLo,Y
;	CMP <World_Map_X,X
;	BNE PRG011_B6F5	
;
;	; Player is going to "enter" this map object...
;
;	LDX Player_Current	 ; X = Player_Current (needless reload?)
;
;	LDA #$00
;	STA Map_Player_SkidBack,X
;
;	LDA #$03
;	STA World_EnterState
;
;	; Store the object ID -> Map_EnterViaID
;	;LDA Map_Objects_IDs,Y
;	;STA <Map_EnterViaID
;
;	; If this is a N-Spade or White Toad house, jump to PRG011_B6E2
;	;CMP #MAPOBJ_NSPADE
;	BEQ PRG011_B6E2
;	;CMP #MAPOBJ_WHITETOADHOUSE
;	BNE PRG011_B6E5
;
;PRG011_B6E2:
;	; N-Spade and White Toad House only...
;	INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn
;
;PRG011_B6E5:
;	LDA Map_Objects_Itm,Y
;	STA Level_TreasureItem
;
;	; Begin level entry
;	LDA #$0f
;	STA Map_Operation
;
;	; Don't return to caller!
;	PLA
;	PLA
;
;	JMP PRG011_B57C	; Jump to PRG011_B57C
;
;PRG011_B6F5:
;	RTS		 ; Return
;
;	; FIXME: Anyone want to claim this?  (Exact same routine appears in PRG010 @ $D228)
;; $B6F6 
;	LDX Player_Current	 ; X = Player_Current
;
;	LDA <World_Map_Dir,X	; Get Player's map direction
;	EOR #$03
;	CMP #$03
;	BNE PRG011_B703	 	; If Player did not travel left or right, jump to PRG011_B703
;
;	EOR #$0f	 ; Otherwise invert all direction bits??
;
;PRG011_B703:
;	STA <World_Map_Dir,X	 ; -> World_Map_Dir
;
;	RTS		 ; Return

	; FIXME: Anyone want to claim this?
	; Gets a tile based on an input 'Y' value to pick from one of the offset sets below...
PRG011_B706:	.byte -16, -16, 0, -32
PRG011_B70A:	.byte $00, $FF, $00, $00	; 16-bit sign extensions
PRG011_B70E:	.byte 16, -16, 0, 0

; $B712
	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_Y,X
	ADD PRG011_B706,Y
	STA <Temp_Var15	

	LDA <World_Map_X,X
	ADD PRG011_B70E,Y
	STA <Temp_Var16	

	LDA <World_Map_XHi,X
	ADC PRG011_B70A,Y
	ASL A		 ; 2 byte index per map screen
	TAX		 ; -> 'X'

	; Set pointer to map screen tiles
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH
	INC <Map_Tile_AddrH	; Map is always on lower part

	; Form row/column offset
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16
	LDA <Temp_Var15
	AND #$f0
	ORA <Temp_Var16
	TAY	 ; -> 'Y'

	LDA [Map_Tile_AddrL],Y	; Get tile
	RTS		 ; Return


PRG011_B74A:
	LDX Map_Unused738		; X =  Map_Unused738

	;LDA Map_Unused7DC6,X
	CMP #$09
	BLT MapStarsIntro_DoStarFX	; If Map_Unused7DC6[X] < 9, jump to MapStarsIntro_DoStarFX

	; Map_StarsState = 1
	LDA #$01
	STA <Map_StarsState

	LDX Player_Current	; X = Player_Current

	LDY Map_Unused7992
	INY
	TYA	; A = Map_Unused7992 + 1

	ASL A
	ASL A
	ASL A
	ASL A
	ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
	CMP <World_Map_Move,X	
	BEQ MapStarsIntro_DoStarFX	 ; If movement is same as Player's current movement, jump to MapStarsIntro_DoStarFX

	JMP WorldMap_UpdateAndDraw	 ; Draw and update map and don't come back

MapStarsIntro_DoStarFX:
	LDA Map_StarFX_State
	JSR DynJump

	.word MapStarsIntro_Init
	.word WWFX_WarpWhistleFlash	; THIS STATE IS NOT USED (accidentally/on-purpose skipped)
	.word MapStarsIntro_Do

	; Default "radius" values for each star on the world intro
MSI_DefaultRadii:	.byte $14, $10, $0C, $08, $04, $00, $1C, $18

	; Per-radius size values
MSI_RadSize:		.byte 0, 24, 48, 71, 90, 106, 118, 125, 128, 125, 118, 106, 90, 71, 48, 24


	; Patterns used by the "stars" in the intro
MapStarsIntro_Patterns:	.byte $67, $69 

MapStarsIntro_Init:
	LDA #SND_MAPENTERWORLD	
	STA Sound_QMap	; Play the starry entrance sound

	; Preload the default "radius" values for each star
	LDX #$07
PRG011_B799:
	LDA MSI_DefaultRadii,X
	STA <Map_StarsRadius,X
	DEX		 	; X--
	BPL PRG011_B799	 	; While X >= 0, loop!

	LDX <Map_StarsState
	BNE PRG011_B7AD	 	; If Map_StarsState <> 0, jump to PRG011_B7AD

	; Stars emanating from center
	LDA #$80	 
	STA <Map_StarsCenterX	; Map_StarsCenterX = $80
	STA <Map_StarsCenterY	; Map_StarsCenterY = $80
	BNE PRG011_B800	 	; Jump (technically always) to PRG011_B800

PRG011_B7AD:
	CPX #$01	 
	BNE PRG011_B7CC	 	; If Map_StarsState <> 1, jump to PRG011_B7CC

	; Stars emanating from Player start
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_X,X
	ADD <Horz_Scroll
	STA <Map_StarsCenterX	; Map_StarsCenterX = Player's Map X + Horz_Scroll

	LDA <World_Map_Y,X	
	STA <Map_StarsCenterY	; Map_StarsCenterY = Player's Map Y

	LDA #$86
	STA Map_Stars_PRelX	; Map_Stars_PRelX = $86

	LDA #$d0	
	STA Map_Stars_PRelY	; Map_Stars_PRelY = $D0

	JMP PRG011_B7E6	 ; Jump to PRG011_B7E6

PRG011_B7CC:
	; Map_StarsState = 2

	LDA #$88
	STA <Map_StarsCenterX	; Map_StarsCenterX = 136

	LDA #$5c
	STA <Map_StarsCenterY	; Map_StarsCenterY = 92

	LDX Player_Current	; X = Player_Current

	LDA <World_Map_X,X
	ADD <Horz_Scroll
	STA Map_Stars_PRelX	 	; Map_Stars_PRelX = Player's map X coordinate + Horz_Scroll

	LDA <World_Map_Y,X
	STA Map_Stars_PRelY	 	; Map_Stars_PRelY = Player's map Y coordinate

	INC <Map_StarFX_State	; Next state... (NOTE: Incremented again below!)

PRG011_B7E6:

	; Calculate step and deltas
	LDX <Map_StarsCenterX
	LDA Map_Stars_PRelX
	JSR MSI_CalcDeltaAndSteps
	STA <Map_StarsXSteps
	STX Map_StarsDeltaX

	LDX <Map_StarsCenterY
	LDA Map_Stars_PRelY
	JSR MSI_CalcDeltaAndSteps
	STA <Map_StarsYSteps	
	STX Map_StarsDeltaY

PRG011_B800:
	LDA #$00
	STA <Map_StarsFrame	; Map_StarsFrame = 0
	STA <Map_StarsLandRad	; Map_StarsLandRad = 0
	STA <Map_StarsOutRad	; Map_StarsOutRad = 0

	LDA #$67
	STA <Map_StarsPattern

	LDA #$09
	STA <Map_StarsConst9	; Map_StarsConst9 = 9 (forever?)

	INC Map_StarFX_State	; Next state... (technically, +2 before it gets back)

	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B81C	 	; If Map_StarsState = 2, jump to PRG011_B81C (RTS)

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B81C:
	RTS		 	; Return


	; FIXME: Anyone want to claim this?
; $B81D
	JMP PRG011_B8B1	; Jump to PRG011_B8B1

MapStarsIntro_Do:
	LDA <Map_StarsLandRad
	BNE PRG011_B834	 		; If Map_StarsLandRad <> 0 (we're doing the "landing" now), jump to PRG011_B834

	LDA <Map_StarsOutRad
	ADD #$04	 
	CMP #$5f	 
	BGE PRG011_B830	 	; If Map_StarsOutRad + 4 >= $5F, jump to PRG011_B830 (change direction)

	; Otherwise, jump to PRG011_B8AF
	JMP PRG011_B8AF	

PRG011_B830:
	LDA #$01	 
	STA <Map_StarsLandRad		; Map_StarsLandRad = 1

PRG011_B834:
	; Stars landing

	LDA <Map_StarsState
	BEQ PRG011_B874	 		; If Map_StarsState = 0, jump to PRG011_B874

	LDA <Map_StarsCenterX
	CMP Map_Stars_PRelX
	BGE PRG011_B84B	 		; If Map_StarsCenterX >= Map_Stars_PRelX (Player's landing is to the left), jump to PRG011_B84B

	; Player's landing is to the right...
	ADC Map_StarsDeltaX		; Map_StarsCenterX += Map_StarsDeltaX
	TAX		 		; X = A
	DEC <Map_StarsXSteps		; Map_StarsXSteps--
	BMI PRG011_B854			; If Map_StarsXSteps < 0, jump to PRG011_B854
	INX		 		; X++
	JMP PRG011_B854	 		; Jump to PRG011_B854

PRG011_B84B:
	SBC Map_StarsDeltaX	 	; Map_StarsCenterX -= Map_StarsDeltaX
	TAX		 		; X = A
	DEC <Map_StarsXSteps		; Map_StarsXSteps--
	BMI PRG011_B854	 		; If Map_StarsXSteps < 0, jump to PRG011_B854
	DEX				; X--

PRG011_B854:
	STX <Map_StarsCenterX		; Update Map_StarsCenterX

 
	LDA <Map_StarsCenterY
	CMP Map_Stars_PRelY
	BGE PRG011_B869	 		; If Map_StarsCenterY >= Map_Stars_PRelY (Player's landing is above), jump to PRG011_B869

	; Player's landing is below...
	ADC Map_StarsDeltaY		; Map_StarsCenterY += Map_StarsDeltaY
	TAX		 		; X = A
	DEC <Map_StarsYSteps		; Map_StarsYSteps--
	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
	INX		 		; X++
	JMP PRG011_B872	 		; Jump to PRG011_B872

PRG011_B869:
	SBC Map_StarsDeltaY	 	; Map_StarsCenterY -= Map_StarsDeltaY
	TAX		 		; X = A
	DEC <Map_StarsYSteps		; Map_StarsYSteps--
	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
	DEX		 		; X--

PRG011_B872:
	STX <Map_StarsCenterY		; Update Map_StarsCenterY

PRG011_B874:
	LDA <Map_StarsOutRad
	SUB #$04	 
	BNE PRG011_B8AF	 		; If Map_StarsOutRad - 4 <> 0, jump to PRG011_B8AF

	LDA #$00	 
	STA Map_StarFX_State	 	; Map_StarFX_State = 0
	STA <Map_StarsLandRad		; Map_StarsLandRad = 0

	LDA <Map_StarsState
	CMP #$02	 
	BEQ PRG011_B8A5			; If Map_StarsState = 2, jump to PRG011_B8A5


	; FIXME: CHECKME: Might be some dead code here
	LDX Map_Unused738	 ; X = Map_Unused738

	;LDA Map_Unused7DC6,X
	CMP #$09
	BLT PRG011_B8A5	 ; If Map_Unused7DC6[X] FIXME < 9, jump to PRG011_B8A5

	; Map_Unused7992 -= 10 (FIXME)
	SUB #10
	STA Map_Unused7992

	LDX Player_Current	; X = Player_Current

	TAY
	INY
	TYA

	ASL A
	ASL A
	ASL A
	ASL A
	ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
	STA <World_Map_Move,X	; Player moves by this amount (but not during the stars display??)

PRG011_B8A5:
	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B8AE	 	; If Map_StarsState = 2, jump to PRG011_B8AE (RTS)

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B8AE:
	RTS		 ; Return

PRG011_B8AF:
	; Stars taking off

	STA <Map_StarsOutRad	; Update Map_StarsOutRad

PRG011_B8B1:
	; This just adds 32 each display frame and toggles the Map_StarsFrame when it overflows
	LDA <Map_StarsAnimCnt
	ADD #32
	STA <Map_StarsAnimCnt	; Map_StarsAnimCnt += 32
	BCC PRG011_B8C6		; If it hasn't overflowed, jump to PRG011_B8C6

	; So Map_StarsFrame toggles every 8 frames
	LDA <Map_StarsFrame	
	EOR #$01	 
	STA <Map_StarsFrame	; Toggle Map_StarsFrame (0/1)

	TAX		 
	LDA MapStarsIntro_Patterns,X	 ; Based on Map_StarsFrame, get the pattern number
	STA <Map_StarsPattern		 ; Store into Map_StarsPattern

PRG011_B8C6:
	LDY #$00	 ; Y = 0

	LDX #$07	 ; X = 7

	; This just adds $70 each display frame and toggles the Map_StarsFrame when it overflows
	LDA <Map_StarsRadCnt
	ADD #$70
	STA <Map_StarsRadCnt	; Map_StarsRadCnt += $70
	BCC PRG011_B8D5	 	; If it hasn't overflowed, jump to PRG011_B8D5

	; So roughly every 2.29 display frames...
	LDY #$01	 	; Y = 1 (+1 to the rotation)

PRG011_B8D5:
	STY <Map_StarsDeltaR	; Map_StarsDeltaR = Y (0 or 1)

PRG011_B8D7:

	; Add to each star's radius 0 or 1, capping the value at 0-31
	LDA <Map_StarsRadius,X	
	ADD <Map_StarsDeltaR	
	AND #$1f	 
	STA <Map_StarsRadius,X	; Map_StarsRadius[X] = (Map_StarsRadius[X] + 1) & $1f

	JSR MSI_CalcStarsXY	; Calculate this star's X and Y (and Temp_Var10 contains the X for the second sprite)
	JSR MSI_DrawStar	; Draw this star!
	DEX		 	; X--
	BPL PRG011_B8D7	 	; If X >= 0, loop!

	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B8F2		; If Map_StarsState = 2, jump to PRG011_B8F2
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B8F2:
	RTS		 ; Return

; MSI_CalcStarsXY
;
; Calculates the current X and Y position of each star
MSI_CalcStarsXY:
	LDA <Map_StarsRadius,X
	AND #$0f		; Only using values 0-15 of the "radius"	 
	TAY
	LDA MSI_RadSize,Y
	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
	LDY <Map_StarsConst9	; Y = Map_StarsConst9
	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

	LDA <Map_StarsRadius,X	
	AND #$18	 
	CMP #16
	BLT PRG011_B917	 	; If (Map_StarsRadius[X] & $18) < 16, jump to PRG011_B917

	; Otherwise...
	LDA #-1
	STA <Temp_Var1		; Temp_Var1 = -1

	LDA <Map_StarsCenterX
	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
	JMP PRG011_B91F	 	; Jump to PRG011_B91F

PRG011_B917:
	LDA #$01
	STA <Temp_Var1		; Temp_Var1 = 1

	LDA <Map_StarsCenterX
	ADC <Temp_Var3		; A = Map_StarsCenterX + Temp_Var3

PRG011_B91F:
	STA <Map_StarsX,X	; Set this as the star's X position
	STA <Temp_Var7		; Temp_Var7 = star's X position

	LDA <Map_StarsCenterX
	STA <Temp_Var8		; Temp_Var8 = all stars center X

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

	LDA <Map_StarsX,X
	ADD #8
	STA <Temp_Var10		; Temp_Var10 = star's X + 8 (will be second sprite's offset)
	STA <Temp_Var7		; Temp_Var7 = Temp_Var10

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6		
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

	LDA <Map_StarsRadius,X	
	ADD #$08	 
	AND #$0f	 
	TAY		 	; Y = (radius value + 8) & $F
	LDA MSI_RadSize,Y
	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
	LDY <Map_StarsConst9	; Y = Map_StarsConst9
	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

	LDA <Map_StarsRadius,X
	SUB #$08	
	AND #$18
	CMP #16
	BLT PRG011_B968	 	; If ((Map_StarsRadius[X] - 8) & $18) < 16, jump to PRG011_B968

	LDA #-1
	STA <Temp_Var1		; Temp_Var1 = -1

	LDA <Map_StarsCenterY
	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
	JMP PRG011_B970	 	; Jump to PRG011_B970

PRG011_B968:
	LDA #1
	STA <Temp_Var1		; Temp_Var1 = 1

	LDA <Map_StarsCenterY
	ADC <Temp_Var3		

PRG011_B970:
	STA <Map_StarsY,X	; star's Y = Map_StarsCenterY + Temp_Var3
	STA <Temp_Var7		; Temp_Var7 = star's Y

	LDA <Map_StarsCenterY	
	STA <Temp_Var8		; Temp_Var8 = all stars center Y

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6	
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980
	RTS		 	; Return

PRG011_B980:
	LDA #$f8
	STA <Map_StarsY,X	; star's Y = $F8 (hides sprite)
	LDA #$00	 
	STA <Map_StarsX,X	; star's X = 0 (we're hiding the sprite)

	STA <Temp_Var10		; Temp_Var10 = star's X (0) (will be second sprite's offset)
	RTS		 	; Return

MSI_CalcXOffset:
	; A = Map_StarsOutRad
	; Y = Map_StarsConst9 (9)

	; MAPOBJ_HAMMERBROFIXME: I don't really understand the algorithm (I think it's some kind of
	; division or fractional multiplication routine?), produces X offset in Temp_Var3

	STA <Temp_Var2	; Temp_Var2 = Map_StarsOutRad

	LDA #$00	
	STA <Temp_Var3	; Temp_Var3 = 0
	STA <Temp_Var4	; Temp_Var4 = 0

PRG011_B993:
	ASL <Temp_Var4
	ROL <Temp_Var3
	ASL <Temp_Var1
	BCC PRG011_B9A6

	LDA <Temp_Var4
	ADD <Temp_Var2
	STA <Temp_Var4

	BCC PRG011_B9A6

	INC <Temp_Var3

PRG011_B9A6:
	DEY		 ; Y--
	BNE PRG011_B993	 ; While Y >= 0, loop

	RTS		 ; Return

; MSI_DrawStar
;
; Generates the hardware sprites for a star
MSI_DrawStar:
	TXA
	ASL A
	ASL A
	ASL A
	TAY		; Y = X << 3

	; Store the Y part of this star's sprites
	LDA <Map_StarsY,X	 
	STA Sprite_RAM+$98,Y	 
	STA Sprite_RAM+$9C,Y	 

	; Store the patterns for this star's sprites
	LDA <Map_StarsPattern	
	STA Sprite_RAM+$99,Y	
	STA Sprite_RAM+$9D,Y	

	; First sprite is palette 3
	LDA #$03	 
	STA Sprite_RAM+$9A,Y

	; Second sprite is same but also HV flipped
	LDA #$c3
	STA Sprite_RAM+$9E,Y

	; Store X coordinate for first sprite
	LDA <Map_StarsX,X
	STA Sprite_RAM+$9B,Y

	; Store X coordinate for second sprite
	LDA <Temp_Var10
	STA Sprite_RAM+$9F,Y

	RTS		 ; Return

PRG011_SUB_B9D4:
	; Temp_Var1 = 1 or -1
	; Temp_Var7 = star's X position
	; Temp_Var8 = all stars center X

	LDA <Temp_Var7
	EOR <Temp_Var8
	AND #$80	 
	BEQ PRG011_B9EA	 	; If Temp_Var7 and Temp_Var8 are oppositely signed, jump to PRG011_B9EA

	LDA <Temp_Var1
	BPL PRG011_B9E6	 	; If Temp_Var1 >= 0, jump to PRG011_B9E6

	LDA <Temp_Var7
	BMI PRG011_B9EF	 	; If Temp_Var7 < 0, jump to PRG011_B9EF
	BPL PRG011_B9EA	 	; Otherwise, jump to PRG011_B9EA

PRG011_B9E6:
	LDA <Temp_Var7
	BPL PRG011_B9EF	 	; If Temp_Var7 >= 0, jump to PRG011_B9EF

PRG011_B9EA:
	LDA #1
	STA <Temp_Var6		; Temp_Var6 = 1
	RTS		 	; Return...

PRG011_B9EF:
	LDA #-1
	STA <Temp_Var6		; Temp_Var6 = -1
	RTS		 	; Return...

MSI_CalcDeltaAndSteps:

	; X = Map_StarsCenterX
	; A = Map_Stars_PRelX

	STX <Temp_Var4	; Temp_Var4 = Map_StarsCenterX
	STA <Temp_Var5	; Temp_Var5 = Map_Stars_PRelX
 
	SUB <Temp_Var4	
	STA <Temp_Var1	; Temp_Var1 = Temp_Var5 (Map_Stars_PRelX) - Temp_Var4 (Map_StarsCenterX)

	LDA <Temp_Var5	
	CMP <Temp_Var4	
	BGE PRG011_BA0B	; If Temp_Var5 >= Temp_Var4, jump to PRG011_BA0B

	; Otherwise, Temp_Var1 is negative; negate it!
	LDA <Temp_Var1
	EOR #$ff	
	ADC #$01	
	STA <Temp_Var1	

	; FIXME: I don't really understand the algorithm (I think it's some kind of
	; division routine?), but it finds the delta X/Y values for the star intro
	; and the number of steps to complete the move
PRG011_BA0B:
	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0

	LDY #$07	; Y = 7
PRG011_BA11:
	ASL <Temp_Var3
	ROL <Temp_Var1
	ROL A		
	BCS PRG011_BA1C	

	CMP #$17
	BLT PRG011_BA20	

PRG011_BA1C:
	SBC #$17	
	INC <Temp_Var3	; Temp_Var3++

PRG011_BA20:
	DEY		 ; Y--
	BPL PRG011_BA11	 ; While Y >= 0, loop!

	LDX <Temp_Var3	 ; X = Temp_Var3
	RTS		 ; Return

Map_CompleteY:
	.byte $20, $30, $40, $50, $60, $70, $80
Map_CompleteY_End

Map_CompleteBit:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

Map_MarkLevelComplete:
	LDA Old_World_Map_Tile 	 ; X = Player_Current
	AND #$0F
	JSR MapGetTileBit
	;ORA World_Complete_Tiles,X
	;STA World_Complete_Tiles,X
	RTS


MapObject_X = Temp_Var2
MapLeft_Edge = Temp_Var3
MapRight_Edge = Temp_Var4

Map_Object_CheckVisibility:
	; For a given object, check if it's visible on the map.  This value is
	; stored into the Map_Objects_Vis array
	; X is the index to the map object we need to work with!
	LDY #$00	 	; Object is not visible until proven visible...

	LDA Map_Objects_XHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <MapObject_X		; Temp_Var2 = object's X Hi byte << 4

	LDA Map_Objects_XLo,X
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	ORA <MapObject_X		
	STA <MapObject_X		; OR'ing the low X >> 4; Temp_Var2 now contains a proper "column" position

	LDA <Horz_Scroll_Hi
	ASL A
	ASL A
	ASL A
	ASL A
	STA <MapLeft_Edge
	ADD #$10
	STA <MapRight_Edge

	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	PHA
	ORA <MapLeft_Edge
	STA <MapLeft_Edge

	PLA 
	ORA <MapRight_Edge
	STA <MapRight_Edge

	LDA <MapObject_X
	CMP <MapLeft_Edge
	BLT PRG011_BAB1	 	; If object is less than the right scroll column, jump to PRG011_BAB1

	CMP <MapRight_Edge	
	BGE PRG011_BAB1	 	; If object is greater-equal to the left scroll column, jump to PRG011_BAB1

	LDY #$01	 	; Object is visible!
PRG011_BAB1:
	TYA		 	; A = Y
	STA Map_Objects_Vis,X 	; Mark this object as visible or not
	RTS		 	; Return

Map_Object_Canoe:
	LDY Player_Current	; Y = Player_Current
	LDA Map_InCanoe_Flag
	BEQ PRG011_BAD9	 	; If Map_InCanoe_Flag = 0, jump to PRG011_BAD9

	; Otherwise, the Canoe is updated to match the Player's
	; position; this seems to only allow one canoe per map!
	; Though it could probably be fixed somehow...
	LDA World_Map_Y,Y 
	STA Map_Objects_Y,X
	STA Map_Object_ActY,X
	LDA World_Map_X,Y	
	STA Map_Objects_XLo,X	
	STA Map_Object_ActX,X	
	LDA World_Map_XHi,Y	
	STA Map_Objects_XHi,X	
	STA Map_Object_ActXH,X	

PRG011_BAD9:

	; Basically if Player is standing in Canoe, it activates the Map_InCanoe_Flag flag
	LDA World_Map_Move,Y
	ORA Map_Player_SkidBack,Y
	BNE PRG011_BAFE	 

	LDA World_Map_Y,Y
	CMP Map_Object_ActY,X
	BNE PRG011_BAFE

	LDA World_Map_XHi,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_BAFE	 

	LDA World_Map_X,Y
	CMP Map_Object_ActX,X
	BNE PRG011_BAFE	 

	; Map_InCanoe_Flag = 1 (In canoe!)
	LDA #$01
	STA Map_InCanoe_Flag

PRG011_BAFE:
	RTS		 ; Return

W8D_CircSprs:
	.byte $F8, $81, $01, $F0
	.byte $F0, $83, $01, $F8
	.byte $E8, $85, $01, $00
	.byte $E8, $85, $41, $08
	.byte $F0, $83, $41, $10
	.byte $F8, $81, $41, $18
	.byte $08, $81, $81, $F0
	.byte $10, $83, $81, $F8
	.byte $18, $85, $81, $00
	.byte $18, $85, $C1, $08
	.byte $10, $83, $C1, $10
	.byte $08, $81, $C1, $18
	.byte $E8, $0B, $01, $F0
	.byte $E8, $0B, $01, $18
	.byte $18, $0B, $01, $F0
	.byte $18, $0B, $01, $18
	.byte $F0, $0B, $01, $E8
	.byte $00, $0B, $01, $E8
	.byte $10, $0B, $01, $E8
	.byte $F0, $0B, $01, $20
	.byte $00, $0B, $01, $20
W8D_CircSprs_Unaligned

	.byte $10, $0B, $01, $20
	.byte $E0, $87, $01, $F8
	.byte $E0, $87, $01, $10
	.byte $20, $87, $81, $F8
W8D_CircSprs_Aligned

PRG011_BB63:
	.byte $20, $87, $81

PRG011_BB66:
	.byte $10, $E0, $E8, $D8, $F0, $D0, $F8

FX_World_8_Darkness:
	LDY World_8_Dark	; Y = World_8_Dark
	BEQ PRG011_BB7A	 	; If not in the World 8 darkness, jump to PRG011_BB7A (RTS)
	LDX Player_Current	; X = Player_Current
	LDA Map_Player_SkidBack,X
	BEQ PRG011_BB7B	 	; If Player's Map_Player_SkidBack = 0, jump to PRG011_BB7B

PRG011_BB7A:
	RTS		 	; Otherwise, return...

PRG011_BB7B:
	CPY #$07	 
	BGE PRG011_BB9A	 	; If World_8_Dark >= 7 (effect complete), jump to PRG011_BB9A
	LDA <World_Map_X,X	; Player's X coordinate -> A
	ADD PRG011_BB66,Y	; Add an offset based on World_8_Dark

	LDY <World_Map_Y,X	; Y = Player's Y coordinate
	LDX #$01	 	; X = 1

	;JSR Map_W8DarknessUpdate	; Update darkness around Player

	INC World_8_Dark	; World_8_Dark++

	LDA World_8_Dark	 
	LSR A		 	
	BCC FX_World_8_Darkness	; Loops if carry not set by the "LSR A" (so only loops on 2, 4, 6)

PRG011_BB9A:
	LDX Player_Current	; X = Player_Current

	LDY #$00	 ; Y = 0

	LDA <World_Map_Move,X
	AND #$07	; Cap 0-7
	CMP #$06
	BEQ PRG011_BBAC	 ; On "6" of every "0-7" jump to PRG011_BBAC

	CMP #$02
	BNE PRG011_BBBB	 ; If not "2" of every "0-7" jump to PRG011_BBBB

	INY		 ; Otherwise, Y++

PRG011_BBAC:
	LDA <World_Map_X,X
	PHA		 ; Save Player's map X

	LDY <World_Map_Y,X	 ; Y = Player's map Y

	LDA <World_Map_Dir,X
	TAX		 ; X = Player's map direction of travel

	PLA		 ; A = Player's map X

	; Update darkness around Player
	;JSR Map_W8DarknessUpdate

PRG011_BBBB:
	LDY #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	LDX Player_Current	 ; X = Player_Current

	; Temp_Var1/2 = Player's Map Y/X
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDX #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	AND #$0f	 ; Get lower 4 bits of X
	BNE PRG011_BBD0	 ; If Player is not perfectly aligned in column, jump to PRG011_BBD0

	LDX #(W8D_CircSprs_Aligned - W8D_CircSprs)

PRG011_BBD0:

	; Set circle sprite Y
	LDA <Temp_Var1
	ADD W8D_CircSprs,X
	STA Sprite_RAM+$08,Y

	; Set circle sprite pattern
	LDA W8D_CircSprs+1,X
	STA Sprite_RAM+$09,Y

	; Set circle sprite attribute
	LDA W8D_CircSprs+2,X
	STA Sprite_RAM+$0A,Y

	; Set circle sprite X
	LDA <Temp_Var2
	ADD W8D_CircSprs+3,X
	STA Sprite_RAM+$0B,Y

	DEY
	DEY
	DEY
	DEY	; Y -= 4 (previous sprite)

	DEX
	DEX
	DEX
	DEX	; X -= 4 (previous circle sprite def)

	BMI PRG011_BC00	 ; If out of sprites, jump to PRG011_BC00

	CPX #(W8D_CircSprs_Unaligned - W8D_CircSprs)
	BNE PRG011_BBD0	 ; If not at end of aligned circle sprites, loop

	LDX #$3c
	BNE PRG011_BBD0	 ; If X <> $3C (?), loop

PRG011_BC00:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoAnimations
;
; This subroutine takes care of the simplistic animations
; that occur on the world maps.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Map_Y_Starts:
	; Map Y start positions, World 1-8 (X is always $20)
	.byte $40, $A0, $A0, $40, $80, $60, $30, $50

Map_AnimCHRROM:
	; This sets the CHRROM page in use per animation frame (common to all worlds)
	.byte $70, $72, $74, $76

Map_DoAnimations:	; $BC29
	LDA <Counter_1
	AND #$60
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY
	LDA Map_AnimCHRROM,Y	; Get the correct CHRROM page
	STA PatTable_BankSel	  	; Put it to use
	RTS		  ; Return!

; ### RELOCATE THIS CODE!	
FindCompletedLevels:
	LDX #$00

FindCompletedLevels3:
	LDA MapPointers, X
	CMP #$FF
	BNE FindCompletedLevels0
	RTS

FindCompletedLevels0:
	STA LevelNumber
	JSR GetLevelBit
	AND Levels_Complete, Y
	BEQ FindCompletedLevels1

	LDA MapPointers + 1, X
	AND #$0F
	STA Block_ChangeXHi

	LDA MapPointers + 1, X
	AND #$F0
	STA Block_ChangeX

	LDA MapPointers + 2, X
	AND #$0F
	ASL A
	ASL A
	ASL A
	ASL A
	SUB #$10
	STA Block_ChangeY

	LDA #$01
	STA Block_ChangeYHi
	STX TempX

	JSR MarkCompletedLevels
	
	LDX TempX

FindCompletedLevels1:
	INX
	INX
	INX

	JMP FindCompletedLevels3

Completion_Tiles: 
	.byte $FF, $7C

MarkCompletedLevels:
	JSR GetMapTile

	AND #$E0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	
	TAX

	LDA Completion_Tiles, X
	STA [Map_Tile_AddrL],Y
	RTS

GetMapTile:
	LDA Block_ChangeXHi
	ASL A
	TAX	

	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL

	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	LDA #$00
	STA <Temp_Var7

	LDA Block_ChangeYHi
	BEQ MarkCompletedLevels1	

	INC <Map_Tile_AddrH	

MarkCompletedLevels1:

	LDA Block_ChangeY
	AND #$f0
	STA <Temp_Var6

	LDA Block_ChangeX
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	LDA Block_ChangeYHi
	BNE MarkCompletedLevels2	

	LDA Block_ChangeY
	AND #$f0
	CMP #$f0
	BNE MarkCompletedLevels3	 

MarkCompletedLevels2:
	LDA Block_ChangeY
	ADD #$10
	STA <Temp_Var6

	LDA #$01
	STA <Temp_Var7

MarkCompletedLevels3:
	LDY <Temp_Var5

	LDA [Map_Tile_AddrL],Y

Map_SaveMenuSCRTS:
	RTS	


Map_SaveMenu:
	LDA Map_Pan_Count
	BNE Map_SaveMenuSCRTS

	LDA Save_Menu_Showing
	BEQ Map_SaveMenuHidden

	JMP Map_SaveMenuShowing

Map_SaveMenuHidden:
	LDA <Pad_Input
	AND #PAD_START
	BEQ Map_SaveMenuHiddenRTS

	LDA #$01
	STA Save_Menu_Showing

	LDA #$00
	STA Save_Menu_YesNo

	LDA #PAUSE_STOPMUSIC
	STA Sound_QPause

Map_SaveMenuHiddenRTS:
	RTS


SAVE_MENU_YES = 0
SAVE_MENU_NO = 1
SAVE_MENU_SPRAM = $A0
SAVE_MENU_SPRAM_STOP = (4 * 10) + SAVE_MENU_SPRAM

Map_SaveMenuTiles:
Map_SaveMenuYes:
	.byte $C1, $C3, $C5, $C7, $C9
	.byte $EB, $ED, $EF, $F1, $F3

Map_SaveMenuNo:
	.byte $CB, $CD, $CF, $D1, $D3
	.byte $E1, $E3, $E5, $E7, $E9

Map_SaveMenuX:
	.byte $6C, $74, $7C, $84, $8C
	.byte $6C, $74, $7C, $84, $8C
	.byte $6C, $74, $7C, $84, $8C
	.byte $6C, $74, $7C, $84, $8C

Map_SaveMenuY:
	.byte $60, $60, $60, $60, $60
	.byte $70, $70, $70, $70, $70
	.byte $60, $60, $60, $60, $60
	.byte $70, $70, $70, $70, $70

Map_SaveMenuOffset:
	.byte 00, (Map_SaveMenuNo - Map_SaveMenuYes)

Map_SaveMenuShowing:
	JSR Cheat_Code
	
	LDY Save_Menu_YesNo 

	LDA Map_SaveMenuOffset, Y
	TAX

	LDY #SAVE_MENU_SPRAM
	
Map_SaveMenuLoop:
	LDA Map_SaveMenuTiles, X
	STA Sprite_RAMTile, Y

	LDA Map_SaveMenuX, X
	STA Sprite_RAMX, Y

	LDA Map_SaveMenuY, X
	STA Sprite_RAMY, Y

	LDA #SPR_PAL1
	STA Sprite_RAMAttr, Y

	INY
	INY
	INY
	INY

	INX

	CPY #SAVE_MENU_SPRAM_STOP
	BNE Map_SaveMenuLoop

	LDA <Pad_Input
	AND #PAD_START
	BEQ Map_SaveMenuToggleCheck

	LDA Save_Menu_YesNo
	BNE Save_MenuRTS

	JSR Save_Game

	LDA Sound_QMap
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

Save_MenuRTS:
	LDA #PAUSE_RESUMEMUSIC
	STA Sound_QPause

	LDA #$00
	STA Save_Menu_Showing
	RTS

Map_SaveMenuToggleCheck:
	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN | PAD_SELECT)
	BEQ Map_SaveMenuShowingRTS


	LDA Save_Menu_YesNo
	EOR #$01
	STA Save_Menu_YesNo

Map_SaveMenuShowingRTS:
	RTS	

U_ = PAD_UP
D_ = PAD_DOWN
L_ = PAD_LEFT
R_ = PAD_RIGHT
S_ = PAD_SELECT
B_ = PAD_B
A_ = PAD_A
__ = 00
X_ = $FF

Cheat_Codes:	
	.byte U_, U_, U_, U_, U_, U_, U_, U_, U_
	.byte U_, R_, D_, L_, U_, R_, D_, L_, __
	.byte L_, D_, R_, D_, L_, D_, R_, D_, L_
	.byte L_, R_, S_, B_, A_, B_, S_, R_, L_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, U_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, D_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, L_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, R_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, S_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, B_
	.byte S_, B_, S_, B_, S_, B_, S_, B_, S_
	.byte U_, R_, S_, U_, L_, A_, S_, U_, B_
	.byte B_, U_, L_, B_, A_, S_, A_, U_, R_
	.byte B_, R_, A_, B_, B_, U_, L_, S_, __
	.byte U_, D_, L_, R_, U_, D_, L_, R_, A_
	.byte U_, D_, L_, R_, U_, D_, L_, R_, B_

Cheat_Index = Temp_Var1
Cheat_Offset = Temp_Var2
Cheat_Number = Temp_Var3
Cheat_Length = 9
Cheat_Count = 16

Cheat_Code:
	LDA <Pad_Input
	BNE Cheat_CodeInput

	RTS

Cheat_CodeInput:
	LDX #$0F

Cheat_InputLoop:
	LDA Cheat_Input - 1, X
	STA Cheat_Input, X

	DEX
	BNE Cheat_InputLoop

	LDA <Pad_Input
	STA Cheat_Input

	LDA #$00
	STA <Cheat_Index
	STA <Cheat_Number

Cheat_BeginSearch:
	LDA #(Cheat_Length)
	STA <Cheat_Offset

	LDX #$00
	
	LDA <Cheat_Index
	ADD #(Cheat_Length - 1)
	TAY

Cheat_CodeSearch:
	LDA Cheat_Codes, Y
	BEQ Cheat_CodeSkip

	CMP Cheat_Input, X
	BNE Cheat_CodeBad

	INX

Cheat_CodeSkip:
	DEY
	DEC <Cheat_Offset
	
	LDA <Cheat_Offset
	BNE Cheat_CodeSearch
	BEQ Cheat_CodeSuccess

Cheat_CodeBad:
	INC <Cheat_Number

	LDA <Cheat_Index
	ADD #(Cheat_Length)
	STA <Cheat_Index

	CMP #(Cheat_Count * Cheat_Length)
	BNE Cheat_BeginSearch
	RTS

Cheat_CodeSuccess:
	LDA Sound_QLevel1
	ORA #SND_LEVEL1UP
	STA Sound_QLevel1

	LDA #$00
	STA Save_Menu_Showing

	LDA #PAUSE_RESUMEMUSIC
	STA Sound_QPause

	LDA #$00
	LDX #(Cheat_Count)

Cheat_Clear:
	STA Cheat_Input, X
	DEX
	BPL Cheat_Clear
	
	LDA <Cheat_Number
	
	JSR DynJump

	.word Cheat_AbilityUp
	.word Cheat_250Coins
	.word Cheat_25Cherries
	.word Cheat_1000Exp
	.word Cheat_Badge1
	.word Cheat_Badge2
	.word Cheat_Badge3
	.word Cheat_Badge4
	.word Cheat_Badge5
	.word Cheat_Badge6
	.word Cheat_DebugMode
	.word Cheat_Sub
	.word Cheat_SecondQuest
	.word Cheat_ToggleMoonGravity
	.word Cheat_IncreaseStars1
	.word Cheat_IncreaseStars10

Cheat_DoNothing:
	RTS

Cheat_AbilityUp:
	LDA Player_Level
	CMP #ABILITY_MAX
	BCS Cheat_AbilityUpRTS

	INC Player_Level

Cheat_AbilityUpRTS:
	RTS

Cheat_250Coins:
	LDA #250
	STA Coins_Earned
	RTS

Cheat_25Cherries:
	LDA Player_Cherries
	ADD #25
	CMP #99
	BCC Cheat_25CherriesRTS

	LDA #99

Cheat_25CherriesRTS:
	STA Player_Cherries
	RTS

Cheat_1000Exp:
	LDA Player_Experience
	STA <CalcParam1

	LDA Player_Experience + 1
	STA <CalcParam1 + 1

	LDA Player_Experience + 2
	STA <CalcParam1 + 2

	LDA #$E7
	STA <CalcParam2

	LDA #$03
	STA <CalcParam2 + 1

	LDA #$00
	STA <CalcParam2 + 2

	JSR Add3ByteValue

	LDA <CalcResult
	STA Player_Experience

	LDA <CalcResult + 1
	STA Player_Experience + 1

	LDA <CalcResult + 2
	STA Player_Experience + 2

	INC Exp_Earned
	RTS

BADGE_ITEMRESERVE = 1
BADGE_XP = 2
BADGE_RADAR = 3
BADGE_PMETER = 4
BADGE_COIN = 5
BADGE_AIR = 6

Cheat_Badge1:
	LDA #BADGE_ITEMRESERVE
	BNE Cheat_BadgeApply

Cheat_Badge2:
	LDA #BADGE_XP
	BNE Cheat_BadgeApply

Cheat_Badge3:
	LDA #BADGE_RADAR
	BNE Cheat_BadgeApply

Cheat_Badge4:
	LDA #BADGE_PMETER
	BNE Cheat_BadgeApply

Cheat_Badge5:
	LDA #BADGE_COIN
	BNE Cheat_BadgeApply

Cheat_Badge6:
	LDA #BADGE_AIR
	BNE Cheat_BadgeApply

Cheat_BadgeApply:
	STA Player_Badge
	RTS

Cheat_DebugMode:
	LDA Player_Debug
	EOR #$01
	STA Player_Debug
	RTS

Cheat_Sub:
	LDA Player_CheatSub
	EOR #$01
	STA Player_CheatSub
	RTS
	
Cheat_SecondQuest:
	LDA SecondQuest
	EOR #$01
	STA SecondQuest
	RTS

Cheat_ToggleMoonGravity:
	LDA Moon_Gravity
	EOR #$01
	STA Moon_Gravity
	RTS

Cheat_IncreaseStars1:
	INC Paper_Stars
	RTS

Cheat_IncreaseStars10:
	LDA Paper_Stars
	ADD #10
	STA Paper_Stars
	RTS
		; List continued in PRG025