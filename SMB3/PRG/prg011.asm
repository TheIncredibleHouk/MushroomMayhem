; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

Check_Save:
	JSR Generate_SaveChecksum
	LDA <Temp_Var1
	ORA <Temp_Var2
	BEQ Checksum_Invalid

	LDA <Temp_Var1
	CMP Save_Ram_CheckSum
	BNE Checksum_Invalid

	LDA <Temp_Var2
	CMP Save_Ram_CheckSum + 1
	BNE Checksum_Invalid
 ;
	LDY #(Player_Stats_Boundary_End - Player_Stats_Boundary_Start)

LoadSave_Loop:
	LDA Save_Ram_Boundary_Start, Y
	STA Player_Stats_Boundary_Start, Y
	DEY
	BPL LoadSave_Loop

	SEC
	RTS

Checksum_Invalid:
	CLC
	RTS


Load_Save:
	JSR Check_Save
	BCS Map_Init

	LDX #$00

	LDA #$01
	STA World_Num

	LDA #$90
	STA Map_Entered_Y
	STA Map_Previous_Y
	
	LDA #$00
	STA Map_Entered_XHi

	; Set starting X position (forced to $20!)
	LDA #$20
	STA Map_Entered_X
	STA Map_Previous_X

	LDA #$FF
	STA SecondQuest

	LDA #$01
	STA Map_Previous_Dir

	LDA #$00
	STA Map_Prev_XOff2
	STA Map_Prev_XHi2
	STA Map_Prev_XOff
	STA Map_Prev_XHi

Map_Init:
	JSR World_Override
	RTS		 ; Return

World_Start_X:
	.byte $00, $20, $20, $30, $10, $20, $20, $30, $80

World_Start_Y:
	.byte $02, $90, $40, $60, $70, $80, $50, $90, $50

World_Start_Num:
	.byte $00, $1, $2, $3, $4, $5, $6, $7, $0

World_Override:
	LDX World_Start
	BEQ World_OverrideRTS

	LDA World_Start_X, X
	STA Map_Entered_X
	STA Map_Previous_X

	LDA World_Start_Y, X
	STA Map_Entered_Y
	STA Map_Previous_Y

	LDA #$00
	STA Map_Entered_XHi
	STA Map_Previous_XHi

	LDA World_Start_Num, X
	STA World_Num

World_OverrideRTS:
	RTS


	; Offset to Player-specific inventory items


; PRG011_A2C8:
; 	LDX Map_Unused738	 ; X = Map_Unused738

; 	; Seems Map_Unused7DC6 was pretty interesting once?
; 	;LDA Map_Unused7DC6,X
; 	JSR DynJump

; 	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
; 	.word PRG011_B74A		; 0
; 	.word WorldMap_UpdateAndDrawInd	; 1
; 	.word WorldMap_UpdateAndDrawInd	; 2
; 	.word WorldMap_UpdateAndDrawInd	; 3
; 	.word WorldMap_UpdateAndDrawInd	; 4
; 	.word PRG011_B74A		; 5
; 	.word WorldMap_UpdateAndDrawInd	; 6
; 	.word Map_DoMap_WarpWind_FX	; 7
; 	.word WorldMap_UpdateAndDrawInd	; 8
; 	.word WorldMap_UpdateAndDrawInd	; 9
; 	.word PRG011_B74A		; 10
; 	.word PRG011_B74A		; 11
; 	.word PRG011_B74A		; 12
; 	.word PRG011_B74A		; 13
; 	.word PRG011_B74A		; 14
; 	.word PRG011_B74A		; 15

; WorldMap_UpdateAndDrawInd:
; 	JMP WorldMap_UpdateAndDraw

; Map_WW_StartX:	.byte 0, 240	; Map warp wind starting X position, depending which direction it comes from
; Map_WW_DeltaX:	.byte 2, -2	; Position change depending on the direction of travel
; Map_WW_TargetX:	.byte 240, 0	; The ending position, depending on direction of travel

; 	; Starting Y position depending on what world you came from
; Map_WW_IslandY:
; 	.byte $50, $70, $70	; World 1 - 3
; 	.byte $70, $70, $70	; World 4 - 6
; 	.byte $90, $90, $90	; World 7 - 9

; 	; Unused?  Guessing this was possible X Hi init values,
; 	; though always zero (maybe there would've been multiple
; 	; islands?  Per group of worlds?)
; 	.byte $00, $00, $00	; World 1 - 3
; 	.byte $00, $00, $00	; World 4 - 6
; 	.byte $00, $00, $00	; World 7 - 9

; 	; Starting X position depending on what world you came from
; Map_WW_IslandX:
; 	.byte $40, $40, $40	; World 1 - 3
; 	.byte $40, $40, $40	; World 4 - 6
; 	.byte $80, $80, $80  	; World 7 - 9


; Map_DoMap_WarpWind_FX:

; 	; Note: In original Japanese version, you could warp from a canoe and then
; 	; sail yourself off the warp island (but never get back on!)  This fixes 
; 	; that bug with a vengeance, since it will be called several times :)
; 	LDA #$00	 	
; 	STA Map_InCanoe_Flag	; Map_InCanoe_Flag = 0 (not in canoe)

; 	; NOTE: If Map_WarpWind_FX = 0,  Map_DoMap_WarpWind_FX is never called,
; 	; so state 0 is technically never used... that's okay, it actually
; 	; contains a "bug", which might just be unmaintained legacy code..

; 	; Dynamic jump based on current map special effect occurring..
; 	LDA <Map_WarpWind_FX	
; 	JSR DynJump

; 	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
; 	.word WWFX_WarpWhistleInit	; 0 - Initializes the warp whistle (NEVER USED, Inv_UseItem_WarpWhistle does this instead)
; 	.word WWFX_WarpWhistleFlash	; 1 - Does the "flash" effect of the whistle
; 	.word WWFX_WarpDoWind		; 2 - Does the wind effect, catches the Player, sets World_Num = 8 (World 9), and clears map objects
; 	.word WWFX_WarpIslandInit	; 3 - Initialize stuff for the warp island, including setting proper Player X/Y position
; 	.word WWFX_WarpLanding		; 4 - Does the wind effect, drops Player off
; 	.word WWFX_WarpWhistleFlash	; 5 - UNUSED; same as State 1, except it will crash by trying to go to undefined "State 6"!

; WarpWhistle_Flash:
; 	LDA <Map_WWOrHT_Cnt
; 	BNE PRG011_A333	 	; If Map_WWOrHT_Cnt <> 0, jump to PRG011_A333

; 	LDA #$20	 
; 	STA <Map_WWOrHT_Cnt	; Otherwise, Map_WWOrHT_Cnt = $20


; PRG011_A333:

; 	; Basically here's what does the white flashing effect
; 	LDY #%00011000		; Show BG + Sprites
; 	DEC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt--
; 	AND #$04	 
; 	BEQ PRG011_A33D	 	; Every 4 ticks, toggle mono effect
; 	LDY #%00011001		; Show BG + Sprites + Mono

; PRG011_A33D:
; 	STY <PPU_CTL2_Copy	; Update
; 	RTS		 	; Return...

; WWFX_WarpWhistleInit:

; 	; *** WWFX_WarpWhistleInit is NEVER USED, Inv_UseItem_WarpWhistle does this instead!

; 	LDY Player_Current	; Y = Player_Current
; 	LDX #$00	 	; X = 0 (come from left)
; 	LDA World_Map_X,Y	; Get Player's world map X coordinate
; 	SUB <Horz_Scroll
; 	CMP #$80	 	
; 	BGE PRG011_A351	 	; If map is scrolled halfway across, jump to PRG011_A351
; 	LDX #$01	 	; Otherwise X = 1 (come from right)

; PRG011_A351:
; 	STX <Map_WWOrHT_Dir	; Store 'X' as direction of warp wind travel

; 	LDA Map_WW_StartX,X
; 	STA <Map_WWOrHT_X	; Set appropriate starting X position

; 	LDA World_Map_Y,Y	
; 	STA <Map_WWOrHT_Y	; Set Y position equal to Player
; 	STA Map_PlyrSprOvrY	; Set Map_PlyrSprOvrY 

; 	LDX #$05	 	; X = 5 NOTE: This is broken (and seems unused anyway); see NOTE @ PRG011_A381

; 	LDA Map_WW_Backup_Y	; Load the backed up Y position
; 	BNE PRG011_A381	 	; If its non-zero, jump to PRG011_A381

; 	; Otherwise, we need to back up everything!  (Y is the only one that absolutely could not be zero)
; 	; But I don't know why?
; 	LDA World_Map_Y,Y
; 	STA Map_WW_Backup_Y	; Store Player's map Y position

; 	LDA World_Map_X,Y	
; 	STA Map_WW_Backup_X	; Store Player's map X position

; 	LDA World_Map_XHi,Y	
; 	STA Map_WW_Backup_XH	; Store Player's map X Hi position

; 	LDA Map_UnusedPlayerVal2,Y	
; 	STA Map_WW_Backup_UPV2	; Store Player's Map_WW_Backup_UPV2

; 	LDX #$01	 	; X = 1

; PRG011_A381:
; 	; NOTE: There's an alternate state 5 here that by the jump table is the same
; 	; as state 1, in theory if it flashes after the backup has already been performed.
; 	; Couple of problems: Why the backup already be performed?  And the other
; 	; problem is there's nothing after state 5, yet the state code will blindly
; 	; increment the state when it finishes, resulting in a crash!
; 	; I'm thinking that's some kind of lost state for something else?

; 	; But that's okay, because technically this routine isn't used anyway! :X

; 	STX <Map_WarpWind_FX		; Map_WarpWind_FX = ... 5 if backup already performed, 1 if not 
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; WWFX_WarpWhistleFlash:
; 	LDA Sound_QMusic2
; 	CMP #MUS2A_WARPWHISTLE	 
; 	BEQ PRG011_A396	 		; If Sound_QMusic2 <> MUS2A_WARPWHISTLE, jump to PRG011_A396

; 	JSR WarpWhistle_Flash		; Do the "flash" effect of the warp whistle

; 	LDA <Map_WWOrHT_Cnt
; 	BNE PRG011_A396	 		; If the counter isn't zero yet, jump to PRG011_A396

; 	INC <Map_WarpWind_FX		; Otherwise, next state!

; PRG011_A396:
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; WWFX_WarpDoWind:
; 	INC <Map_WWOrHT_Cnt		; Map_WWOrHT_Cnt++

; 	LDY Player_Current	 	; Y = Player_Current
; 	LDX <Map_WWOrHT_Dir		; X = Map_WWOrHT_Dir

; 	LDA <Map_WWOrHT_X
; 	ADD Map_WW_DeltaX,X
; 	STA <Map_WWOrHT_X		; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

; 	LDA World_Map_X,Y
; 	SUB <Horz_Scroll
; 	CMP <Map_WWOrHT_X
; 	BNE PRG011_A3BA	 		; If warp wind hasn't hit the Player yet, jump to PRG011_A3BA

; 	LDA #$f8
; 	STA Map_PlyrSprOvrY	 	; Map_PlyrSprOvrY = $F8 (will erase Player's map sprite)
; 	JMP PRG011_A3D9	 		; Jump to PRG011_A3D9...

; PRG011_A3BA:
; 	; Haven't hit the Player yet...
; 	LDA <Map_WWOrHT_X		
; 	CMP Map_WW_TargetX,X
; 	BNE PRG011_A3D9	 		; If Warp Wind hasn't reached its target edge yet, jump to PRG011_A3D9

; 	LDA World_Num	 	
; 	STA Map_Warp_PrevWorld	 	; Map_Warp_PrevWorld = World_Num (where you're coming FROM)

; 	LDA #$08	 
; 	STA World_Num	 		; World_Num = 8 (World 9)

; 	; Clears out map objects 
; 	LDY #(MAPOBJ_TOTAL-1) ; Y = (MAPOBJ_TOTAL-1)
; 	LDA #MAPOBJ_EMPTY ; A = MAPOBJ_EMPTY
; PRG011_A3D0:
; 	STA Map_Objects_IDs,Y
; 	DEY		 ; Y--
; 	BPL PRG011_A3D0	 ; If Y >= 0, loop..

; 	INC <Map_WarpWind_FX		; Next state...
; 	RTS		 ; Return

; PRG011_A3D9:
; 	JSR WorldMap_UpdateAndDraw	; Update and draw map

; 	LDA <Map_WWOrHT_X
; 	STA <Temp_Var2			; Temp_Var2 = Map_WWOrHT_X

; 	LDA #$01
; 	STA <Temp_Var3		 	; Temp_Var3 = 1 (uses palette 1, the white color; otherwise would use hand trap stuff)

; 	JMP WarpWindHandTrap_Draw	 		; Jump to WarpWindHandTrap_Draw...


; WWFX_WarpIslandInit:
; 	LDA #$00
; 	STA <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt = 0

; 	LDA #248
; 	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248 (overwritten further down... oops?)
; 	INC <Map_WarpWind_FX	; Next state...

; 	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld
; 	LDX Player_Current	; X = Map_Warp_PrevWorld

; 	; Clears all map X related variables
; 	LDA #$00
; 	STA Map_Prev_XOff,X
; 	STA Map_Prev_XHi,X
; 	STA <World_Map_XHi,X

; 	LDA Map_WW_IslandX,Y
; 	STA <World_Map_X,X	; Store appropriate X coordinate based on world you came from

; 	LDA #240
; LT0:	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 240 (oops, reassigned?)

; 	LDA Map_WW_IslandY,Y
; 	STA <Map_WWOrHT_Y	; Store appropriate Y coordinate based on world you came from

; 	LDA #$80	 
; 	STA Map_Intro_Tick	; Map_Intro_Tick = $80

; 	LDA #$01	
; 	STA Map_ReturnStatus	 ; Map_ReturnStatus = 3 (??)

; 	RTS		 ; Return

; WWFX_WarpLanding:
; 	LDA #$00	 
; 	STA Map_ReturnStatus 	; Map_ReturnStatus = 0 (was just set to 3?)

; 	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (reassigned not two instructions later!)
; 	LDX Player_Current	; X = Player_Current

; 	INC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt++

; 	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (assigned again??)
; 	LDX <Map_WWOrHT_Dir	; X = Map_WWOrHT_Dir

; 	LDA <Map_WWOrHT_X
; 	ADD Map_WW_DeltaX,X	; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

; 	STA <Map_WWOrHT_X
; 	CMP Map_WW_IslandX,Y
; 	BNE PRG011_A44C	 	; If wind hasn't reached your landing point, jump to PRG011_A44C

; 	LDX Player_Current	; X = Player_Current

; 	LDA Map_WW_IslandY,Y
; 	STA Map_PlyrSprOvrY	; Map_PlyrSprOvrY = Map_WW_IslandY[Y] (target Y) (restore map sprite)
; 	STA <World_Map_Y,X	; World_Map_Y = Map_WW_IslandY[Y] (target Y)

; 	JMP PRG011_A45B	 	; Jump to PRG011_A45B

; PRG011_A44C:
; 	; Wind hasn't reached landing point... (or is passed it already, as the case may be)

; 	CMP Map_WW_TargetX,X
; 	BNE PRG011_A45B	 	; If warp wind hasn't hit the appropriate edge, jump to PRG011_A45B

; 	; Otherwise, shut it down!
; 	LDA #$00	 
; 	STA <Map_WWOrHT_Cnt
; 	STA <Map_WarpWind_FX

; 	LDA #248
; 	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248

; PRG011_A45B:
; 	JMP PRG011_A3D9	 ; Jump to PRG011_A3D9


; MO_HandTrap:
; 	LDA Map_HandState
; 	JSR DynJump	 

; 	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
; 	.word HT_Init
; 	.word HT_Flash
; 	.word HT_GrabPlayer

; HT_Init:
; 	LDX Player_Current
; 	LDA <World_Map_Y,X
; 	STA Map_PlyrSprOvrY	; Reset Map_PlyrSprOvrY to the Player's current Y

; 	ADD #16
; 	STA <Map_WWOrHT_Y	; Start 16 pixels beneath Player

; 	; Match Player's X
; 	LDA <World_Map_XHi,X	 
; 	STA <Map_HandTrap_XHi	
; 	LDA <World_Map_X,X
; 	STA <Map_WWOrHT_X

; 	INC Map_HandState		; Next state...
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

; HT_Flash:
; 	JSR WarpWhistle_Flash	 	; Reused flashing effect

; 	LDA <Map_WWOrHT_Cnt
; 	BNE PRG011_A494	 		; If Map_WWOrHT_Cnt <> 0, the effect is not over, jump to PRG011_A494

; 	INC Map_HandState	 	; Next state...

; 	LDA #SND_LEVELRISE	 
; 	STA Sound_QLevel1		; "Rising" sound

; PRG011_A494:
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; HT_GrabPlayer:
; 	LDA #$01
; 	STA <Temp_Var1			; Temp_Var1 = 1

; 	JSR HT_DoRaiseAndFall	 	; Raise hand, take Player down with it

; 	LDA <Map_WWOrHT_Cnt
; 	CMP #32 
; 	BNE PRG011_A4B8	 		; If Map_WWOrHT_Cnt <> 32, jump to PRG011_A4B8

; 	LDA #$10
; 	STA Map_Operation	 	; Map_Operation = $10 (enter level)

; 	LDX Player_Current
; 	LDA #$00	 
; 	STA Map_Player_SkidBack,X	; Map_Player_SkidBack = 0
; 	STA World_EnterState		; World_EnterState = 0
; 	STA Map_HandState	 	; The multipurpose state variable is reset
; 	RTS		 		; Return...


; PRG011_A4B8:
; 	JSR WorldMap_UpdateAndDraw	; Do WorldMap_UpdateAndDraw

; 	LDX Player_Current
; 	LDA <World_Map_Y,X
; 	ADD #16
; 	STA <Temp_Var1		 	; Temp_Var1 = Player's map Y + 16

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	STA <Temp_Var2		 	; Temp_Var2 = Player's map X - Horz_Scroll

; 	LDA #$00
; 	STA <Temp_Var3		 	; Temp_Var3 = 0
; 	JMP PRG011_A503	 		; Jump to PRG011_A503

; 	; Hand Trap raises for 16 ticks (-1), then falls (1)
; HT_RaiseFall:	.byte -1, 1

; HT_DoRaiseAndFall:
; 	LDA <Counter_1
; 	AND #$01	
; 	BNE PRG011_A4FC	 	; Every other tic, jump to PRG011_A4FC

; 	; More specifically, 16 tics for the hand to come up, 16
; 	; tics for the hand to go down...
; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10	 	; Every 16 counter tics...
; 	LSR A	
; 	LSR A	
; 	LSR A	
; 	LSR A		 	; Amounts to 0/1 every 16 tics
; 	TAY		 	; Y = 0 or 1
; 	LDX Player_Current	; X = Player_Current

; 	LDA <Map_WWOrHT_Y
; 	ADD HT_RaiseFall,Y
; 	STA <Map_WWOrHT_Y	; Hand trap's Y += HT_RaiseFall[Y]

; 	INC <Map_WWOrHT_Cnt
; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10
; 	BEQ PRG011_A4FC	 	; If hand is still raising (pre 16 ticks), jump to PRG011_A4FC

; 	; As hand falls, it takes Player down with it!
; 	LDA <Map_WWOrHT_Y	
; 	STA Map_PlyrSprOvrY	

; PRG011_A4FC:
; 	RTS		 	; Return...

; 	; NOTE: These values are shared with the HAND TRAP of World 8
; Map_WW_Pal:	.byte $01, $03	; The former is a BROWN color (hand trap), the latter is its white color
; Map_WW_Pattern:
; 	.byte $59, $51	; Frame 0 (Hand, Wind)
; 	.byte $5D, $55	; Frame 1 (Hand, Wind)

; PRG011_A503:

; 	; This masks the bottom of the hand by deliberately drawing 8 junk sprites
; 	; 16 pixels beneath it to force the hardware to stop drawing at that 
; 	; scanline; it's dirty, but effective -- so long as no other sprites
; 	; are on that scanline to be noticeably effected :)
; 	LDX #$07	 ; X = 7
; PRG011_A505:
; 	TXA		 
; 	ASL A		 
; 	ASL A		 
; 	TAY		 	; Y = X << 2 (* 4, or for 7 sprites...)

; 	LDA <Temp_Var1
; 	STA Sprite_RAM+$00,Y	; Store Y

; 	LDA #$27	 
; 	STA Sprite_RAM+$01,Y	; Pattern

; 	LDA #%00100011
; 	STA Sprite_RAM+$02,Y	; Place sprite behind BG, flipped horizontally and vertically

; 	LDA #$00	 
; 	STA Sprite_RAM+$03,Y	; X = 0

; 	DEX		 	; X--
; 	BPL PRG011_A505	 	; While X >= 0, loop!

; WarpWindHandTrap_Draw:
; 	LDX <Temp_Var3		; X = Temp_Var3 (warp wind palette)

; 	; The warp wind sprite Y
; 	LDA <Map_WWOrHT_Y	; A = Map_WWOrHT_Y
; 	STA Sprite_RAM+$60
; 	STA Sprite_RAM+$64

; 	LDA <Temp_Var3		; A = Temp_Var3
; 	BEQ PRG011_A544	 	; If Temp_Var3 = 0, jump to PRG011_A544 (AFAIK, this is never the case)

; 	LDA Map_PlyrSprOvrY
; 	CMP #$f8
; 	BNE PRG011_A56B	 	; If Map_PlyrSprOvrY <> $f8, jump to PRG011_A56B

; 	; Disable Player map sprite!
; 	STA Sprite_RAM+$84
; 	STA Sprite_RAM+$88
; 	STA Sprite_RAM+$8C
; 	STA Sprite_RAM+$90

; 	JMP PRG011_A56B	 	; Jump to PRG011_A56B...

; PRG011_A544:
; 	; Otherwise, not disabling Player map sprite...

; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10
; 	BEQ PRG011_A56B

; 	; Restore Player's map sprite Y
; 	LDA Map_PlyrSprOvrY
; 	STA Sprite_RAM+$8C
; 	STA Sprite_RAM+$90
; 	SUB #16
; 	STA Sprite_RAM+$84
; 	STA Sprite_RAM+$88

; 	LDA Sprite_RAM+$85
; 	CMP #$27	 
; 	BNE PRG011_A56B	 	; If the pattern in use is not $27, jump to PRG011_A56B

; 	; Otherwise, disable half the sprite
; 	LDA #$f8	 
; 	STA Sprite_RAM+$84
; 	STA Sprite_RAM+$88

; PRG011_A56B:
; 	; Set the warp wind's attributes (white palette)
; 	LDA Map_WW_Pal,X
; 	STA Sprite_RAM+$62
; 	STA Sprite_RAM+$66

; 	; Set the warp wind's X
; 	LDA <Temp_Var2		; Map_WWOrHT_X
; 	STA Sprite_RAM+$63
; 	ADD #$08	 
; 	STA Sprite_RAM+$67	; Map_WWOrHT_X + 8

; 	LDY Map_WW_Pattern,X	; Get the pattern for the wind/hand

; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10	 
; 	BEQ PRG011_A58B	 
; 	LDY Map_WW_Pattern+2,X	; Every 16 tics, use the second frame

; PRG011_A58B:
; 	; Store the pattern for the first sprite
; 	STY Sprite_RAM+$61

; 	INY	
; 	INY			; Pattern += 2
; 	STY Sprite_RAM+$65	; Store the pattern for the second sprite

; 	LDA <Map_WWOrHT_Dir
; 	BEQ PRG011_A5AA	 	; If Map_WWOrHT_Dir = 0, jump to PRG011_A5AA

; 	; Flip the wind patterns!
; 	STY Sprite_RAM+$61
; 	DEY		
; 	DEY		
; 	STY Sprite_RAM+$65

; 	; Set the flip attribute
; 	LDA Sprite_RAM+$62	; Get old attributes
; 	ORA #$40	 	; H-Flip attr
; 	STA Sprite_RAM+$62	
; 	STA Sprite_RAM+$66	

; PRG011_A5AA:

; 	; This draw a couple high-priority sprites at the border's edge 
; 	; using border patterns to clip the warp wind sprite!

; 	; Sprite set to Y
; 	LDA <Map_WWOrHT_Y
; 	STA Sprite_RAM+$00
; 	STA Sprite_RAM+$04

; 	; Pattern 1
; 	LDA #$01	 
; 	STA Sprite_RAM+$01

; 	; Pattern $B
; 	LDA #$0b	 
; 	STA Sprite_RAM+$05

; 	; Attributes
; 	LDA #$01	 
; 	STA Sprite_RAM+$02
; 	STA Sprite_RAM+$06

; 	; And X = 1
; 	STA Sprite_RAM+$07

; 	; And X = 8
; 	LDA #$08	 
; 	STA Sprite_RAM+$03

; 	LDA <Temp_Var2	 ; MapWWOrHT_X
; 	AND #$80	 
; 	BEQ PRG011_A5DC	 ; If MapWWOrHT_X is not in the right half of the screen, jump to PRG011_A5DC (RTS)

; 	; Otherwise, put the border patch on the RIGHT side!
; 	LDA #$f0	
; 	STA Sprite_RAM+$03
; 	LDA #$f8	 
; 	STA Sprite_RAM+$07

; PRG011_A5DC:
; 	RTS		 ; Return

; GameOver_TwirlToStart:
; 	LDX Player_Current	 

; 	LDA <Map_SkidBack
; 	BNE PRG011_A63D	 ; If Map_SkidBack is set, jump to PRG011_A63D

; 	LDY World_Num	 ; Y = World_Num

; 	LDA <World_Map_Y,X
; 	SUB Map_Y_Starts,Y
; 	STA <Map_Skid_DeltaY

; 	LDA <World_Map_X,X
; 	SUB #$20
; 	STA <Map_Skid_DeltaX

; 	LDA #$00
; 	STA <Map_Skid_TravDirs
; 	STA <Map_Skid_DeltaFracX
; 	STA <Map_Skid_DeltaFracY

; 	LDA <World_Map_X,X
; 	CMP #32
; 	BGE PRG011_A610	 ; If Player's Map X >= 32 (the common start X of all maps), jump to PRG011_A610

; 	; Player's Map X < 32...

; 	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
; 	LDA #$01
; 	STA <Map_Skid_TravDirs

; 	; Negate Map_Skid_DeltaX
; 	LDA #$ff
; 	EOR <Map_Skid_DeltaX
; 	TAY
; 	INY
; 	STY <Map_Skid_DeltaX

; PRG011_A610:
; 	LDY World_Num	 ; Y = World_Num

; 	LDA <World_Map_Y,X
; 	CMP Map_Y_Starts,Y
; 	BGE PRG011_A628	 ; If Player's Map Y >= the starting Y of the map, jump to PRG011_A628

; 	; Player's Map Y < the starting Y of the map...

; 	; Negate Map_Skid_DeltaY
; 	LDA #$ff
; 	EOR <Map_Skid_DeltaY
; 	TAY
; 	INY
; 	STY <Map_Skid_DeltaY

; 	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
; 	LDA <Map_Skid_TravDirs
; 	ORA #$02
; 	STA <Map_Skid_TravDirs

; PRG011_A628:

; 	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
; 	LDY #$04	 ; Y = 4
; PRG011_A62A:
; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
; 	ROR <Map_Skid_DeltaFracY		; Set as bit 7 of Map_Skid_DeltaFracY

; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
; 	ROR <Map_Skid_DeltaFracX		; Set as bit 7 of Map_Skid_DeltaFracX

; 	DEY			; Y--
; 	BPL PRG011_A62A		; While Y >= 0, loop!

; 	; Map_Skid_Counter = $20
; 	LDA #$20
; 	STA <Map_Skid_Counter

; 	INC <Map_SkidBack		 ; Set Map_SkidBack

; PRG011_A63D:

; 	; Skid sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A65E	 ; If Player is traveling left, jump to PRG011_A65E

; 	; Traveling to the right...

; 	; Map_Skid_FracX += Map_Skid_DeltaFracX
; 	LDA <Map_Skid_FracX
; 	ADD <Map_Skid_DeltaFracX
; 	STA <Map_Skid_FracX

; 	; Add and carry into the full X
; 	LDA <World_Map_X,X
; 	ADC <Map_Skid_DeltaX
; 	STA <World_Map_X,X

; 	; Any additional carry into Map XHi
; 	LDA <World_Map_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	JMP PRG011_A671	 ; Jump to PRG011_A671

; PRG011_A65E:

; 	; Traveling to the left

; 	; Map_Skid_FracX -= Map_Skid_DeltaFracX
; 	LDA <Map_Skid_FracX
; 	SUB <Map_Skid_DeltaFracX
; 	STA <Map_Skid_FracX

; 	; Subtract and carry into the full X
; 	LDA <World_Map_X,X
; 	SBC <Map_Skid_DeltaX
; 	STA <World_Map_X,X

; 	; Any additional carry into Map XHi
; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; PRG011_A671:
; 	LDA <Map_Skid_TravDirs
; 	AND #$02
; 	BEQ PRG011_A687	 ; If Player is traveling up, jump to PRG011_A65E

; 	; Traveling downward

; 	; Map_Skid_FracY += Map_Skid_DeltaFracY
; 	LDA <Map_Skid_FracY
; 	ADD <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	; Add and carry into the full Y
; 	LDA <World_Map_Y,X
; 	ADC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; 	JMP PRG011_A694	 ; Jump to PRG011_A694

; PRG011_A687:

; 	; Traveling downward

; 	; Map_Skid_FracY -= Map_Skid_DeltaFracY
; 	LDA <Map_Skid_FracY
; 	SUB <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	; Subtract and carry into the full Y
; 	LDA <World_Map_Y,X
; 	SBC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; PRG011_A694:
; 	DEC <Map_Skid_Counter	; Map_Skid_Counter--
; 	BNE PRG011_A6BC	 ; If Map_Skid_Counter <> 0, jump to PRG011_A6BC

; PRG011_A698:
; 	; GameOver_State = 8 (we've landed, we're done)
; 	LDA #$08
; 	STA GameOver_State

; 	LDX Player_Current	 ; X = Player_Current

; 	LDA #$00
; 	STA <Map_SkidBack
; 	STA World_Map_Twirl,X	 ; Twirling is done
; 	STA Map_Prev_XOff2,X
; 	STA Map_Prev_XHi2,X

; 	; Set the previous values at the twirl landing spot

; 	; Map_Previous_Y = World_Map_Y
; 	LDA <World_Map_Y,X
; 	STA Map_Previous_Y,X

; 	; Map_Previous_X/Hi = Map_Previous_X/Hi
; 	LDA <World_Map_XHi,X
; 	STA Map_Previous_XHi,X
; 	LDA <World_Map_X,X
; 	STA Map_Previous_X,X

; PRG011_A6BC:
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; GameOver_TwirlFromAfar:
; 	LDX Player_Current	 ; X = Player_Current

; 	; Map X -= 2 (Player flying from way off goes directly left)
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X
; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	BNE PRG011_A6E4	 ; If Player Map X <> Horz_Scroll, jump to PRG011_A6E4

; 	LDA #$00
; 	STA Map_Prev_XOff,X
; 	STA Map_Prev_XHi,X
; 	STA Map_Entered_XHi,X

; 	INC GameOver_State	 ; GameOver_State++

; PRG011_A6E4:

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	JSR Map_DrawBorderForPlayer	 ; Draw border sprites to cover twirling Player

; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; Map_DrawBorderForPlayer:
; 	LDX Player_Current	; X = Player_Current

; 	; Set Map Border Sprite Y
; 	LDA <World_Map_Y,X
; 	STA Sprite_RAM+$00
; 	STA Sprite_RAM+$04

; 	; Set Map Border Sprite left Pattern
; 	LDA #$01
; 	STA Sprite_RAM+$01

; 	; Set Map Border Sprite right Pattern
; 	LDA #$0b
; 	STA Sprite_RAM+$05

; 	; Set Map Border Sprite attributes
; 	LDA #SPR_PAL0
; 	STA Sprite_RAM+$02
; 	STA Sprite_RAM+$06

; 	; Set Map Border left Sprite X
; 	STA Sprite_RAM+$07

; 	; Set Map Border right Sprite X
; 	LDA #$08
; 	STA Sprite_RAM+$03

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	AND #$80
; 	BEQ PRG011_A727	 ; If difference is positive, jump to PRG011_A727 (RTS)

; 	; Set Map Border Sprite X
; 	LDA #240
; 	STA Sprite_RAM+$03
; 	LDA #248
; 	STA Sprite_RAM+$07

; PRG011_A727:
; 	RTS		 ; Return


; GameOver_AlignToStartY
; 	LDX Player_Current	 ; X = Player_Current

; 	; Enter from right side
; 	LDA #240
; 	STA <World_Map_X,X

; 	LDY World_Num		 ; Y = World_Num
; 	LDA Map_Y_Starts,Y	 ; Get start Y
; 	STA <World_Map_Y,X	 ; Set Player at start Y

; 	INC GameOver_State	 ; GameOver_State++
; 	JMP PRG011_A6E4	 	; Jump to PRG011_A6E4

; GameOver_ReturnToStartX:
; 	LDX Player_Current	 ; X = Player_Current

; 	; Player's Map X -= 2 (skidding towards Start panel)
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X

; 	CMP #$20
; 	BNE PRG011_A74E	 ; If Player is not at $20 (fixed start point X), jump to PRG011_A74E

; 	JMP PRG011_A698	 ; Jump to PRG011_A698

; PRG011_A74E:

; 	; Play skidding sound (actually pointless from where it jumps)
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	JMP PRG011_A6E4	 ; Jump to PRG011_A6E4

; MO_SkidToPrev:
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <Map_SkidBack
; 	BEQ PRG011_A760	 ; If Map_SkidBack is not set, jump to PRG011_A760

; 	JMP PRG011_A834	 ; Jump to PRG011_A834

; PRG011_A760:

; 	; Checks all map objects to see if Player has died while in a map object

; 	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1)
; PRG011_A762:
; 	LDA Map_Objects_IDs,Y
; 	BNE PRG011_A76D	 ; If this map object slot is not empty, jump to PRG011_A76D

; PRG011_A767:
; 	DEY		 ; Y--
; 	BNE PRG011_A762	 ; While Y > 0, loop!  (Ignores the HELP bubble)
; 	JMP PRG011_A79D	 ; Jump to PRG011_A79D

; PRG011_A76D:

; 	; If Player is not on top of the airship, jump to PRG011_A767
; 	LDA <World_Map_Y,X
; 	CMP Map_Objects_Y,Y
; 	BNE PRG011_A767

; 	LDA <World_Map_XHi,X
; 	CMP Map_Objects_XHi,Y
; 	BNE PRG011_A767

; 	LDA <World_Map_X,X
; 	CMP Map_Objects_XLo,Y
; 	BNE PRG011_A767

; 	JMP PRG011_A791

; 	; Player is on top of the airship
; 	; NOTE: Assumes Index 1 is the Airship!

; 	; Set airship count = $20 (orders it to scurry away)
; 	LDA #$20
; 	STA Map_March_Count+1

; 	JMP PRG011_A767	 ; Jump to PRG011_A767

; PRG011_A791:
; 	JMP PRG011_A767	 ; If this is NOT a Coin Ship, jump to PRG011_A767


; 	JMP PRG011_A767	 ; Jump to PRG011_A767

; PRG011_A79D:

; 	; Player died on top of something not an Airship or a Coin ship...

; 	LDA Map_Previous_Y,X
; 	SUB <World_Map_Y,X
; 	STA <Map_Skid_DeltaY

; 	LDA Map_Previous_XHi,X
; 	CMP <World_Map_XHi,X
; 	BEQ PRG011_A7B0	 ; If Player is on the same map screen as he was before, jump to PRG011_A7B0
; 	BGE PRG011_A7B7	 ; If Player is on a map screen to the right, jump to PRG011_A7B7
; 	BLT PRG011_A7CB	 ; If Player is on a map screen to the left, jump to PRG011_A7CB

; PRG011_A7B0:

; 	; Player is on the same map screen he was previously...

; 	LDA Map_Previous_X,X
; 	CMP <World_Map_X,X
; 	BLT PRG011_A7CB	 ; If Player is to the left from where he was, jump to PRG011_A7CB

; PRG011_A7B7:

; 	; Player is to the right from where he was...

; 	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
; 	LDA Map_Previous_X,X
; 	SUB <World_Map_X,X
; 	STA <Map_Skid_DeltaFracX

; 	; Map_Skid_DeltaX starts as straight difference in X Hi
; 	LDA Map_Previous_XHi,X
; 	SBC <World_Map_XHi,X	
; 	STA <Map_Skid_DeltaX

; 	; Do not set bit 0 on Map_Skid_TravDirs (travel left instead of right)
; 	LDY #$00	 ; Y = 0

; 	JMP PRG011_A7DC	 ; Jump to PRG011_A7DC

; PRG011_A7CB:

; 	; Player is to the left from where he was

; 	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
; 	LDA <World_Map_X,X
; 	SUB Map_Previous_X,X
; 	STA <Map_Skid_DeltaFracX

; 	; Map_Skid_DeltaX starts as straight difference in X Hi
; 	LDA <World_Map_XHi,X
; 	SBC Map_Previous_XHi,X
; 	STA <Map_Skid_DeltaX

; 	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
; 	LDY #$01	 ; Y = 1

; PRG011_A7DC:
; 	STY <Map_Skid_TravDirs	 ; Set Map_Skid_TravDirs

; 	LDA #$00
; 	STA <Map_Skid_FracX
; 	STA <Map_Skid_DeltaFracY

; 	LDA Map_Previous_Y,X
; 	CMP <World_Map_Y,X
; 	BGE PRG011_A7F9	 ; If Player is lower than he was before, jump to PRG011_A7F9

; 	; Player was higher than before... negate Map_Skid_DeltaY
; 	LDA #$ff
; 	EOR <Map_Skid_DeltaY
; 	TAY
; 	INY
; 	STY <Map_Skid_DeltaY

; 	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
; 	LDA <Map_Skid_TravDirs
; 	ORA #$02
; 	STA <Map_Skid_TravDirs

; PRG011_A7F9:
; 	LDA <Map_Skid_DeltaX
; 	BNE PRG011_A817	 ; If Player is left/right of where he was before, jump to PRG011_A817

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	TAY

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BNE PRG011_A811	 ; If Player is traveling right, jump to PRG011_A811

; 	TYA
; 	ADD <Map_Skid_DeltaFracX
; 	BCC PRG011_A81D	 ; If no carry, jump to PRG011_A81D
; 	BCS PRG011_A817	 ; Otherwise, jump to PRG011_A817

; PRG011_A811:
; 	TYA
; 	SUB <Map_Skid_DeltaFracX
; 	BCS PRG011_A81D	 ; If carry set, jump to PRG011_A81D

; PRG011_A817:
; 	INC Map_Operation	 ; Map_Operation++ (go to the "twirl from afar" state)
; 	JMP MO_SkidToPrevAfar	 ; Jump to MO_SkidToPrevAfar

; PRG011_A81D:

; 	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
; 	LDY #$04	 ; Y = 4
; PRG011_A81F:
; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
; 	ROR <Map_Skid_DeltaFracY	; Set as bit 7 of Map_Skid_DeltaFracY

; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
; 	ROR <Map_Skid_DeltaFracX	; Set as bit 7 of Map_Skid_DeltaFracX; Bit 0 -> Carry
; 	ROR <Map_Skid_FracX		; Set as bit 7 of <Map_Skid_FracX

; 	DEY			; Y--
; 	BPL PRG011_A81F		; While Y >= 0, loop!

; 	; Map_Skid_Counter = $20
; 	LDA #$20
; 	STA <Map_Skid_Counter

; 	INC <Map_SkidBack		 ; Set Map_SkidBack

; PRG011_A834:
; 	LDA <Map_Skid_Counter
; 	BEQ PRG011_A891	 ; If Map_Skid_Counter = 0, jump to PRG011_A891

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BNE PRG011_A859	 ; If Player is traveling right, jump to PRG011_A859

; 	LDA <Map_Skid_FracCarry
; 	ADD <Map_Skid_FracX
; 	STA <Map_Skid_FracCarry

; 	LDA <World_Map_X,X
; 	ADC <Map_Skid_DeltaFracX
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	ADC <Map_Skid_DeltaX
; 	STA <World_Map_XHi,X

; 	JMP PRG011_A86C	 ; Jump to PRG011_A86C

; PRG011_A859:
; 	LDA <Map_Skid_FracCarry
; 	SUB <Map_Skid_FracX
; 	STA <Map_Skid_FracCarry

; 	LDA <World_Map_X,X
; 	SBC <Map_Skid_DeltaFracX
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	SBC <Map_Skid_DeltaX
; 	STA <World_Map_XHi,X

; PRG011_A86C:
; 	LDA <Map_Skid_TravDirs
; 	AND #$02
; 	BNE PRG011_A882	 ; If Player is traveling down, jump to PRG011_A882

; 	LDA <Map_Skid_FracY
; 	ADD <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	LDA <World_Map_Y,X
; 	ADC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; 	JMP PRG011_A88F	 ; Jump to PRG011_A88F

; PRG011_A882:
; 	LDA <Map_Skid_FracY
; 	SUB <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	LDA <World_Map_Y,X
; 	SBC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; PRG011_A88F:
; 	DEC <Map_Skid_Counter		 ; Map_Skid_Counter--

; PRG011_A891:
; 	JSR WorldMap_UpdateAndDraw	 ; Update and draw map

; 	LDA <Map_Skid_Counter
; 	ORA Map_March_Count+1	; <--- Airship's movement counter
; 	ORA Map_Pan_Count
; 	BNE PRG011_A8C8	 ; If skidding, the airship is moving, or the map is panning, jump to PRG011_A8C8 (RTS)

; 	; Map_Operation = $0B (Hammer bros march around)
; 	LDA #$0b
; 	STA Map_Operation

; 	LDX Player_Current	 ; X = Player_Current

; 	; Ensure Player is precisely at his previous position
; 	LDA <World_Map_Y,X
; 	STA Map_Entered_Y,X
; 	LDA <World_Map_XHi,X
; 	STA Map_Entered_XHi,X
; 	LDA <World_Map_X,X
; 	STA Map_Entered_X,X

; 	LDA Map_Prev_XOff2,X
; 	STA Map_Prev_XOff,X

; 	LDA Map_Prev_XHi2,X
; 	STA Map_Prev_XHi,X

; 	; Clear skid vars
; 	LDA #$00
; 	STA <Map_SkidBack
; 	STA Map_Player_SkidBack,X

; PRG011_A8C8:
; 	RTS		 ; Return

; MO_SkidToPrevAfar:
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A8E9	 ; If Player is traveling left, jump to PRG011_A8E9

; 	; Far away Player skidding directly to the left; Map X -= 2
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X
; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	BEQ PRG011_A8FF	 ; If Player hit left edge, jump to PRG011_A8FF

; 	JMP PRG011_A90E	 ; Jump to PRG011_A90E

; PRG011_A8E9:

; 	; Far away Player skidding directly to the right; Map X += 2
; 	LDA <World_Map_X,X
; 	ADD #$02
; 	STA <World_Map_X,X
; 	LDA <World_Map_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	CMP #240
; 	BNE PRG011_A90E	 ; If Player has not hit right edge, jump to PRG011_A90E

; PRG011_A8FF:

; 	; Player hit edge of the screen

; 	LDA Map_Prev_XOff2,X
; 	STA Map_Prev_XOff,X

; 	LDA Map_Prev_XHi2,X
; 	STA Map_Prev_XHi,X

; 	INC Map_Operation	 ; Map_Operation++

; PRG011_A90E:

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	JSR Map_DrawBorderForPlayer	 ; Draw border to block Player sprite

; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw map and don't come back!

; MO_SkidAfarPrep:
; 	LDX Player_Current	 ; X = Player_Current

; 	; Set Player's Y and XHi to their previous values
; 	LDA Map_Previous_Y,X
; 	STA <World_Map_Y,X
; 	LDA Map_Previous_XHi,X
; 	STA <World_Map_XHi,X

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A946	 ; If Player is traveling left, jump to PRG011_A946

; 	; Traveling rightward

; 	LDY #240	 ; Y = 240

; 	LDA <Horz_Scroll
; 	BEQ PRG011_A941		; If horizontal scroll = 0, jump to PRG011_A941

; 	LDA Map_Previous_X,X
; 	ADD <Horz_Scroll
	
; 	LDA Map_Previous_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	LDY #112	 ; Y = 112

; PRG011_A941:
; 	STY <World_Map_X,X ; Set proper World Map X to begin skidding from

; 	JMP PRG011_A95B	 ; Jump to PRG011_A95B

; PRG011_A946:

; 	; Traveling leftward

; 	LDA <Horz_Scroll
; 	BEQ PRG011_A957	 ; If Horz_Scroll = 0, jump to PRG011_A957

; 	LDA Map_Previous_X,X
; 	SUB <Horz_Scroll
; 	LDA Map_Previous_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; PRG011_A957:
; 	LDA <Horz_Scroll
; 	STA <World_Map_X,X

; PRG011_A95B:

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	INC Map_Operation	 ; Map_Operation++

; 	JMP PRG011_A90E	 ; Jump to PRG011_A90E

; MO_SkidAfarFinish:
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A986	 ; If Player is traveling left, jump to PRG011_A946

; 	; Player traveling left

; 	; Map X -= 2
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	CMP Map_Previous_X,X
; 	BEQ PRG011_A99A	 ; If Player Map X is at his previous X, jump to PRG011_A99A

; 	JMP PRG011_A9B5	 ; Otherwise, jump to PRG011_A9B5 (indirect to PRG011_A90E)

; PRG011_A986:

; 	; Player traveling right

; 	; Map X += 2
; 	LDA <World_Map_X,X
; 	ADD #$02
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	CMP Map_Previous_X,X
; 	BNE PRG011_A9B5	 ; If Player Map X is not at his previous X, jump to PRG011_A9B5 (indirect to PRG011_A90E)

; PRG011_A99A:

; 	; Player has finally arrived at his "previous" position, completing the skid back from afar

; 	; Map_Operation = $0B (Hammer bros march around)
; 	LDA #$0b
; 	STA Map_Operation

; 	; Ensure Player is precisely at his previous position
; 	LDA <World_Map_Y,X
; 	STA Map_Entered_Y,X
; 	LDA <World_Map_XHi,X
; 	STA Map_Entered_XHi,X
; 	LDA <World_Map_X,X
; 	STA Map_Entered_X,X

; 	LDA #$00
; 	STA <Map_SkidBack
; 	STA Map_Player_SkidBack,X

; PRG011_A9B5:
; 	JMP PRG011_A90E	 ; Jump to PRG011_A90E

	; Indexed by Map_ClearLevelFXCnt * 2
Map_ClearLevelFXPatterns:

	; "Poof" effect
	.byte $45, $47	; 0
	.byte $45, $47	; 1
	.byte $49, $31	; 2
	.byte $49, $35	; 3
	.byte $49, $39	; 4
	.byte $49, $41	; 5

	; "Flip" effect
	.byte $B5, $B5	; 6
	.byte $A1, $A1	; 7
	.byte $B5, $B5	; 8

	; Indexed by Player and tile quadrant (except the last three which are hardcoded specific)

	; This just forces "poof" completion on the following tiles (in quadrant zero, since all other
	; quadrants always "poof" except fortress tiles)



; The old Coin Ship ruleset:
; 1.) End the stage with an even number on the clock.
; 2.) Coins must be a Multiple of 11.
; 3.) The 10â€²s digit of your score must be the multiple of 11 that corresponds to your coins.
; 4.) Finally it must be in World 1, 3, 5, and 6.
;	NOTE: The worlds that don't count are literally because there's no "Hammer Bro"
;	map objects there; the code doesn't actually care about the world number!

MapBonusChk_CoinShip:
	RTS

	; This will always appear at the same location!!
MAPOBJ_UNK0C_Y:	.byte $60
MAPOBJ_UNK0C_X:	.byte $60

MapBonusChk_MAPOBJ_UNK0C:
	RTS		 ; Return


	; This looks for an empty map object slot and returns the index in 'Y'
	; Assumes that the first two slots are always occupied...
	; NOTE: Dangerous!  If all slots are filled, this could loop for eternity
	; or return a bad index!  There's just an assumption of a free slot!
	;
	; A better implemention per what the rest of the engine would do is make
	; sure we don't loop beyond the last object ((MAPOBJ_TOTAL-1)) and in failure
	; "Do Not Return to Caller" (double PLA instruction), but oh well...
Map_FindEmptyObjectSlot:
	LDY #$02	 ; Y = 2
	
PRG011_AD9F:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADA8	 ; If this map object slot is empty, jump to PRG011_ADA8 (RTS)

	INY		 ; Y++
	JMP PRG011_AD9F	 ; Loop

PRG011_ADA8:
	RTS		 ; Return

Map_March_InitValues:
	; Initializes Map_March_Count values per Map_Object_ID
	; Generally the value is $20 (Marching time amount) and $00 (Don't march)
	; There's some restriction on these values because of internal ANDings.

	; Also, an object won't actually march unless it is tied into the march
	; function (check function pointer list @ PRG011_AE0B), but if it uses 
	; the Map_Object_Stationary function, it will briefly animate slightly
	; faster (as does a Hammer Brother marching around) due to a jump it
	; makes; this is used to make the World 7 Plant look ferocious (I suppose)
	; and would happen with World 8 stuff too, but they use $00 values so
	; the net effect is absolutely nothing.
	.byte $00	; None
	.byte $00	; HELP
	.byte $00	; Airship
	.byte $20	; Hammer Bro
	.byte $20	; Boomerang Bro
	.byte $20	; Heavy Bro
	.byte $20	; Fire Bro
	.byte $20	; World 7 Plant (doesn't really "go" anywhere, though!)
	.byte $20	; Unknown/unused marching glitch object
	.byte $00	; N-Spade
	.byte $00	; White Toad House
	.byte $20	; Coin Ship (does "sail" around the map)
	.byte $00	; Unknown white colorization of $0F (goes to World 7 level??)
	.byte $00	; World 8 Battleship
	.byte $00	; World 8 Tank
	.byte $00	; World 8 Airship
	.byte $00	; Canoe

	.byte $00, $00, $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Object_Do_All
;
; Runs update code on all map objects, e.g. what makes a 
; Hammer Brother march, an airship fly, etc.  Does NOT have
; anything to do with the interaction of the object, except
; for the canoe, which simply sets the "In Canoe" flag if
; the Player is standing in it.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Object_Do_All:

	LDY #(MAPOBJ_TOTAL-1) 	; Total map objects which may exist on the map (only 8 are defined at start)
	STY <Temp_Var13		; Temp_Var13 = $0D

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_ADE6	 	; If Map_Operation <> $0B (Hammer Bro marching around), jump to PRG011_ADE6

	LDA Map_MarchInit
	BNE PRG011_ADE6	 	; If Map_MarchInit is set, jump to PRG011_ADE6

PRG011_ADD2:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADDE	 	; If the object ID is zero, nothing to do, jump to PRG011_ADDE
	TAX		 	; X = A

	; Initialize all the map march values
	LDA Map_March_InitValues,X	; For this object's ID, get the init value
	STA Map_March_Count,Y	 	; Store it in this object's slot

PRG011_ADDE:
	DEY		 ; Y--
	CPY #$01	 
	BNE PRG011_ADD2	 ; While Y <> 1, loop!


	INC Map_MarchInit	 ; Set Map_MarchInit (March initialization complete!)

PRG011_ADE6:
	LDX <Temp_Var13		; X = Temp_Var13

	LDA Map_Objects_IDs,X
	BEQ PRG011_ADF0	 	; If the object ID is zero, nothing to do, jump to PRG011_ADF0

	JSR Map_Object_Do 	; Process this map object!

PRG011_ADF0:
	DEC <Temp_Var13		; Temp_Var13--
	BPL PRG011_ADE6	 	; While Temp_Var13 >= 0, loop!

PRG011_ADF4:
	RTS		 ; Return


Map_Object_Do:
	; Map object to do...
	JSR Map_Object_CheckVisibility	 ; Check and store if this object is visible

	LDA Map_Objects_IDs,X	; Get the ID

PRG011_AE0B:
	RTS
	; Based on the ID, jump to proper routine for how it should act on the map
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; None (Just RTS)
	.word PRG011_ADF4		; HELP (Just RTS)
	.word PRG011_ADF4	; Airship
	.word PRG011_ADF4		; Hammer Bro
	.word PRG011_ADF4		; Boomerang Bro
	.word PRG011_ADF4		; Heavy Bro
	.word PRG011_ADF4		; Fire Bro
	.word PRG011_ADF4	; World 7 Plant
	.word PRG011_ADF4		; Unknown marching glitch object
	.word PRG011_ADF4		; N-Spade
	.word PRG011_ADF4		; White Toad House
	.word PRG011_ADF4		; Coin Ship
	.word PRG011_ADF4	; Unknown white colorization of 15 (goes to World 7 level??)
	.word PRG011_ADF4	; World 8 Battleship
	.word PRG011_ADF4	; World 8 Tank
	.word PRG011_ADF4	; World 8 Airship
	.word PRG011_ADF4		; Canoe
	.word PRG011_ADF4		; Canoe
	.word PRG011_ADF4		; Canoe


MapObject_LeftTile:
	.byte $0D, $11, $15, $19	; 01=Rain
	.byte $2D, $31, $35, $39	; 02=Snow
	.byte $21, $21, $41, $41	; 03=Ship
	.byte $47, $47, $47, $47	; 04=wrecked Ship
	.byte $4D, $4D, $4D, $4D	; 05=Boo
	.byte $51, $51, $51, $51	; Red mushroom
	.byte $11, $11, $11, $11	;
	.byte $51, $51, $51, $51	; Green Mushroom
	.byte $51, $51, $51, $51	; Orange Mushroom
	.byte $61, $61, $63, $63	; Piranah Plant
	.byte $69, $6D, $6B, $6F	; Cheep
	.byte $71, $73, $75, $77	; Freezie
	.byte $55, $55, $55, $55	; Bullet Turret
	.byte $59, $5D, $5B, $5F	; Bobomb
	.byte $3D, $3D, $3D, $3D	; 0F = Piranha Stem
	.byte $79, $2B, $79, $2B	; 
	.byte $71, $75, $71, $75	;

MapObject_RightTile:
	.byte $0F, $13, $17, $1B	; 01=Rain
	.byte $2F, $33, $37, $3B	; 02=Snow
	.byte $23, $23, $43, $43	; 03=Ship
	.byte $49, $49, $49, $49	; 04=wrecked Ship
	.byte $4F, $4F, $4F, $4F	; 05=Boo
	.byte $53, $53, $53, $53	; 06=Red mushroom
	.byte $11, $11, $11, $11	; 07=None
	.byte $53, $53, $53, $53	; 08=Blue Mushroom
	.byte $53, $53, $53, $53	; 09=Orange Mushroom
	.byte $61, $61, $63, $63	; 0A=Piranah Plant
	.byte $6B, $6F, $69, $6D	; 0B=Cheep
	.byte $4B, $4B, $4B, $4B	; 0C=Freezie
	.byte $57, $57, $57, $57	; 0D
	.byte $5B, $5F, $59, $5D	; 0E = Bobomb
	.byte $3D, $3D, $3D, $3D	; 0F = Piranha Stem
	.byte $7B, $7B, $7B, $7B	; 
	.byte $73, $77, $73, $77	; 

MapObject_AttrLeft:
	.byte $02, $02, $02, $02	; 01=Rain Cloud
	.byte $02, $02, $02, $02	; 02=Snow
	.byte $03, $03, $03, $03	; 03=Ship
	.byte $03, $03, $03, $03	; 04=wrecked Ship
	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1, SPR_PAL1	; 05=Boo
	.byte $01, $01, $01, $01	; Red Mushroom
	.byte $02, $02, $02, $02	; None
	.byte $02, $02, $02, $02	; Blue Mushroom
	.byte $03, $03, $03, $03	; Orange Mushroom
	.byte SPR_PAL2, SPR_PAL2, SPR_PAL2, SPR_PAL2	; Piranha
	.byte SPR_PAL1, SPR_PAL1, (SPR_PAL1 | SPR_HFLIP), (SPR_PAL1 | SPR_HFLIP)	; Cheep
	.byte $02, $02, $02, $02	; Freezie
	.byte $03, $03, $03, $03	; Bullet Turret
	.byte SPR_PAL3, SPR_PAL3, (SPR_PAL3 | SPR_HFLIP), (SPR_PAL3 | SPR_HFLIP)	; 0E = Bobomb
	.byte SPR_PAL2, SPR_PAL2, SPR_PAL2, SPR_PAL2	; 0F = Piranha Stem
	.byte SPR_PAL3, SPR_PAL3, SPR_PAL3, SPR_PAL3	; 
	.byte $02, $02, $02, $02	; 

MapObject_AttrRight:
	.byte $02, $02, $02, $02	; 01=Rain Cloud
	.byte $02, $02, $02, $02	; 02=Snow
	.byte $03, $03, $03, $03	; 03=Ship
	.byte $03, $03, $03, $03	; 04=wrecked Ship
	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1, SPR_PAL1	; 05=Boo
	.byte $01, $01, $01, $01	; Red Mushroom
	.byte $02, $02, $02, $02	; None
	.byte $02, $02, $02, $02	; Blue Mushroom
	.byte $03, $03, $03, $03	; Orange Mushroom
	.byte (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP)	; Piranha Plant
	.byte SPR_PAL1, SPR_PAL1, (SPR_PAL1 | SPR_HFLIP), (SPR_PAL1 | SPR_HFLIP)	; Cheep
	.byte $03, $02, $02, $02	; 
	.byte $03, $03, $03, $03	; 0E = Bobomb
	.byte SPR_PAL3, SPR_PAL3, (SPR_PAL3 | SPR_HFLIP), (SPR_PAL3 | SPR_HFLIP)	; 
	.byte (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP)	; 0F = Piranha Stem
	.byte SPR_PAL3, SPR_PAL3, SPR_PAL3, SPR_PAL3	; 
	.byte $02, $02, $02, $02	; 

	; This is a rotated array of Sprite_RAM offsets, helps distribute
	; the map object display so even if there's scanline overflows,
	; there will be at least some visibility of all objects.
Map_SpriteRAM_Offset:
	.byte $08, $10, $18, $20, $28, $30, $38, $40, $08, $10, $18, $20, $28, $30, $38, $40


MapObjects_UpdateDrawEnter:
	JSR Map_Object_Do_All	 ; Runs update code for all map objects

	; Temp_Var13 = $0D
	LDA #14	 	; Total map objects which may exist on the map (only 8 are defined at start)
	STA <Temp_Var13

	; Map_SprRAMOffDistr runs from $00 to $0A, inclusive
	INC Map_SprRAMOffDistr

	LDA Map_SprRAMOffDistr
	AND #$07
	STA Map_SprRAMOffDistr

PRG011_B554:

	; Temp_Var6 = 0
	LDA #$00
	STA <Temp_Var6

	LDY <Temp_Var13	 ; Y = Temp_Var13 (current map slot index)
	LDA Map_SpriteRAM_Offset, Y	 ; A = Map_SprRAMOffDistr + Temp_Var13

PRG011_B568:
	STA <Temp_Var6		 	; -> Temp_Var6

PRG011_B56E:
	LDX <Temp_Var13		 ; X = Temp_Var13

	LDA Map_Objects_Vis,X
	BEQ PRG011_B578	 ; If this object isn't visible, jump to PRG011_B578

	JSR MapObject_DrawSleepEnter	 ; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered

PRG011_B578:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG011_B554	 ; While Temp_Var13 >= 0, loop!

PRG011_B57C:
	LDA Map_Operation
	CMP #$0d
	BNE PRG011_B58C	 ; If the map operation <> $0D (normal), jump to PRG011_B58C (RTS)

	LDA <Counter_1
	AND #$03
	BNE PRG011_B58C

	INC Map_March_Count	; Increment Map_March_Count every 4 ticks

PRG011_B58C:
	RTS		 ; Return


	; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered
MapObject_DrawSleepEnter:
	LDA Map_Objects_IDs,X
	; Map object slot 0 (typ. HELP bubble) or any object that is not in the Map_HideObj override slot

	; Jump by the Map Object ID (this is largely wasted here...)
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; 00=None (RTS)
	.word MapObj_DrawAndEnter	; 01=HELP
	.word MapObj_DrawAndEnter	; 02=Airship
	.word MapObj_DrawAndEnter	; 03=Hammer Bro
	.word MapObj_DrawAndEnter	; 04=Boomerang Bro
	.word MapObj_DrawAndEnter	; 05=Heavy Bro
	.word MapObj_DrawAndEnter	; 06=Fire Bro
	.word MapObj_DrawAndEnter	; 07=World 7 Plant
	.word MapObj_DrawAndEnter	; 08=Unknown marching glitch object
	.word MapObj_DrawAndEnter	; 09=N-Spade
	.word MapObj_DrawAndEnter	; 0A=White Toad House
	.word MapObj_DrawAndEnter	; 0B=Coin Ship
	.word MapObj_DrawAndEnter	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.word MapObj_DrawAndEnter	; 0D=World 8 Battleship
	.word MapObj_DrawAndEnter	; 0E=World 8 Tank
	.word MapObj_DrawAndEnter	; 0F=World 8 Airship
	.word MapObj_DrawAndEnter	; 10=Canoe

MapObj_DrawAndEnter:
	LDA <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)
	ADD #$90
	STA <Temp_Var6
	TAY

	LDA #$00	 ; A = 0 (no offset on map sprite)

	; Set Y for map object sprite
	ADD Map_Object_ActY,X
	STA Sprite_RAMY,Y
	STA Sprite_RAMY + 4,Y

	; Set X for map object sprite
	LDA Map_Object_ActX,X
	SUB <Horz_Scroll
	STA Sprite_RAMX,Y

	; Right half
	ADD #$08
	STA Sprite_RAMX + 4,Y

	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	; Map object ID -> Temp_Var8
	LDA Map_Objects_IDs,X
	STA <Temp_Var8

	LDA <Counter_1	 ; X = 8 (masking value against Counter_1 for animation)
	AND #$30
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var9	 ; -> Temp_Var9 (masking value for animation)

	LDA <Temp_Var8	 ; A = map object ID
	ASL A		 ; Multiply by 2
	ASL A		 ; Multiply by 4
	ADD <Temp_Var9
	TAX

PRG011_B630:
	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Load the patterns of the map object
	LDA MapObject_LeftTile-4,X
	STA Sprite_RAMTile,Y

	LDA MapObject_RightTile-4,X	
	STA Sprite_RAMTile + 4,Y	

	
	; Load the attributes of the map object
	LDA MapObject_AttrLeft-4,X	
	STA Sprite_RAMAttr,Y	

	LDA MapObject_AttrRight-4,X	
	STA Sprite_RAMAttr + 4,Y	

	RTS

;	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)
;
;	LDA Map_Objects_IDs,X
;	LDY <Temp_Var13		 ; Y = Temp_Var13 (the map object slot index)
;
;	; HELP bubble was already eliminated
;
;	; Map Object ID $03-$08  all jump to PRG011_B69C
;	; Otherwise, jump to PRG011_B6A1
;	LDA Map_Objects_IDs,Y
;	LDA Map_DrawPanState
;	BNE PRG011_B6F5	 ; If some kind of map drawing/panning activity is occurring, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Pan_Count
;	BNE PRG011_B6F5	 ; If the map is panning, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Operation
;	CMP #$0D
;	BNE PRG011_B6F5	 ; If Map_Operation <> $0D (something is going on), jump to PRG011_B6F5 (RTS)
;
;	LDX Player_Current	 ; X = Player_Current
;
;	; If the Player is not perfectly situated on top of the map object, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Objects_Y,Y
;	CMP <World_Map_Y,X
;	BNE PRG011_B6F5
;
;	LDA Map_Objects_XHi,Y
;	CMP <World_Map_XHi,X
;	BNE PRG011_B6F5
;
;	LDA Map_Objects_XLo,Y
;	CMP <World_Map_X,X
;	BNE PRG011_B6F5	
;
;	; Player is going to "enter" this map object...
;
;	LDX Player_Current	 ; X = Player_Current (needless reload?)
;
;	LDA #$00
;	STA Map_Player_SkidBack,X
;
;	LDA #$03
;	STA World_EnterState
;
;	; Store the object ID -> Map_EnterViaID
;	;LDA Map_Objects_IDs,Y
;	;STA <Map_EnterViaID
;
;	; If this is a N-Spade or White Toad house, jump to PRG011_B6E2
;	;CMP #MAPOBJ_NSPADE
;	BEQ PRG011_B6E2
;	;CMP #MAPOBJ_WHITETOADHOUSE
;	BNE PRG011_B6E5
;
;PRG011_B6E2:
;	; N-Spade and White Toad House only...
;	INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn
;
;PRG011_B6E5:
;	LDA Map_Objects_Itm,Y
;	STA Level_TreasureItem
;
;	; Begin level entry
;	LDA #$0f
;	STA Map_Operation
;
;	; Don't return to caller!
;	PLA
;	PLA
;
;	JMP PRG011_B57C	; Jump to PRG011_B57C
;
;PRG011_B6F5:
;	RTS		 ; Return
;
;	; FIXME: Anyone want to claim this?  (Exact same routine appears in PRG010 @ $D228)
;; $B6F6 
;	LDX Player_Current	 ; X = Player_Current
;
;	LDA <World_Map_Dir,X	; Get Player's map direction
;	EOR #$03
;	CMP #$03
;	BNE PRG011_B703	 	; If Player did not travel left or right, jump to PRG011_B703
;
;	EOR #$0f	 ; Otherwise invert all direction bits??
;
;PRG011_B703:
;	STA <World_Map_Dir,X	 ; -> World_Map_Dir
;
;	RTS		 ; Return

; 	; FIXME: Anyone want to claim this?
; 	; Gets a tile based on an input 'Y' value to pick from one of the offset sets below...
; PRG011_B706:	.byte -16, -16, 0, -32
; PRG011_B70A:	.byte $00, $FF, $00, $00	; 16-bit sign extensions
; PRG011_B70E:	.byte 16, -16, 0, 0

; ; $B712
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <World_Map_Y,X
; 	ADD PRG011_B706,Y
; 	STA <Temp_Var15	

; 	LDA <World_Map_X,X
; 	ADD PRG011_B70E,Y
; 	STA <Temp_Var16	

; 	LDA <World_Map_XHi,X
; 	ADC PRG011_B70A,Y
; 	ASL A		 ; 2 byte index per map screen
; 	TAX		 ; -> 'X'

; 	; Set pointer to map screen tiles
; 	LDA Tile_Mem_Addr,X
; 	STA <Map_Tile_AddrL
; 	LDA Tile_Mem_Addr+1,X
; 	STA <Map_Tile_AddrH
; 	INC <Map_Tile_AddrH	; Map is always on lower part

; 	; Form row/column offset
; 	LDA <Temp_Var16
; 	LSR A
; 	LSR A
; 	LSR A
; 	LSR A
; 	STA <Temp_Var16
; 	LDA <Temp_Var15
; 	AND #$f0
; 	ORA <Temp_Var16
; 	TAY	 ; -> 'Y'

; 	LDA [Map_Tile_AddrL],Y	; Get tile
; 	RTS		 ; Return


; PRG011_B74A:
; 	LDX Map_Unused738		; X =  Map_Unused738

; 	;LDA Map_Unused7DC6,X
; 	CMP #$09
; 	BLT MapStarsIntro_DoStarFX	; If Map_Unused7DC6[X] < 9, jump to MapStarsIntro_DoStarFX

; 	; Map_StarsState = 1
; 	LDA #$01
; 	STA <Map_StarsState

; 	LDX Player_Current	; X = Player_Current

; 	LDY Map_Unused7992
; 	INY
; 	TYA	; A = Map_Unused7992 + 1

; 	; ASL A
; 	; ASL A
; 	; ASL A
; 	; ASL A
; 	; ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
; 	; CMP <World_Map_Move,X	
; 	; BEQ MapStarsIntro_DoStarFX	 ; If movement is same as Player's current movement, jump to MapStarsIntro_DoStarFX

; 	JMP WorldMap_UpdateAndDraw	 ; Draw and update map and don't come back

; MapStarsIntro_DoStarFX:
; 	LDA Map_StarFX_State
; 	JSR DynJump

; 	.word MapStarsIntro_Init
; 	.word WWFX_WarpWhistleFlash	; THIS STATE IS NOT USED (accidentally/on-purpose skipped)
; 	.word MapStarsIntro_Do

; 	; Default "radius" values for each star on the world intro
; MSI_DefaultRadii:	.byte $14, $10, $0C, $08, $04, $00, $1C, $18

; 	; Per-radius size values
; MSI_RadSize:		.byte 0, 24, 48, 71, 90, 106, 118, 125, 128, 125, 118, 106, 90, 71, 48, 24


; 	; Patterns used by the "stars" in the intro
; MapStarsIntro_Patterns:	.byte $67, $69 

; MapStarsIntro_Init:
; 	LDA #SND_MAPENTERWORLD	
; 	STA Sound_QMap	; Play the starry entrance sound

; 	; Preload the default "radius" values for each star
; 	LDX #$07
; PRG011_B799:
; 	LDA MSI_DefaultRadii,X
; 	STA <Map_StarsRadius,X
; 	DEX		 	; X--
; 	BPL PRG011_B799	 	; While X >= 0, loop!

; 	LDX <Map_StarsState
; 	BNE PRG011_B7AD	 	; If Map_StarsState <> 0, jump to PRG011_B7AD

; 	; Stars emanating from center
; 	LDA #$80	 
; 	STA <Map_StarsCenterX	; Map_StarsCenterX = $80
; 	STA <Map_StarsCenterY	; Map_StarsCenterY = $80
; 	BNE PRG011_B800	 	; Jump (technically always) to PRG011_B800

; PRG011_B7AD:
; 	CPX #$01	 
; 	BNE PRG011_B7CC	 	; If Map_StarsState <> 1, jump to PRG011_B7CC

; 	; Stars emanating from Player start
; 	LDX Player_Current	; X = Player_Current

; 	LDA <World_Map_X,X
; 	ADD <Horz_Scroll
; 	STA <Map_StarsCenterX	; Map_StarsCenterX = Player's Map X + Horz_Scroll

; 	LDA <World_Map_Y,X	
; 	STA <Map_StarsCenterY	; Map_StarsCenterY = Player's Map Y

; 	LDA #$86
; 	STA Map_Stars_PRelX	; Map_Stars_PRelX = $86

; 	LDA #$d0	
; 	STA Map_Stars_PRelY	; Map_Stars_PRelY = $D0

; 	JMP PRG011_B7E6	 ; Jump to PRG011_B7E6

; PRG011_B7CC:
; 	; Map_StarsState = 2

; 	LDA #$88
; 	STA <Map_StarsCenterX	; Map_StarsCenterX = 136

; 	LDA #$5c
; 	STA <Map_StarsCenterY	; Map_StarsCenterY = 92

; 	LDX Player_Current	; X = Player_Current

; 	LDA <World_Map_X,X
; 	ADD <Horz_Scroll
; 	STA Map_Stars_PRelX	 	; Map_Stars_PRelX = Player's map X coordinate + Horz_Scroll

; 	LDA <World_Map_Y,X
; 	STA Map_Stars_PRelY	 	; Map_Stars_PRelY = Player's map Y coordinate

; 	INC <Map_StarFX_State	; Next state... (NOTE: Incremented again below!)

; PRG011_B7E6:

; 	; Calculate step and deltas
; 	LDX <Map_StarsCenterX
; 	LDA Map_Stars_PRelX
; 	JSR MSI_CalcDeltaAndSteps
; 	STA <Map_StarsXSteps
; 	STX Map_StarsDeltaX

; 	LDX <Map_StarsCenterY
; 	LDA Map_Stars_PRelY
; 	JSR MSI_CalcDeltaAndSteps
; 	STA <Map_StarsYSteps	
; 	STX Map_StarsDeltaY

; PRG011_B800:
; 	LDA #$00
; 	STA <Map_StarsFrame	; Map_StarsFrame = 0
; 	STA <Map_StarsLandRad	; Map_StarsLandRad = 0
; 	STA <Map_StarsOutRad	; Map_StarsOutRad = 0

; 	LDA #$67
; 	STA <Map_StarsPattern

; 	LDA #$09
; 	STA <Map_StarsConst9	; Map_StarsConst9 = 9 (forever?)

; 	INC Map_StarFX_State	; Next state... (technically, +2 before it gets back)

; 	LDX <Map_StarsState
; 	CPX #$02	 
; 	BEQ PRG011_B81C	 	; If Map_StarsState = 2, jump to PRG011_B81C (RTS)

; 	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

; PRG011_B81C:
; 	RTS		 	; Return


; 	; FIXME: Anyone want to claim this?
; ; $B81D
; 	JMP PRG011_B8B1	; Jump to PRG011_B8B1

; MapStarsIntro_Do:
; 	LDA <Map_StarsLandRad
; 	BNE PRG011_B834	 		; If Map_StarsLandRad <> 0 (we're doing the "landing" now), jump to PRG011_B834

; 	LDA <Map_StarsOutRad
; 	ADD #$04	 
; 	CMP #$5f	 
; 	BGE PRG011_B830	 	; If Map_StarsOutRad + 4 >= $5F, jump to PRG011_B830 (change direction)

; 	; Otherwise, jump to PRG011_B8AF
; 	JMP PRG011_B8AF	

; PRG011_B830:
; 	LDA #$01	 
; 	STA <Map_StarsLandRad		; Map_StarsLandRad = 1

; PRG011_B834:
; 	; Stars landing

; 	LDA <Map_StarsState
; 	BEQ PRG011_B874	 		; If Map_StarsState = 0, jump to PRG011_B874

; 	LDA <Map_StarsCenterX
; 	CMP Map_Stars_PRelX
; 	BGE PRG011_B84B	 		; If Map_StarsCenterX >= Map_Stars_PRelX (Player's landing is to the left), jump to PRG011_B84B

; 	; Player's landing is to the right...
; 	ADC Map_StarsDeltaX		; Map_StarsCenterX += Map_StarsDeltaX
; 	TAX		 		; X = A
; 	DEC <Map_StarsXSteps		; Map_StarsXSteps--
; 	BMI PRG011_B854			; If Map_StarsXSteps < 0, jump to PRG011_B854
; 	INX		 		; X++
; 	JMP PRG011_B854	 		; Jump to PRG011_B854

; PRG011_B84B:
; 	SBC Map_StarsDeltaX	 	; Map_StarsCenterX -= Map_StarsDeltaX
; 	TAX		 		; X = A
; 	DEC <Map_StarsXSteps		; Map_StarsXSteps--
; 	BMI PRG011_B854	 		; If Map_StarsXSteps < 0, jump to PRG011_B854
; 	DEX				; X--

; PRG011_B854:
; 	STX <Map_StarsCenterX		; Update Map_StarsCenterX

 
; 	LDA <Map_StarsCenterY
; 	CMP Map_Stars_PRelY
; 	BGE PRG011_B869	 		; If Map_StarsCenterY >= Map_Stars_PRelY (Player's landing is above), jump to PRG011_B869

; 	; Player's landing is below...
; 	ADC Map_StarsDeltaY		; Map_StarsCenterY += Map_StarsDeltaY
; 	TAX		 		; X = A
; 	DEC <Map_StarsYSteps		; Map_StarsYSteps--
; 	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
; 	INX		 		; X++
; 	JMP PRG011_B872	 		; Jump to PRG011_B872

; PRG011_B869:
; 	SBC Map_StarsDeltaY	 	; Map_StarsCenterY -= Map_StarsDeltaY
; 	TAX		 		; X = A
; 	DEC <Map_StarsYSteps		; Map_StarsYSteps--
; 	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
; 	DEX		 		; X--

; PRG011_B872:
; 	STX <Map_StarsCenterY		; Update Map_StarsCenterY

; PRG011_B874:
; 	LDA <Map_StarsOutRad
; 	SUB #$04	 
; 	BNE PRG011_B8AF	 		; If Map_StarsOutRad - 4 <> 0, jump to PRG011_B8AF

; 	LDA #$00	 
; 	STA Map_StarFX_State	 	; Map_StarFX_State = 0
; 	STA <Map_StarsLandRad		; Map_StarsLandRad = 0

; 	LDA <Map_StarsState
; 	CMP #$02	 
; 	BEQ PRG011_B8A5			; If Map_StarsState = 2, jump to PRG011_B8A5


; 	; FIXME: CHECKME: Might be some dead code here
; 	LDX Map_Unused738	 ; X = Map_Unused738

; 	;LDA Map_Unused7DC6,X
; 	CMP #$09
; 	BLT PRG011_B8A5	 ; If Map_Unused7DC6[X] FIXME < 9, jump to PRG011_B8A5

; 	; Map_Unused7992 -= 10 (FIXME)
; 	SUB #10
; 	STA Map_Unused7992

; 	LDX Player_Current	; X = Player_Current

; 	TAY
; 	INY
; 	TYA

; 	ASL A
; 	ASL A
; 	ASL A
; 	ASL A
; 	ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
; 	STA <World_Map_Move,X	; Player moves by this amount (but not during the stars display??)

; PRG011_B8A5:
; 	LDX <Map_StarsState
; 	CPX #$02	 
; 	BEQ PRG011_B8AE	 	; If Map_StarsState = 2, jump to PRG011_B8AE (RTS)

; 	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

; PRG011_B8AE:
; 	RTS		 ; Return

; PRG011_B8AF:
; 	; Stars taking off

; 	STA <Map_StarsOutRad	; Update Map_StarsOutRad

; PRG011_B8B1:
; 	; This just adds 32 each display frame and toggles the Map_StarsFrame when it overflows
; 	LDA <Map_StarsAnimCnt
; 	ADD #32
; 	STA <Map_StarsAnimCnt	; Map_StarsAnimCnt += 32
; 	BCC PRG011_B8C6		; If it hasn't overflowed, jump to PRG011_B8C6

; 	; So Map_StarsFrame toggles every 8 frames
; 	LDA <Map_StarsFrame	
; 	EOR #$01	 
; 	STA <Map_StarsFrame	; Toggle Map_StarsFrame (0/1)

; 	TAX		 
; 	LDA MapStarsIntro_Patterns,X	 ; Based on Map_StarsFrame, get the pattern number
; 	STA <Map_StarsPattern		 ; Store into Map_StarsPattern

; PRG011_B8C6:
; 	LDY #$00	 ; Y = 0

; 	LDX #$07	 ; X = 7

; 	; This just adds $70 each display frame and toggles the Map_StarsFrame when it overflows
; 	LDA <Map_StarsRadCnt
; 	ADD #$70
; 	STA <Map_StarsRadCnt	; Map_StarsRadCnt += $70
; 	BCC PRG011_B8D5	 	; If it hasn't overflowed, jump to PRG011_B8D5

; 	; So roughly every 2.29 display frames...
; 	LDY #$01	 	; Y = 1 (+1 to the rotation)

; PRG011_B8D5:
; 	STY <Map_StarsDeltaR	; Map_StarsDeltaR = Y (0 or 1)

; PRG011_B8D7:

; 	; Add to each star's radius 0 or 1, capping the value at 0-31
; 	LDA <Map_StarsRadius,X	
; 	ADD <Map_StarsDeltaR	
; 	AND #$1f	 
; 	STA <Map_StarsRadius,X	; Map_StarsRadius[X] = (Map_StarsRadius[X] + 1) & $1f

; 	JSR MSI_CalcStarsXY	; Calculate this star's X and Y (and Temp_Var10 contains the X for the second sprite)
; 	JSR MSI_DrawStar	; Draw this star!
; 	DEX		 	; X--
; 	BPL PRG011_B8D7	 	; If X >= 0, loop!

; 	LDX <Map_StarsState
; 	CPX #$02	 
; 	BEQ PRG011_B8F2		; If Map_StarsState = 2, jump to PRG011_B8F2
; 	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

; PRG011_B8F2:
; 	RTS		 ; Return

; ; MSI_CalcStarsXY
; ;
; ; Calculates the current X and Y position of each star
; MSI_CalcStarsXY:
; 	LDA <Map_StarsRadius,X
; 	AND #$0f		; Only using values 0-15 of the "radius"	 
; 	TAY
; 	LDA MSI_RadSize,Y
; 	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

; 	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
; 	LDY <Map_StarsConst9	; Y = Map_StarsConst9
; 	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

; 	LDA <Map_StarsRadius,X	
; 	AND #$18	 
; 	CMP #16
; 	BLT PRG011_B917	 	; If (Map_StarsRadius[X] & $18) < 16, jump to PRG011_B917

; 	; Otherwise...
; 	LDA #-1
; 	STA <Temp_Var1		; Temp_Var1 = -1

; 	LDA <Map_StarsCenterX
; 	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
; 	JMP PRG011_B91F	 	; Jump to PRG011_B91F

; PRG011_B917:
; 	LDA #$01
; 	STA <Temp_Var1		; Temp_Var1 = 1

; 	LDA <Map_StarsCenterX
; 	ADC <Temp_Var3		; A = Map_StarsCenterX + Temp_Var3

; PRG011_B91F:
; 	STA <Map_StarsX,X	; Set this as the star's X position
; 	STA <Temp_Var7		; Temp_Var7 = star's X position

; 	LDA <Map_StarsCenterX
; 	STA <Temp_Var8		; Temp_Var8 = all stars center X

; 	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

; 	LDA <Temp_Var6
; 	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

; 	LDA <Map_StarsX,X
; 	ADD #8
; 	STA <Temp_Var10		; Temp_Var10 = star's X + 8 (will be second sprite's offset)
; 	STA <Temp_Var7		; Temp_Var7 = Temp_Var10

; 	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

; 	LDA <Temp_Var6		
; 	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

; 	LDA <Map_StarsRadius,X	
; 	ADD #$08	 
; 	AND #$0f	 
; 	TAY		 	; Y = (radius value + 8) & $F
; 	LDA MSI_RadSize,Y
; 	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

; 	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
; 	LDY <Map_StarsConst9	; Y = Map_StarsConst9
; 	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

; 	LDA <Map_StarsRadius,X
; 	SUB #$08	
; 	AND #$18
; 	CMP #16
; 	BLT PRG011_B968	 	; If ((Map_StarsRadius[X] - 8) & $18) < 16, jump to PRG011_B968

; 	LDA #-1
; 	STA <Temp_Var1		; Temp_Var1 = -1

; 	LDA <Map_StarsCenterY
; 	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
; 	JMP PRG011_B970	 	; Jump to PRG011_B970

; PRG011_B968:
; 	LDA #1
; 	STA <Temp_Var1		; Temp_Var1 = 1

; 	LDA <Map_StarsCenterY
; 	ADC <Temp_Var3		

; PRG011_B970:
; 	STA <Map_StarsY,X	; star's Y = Map_StarsCenterY + Temp_Var3
; 	STA <Temp_Var7		; Temp_Var7 = star's Y

; 	LDA <Map_StarsCenterY	
; 	STA <Temp_Var8		; Temp_Var8 = all stars center Y

; 	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

; 	LDA <Temp_Var6	
; 	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980
; 	RTS		 	; Return

; PRG011_B980:
; 	LDA #$f8
; 	STA <Map_StarsY,X	; star's Y = $F8 (hides sprite)
; 	LDA #$00	 
; 	STA <Map_StarsX,X	; star's X = 0 (we're hiding the sprite)

; 	STA <Temp_Var10		; Temp_Var10 = star's X (0) (will be second sprite's offset)
; 	RTS		 	; Return

; MSI_CalcXOffset:
; 	; A = Map_StarsOutRad
; 	; Y = Map_StarsConst9 (9)

; 	; MAPOBJ_HAMMERBROFIXME: I don't really understand the algorithm (I think it's some kind of
; 	; division or fractional multiplication routine?), produces X offset in Temp_Var3

; 	STA <Temp_Var2	; Temp_Var2 = Map_StarsOutRad

; 	LDA #$00	
; 	STA <Temp_Var3	; Temp_Var3 = 0
; 	STA <Temp_Var4	; Temp_Var4 = 0

; PRG011_B993:
; 	ASL <Temp_Var4
; 	ROL <Temp_Var3
; 	ASL <Temp_Var1
; 	BCC PRG011_B9A6

; 	LDA <Temp_Var4
; 	ADD <Temp_Var2
; 	STA <Temp_Var4

; 	BCC PRG011_B9A6

; 	INC <Temp_Var3

; PRG011_B9A6:
; 	DEY		 ; Y--
; 	BNE PRG011_B993	 ; While Y >= 0, loop

; 	RTS		 ; Return

; ; MSI_DrawStar
; ;
; ; Generates the hardware sprites for a star
; MSI_DrawStar:
; 	TXA
; 	ASL A
; 	ASL A
; 	ASL A
; 	TAY		; Y = X << 3

; 	; Store the Y part of this star's sprites
; 	LDA <Map_StarsY,X	 
; 	STA Sprite_RAM+$98,Y	 
; 	STA Sprite_RAM+$9C,Y	 

; 	; Store the patterns for this star's sprites
; 	LDA <Map_StarsPattern	
; 	STA Sprite_RAM+$99,Y	
; 	STA Sprite_RAM+$9D,Y	

; 	; First sprite is palette 3
; 	LDA #$03	 
; 	STA Sprite_RAM+$9A,Y

; 	; Second sprite is same but also HV flipped
; 	LDA #$c3
; 	STA Sprite_RAM+$9E,Y

; 	; Store X coordinate for first sprite
; 	LDA <Map_StarsX,X
; 	STA Sprite_RAM+$9B,Y

; 	; Store X coordinate for second sprite
; 	LDA <Temp_Var10
; 	STA Sprite_RAM+$9F,Y

; 	RTS		 ; Return

; PRG011_SUB_B9D4:
; 	; Temp_Var1 = 1 or -1
; 	; Temp_Var7 = star's X position
; 	; Temp_Var8 = all stars center X

; 	LDA <Temp_Var7
; 	EOR <Temp_Var8
; 	AND #$80	 
; 	BEQ PRG011_B9EA	 	; If Temp_Var7 and Temp_Var8 are oppositely signed, jump to PRG011_B9EA

; 	LDA <Temp_Var1
; 	BPL PRG011_B9E6	 	; If Temp_Var1 >= 0, jump to PRG011_B9E6

; 	LDA <Temp_Var7
; 	BMI PRG011_B9EF	 	; If Temp_Var7 < 0, jump to PRG011_B9EF
; 	BPL PRG011_B9EA	 	; Otherwise, jump to PRG011_B9EA

; PRG011_B9E6:
; 	LDA <Temp_Var7
; 	BPL PRG011_B9EF	 	; If Temp_Var7 >= 0, jump to PRG011_B9EF

; PRG011_B9EA:
; 	LDA #1
; 	STA <Temp_Var6		; Temp_Var6 = 1
; 	RTS		 	; Return...

; PRG011_B9EF:
; 	LDA #-1
; 	STA <Temp_Var6		; Temp_Var6 = -1
; 	RTS		 	; Return...

; MSI_CalcDeltaAndSteps:

; 	; X = Map_StarsCenterX
; 	; A = Map_Stars_PRelX

; 	STX <Temp_Var4	; Temp_Var4 = Map_StarsCenterX
; 	STA <Temp_Var5	; Temp_Var5 = Map_Stars_PRelX
 
; 	SUB <Temp_Var4	
; 	STA <Temp_Var1	; Temp_Var1 = Temp_Var5 (Map_Stars_PRelX) - Temp_Var4 (Map_StarsCenterX)

; 	LDA <Temp_Var5	
; 	CMP <Temp_Var4	
; 	BGE PRG011_BA0B	; If Temp_Var5 >= Temp_Var4, jump to PRG011_BA0B

; 	; Otherwise, Temp_Var1 is negative; negate it!
; 	LDA <Temp_Var1
; 	EOR #$ff	
; 	ADC #$01	
; 	STA <Temp_Var1	

; 	; FIXME: I don't really understand the algorithm (I think it's some kind of
; 	; division routine?), but it finds the delta X/Y values for the star intro
; 	; and the number of steps to complete the move
; PRG011_BA0B:
; 	LDA #$00
; 	STA <Temp_Var3	; Temp_Var3 = 0

; 	LDY #$07	; Y = 7
; PRG011_BA11:
; 	ASL <Temp_Var3
; 	ROL <Temp_Var1
; 	ROL A		
; 	BCS PRG011_BA1C	

; 	CMP #$17
; 	BLT PRG011_BA20	

; PRG011_BA1C:
; 	SBC #$17	
; 	INC <Temp_Var3	; Temp_Var3++

; PRG011_BA20:
; 	DEY		 ; Y--
; 	BPL PRG011_BA11	 ; While Y >= 0, loop!

; 	LDX <Temp_Var3	 ; X = Temp_Var3
; 	RTS		 ; Return

Map_CompleteY:
	.byte $20, $30, $40, $50, $60, $70, $80
Map_CompleteY_End

Map_CompleteBit:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

Map_MarkLevelComplete:
	LDA Old_World_Map_Tile 	 ; X = Player_Current
	AND #$0F
	JSR MapGetTileBit
	;ORA World_Complete_Tiles,X
	;STA World_Complete_Tiles,X
	RTS


MapObject_X = Temp_Var2
MapLeft_Edge = Temp_Var3
MapRight_Edge = Temp_Var4

Map_Object_CheckVisibility:
	; For a given object, check if it's visible on the map.  This value is
	; stored into the Map_Objects_Vis array
	; X is the index to the map object we need to work with!
	LDY #$00	 	; Object is not visible until proven visible...

	LDA Map_Objects_XHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <MapObject_X		; Temp_Var2 = object's X Hi byte << 4

	LDA Map_Objects_XLo,X
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	ORA <MapObject_X		
	STA <MapObject_X		; OR'ing the low X >> 4; Temp_Var2 now contains a proper "column" position

	LDA <Horz_Scroll_Hi
	ASL A
	ASL A
	ASL A
	ASL A
	STA <MapLeft_Edge
	ADD #$10
	STA <MapRight_Edge

	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	PHA
	ORA <MapLeft_Edge
	STA <MapLeft_Edge

	PLA 
	ORA <MapRight_Edge
	STA <MapRight_Edge

	LDA <MapObject_X
	CMP <MapLeft_Edge
	BLT PRG011_BAB1	 	; If object is less than the right scroll column, jump to PRG011_BAB1

	CMP <MapRight_Edge	
	BGE PRG011_BAB1	 	; If object is greater-equal to the left scroll column, jump to PRG011_BAB1

	LDY #$01	 	; Object is visible!
PRG011_BAB1:
	TYA		 	; A = Y
	STA Map_Objects_Vis,X 	; Mark this object as visible or not
	RTS		 	; Return

Map_Object_Canoe:
	LDY Player_Current	; Y = Player_Current
	LDA Map_InCanoe_Flag
	BEQ PRG011_BAD9	 	; If Map_InCanoe_Flag = 0, jump to PRG011_BAD9

	; Otherwise, the Canoe is updated to match the Player's
	; position; this seems to only allow one canoe per map!
	; Though it could probably be fixed somehow...
	LDA World_Map_Y,Y 
	STA Map_Objects_Y,X
	STA Map_Object_ActY,X
	LDA World_Map_X,Y	
	STA Map_Objects_XLo,X	
	STA Map_Object_ActX,X	
	LDA World_Map_XHi,Y	
	STA Map_Objects_XHi,X	
	STA Map_Object_ActXH,X	

PRG011_BAD9:

	; Basically if Player is standing in Canoe, it activates the Map_InCanoe_Flag flag
	LDA World_Map_Move,Y
	ORA Map_Player_SkidBack,Y
	BNE PRG011_BAFE	 

	LDA World_Map_Y,Y
	CMP Map_Object_ActY,X
	BNE PRG011_BAFE

	LDA World_Map_XHi,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_BAFE	 

	LDA World_Map_X,Y
	CMP Map_Object_ActX,X
	BNE PRG011_BAFE	 

	; Map_InCanoe_Flag = 1 (In canoe!)
	LDA #$01
	STA Map_InCanoe_Flag

PRG011_BAFE:
	RTS		 ; Return

W8D_CircSprs:
	.byte $F8, $81, $01, $F0
	.byte $F0, $83, $01, $F8
	.byte $E8, $85, $01, $00
	.byte $E8, $85, $41, $08
	.byte $F0, $83, $41, $10
	.byte $F8, $81, $41, $18
	.byte $08, $81, $81, $F0
	.byte $10, $83, $81, $F8
	.byte $18, $85, $81, $00
	.byte $18, $85, $C1, $08
	.byte $10, $83, $C1, $10
	.byte $08, $81, $C1, $18
	.byte $E8, $0B, $01, $F0
	.byte $E8, $0B, $01, $18
	.byte $18, $0B, $01, $F0
	.byte $18, $0B, $01, $18
	.byte $F0, $0B, $01, $E8
	.byte $00, $0B, $01, $E8
	.byte $10, $0B, $01, $E8
	.byte $F0, $0B, $01, $20
	.byte $00, $0B, $01, $20
W8D_CircSprs_Unaligned

	.byte $10, $0B, $01, $20
	.byte $E0, $87, $01, $F8
	.byte $E0, $87, $01, $10
	.byte $20, $87, $81, $F8
W8D_CircSprs_Aligned

PRG011_BB63:
	.byte $20, $87, $81

PRG011_BB66:
	.byte $10, $E0, $E8, $D8, $F0, $D0, $F8

FX_World_8_Darkness:
	LDY World_8_Dark	; Y = World_8_Dark
	BEQ PRG011_BB7A	 	; If not in the World 8 darkness, jump to PRG011_BB7A (RTS)
	LDX Player_Current	; X = Player_Current
	LDA Map_Player_SkidBack,X
	BEQ PRG011_BB7B	 	; If Player's Map_Player_SkidBack = 0, jump to PRG011_BB7B

PRG011_BB7A:
	RTS		 	; Otherwise, return...

PRG011_BB7B:
	CPY #$07	 
	BGE PRG011_BB9A	 	; If World_8_Dark >= 7 (effect complete), jump to PRG011_BB9A
	LDA <World_Map_X,X	; Player's X coordinate -> A
	ADD PRG011_BB66,Y	; Add an offset based on World_8_Dark

	LDY <World_Map_Y,X	; Y = Player's Y coordinate
	LDX #$01	 	; X = 1

	;JSR Map_W8DarknessUpdate	; Update darkness around Player

	INC World_8_Dark	; World_8_Dark++

	LDA World_8_Dark	 
	LSR A		 	
	BCC FX_World_8_Darkness	; Loops if carry not set by the "LSR A" (so only loops on 2, 4, 6)

PRG011_BB9A:
	LDX Player_Current	; X = Player_Current

	LDY #$00	 ; Y = 0

	LDA <World_Map_Move,X
	AND #$07	; Cap 0-7
	CMP #$06
	BEQ PRG011_BBAC	 ; On "6" of every "0-7" jump to PRG011_BBAC

	CMP #$02
	BNE PRG011_BBBB	 ; If not "2" of every "0-7" jump to PRG011_BBBB

	INY		 ; Otherwise, Y++

PRG011_BBAC:
	LDA <World_Map_X,X
	PHA		 ; Save Player's map X

	LDY <World_Map_Y,X	 ; Y = Player's map Y

	LDA <World_Map_Dir,X
	TAX		 ; X = Player's map direction of travel

	PLA		 ; A = Player's map X

	; Update darkness around Player
	;JSR Map_W8DarknessUpdate

PRG011_BBBB:
	LDY #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	LDX Player_Current	 ; X = Player_Current

	; Temp_Var1/2 = Player's Map Y/X
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDX #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	AND #$0f	 ; Get lower 4 bits of X
	BNE PRG011_BBD0	 ; If Player is not perfectly aligned in column, jump to PRG011_BBD0

	LDX #(W8D_CircSprs_Aligned - W8D_CircSprs)

PRG011_BBD0:

	; Set circle sprite Y
	LDA <Temp_Var1
	ADD W8D_CircSprs,X
	STA Sprite_RAM+$08,Y

	; Set circle sprite pattern
	LDA W8D_CircSprs+1,X
	STA Sprite_RAM+$09,Y

	; Set circle sprite attribute
	LDA W8D_CircSprs+2,X
	STA Sprite_RAM+$0A,Y

	; Set circle sprite X
	LDA <Temp_Var2
	ADD W8D_CircSprs+3,X
	STA Sprite_RAM+$0B,Y

	DEY
	DEY
	DEY
	DEY	; Y -= 4 (previous sprite)

	DEX
	DEX
	DEX
	DEX	; X -= 4 (previous circle sprite def)

	BMI PRG011_BC00	 ; If out of sprites, jump to PRG011_BC00

	CPX #(W8D_CircSprs_Unaligned - W8D_CircSprs)
	BNE PRG011_BBD0	 ; If not at end of aligned circle sprites, loop

	LDX #$3c
	BNE PRG011_BBD0	 ; If X <> $3C (?), loop

PRG011_BC00:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoAnimations
;
; This subroutine takes care of the simplistic animations
; that occur on the world maps.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Map_Y_Starts:
	; Map Y start positions, World 1-8 (X is always $20)
	.byte $40, $A0, $A0, $40, $80, $60, $30, $50

Map_AnimCHRROM:
	; This sets the CHRROM page in use per animation frame (common to all worlds)
	.byte $70, $72, $74, $76

Map_DoAnimations:	; $BC29
	LDA Save_Menu_Showing
	BNE Map_DoAnimationsRTS

	LDA <Counter_1
	AND #$60
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY
	LDA Map_AnimCHRROM,Y	; Get the correct CHRROM page
	STA PatTable_BankSel	  	; Put it to use

Map_DoAnimationsRTS:	
	RTS		  ; Return!


FindCompletedLevels:
	LDX #$00

FindCompletedLevels3:
	LDA MapPointers, X
	CMP #$FF
	BNE FindCompletedLevels0
	RTS

FindCompletedLevels0:
	STA LevelNumber
	JSR GetLevelBit
	AND Levels_Complete, Y
	BEQ FindCompletedLevels1

	LDA MapPointers + 1, X
	AND #$0F
	STA Block_ChangeXHi

	LDA MapPointers + 1, X
	AND #$F0
	STA Block_ChangeX

	LDA MapPointers + 2, X
	AND #$0F
	ASL A
	ASL A
	ASL A
	ASL A
	SUB #$10
	STA Block_ChangeY

	LDA #$01
	STA Block_ChangeYHi
	STX TempX

	JSR MarkCompletedLevels
	
	LDX TempX

FindCompletedLevels1:
	INX
	INX
	INX

	JMP FindCompletedLevels3

Completion_Tiles: 
	; .byte $A7, $0F, $31, $38
	; .byte $AD, $CD, $00, $7C
	; .byte $00, $8E, $00, $A7
	; .byte $00, $44, $00, $00

	.byte $A7, $0F, $31, $38
	.byte $AD, $CD, $38, $7C
	.byte $FF, $8E, $FF, $A7
	.byte $FF, $44, $FF, $FF	

MarkCompletedLevels:
	JSR GetMapTile
	TAY

	LDA TileProperties, Y
	CMP #MAP_PROP_BOUNDARY
	BEQ ReplaceMapTile

	CMP #MAP_PROP_COMPLETABLE
	BNE MarkCompletedLevelsRTS

ReplaceMapTile:
	TYA

	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A
	
	TAX

	LDY <Temp_Var5
	LDA Completion_Tiles, X
	STA [Map_Tile_AddrL],Y

MarkCompletedLevelsRTS:	
	RTS

GetMapTile:
	LDA Block_ChangeXHi
	ASL A
	TAX	

	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL

	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	LDA #$00
	STA <Temp_Var7

	LDA Block_ChangeYHi
	BEQ MarkCompletedLevels1	

	INC <Map_Tile_AddrH	

MarkCompletedLevels1:

	LDA Block_ChangeY
	AND #$f0
	STA <Temp_Var6

	LDA Block_ChangeX
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	LDA Block_ChangeYHi
	BNE MarkCompletedLevels2	

	LDA Block_ChangeY
	AND #$f0
	CMP #$f0
	BNE MarkCompletedLevels3	 

MarkCompletedLevels2:
	LDA Block_ChangeY
	ADD #$10
	STA <Temp_Var6

	LDA #$01
	STA <Temp_Var7

MarkCompletedLevels3:
	LDY <Temp_Var5

	LDA [Map_Tile_AddrL],Y

Map_SaveMenuSCRTS:
	RTS	

Map_SaveMenu:

	LDA Map_Pan_Count
	BNE Map_SaveMenuSCRTS

	JSR Save_Game

Map_NoAutoSave:	
	LDA Save_Menu_Showing
	BEQ Map_SaveMenuHidden

	JMP Map_SaveMenuShowing

Map_SaveMenuHidden:
	LDA <Pad_Input
	AND #PAD_START
	BEQ Map_SaveMenuHiddenRTS

	LDA #$01
	STA Save_Menu_Showing

	LDA #$5C
	STA PatTable_BankSel

	LDA <Horz_Scroll
	STA Options_Horz_Restore

	LDA #$00
	STA <Horz_Scroll
	STA Options_Line_Count

	LDA #PAUSE_STOPMUSIC
	STA Sound_QPause

	LDA #$0F
	STA <Vert_Scroll

	LDA #$0F
	STA Palette_Buffer + 2

Map_SaveMenuHiddenRTS:
	RTS

Map_DisplayOptions:
	RTS

Option_Lines:
	.word Option_Line1
	.word Option_Line2
	.word Option_Line3
	.word Option_Line4
	.word Option_Line5
	.word Option_Line6

STATUS_BAR_OPTION = 5

Option_Off:
	vaddr $2104
	.byte 04
	.db "OFF "
	.byte 00

Option_On:
	vaddr $2104
	.byte 04
	.db "ON  "
	.byte 00

Option_Line1:
	vaddr $2104
	.byte 22
	.db "OFF  STARS GATE BOSSES"
	.byte 00

Option_Line2:
	vaddr $2144
	.byte 20
	.db "OFF  INVULNERABILITY"
	.byte 00

Option_Line3:
	vaddr $2184
	.byte 17
	.db "OFF  OXYGEN METER"
	.byte 00

Option_Line4:
	vaddr $21C4
	.byte 20
	.db "OFF  HOLD A TO FLOAT"
	.byte 00

Option_Line5:
	vaddr $2204
	.byte 19
	.db "OFF  BLUE NIGHT SKY"
	.byte 00	

Option_Line6:
	vaddr $22C4
	.byte 21
	.db " 0   STATUS BAR COLOR"
	.byte 00	

Options_Draw:
	LDA Options_Line_Count
	CMP #STATUS_BAR_OPTION + 1
	BCS Options_DrawRTS

	LDA Graphics_BufCnt
	BNE Options_DrawRTS

	LDA Options_Line_Count
	ASL A
	TAY

	LDA Option_Lines, Y
	STA <Temp_Var1

	LDA Option_Lines + 1, Y
	STA <Temp_Var2

	LDY #$00

Option_Line:
	LDA [Temp_Var1], Y
	BEQ Option_NextLine

	STA Graphics_Buffer, Y
	INY
	JMP Option_Line

Option_NextLine:
	STA Graphics_Buffer, Y
	STY Graphics_BufCnt
	
	LDA Options_Line_Count
	CMP #STATUS_BAR_OPTION
	BEQ Options_SkipStatusBar

	TAX
	ASL A
	ASL A
	STA <Temp_Var3

	LDA Game_Options
	AND Option_Mask, X
	BEQ Option_UpdateToggle

	INC <Temp_Var3
	INC <Temp_Var3

Option_UpdateToggle:
	LDX <Temp_Var3

	LDA Option_ToggleDisplay, X
	STA <Temp_Var1

	LDA Option_ToggleDisplay + 1, X
	STA <Temp_Var2

	LDY #$04

Option_ReplaceOnOff:	
	LDA [Temp_Var1], Y
	STA Graphics_Buffer, Y
	INY
	CPY #$07
	BCC Option_ReplaceOnOff

	INC Options_Line_Count
	RTS

Options_SkipStatusBar:
	LDA Game_Options
	AND #$E0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	ADD #$30
	STA Graphics_Buffer + 4
	INC Options_Line_Count

Options_DrawRTS:
	RTS

Option_SelectionYOffset:
	.byte $30, $40, $50, $60, $70, $A0

OPTION_SPRAM_OFF = $C0

Option_ShowSelection:
	LDX Option_Selection

	LDY #OPTION_SPRAM_OFF
	
	LDA #$CB
	STA Sprite_RAMTile, Y

	LDA #$CD
	STA Sprite_RAMTile + 4, Y

	LDA Option_SelectionYOffset, X
	STA Sprite_RAMY, Y
	STA Sprite_RAMY + 4, Y

	LDA #$18
	STA Sprite_RAMX, Y

	LDA #$38
	STA Sprite_RAMX + 4, Y

	LDA #SPR_PAL1
	STA Sprite_RAMAttr, Y
	STA Sprite_RAMAttr + 4, Y
	RTS


Option_Mask:
	.byte %00000001
	.byte %00000010
	.byte %00000100
	.byte %00001000
	.byte %00010000

Option_StatusBarColors:

Option_ToggleDisplay:
	.word Option_On, Option_Off
	.word Option_Off, Option_On
	.word Option_On, Option_Off
	.word Option_Off, Option_On
	.word Option_Off, Option_On

Option_SetOptions:
	LDA <Pad_Input
	AND #(PAD_DOWN | PAD_UP)
	BEQ Option_ToggleLine

	AND #PAD_DOWN
	BNE Option_MoveDown

	LDA #SND_MAPPATHMOVE
	STA Sound_QMap

	DEC Option_Selection
	LDA Option_Selection
	BPL Option_SetOptionsRTS

	LDA #STATUS_BAR_OPTION
	STA Option_Selection
	BNE Option_SetOptionsRTS

Option_MoveDown:
	INC Option_Selection
	LDA Option_Selection
	CMP #STATUS_BAR_OPTION + 1
	BCC Option_SetOptionsRTS

	LDA #$00
	STA Option_Selection
	BEQ Option_SetOptionsRTS

Option_ToggleLine:
	LDA <Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT | PAD_A)
	BEQ Option_SetOptionsRTS

	LDA #SND_LEVELBLIP
	STA Sound_QLevel1
	
	LDX Option_Selection
	CPX #STATUS_BAR_OPTION
	BNE Option_ToggleFlag

	LDA <Pad_Input
	AND #(PAD_RIGHT | PAD_A)
	BEQ Option_DecStatusColor

	LDA Game_Options
	ADD #$20
	STA Game_Options
	INC Option_Needs_Update
	RTS

Option_DecStatusColor:
	LDA Game_Options
	SUB #$20
	STA Game_Options

	LDA #$01
	STA Option_Needs_Update
	RTS	

Option_ToggleFlag:
	LDA Game_Options
	EOR Option_Mask, X
	STA Game_Options

	INC Option_Needs_Update

Option_SetOptionsRTS:	
	RTS

Option_UpdateLineOffset:
	.byte $00, $40, $80, $C0, $00
	.byte $00, $00, $00, $00, $01

Option_StatusBarUpdate:
	.byte $30, $11, $27, $00
	.byte $30, $14, $27, $00
	.byte $30, $15, $27, $00
	.byte $30, $06, $27, $00
	.byte $30, $17, $27, $00
	.byte $30, $0A, $27, $00
	.byte $30, $0C, $27, $00
	.byte $30, $2D, $27, $00

Option_UpdateRts:
	RTS

Option_UpdateDisplay:
	LDA Option_Needs_Update
	BEQ Option_UpdateRts

	LDA Graphics_BufCnt
	BNE Option_UpdateRts

	LDA Option_Selection
	CMP #STATUS_BAR_OPTION
	BNE Option_OnOffUpdate

	LDA #$22
	STA Graphics_Buffer

	LDA #$C5
	STA Graphics_Buffer + 1

	LDA #$01
	STA Graphics_Buffer + 2

	LDA Game_Options
	AND #$E0
	LSR A
	LSR A
	LSR A
	TAX
	LSR A
	LSR A
	ADD #$30
	STA Graphics_Buffer + 3

	LDA #$00
	STA Graphics_Buffer + 4

	LDA #$04
	STA Graphics_BufCnt

	LDA #$00
	STA Option_Needs_Update

	LDA Option_StatusBarUpdate, X
	STA StatusBar_Palette
	
	LDA Option_StatusBarUpdate + 1, X
	STA StatusBar_Palette + 1
	
	LDA Option_StatusBarUpdate + 2, X
	STA StatusBar_Palette + 2
	RTS

Option_OnOffUpdate:
	TAX
	ASL A
	ASL A
	STA <Temp_Var3

	LDA Game_Options
	AND Option_Mask, X
	BEQ Option_UpdateSelection

	INC <Temp_Var3
	INC <Temp_Var3

Option_UpdateSelection:
	LDX <Temp_Var3

	LDA Option_ToggleDisplay, X
	STA <Temp_Var1

	LDA Option_ToggleDisplay + 1, X
	STA <Temp_Var2

	LDY #$00

Option_UpdateOnOffFlag:
	LDA [Temp_Var1], Y
	BEQ Option_UpdateDone

	STA Graphics_Buffer, Y
	INY
	BCC Option_UpdateOnOffFlag

Option_UpdateDone:
	STA Graphics_Buffer, Y
	STY Graphics_BufCnt

	LDX Option_Selection
	
	LDA Graphics_Buffer + 1
	ADD Option_UpdateLineOffset, X
	STA Graphics_Buffer + 1

	LDA Graphics_Buffer
	ADC Option_UpdateLineOffset + 5, X
	STA Graphics_Buffer

	LDA #$00
	STA Option_Needs_Update

Option_UpdateDisplayRTS:
	RTS


Option_UpdateCurrentSelection:

Map_SaveMenuShowing:
	JSR Options_Draw
	JSR Cheat_Code
	JSR Option_ShowSelection
	JSR Option_SetOptions
	JSR Option_UpdateDisplay

	LDA Save_Menu_Showing
	BEQ Exit_Options_Menu

	LDA <Pad_Input
	AND #PAD_START
	BEQ Map_SaveMenuShowingRTS

Exit_Options_Menu:
	LDA #PAUSE_RESUMEMUSIC
	STA Sound_QPause

	LDA #$00
	STA Save_Menu_Showing

	LDA Map_Prev_XOff

	LDA #$EF
	STA <Vert_Scroll

	LDA Options_Horz_Restore
	STA <Horz_Scroll

	LDA MasterPal_Data + 2
	STA Palette_Buffer + 2

	JMP Map_DoAnimations

Map_SaveMenuShowingRTS:
	RTS	

U_ = PAD_UP
D_ = PAD_DOWN
L_ = PAD_LEFT
R_ = PAD_RIGHT
S_ = PAD_SELECT
B_ = PAD_B
A_ = PAD_A
__ = 00
X_ = $FF

Cheat_Codes:	
	.byte B_, B_, A_, A_, U_, U_, U_, U_, U_ ; Cheat_AbilityUp
	.byte U_, R_, D_, L_, U_, R_, D_, L_, __ ; Cheat_250Coins
	.byte L_, D_, R_, D_, L_, D_, R_, D_, L_ ; Cheat_25Cherries
	.byte L_, R_, S_, B_, A_, B_, S_, R_, L_ ; Cheat_1000Exp
	.byte B_, A_, B_, A_, B_, A_, B_, A_, U_ ; Cheat_Badge1
	.byte B_, A_, B_, A_, B_, A_, B_, A_, D_ ; Cheat_Badge2
	.byte B_, A_, B_, A_, B_, A_, B_, A_, L_ ; Cheat_Badge3
	.byte B_, A_, B_, A_, B_, A_, B_, A_, R_ ; Cheat_Badge4
	.byte B_, A_, B_, A_, B_, A_, B_, A_, S_ ; Cheat_Badge5
	.byte B_, A_, B_, A_, B_, A_, B_, A_, B_ ; Cheat_Badge6
	.byte U_, D_, U_, D_, B_, B_, A_, A_, S_ ; Cheat_DebugMode
	.byte U_, R_, S_, U_, L_, A_, S_, U_, B_ ; Cheat_Sub
	.byte B_, U_, L_, B_, A_, S_, A_, U_, R_ ; Cheat_SecondQuest
	.byte B_, R_, A_, B_, B_, U_, L_, S_, __ ; Cheat_ToggleMoonGravity
	.byte U_, D_, L_, R_, U_, D_, L_, R_, A_ ; Cheat_IncreaseStars1
	.byte U_, D_, L_, R_, U_, D_, L_, R_, B_ ; Cheat_IncreaseStars10
	.byte A_, A_, A_, L_, L_, L_, L_, L_, L_ ; Cheat_SkipMapLeft
	.byte A_, A_, A_, R_, R_, R_, R_, R_, R_ ; Cheat_SkipMapRight
	.byte A_, A_, A_, U_, U_, U_, U_, U_, U_ ; Cheat_SkipMapUp
	.byte A_, A_, A_, D_, D_, D_, D_, D_, D_ ; Cheat_SkipMapDown
	.byte B_, R_, R_, R_, R_, R_, A_, A_, A_ ; Cheat Plane

Cheat_Index = Temp_Var1
Cheat_Offset = Temp_Var2
Cheat_Number = Temp_Var3
Cheat_Length = 9
Cheat_Count = 21

Cheat_Code:
	LDA <Pad_Input
	BNE Cheat_CodeInput

	RTS

Cheat_CodeInput:
	LDX #$0F

Cheat_InputLoop:
	LDA Cheat_Input - 1, X
	STA Cheat_Input, X

	DEX
	BNE Cheat_InputLoop

	LDA <Pad_Input
	STA Cheat_Input

	LDA #$00
	STA <Cheat_Index
	STA <Cheat_Number

Cheat_BeginSearch:
	LDA #(Cheat_Length)
	STA <Cheat_Offset

	LDX #$00
	
	LDA <Cheat_Index
	ADD #(Cheat_Length - 1)
	TAY

Cheat_CodeSearch:
	LDA Cheat_Codes, Y
	BEQ Cheat_CodeSkip

	CMP Cheat_Input, X
	BNE Cheat_CodeBad

	INX

Cheat_CodeSkip:
	DEY
	DEC <Cheat_Offset
	
	LDA <Cheat_Offset
	BNE Cheat_CodeSearch
	BEQ Cheat_CodeSuccess

Cheat_CodeBad:
	INC <Cheat_Number

	LDA <Cheat_Index
	ADD #(Cheat_Length)
	STA <Cheat_Index

	CMP #(Cheat_Count * Cheat_Length)
	BNE Cheat_BeginSearch
	RTS

Cheat_CodeSuccess:
	LDA Sound_QLevel1
	ORA #SND_LEVEL1UP
	STA Sound_QLevel1

	LDA #$00
	STA Save_Menu_Showing

	LDA #PAUSE_RESUMEMUSIC
	STA Sound_QPause

	LDA #$00
	LDX #(Cheat_Count)

Cheat_Clear:
	STA Cheat_Input, X
	DEX
	BPL Cheat_Clear
	
	LDA <Cheat_Number
	
	JSR DynJump

	.word Cheat_AbilityUp
	.word Cheat_250Coins
	.word Cheat_25Cherries
	.word Cheat_1000Exp
	.word Cheat_Badge1
	.word Cheat_Badge2
	.word Cheat_Badge3
	.word Cheat_Badge4
	.word Cheat_Badge5
	.word Cheat_Badge6
	.word Cheat_DebugMode
	.word Cheat_Sub
	.word Cheat_SecondQuest
	.word Cheat_ToggleMoonGravity
	.word Cheat_IncreaseStars1
	.word Cheat_IncreaseStars10
	.word Cheat_SkipMapLeft
	.word Cheat_SkipMapRight
	.word Cheat_SkipMapUp
	.word Cheat_SkipMapDown
	.word Cheat_Plane

Cheat_DoNothing:
	RTS

Cheat_AbilityUp:
	LDA Player_Level
	CMP #ABILITY_MAX
	BCS Cheat_AbilityUpRTS

	INC Player_Level

Cheat_AbilityUpRTS:
	RTS

Cheat_250Coins:
	LDA #250
	STA Coins_Earned
	RTS

Cheat_25Cherries:
	LDA Player_Cherries
	ADD #25
	CMP #99
	BCC Cheat_25CherriesRTS

	LDA #99

Cheat_25CherriesRTS:
	STA Player_Cherries
	RTS

Cheat_1000Exp:
	LDA Player_Experience
	STA <CalcParam1

	LDA Player_Experience + 1
	STA <CalcParam1 + 1

	LDA Player_Experience + 2
	STA <CalcParam1 + 2

	LDA #$E7
	STA <CalcParam2

	LDA #$03
	STA <CalcParam2 + 1

	LDA #$00
	STA <CalcParam2 + 2

	JSR Add3ByteValue

	LDA <CalcResult
	STA Player_Experience

	LDA <CalcResult + 1
	STA Player_Experience + 1

	LDA <CalcResult + 2
	STA Player_Experience + 2

	INC Exp_Earned
	RTS

Cheat_Badge1:
	LDA #BADGE_ITEMRESERVE
	BNE Cheat_BadgeApply

Cheat_Badge2:
	LDA #BADGE_XP
	BNE Cheat_BadgeApply

Cheat_Badge3:
	LDA #BADGE_RADAR
	BNE Cheat_BadgeApply

Cheat_Badge4:
	LDA #BADGE_PMETER
	BNE Cheat_BadgeApply

Cheat_Badge5:
	LDA #BADGE_COIN
	BNE Cheat_BadgeApply

Cheat_Badge6:
	LDA #BADGE_AIR
	BNE Cheat_BadgeApply

Cheat_BadgeApply:
	STA Player_Badge
	RTS

Cheat_DebugMode:
	LDA Player_Debug
	EOR #$01
	STA Player_Debug
	RTS

Cheat_Plane:
	LDA #$01
	STA Player_CheatSub
	RTS

Cheat_Sub:
	LDA #$02
	STA Player_CheatSub
	RTS
	
Cheat_SecondQuest:
	LDA SecondQuest
	EOR #$01
	STA SecondQuest
	RTS

Cheat_ToggleMoonGravity:
	LDA Moon_Gravity
	EOR #$01
	STA Moon_Gravity
	RTS

Cheat_IncreaseStars1:
	INC Paper_Stars
	RTS

Cheat_IncreaseStars10:
	LDA Paper_Stars
	ADD #10
	STA Paper_Stars
	RTS

Cheat_SkipMapLeft:
	LDA #$01
	STA Map_PrevMoveDir
	RTS

Cheat_SkipMapRight:	
	LDA #$02
	STA Map_PrevMoveDir
	RTS

Cheat_SkipMapUp:
	LDA #$04
	STA Map_PrevMoveDir
	RTS

Cheat_SkipMapDown:
	LDA #$08
	STA Map_PrevMoveDir
	RTS

	.org $D000

	.byte $BB,$BB,$BB,$BB,$BB,$BB,$BB,$BB,$BB,$BB,$BB,$BB
; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-06 18:57:13.927921102 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

	; Nintendo did a minor trick here to keep the offset down to one byte...
	; - They have 81 frames total, with 6 patterns each
	; - Dividing by 2 (to be fixed later) means the offset into the pattern lookup table is reduced to 3
	; - 3 * 81 = 243, which fits the 1 byte offset
	; But, for some reason, everything is off by 4?  The SPPF function below compensates for this, and 
	; PRG029_CF1E loads from 4 bytes shy of the proper address.  Maybe this was a mistake?  
SPPF .func ((\1 - SPPF_Table + 4) / 2)	; The offsets 
SPPF_Offsets:
	.byte SPPF(PF00), SPPF(PF01), SPPF(PF02), SPPF(PF03), SPPF(PF04), SPPF(PF05), SPPF(PF06), SPPF(PF07)
	.byte SPPF(PF08), SPPF(PF09), SPPF(PF0A), SPPF(PF0B), SPPF(PF0C), SPPF(PF0D), SPPF(PF0E), SPPF(PF0F)
	.byte SPPF(PF10), SPPF(PF11), SPPF(PF12), SPPF(PF13), SPPF(PF14), SPPF(PF15), SPPF(PF16), SPPF(PF17)
	.byte SPPF(PF18), SPPF(PF19), SPPF(PF1A), SPPF(PF1B), SPPF(PF1C), SPPF(PF1D), SPPF(PF1E), SPPF(PF1F)
	.byte SPPF(PF20), SPPF(PF21), SPPF(PF22), SPPF(PF23), SPPF(PF24), SPPF(PF25), SPPF(PF26), SPPF(PF27)
	.byte SPPF(PF28), SPPF(PF29), SPPF(PF2A), SPPF(PF2B), SPPF(PF2C), SPPF(PF2D), SPPF(PF2E), SPPF(PF2F)
	.byte SPPF(PF30), SPPF(PF31), SPPF(PF32), SPPF(PF33), SPPF(PF34), SPPF(PF35), SPPF(PF36), SPPF(PF37)
	.byte SPPF(PF38), SPPF(PF39), SPPF(PF3A), SPPF(PF3B), SPPF(PF3C), SPPF(PF3D), SPPF(PF3E), SPPF(PF3F)
	.byte SPPF(PF40), SPPF(PF41), SPPF(PF42), SPPF(PF43), SPPF(PF44), SPPF(PF45), SPPF(PF46), SPPF(PF47)
	.byte SPPF(PF48), SPPF(PF49), SPPF(PF4A), SPPF(PF4B), SPPF(PF4C), SPPF(PF4D), SPPF(PF4E), SPPF(PF4F)
	.byte SPPF(PF50), SPPF(PF00), SPPF(PF01), SPPF(PF02), SPPF(PF03), SPPF(PF04), SPPF(PF05), SPPF(PF06)
	.byte SPPF(PF07)
	
	

	; The six Patterns per Player_Frame to start each of the six Player sprites with!
	; Note the order is the three patterns for the three sprites that make the upper 
	; half followed by the next three for the lower half.
	; $F1 is a magic value reserved as a "don't display this sprite" flag

SPPF_Table:
PF00:	.byte $01, $03, $F1, $05, $07, $09
PF01:	.byte $0B, $0D, $F1, $0F, $29, $2B
PF02:	.byte $2D, $2F, $F1, $19, $1B, $1D
PF03:	.byte $2D, $2F, $F1, $19, $1B, $09
PF04:	.byte $21, $21, $F1, $23, $23, $F1
PF05:	.byte $25, $25, $F1, $27, $27, $F1
PF06:	.byte $01, $03, $F1, $05, $07, $F1
PF07:	.byte $31, $33, $F1, $35, $37, $39
PF08:	.byte $01, $03, $F1, $05, $07, $39
PF09:	.byte $01, $03, $F1, $05, $07, $09
PF0A:	.byte $01, $03, $F1, $05, $07, $3B
PF0B:	.byte $F1, $F1, $F1, $3D, $3F, $F1
PF0C:	.byte $01, $03, $F1, $05, $07, $F1
PF0D:	.byte $0B, $0D, $F1, $0F, $29, $F1
PF0E:	.byte $2D, $2F, $F1, $19, $1B, $F1
PF0F:	.byte $31, $33, $F1, $35, $37, $F1
PF10:	.byte $09, $2F, $F1, $1D, $1F, $F1
PF11:	.byte $2D, $2F, $F1, $39, $3B, $F1
PF12:	.byte $31, $31, $F1, $33, $33, $F1
PF13:	.byte $35, $35, $F1, $37, $37, $F1
PF14:	.byte $39, $39, $F1, $3B, $3B, $F1
PF15:	.byte $01, $03, $F1, $05, $07, $09
PF16:	.byte $0B, $0D, $F1, $0F, $29, $2B
PF17:	.byte $2D, $2F, $F1, $19, $1B, $1D
PF18:	.byte $2D, $2F, $F1, $A9, $AB, $F1
PF19:	.byte $2D, $2F, $F1, $A9, $AD, $F1
PF1A	.byte $01, $03, $05, $07, $09, $0B
PF1B:	.byte $0D, $0F, $39, $3B, $3D, $3F
PF1C:	.byte $19, $1B, $1D, $1F, $21, $23
PF1D:	.byte $25, $27, $29, $2B, $2D, $2F
PF1E:	.byte $31, $33, $F1, $35, $37, $F1
PF1F:	.byte $25, $29, $2D, $33, $37, $0D
PF20:	.byte $25, $29, $2D, $33, $37, $0F
PF21:	.byte $19, $1D, $21, $1B, $1F, $23
PF22:	.byte $25, $29, $2D, $27, $2B, $2F
PF23:	.byte $25, $29, $2D, $33, $37, $3B
PF24:	.byte $01, $01, $F1, $03, $03, $F1
PF25:	.byte $05, $05, $F1, $07, $07, $F1
PF26:	.byte $09, $09, $F1, $0B, $0B, $F1
PF27:	.byte $31, $33, $F1, $35, $37, $F1
PF28:	.byte $31, $35, $F1, $39, $3D, $F1
PF29:	.byte $01, $03, $F1, $05, $07, $09

	; Second page begins here
PF2A:	.byte $01, $03, $F1, $0B, $0D, $0F
PF2B:	.byte $01, $03, $F1, $21, $23, $25
PF2C:	.byte $31, $33, $F1, $35, $37, $F1
PF2D:	.byte $27, $19, $F1, $1D, $1F, $F1
PF2E:	.byte $F1, $F1, $F1, $35, $37, $F1
PF2F:	.byte $F1, $F1, $F1, $31, $33, $F1
PF30:	.byte $29, $2B, $F1, $2D, $2F, $F1
PF31:	.byte $39, $3B, $F1, $3D, $3F, $F1
PF32:	.byte $F1, $F1, $F1, $2F, $2F, $F1
PF33:	.byte $F1, $F1, $F1, $2B, $2D, $F1
PF34:	.byte $29, $2B, $F1, $0D, $0F, $27
PF35:	.byte $29, $2B, $F1, $09, $0B, $25
PF36:	.byte $29, $2B, $F1, $01, $03, $3F
PF37:	.byte $29, $2B, $F1, $01, $03, $05
PF38:	.byte $29, $2B, $F1, $01, $03, $07
PF39:	.byte $29, $2B, $F1, $31, $33, $3D
PF3A:	.byte $29, $2B, $F1, $35, $37, $3D
PF3B:	.byte $29, $2B, $F1, $39, $3B, $3D
PF3C:	.byte $29, $2B, $F1, $0D, $1F, $25
PF3D:	.byte $29, $2B, $F1, $0D, $2D, $2F
PF3E:	.byte $F1, $F1, $F1, $05, $07, $F1
PF3F:	.byte $F1, $F1, $F1, $01, $03, $F1
PF40:	.byte $F1, $F1, $F1, $19, $1B, $F1
PF41:	.byte $F1, $F1, $F1, $21, $23, $F1
PF42:	.byte $F1, $F1, $F1, $1D, $1F, $F1
PF43:	.byte $05, $07, $F1, $A9, $AB, $F1
PF44:	.byte $05, $07, $F1, $A9, $AD, $F1
PF45:	.byte $29, $2B, $F1, $01, $03, $05
PF46:	.byte $F1, $F1, $F1, $25, $27, $F1
PF47:	.byte $F1, $F1, $F1, $29, $2B, $F1
PF48:	.byte $F1, $F1, $F1, $29, $2F, $F1
PF49:	.byte $F1, $F1, $F1, $25, $2D, $F1
PF4A:	.byte $F1, $F1, $F1, $09, $0B, $F1
PF4B:	.byte $F1, $F1, $F1, $0D, $0D, $F1
PF4C:	.byte $F1, $F1, $F1, $31, $33, $F1
PF4D:	.byte $F1, $F1, $F1, $35, $37, $F1
PF4E:	.byte $F1, $F1, $F1, $0F, $3F, $F1
PF4F:	.byte $19, $1B, $F1, $1D, $21, $F1
PF50:	.byte $19, $1B, $F1, $1D, $21, $23

SPPF_Table2:
PF51:	.byte $F1, $F1, $F1, $35, $37, $F1 ; ShellAnim1
PF52:	.byte $F1, $F1, $F1, $1D, $1F, $F1 ; ShellAnim2		
PF53:	.byte $F1, $F1, $F1, $39, $3B, $F1 ; ShellAnim3		
PF54:	.byte $F1, $F1, $F1, $3D, $3F, $F1 ; ShellAnim4		
PF55:	.byte $01, $03, $05, $21, $23, $25 ; FireballAnim1
PF56:	.byte $07, $09, $0B, $27, $29, $2B ; FireballAnim2	
PF57:	.byte $0D, $0F, $19, $2D, $2F, $39 ; FireballAnim3	
PF58:	.byte $1B, $1D, $1F, $3B, $3D, $3F ; FireballAnim4	

	; Selects a VROM page offset per Player_Frame
Player_FramePageOff:
	.byte 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 00 - 0F
	.byte 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1	; 10 - 1F
	.byte 1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2	; 20 - 2F
	.byte 2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3	; 30 - 3F
	.byte 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3	; 40 - 4F
	.byte 3,  0,  0,  0,  0,  1,  1,  1,  1

PRG029_CE88:
	.byte -8, 10, -8, 18,  8, 10,  8, 18,  1,  9,  0,  8,  2, 10, -2, 6

	; Specified root VROM page for a given power up
Player_PUpRootPage:
	;     Small, Big, Fire, Leaf, Frog, Koopa,   Hammer
	.byte $50,   $54, $54,  $00,  $50,  $40,     $44
	;     xxxxxxxxxx  Ice   xxx    xxx   xxx   Ninja
	.byte			  $54,  $2C,   $00 , $24 ,  $28				

RAINBOW_PAL_CYCLE:
	.byte $01, $03, $05, $06, $07, $09, $0A, $0C ; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Draw
;
; Not literally "draw", but configure the sprites for the Player
; to be drawn!  With the given data set of where the screen is
; scrolled, the Player's animation frame, invincibility status,
; etc. all handled by this major subroutine...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Draw:
	LDA Player_Vehicle
	BEQ Player_DrawNorm

	JMP Player_DrawVehicle

Player_DrawNorm:	
	JSR Player_RainbowCycle

	LDX Frozen_Frame
	BNE Player_Draw1

	JSR Player_FrameOverride
	
	LDX <Player_Frame

Player_Draw1:
	LDA Player_FramePageOff,X
	STA <Temp_Var1		 ; Get VROM page offset for this animation frame -> Temp_Var1

	LDY Player_EffectiveSuit
	
	LDA Player_PUpRootPage,Y ; Get VROM root page for this power up
	ADD <Temp_Var1		 ; Add appropriate offset to the VROM base for the animation frame

	STA PatTable_BankSel+2	 ; Set VROM bank switch for sprites 1/4

	LDA <Player_X
	SUB <Horz_Scroll
	STA <Player_SpriteX	 ; Player_SpriteX = Player_X - Horz_Scroll

	LDA <Player_YZ
	SUB Level_VertScroll
	STA <Player_SpriteY	; Player_SpriteY = Player_Y - Level_VertScroll

	LDA <Player_YHiZ	
	SBC Level_VertScrollH
	STA Player_AboveTop	 ; Player_Above top calculated if Player is off top of screen

	LDA Player_Invulnerable
	BEQ PRG029_CED7	 	; If Player_Invulnerable = 0, jump to PRG029_CED7

	DEC Player_Invulnerable	; Player_Invulnerable--
	AND #$02	 
	BEQ PRG029_CED7	 	; Every 2 ticks, draw Player
	JMP PRG029_D094	 	; Every other 2 ticks, don't!

PRG029_CED7:
	LDA #$00
	STA <Temp_Var1	 ; Store cycle tick into Temp_Var1 (0 if not invincible, sprite palette 0)

	LDA Player_Behind
	ORA Player_SandSink
	BEQ PRG029_CF1E	 ; If Player is behind the scenes, jump to PRG029_CF1E

	; Set priority over background (normal most game sprite behavior)
	LDA #$20
	ORA <Temp_Var1
	STA <Temp_Var1

PRG029_CF1E:
	CPX #$51
	BCC PRG029_CF1F
	
	LDA #LOW(SPPF_Table2-4)
	STA <Player_SprWorkL

	LDA #HIGH(SPPF_Table2-4)
	STA <Player_SprWorkH

	JMP PRG029_CF20

PRG029_CF1F:
	LDA #LOW(SPPF_Table-4)
	STA <Player_SprWorkL

	LDA #HIGH(SPPF_Table-4)
	STA <Player_SprWorkH

PRG029_CF20:
	; X = Player_Frame
	LDA SPPF_Offsets,X	; Get offset value to sprite's pattern set
	ASL A
	TAY			; Needs to be shifted up to be correct (stored shifted right 1)
	BCC PRG029_CF2F		; If carry is NOT set (a >= $80 value indicate "second page"), jump to PRG029_CF2F

	INC <Player_SprWorkH	 ; Go to second page

PRG029_CF2F:
	LDX Player_SprOff	 ; X = Root offset where Player sprite should begin

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$0D,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$11,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$15,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$01,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$05,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$09,X	 

	LDA <Player_FlipBits
	AND #$c0
	ORA <Temp_Var1		 ; Merge with possible other attributes (the star invincibility palette cycle)

	; Store attributes to all Player sprites
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$06,X
	STA Sprite_RAM+$0A,X
	STA Sprite_RAM+$0E,X
	STA Sprite_RAM+$12,X
	STA Sprite_RAM+$16,X

	LDA Sprite_RAM+$01,X
	CMP Sprite_RAM+$05,X
	BNE PRG029_CF88		; If the patterns to the first two sprites are not the same, jump to PRG029_CF88

	; If they ARE the same, this is a mirrored sprite (like Mario "looking towards screen" etc.)
	; So the "right half" sprites must mirror the "left half"

	LDA Sprite_RAM+$0E,X
	AND #~SPR_HFLIP	 	; Keep all attributes EXCEPT horizontal flip
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$0E,X
	ORA #SPR_HFLIP	 	; Force horizontal flip
	STA Sprite_RAM+$06,X
	STA Sprite_RAM+$12,X

PRG029_CF88:

	; First row sprites
	LDA <Player_SpriteY
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	; Second row sprites
	ADD #16
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

	; Left column
	LDA <Player_SpriteX
	STA Sprite_RAM+$03,X
	STA Sprite_RAM+$0F,X

	; Middle column
	ADD #8
	STA Sprite_RAM+$07,X
	STA Sprite_RAM+$13,X

	; Right column
	ADD #8
	STA Sprite_RAM+$0B,X
	STA Sprite_RAM+$17,X

	LDA <Player_FlipBits
	AND #SPR_HFLIP
	BEQ PRG029_D010	 ; If Player sprite is NOT horizontally flipped, jump to PRG029_D010

	; Reverse these patterns
	LDA Sprite_RAM+$01,X	 
	PHA		 
	LDA Sprite_RAM+$05,X	 
	STA Sprite_RAM+$01,X	 
	PLA		 
	STA Sprite_RAM+$05,X	 

	; Reverse these X values
	LDA Sprite_RAM+$0B,X	 
	ADD #-24
	STA Sprite_RAM+$0B,X	 
	STA Sprite_RAM+$17,X	

	; Reverse these patterns 
	LDA Sprite_RAM+$0D,X	 
	PHA		 
	LDA Sprite_RAM+$11,X	 
	STA Sprite_RAM+$0D,X	 
	PLA		 
	STA Sprite_RAM+$11,X	 


	LDA Player_Flip
	BEQ PRG029_D010	; If Player is not somersaulting, jump to PRG029_D010

	; Otherwise all of the sprites are pushed to the right by 8

	LDA Sprite_RAM+$03,X	 
	ADD #8
	STA Sprite_RAM+$03,X
	STA Sprite_RAM+$0F,X

	LDA Sprite_RAM+$07,X	 
	ADD #8
	STA Sprite_RAM+$07,X
	STA Sprite_RAM+$13,X
	 
	LDA Sprite_RAM+$0B,X	 
	ADD #8
	STA Sprite_RAM+$0B,X	 
	STA Sprite_RAM+$17,X	 


PRG029_D010:
PRG029_D050:
	LDA <Player_Frame
	CMP #PF_KICK_BIG 
	BNE PRG029_D076	 ; If Player_Frame <> PF_KICK_BIG (kicking shell, etc. when not small), jump to PRG029_D076

	; Otherwise the third "first row" sprite is pulled down to "second row"
	; This becomes the foot involved in the kick!
	LDA Sprite_RAM+$00,X
	STA Sprite_RAM+$14,X

	; If Player is not horizontally flipped, A = -8, otherwise A = 16
	LDA #-8
	LDY <Player_FlipBits
	BEQ PRG029_D064
	LDA #16
PRG029_D064:

	; The aforementioned foot sprite is offset into proper X position
	ADD Sprite_RAM+$0F,X
	STA Sprite_RAM+$17,X

	LDA #$1b
	STA Sprite_RAM+$15,X	; The foot sprite is forced to pattern $1B

	LDA Sprite_RAM+$0E,X
	STA Sprite_RAM+$16,X	; Attributes are copied (is this necessary?)

PRG029_D076:
	LDA <Player_FlipBits
	AND #$80	 
	BEQ PRG029_D094	 

	; If Player is vertically flipped, all sprite Y values must be reversed too!

	LDA Sprite_RAM+$00,X
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	ADD #-16
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

PRG029_D094:
	LDA #$00
	STA Player_OffScreen	 ; Player_OffScreen = 0 (not off screen until we decide so!)

	LDY #$ff

	LDA Player_AboveTop
	BPL PRG029_D0AE	 	; If Player is not above top of screen, jump to PRG029_D0AE

	LDA <Player_SpriteY
	ADD #16
	LDA #$00
	ADC Player_AboveTop

	BNE PRG029_D0BC	 ; If Player is completely off the top of screen, jump to PRG029_D0BC
	BEQ PRG029_D0D3	 ; If Player is not at all off the top of screen, jump to PRG029_D0D3

PRG029_D0AE:
	BNE PRG029_D0BC	 ; Jump reserved for when Player is already known as off screen, so jump (technically always) to PRG029_D0BC

	LDA <Player_SpriteY
	CMP #$c0	 
	BGE PRG029_D0BC	 ; If Player_SpriteY >= $C0, he's below the status bar, so jump to PRG029_D0BC

	CMP #$b0
	BGE PRG029_D0C9	 ; If Player_SpriteY >= $B0, he's halway below the status bar, so jump to PRG029_D0C9
	BLT PRG029_D0D3	 ; Otherwise, Player is totally visible, jump to PRG029_D0D3

PRG029_D0BC:
	INC Player_OffScreen	; Player is off screen

	; Prevent "second row" sprites from being displayed
	TYA		 	; A = $FF
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

PRG029_D0C9:

	; Prevent "first row" sprites from being displayed
	TYA		 	; A = $FF
	STA Sprite_RAM+$00,X	
	STA Sprite_RAM+$04,X	
	STA Sprite_RAM+$08,X	

PRG029_D0D3:


	; $F1 is a magic value reserved as a "don't display this sprite" flag
	; So let's check if any sprite is using that value right now...
	LDY #$05	 ; Y = 5 (looping through all six Player sprites)

PRG029_D0D5:
	LDA Sprite_RAM+$01,X
	CMP #$f1	 
	BNE PRG029_D0E1	 ; If this sprite is NOT using pattern $F1, PRG029_D0E1

	; Pattern $F1 is the "don't use" pattern, so set this sprite's Y to $F8 (make invisible)
	LDA #$f8	 
	STA Sprite_RAM+$00,X

PRG029_D0E1:
	INX
	INX
	INX
	INX		 ; X -= 4 (previous sprite)
	DEY		 ; Y--
	BPL PRG029_D0D5	 ; While Y >= 0, loop!

	LDA Level_PipeMove
	BEQ PRG029_D13A	 ; If Level_PipeMove = 0, jump to PRG029_D13A (RTS)

	; When Player is going through pipe, a special "cover sprite" is used
	; at the pipe entrance which masks the Player...

	; Mask sprite X
	LDA <Pipe_PlayerX
	SUB <Horz_Scroll
	STA Sprite_RAMX
	STA Sprite_RAMX + 8

	ADD #$08
	STA Sprite_RAMX + 4
	STA Sprite_RAMX + 12

	; Mask sprite Y
	LDA <Pipe_PlayerY
	SUB Level_VertScroll
	PHA
	CMP #$f0
	BLT PRG029_D10E

	LDA #$00	

PRG029_D10E:
	STA Sprite_RAMY
	STA Sprite_RAMY + 4
	PLA
	ADD #$10
	STA Sprite_RAMY + 8
	STA Sprite_RAMY + 12

	; Uses pattern $77 ("metal block" from used up [?], should be completely opaque)
	LDA #$6B
	STA Sprite_RAMTile 
	STA Sprite_RAMTile + 4
	STA Sprite_RAMTile + 8
	STA Sprite_RAMTile + 12

	; Must appear behind tiles
	LDA #SPR_BEHINDBG
	STA Sprite_RAMAttr
	STA Sprite_RAMAttr + 4
	STA Sprite_RAMAttr + 8
	STA Sprite_RAMAttr + 12


PRG029_D13A:
	JSR Player_RecoverOverrides
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DrawAndDoActions
;
; Have to give this one its props; this function does an entire
; mess of routines, from adjusting the Player during autoscroll,
; going to coin heaven, the airship intro, going through pipes,
; changing power ups... all the things that happen to the Player
; object, though none of the instigation code is here!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DrawAndDoActions:
	LDA Player_HaltTick
	BEQ PRG029_D1CE	 	; If Player_HaltTick = 0 (not halted), jump to PRG029_D1CE

	DEC Player_HaltTick	; Player_HaltTick--

	JSR Player_Draw	 	; Draw Player's sprite!

	LDA Level_AScrlConfig
	BEQ PRG029_D1CD	 		; If Level_AScrlConfig = 0 (no auto scroll going on), jump to PRG029_D1CD

	JSR AutoScroll_CalcPlayerY	; Adjust Player_Y and Player_YHiZ for auto scroll

PRG029_D1CD:
	RTS		 ; Return


PRG029_D1CE:
	LDA <Player_IsDying
	BEQ PRG029_D1D5	 ; If Player is not dying, jump to PRG029_D1D5

	JMP PRG029_D6BC	 ; Jump to PRG029_D6BC (the Player's death routine)

PRG029_D1D5:
	LDA Player_SuitLost
	BEQ PRG029_D20E	 ; If Player_SuitLost = 0, jump to PRG029_D20E

	JSR Player_SuitLost_DoPoof	; Do the suit lost poof

	RTS		 ; Return


PRG029_D20E:
	LDA Player_StarOff
	BEQ PRG029_D224	 ; If Player_StarOff = 0 (invincibility is not wearing off), jump to PRG029_D224

	CMP #31
	BNE PRG029_D21D	 ; If Player_StarOff <> 31, jump to PRG029_D21D

	DEC Player_StarOff ; Player_StarOff--
	JMP PRG029_D224	   ; Jump to PRG029_D224

PRG029_D21D:
	JSR Player_Draw	   ; Draw Player
	DEC Player_StarOff ; Player_StarOff--

	RTS		 ; Return

PRG029_D224:
	LDA Player_Grow
	BEQ PRG029_D257	 ; If Player is not transforming into "Super", jump to PRG029_D257

	LSR A
	LSR A
	TAX		 ; X = Player_Grow >> 2

	LDY <Player_Suit ; Y = Player_Suit
	BNE PRG029_D238	 ; If Y <> 0 (small), jump to PRG029_D238

	STX <Temp_Var1
	LDA #$0b
	SUB <Temp_Var1
	TAX		 ; Otherwise, X = $0B - (Player_Grow >> 2)

PRG029_D238:
	AND #$01
	PHP		 ; Save result

	LDA Player_GrowFrames,X	 ; Get this grow frame
	STA <Player_Frame	 ; Set as current frame
	
	JSR Player_Draw		 ; Draw Player

	; Changes the Sprite 1/4 VROM bank as appropriate
	LDA PatTable_BankSel+2
	AND #$03
	ORA #$54
	PLP		 ; Restore result
	BEQ PRG029_D250
	SUB #$10	
PRG029_D250:
	STA PatTable_BankSel+2

	DEC Player_Grow	 ; Player_Grow--
	
	RTS		 ; Return

PRG029_D257:

	; Level_PipeMove is set to $8x when we are EXITING from
	; a pipe OR moving through it (in-level transit style),
	; but NOT when a non-transit pipe is entered; just being
	; clear, the "BPL" is for jumping when Level_PipeMove is
	; NOT holding an $8x value (and it might be zero, but 
	; that check is coming up next...)
	LDA Level_PipeMove
	BPL PRG029_D369		; If not transiting or exiting, jump to PRG029_D369

	JMP Level_PipeTransitOrExit	 ; Otherwise jump to Level_PipeTransitOrExit

PRG029_D369:
	BNE Level_PipeEnter	 ; If Level_PipeMove is not zero (and not in the $8x range), jump to Level_PipeEnter

	JMP PRG008_A224	 ; Otherwise, jump to PRG008_A224

Level_PipeEnter:

	; For when you've just entered a pipe of any sort...

	LDA Event_Countdown
	BNE PRG029_D3A0	 ; If Event_Countdown <> 0, jump to PRG029_D3A0

	; Init...

	JSR Do_Pointer_Effect
	LDA Level_PipeMove
	AND #%00011100	 ; Examine just bits 2-4 (determines what the pipe will do)
	CMP #%00010100	 
	BNE PRG029_D384	 ; If this is NOT an in-level transit pipe, jump to PRG029_D384

	LDA #$05
	STA Level_PipeExitDir	 ; Otherwise, Level_PipeExitDir = 5 (in-level transit flag)
	JMP PRG029_D395	 	; Jump to PRG029_D395

PRG029_D384:

	; Non in-level transit pipe...

	LSR A
	LSR A		 ; Shift down twice so the pipe behavior value is index based
	STA Level_JctCtl ; Push it right into Level_JctCtl!
	CMP #$01	 ; Although Level_JctCtl = 1 is not valid, this is used as "return to map"...
	BNE PRG029_D395	 ; If Level_JctCtl <> 1, jump to PRG029_D395

	INC <Level_ExitToMap	 ; Level_ExitToMap = 1 (return to map)

	LDA #$00
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 0 (completed level, i.e. did not die)

	RTS		 ; Return


PRG029_D395:

	; Entered into an in-level transit pipe...

	; Level_PipeMove will hold the direction and bit 7, which flags the in-level transit pipe
	LDA Level_PipeMove
	AND #$03
	ORA #$80
	STA Level_PipeMove	 

	RTS		 ; Return

PRG029_D3A0:

	; While traveling in a pipe (but not an in-level transit style)

	LDA Level_PipeMove
	AND #%00000011	 ; Just keep the lower 2 bits (direction)
	CMP #$02
	BGS PRG029_D3CB	 ; If direction is down/up, jump to PRG029_D3CB

	; Left/right pipe

	LDA Event_Countdown
	CMP #16
	BLS PRG029_D3CA  ; If Event_Countdown < 16, jump to PRG029_D3CA (RTS)

	PHA		 ; Save Event_Countdown

	JSR PipeMove_LeftRight	 ; Move through pipe horizontally

	PLA		 ; Restore Event_Countdown

	CMP #36
	BGS PRG029_D3CA	 ; If Event_Countdown >= 36, jump to PRG029_D3CA

	; Remove Player's edge sprites as he vanishes into pipe
	LDX Player_SprOff
	LDA #$f8
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X

PRG029_D3CA:
	RTS		 ; Return

PRG029_D3CB:

	; Up/down pipe

	JSR PipeMove_UpDown	 ; Move through pipe vertically

	LDA Event_Countdown
	CMP #16
	BGE PRG029_D3EB	 	; If Event_Countdown >= 16, jump to PRG029_D3EB (RTS)

	LDA Player_SprOff

	LDX <Player_YVelZ
	BPL PRG029_D3DF	 ; If Player_YVelZ >= 0 (going down), jump to PRG029_D3DF

	ADD #$0c	 ; Remove other half of Player


	; Gets rid of appropriate half of Player sprites as he disappears into pipe
PRG029_D3DF:
	TAX 	; X = Player_SprOff

	LDA #$f8
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

PRG029_D3EB:
	RTS		 ; Return


Level_EndFlipBits:
	.byte $00, $40

PRG029_D457
PRG029_D47E:	; Jump point for horizontal pipe-walking

PRG029_D491:
	LDA <Player_Suit
	ASL A
	ASL A		
	ORA <Temp_Var1
	TAY		; Y = (Player_Suit << 2) | Temp_Var1 (0 to 3)
	LDA Player_WalkFramesByPUp,Y	; Get appropriate frame

PRG029_D49B:
	STA <Player_Frame	; Whatever the result, store as Player frame!
	JSR Player_Draw	 	; Draw Player
	RTS		 ; Return


Pipe_Move_JumpTable:
	.word Player_Die_NotDying	; 0 - Not used
	.word Pipe_Move_Up		; 1 - Moving Up
	.word Pipe_Move_Down		; 2 - Down
	.word Pipe_Move_Right		; 3 - Right
	.word Pipe_Move_Left		; 4 - Left
	.word Pipe_Transit		; 5 - In-level transit

	; For horizontal pipe movement, X velocity right and left, respectively
PipeMove_XVel:	.byte 8, -8

	; For vertical pipe movement, Y velocity down and up, respectively
PipeMove_YVel:	.byte 8, -8

	; This sets the Scroll_LastDir variable based on travel direction (right and left, respectively)
PipeMove_LR_Dir:	.byte 0, 1

	; This adds to Horz_Scroll based on travel direction (right and left, respectively)
PipeMove_LR:	.byte 1, -1

	; High byte sign extension to values in table immediately above
PipeMove_LRH:	.byte $00, $FF

Level_PipeTransitOrExit:
	; Jump here when Level_PipeExitDir is one of the $8x varities
	; indicating that we're moving through the pipe (in-level
	; transit or simply exiting out one end of it)

	LDA Level_PipeExitDir
	ASL A		 
	TAY		

	; Dynamic jump based on Level_PipeExitDir index into Pipe_Move_JumpTable table 
	LDA Pipe_Move_JumpTable,Y
	STA <Temp_Var1	
	LDA Pipe_Move_JumpTable+1,Y
	STA <Temp_Var2		
	JMP [Temp_Var1]

Player_Die_NotDying:
	RTS		 ; Return

Pipe_Move_Up:
	; Level_PipeMove = $83 (indicates Player is moving up through pipe, no additional action to be taken)
	LDA #$83
	STA Level_PipeMove

	JSR PipeMove_UpDown	; Do pipe movement and draw Player

	LDA Event_Countdown
	BNE PRG029_D4DF	 	; If Event_Countdown <> 0, jump to PRG029_D4DF

	JMP Player_StopMovement	; Jump to Player_StopMovement

PRG029_D4DF:
	CMP #32
	LDA Player_SprOff
	BLT PRG029_D4E9	 ; If Event_Countdown < 32, jump to PRG029_D4E9 (RTS)

	JMP PRG029_D3DF ; Jump to PRG029_D3DF

PRG029_D4E9:
	RTS		 ; Return

Pipe_Move_Down:
	; Level_PipeMove = $82 (indicates Player is moving down through pipe, no additional action to be taken)
	LDA #$82
	STA Level_PipeMove
	STA <Player_InAir 	; Flag Player as being mid-air (going to fall out the bottom)

	LDA #$30
	STA <Player_YVelZ 	; Player_YVelZ = $30 

	JSR Player_ApplyYVelocity ; Apply Player's Y velocity
	JSR PipeMove_UpDown	 ; Move through pipe vertically

	LDA Event_Countdown
	BNE PRG029_D50E	 	; If Event_Countdown <> 0, jump to PRG029_D50E

	LDA #$00	 
	STA Player_IsDucking	; Clear ducking flag (since Player pressed down on a pipe, it's incorrectly set)
	STA Level_PipeMove	; Not moving through a pipe anymore
	STA <Player_XVelZ	; Not horizontally moving, period

	LDA #$38
	STA <Player_YVelZ	; Player_IsDucking = $38 (fall out the bottom)

PRG029_D50E:
	RTS		 ; Return

Pipe_Move_Right:
	; Level_PipeMove = $80 (indicates Player is moving right through pipe, no additional action to be taken)
	LDA #$80
	STA Level_PipeMove

	LDA #$40
	STA <Player_FlipBits ; Player_FlipBits = $40 (facing right)

	LDY #$00	 ; Y = 0 (moving right)

PRG029_D51A:
	LDA <Counter_1
	LSR A		
	BCC PRG029_D53B	 ; Basically, every other tick, jump to PRG029_D53B

	; And on the other ticks...

	LDA PipeMove_LR_Dir,Y
	STA <Scroll_LastDir

	LDA <Horz_Scroll

	LDX <Horz_Scroll_Hi
	BNE PRG029_D52E	 	; If Horz_Scroll_Hi = 0, jump to PRG029_D52E

	; Horz_Scroll_Hi <> 0...

	CMP #$80	 
	BLT PRG029_D53B	 ; If Horz_Scroll < $80, jump to PRG029_D53B

PRG029_D52E:
	ADD PipeMove_LR,Y
	STA <Horz_Scroll	; Horz_Scroll += PipeMove_LR[Y]

	; Add matching sign extension and any carry
	LDA PipeMove_LRH,Y
	ADC <Horz_Scroll_Hi
	STA <Horz_Scroll_Hi

PRG029_D53B:
	JSR PipeMove_LeftRight	 ; Move through pipe horizontally

	LDX Player_SprOff	 ; X = Player's root sprite position

	; Remove one of the masking sprites??
	LDA #$f8
	STA Sprite_RAM+$08,X

	LDA Event_Countdown
	BNE PRG029_D54E	 ; If Event_Countdown <> 0, jump to PRG029_D54E (RTS)

	JSR Player_StopMovement	 ; Stop movement exiting pipe!

PRG029_D54E:
	RTS		 ; Return

Pipe_Move_Left:
	; Level_PipeMove = $81 (indicates Player is moving left through pipe, no additional action to be taken)
	LDA #$81
	STA Level_PipeMove

	LDA #$00
	STA <Player_FlipBits ; Player_FlipBits = $00 (facing left)

	LDY #$01	 ; Y = 1 (moving left)

	JMP PRG029_D51A	; Jump to PRG029_D51A

	; Y Offset based on direction (down and up respectively)
PipeTransit_YOff:
	.byte 31, 0

Pipe_Transit:
	
	LDA #-2		 ; A = -2 (scroll upward)
	LDX #$01	 ; X = 1
	LDY <Player_YVelZ ; Y = Player_YVel
	BMI PRG029_D56F	 ; If Player_YVelZ < 0, jump to PRG029_D56F

	; If Player_Vel >= 0...
	LDA #$02	 ; A = 2 (scroll downward)
	DEX		 ; X = 0

PRG029_D56F:
	STA Pipe_TransYDelta	 ; Pipe_TransYDelta = -2 (going up) or 2 (going down)

	ADD <Vert_Scroll
	STA <Vert_Scroll 	; Vert_Scroll += A
	STA Level_VertScroll	; Level_VertScroll += A

	LDY <Player_YVelZ	; Y = Player_YVel
	BPL PRG029_D584	 	; If Player_YVelZ >= 0, jump to PRG029_D584

	BCS PRG029_D59B	 	; If carry occurred from addition to Vert_Scroll, jump to PRG029_D59B

	; Otherwise...

	; Inter-level vertical pipes stop moving upward when scroll reaches $00
	LDA #$00	 ; A = 0 
	BEQ PRG029_D58A	 ; Jump (technically always) to PRG029_D58A

PRG029_D584:
	CMP #$ef	 
	BLT PRG029_D59B	 ; If Vert_Scroll < $EF, jump to PRG029_D59B

	; Inter-level vertical pipes stop moving downward when scroll reaches $EF
	LDA #$ef	 ; Otherwise, A = $EF (bottom scroll)

PRG029_D58A:
	; Common termination point when exiting inter-level vertical pipe
	STA <Vert_Scroll ; Update Vert_Scroll

	LDA #$01
	STA Level_PipeExitDir	 ; Level_PipeExitDir = 1 (exiting up)

	LDY <Player_YVelZ
	BMI PRG029_D598	 	; If Player_YVelZ < 0, jump to PRG029_D598

	INC Level_PipeExitDir	 ; Otherwise, Level_PipeExitDir = 2 (exiting down)

PRG029_D598:
	JMP PRG008_A38E	 ; Jump to PRG008_A38E (Player exits pipe)

PRG029_D59B:
	; X = 0 (going down) or 1 (going up)

	LDA PipeTransit_YOff,X
	STA <Temp_Var10	 ; Temp_Var10 = PipeTransit_YOff[X] (appropriate Y offset)

	LDA #$08
	STA <Temp_Var11	 ; Temp_Var11 = 8

	JSR Player_GetTileAndSlope	; Get tile
	CMP #TILE_ITEM_COIN
	BGE PRG029_D5B7

	AND #$0F
	CMP #TILE_PROP_VPIPE_LEFT
	BEQ PRG029_D5C3

	CMP #TILE_PROP_VPIPE_RIGHT
	BEQ PRG029_D5C3	 	; If tile is one of the transit pipe top/bottom tiles, jump to PRG029_D5C3 (RTS)

PRG029_D5B7:
	LDA #16	 	; A = 16
 
	CPX #$00	 
	BEQ PRG029_D5B8	 ; If Player was going down, jump to PRG029_D5B8

	; Player was going up

	DEC <Player_YHiZ	 ; Player_YHiZ--
	LDA #-16	 ; A = 16

PRG029_D5B8:
	ADD <Player_YZ	
	AND #$f0	
	STA <Player_YZ	 ; Player_Y = (Player_Y + A) & $F0  (tile-aligned move)

	BCC PRG029_D5C3	 ; If no carry, jump to PRG029_D5C3

	INC <Player_YHiZ	 ; Otherwise, apply carry

PRG029_D5C3:
	RTS		 ; Return

	; Defines Y and X offset pairs, for two different rotation possibilities
	; when Player hits an elbow (does he go from up to right, or up to left? etc.)
	; Indexed per lower 2 bits of Level_PipeMove, shifted up by 2
PipeTransit_XYOffsets:
	;    YO1 XO1 YO2 XO2
	.byte 30, 18,  2, 18	; Moving right
	.byte 30,  2,  2,  2	; Moving left
	.byte 30, 14, 30,  2	; Moving up
	.byte  2, 14,  2,  2	; Moving down

	; This is actually access as a contiguous array, but might as well be clear
PipeTransit_YDelta:	.byte 2, -2	; Y Deltas while moving through pipes (down and up)
PipeTransit_XDelta:	.byte 2, -2	; X Deltas while moving through pipes (right and left)

	; Sets Level_PipeExitDir appropriately based on direction
Level_PipeExitDirTable:	.byte $03, $04, $02, $01

PRG029_D5DC:

	; Pipe transit in vertical levels

	LDA Level_PipeMove
	AND #$03	 ; Just the lower 2 bits of Level_PipeMove (the direction)
	PHA		 ; Save it

	TAY		 ; Y = the direction of Level_PipeMove

	LDX #$00	 		; Index Player's X

	CPY #$02
	BLS PRG029_D605	 ; If direction is right or left, jump to PRG029_D605

	; Direction is down or up

	LDX #(Player_YZ - Player_X)	; Index Player's Y instead

	LDA PipeTransit_YDelta,Y	; Get delta
	BPL PRG029_D5FD	 		; If it's not negative, jump to PRG029_D5FD

	LDA <Player_SpriteY
	CMP #$68
	LDA #$00
	BLT PRG029_D608	 ; If Player_SpriteY < $68, jump to PRG029_D608

	DEC <Player_XHi,X ; Decrement approprate Player Hi
	JMP PRG029_D605	 ; Jump to PRG029_D605

PRG029_D5FD:
	LDA <Player_SpriteY
	CMP #$38	 
	LDA #$00	 
	BGE PRG029_D608	 ; If Player_SpriteY >= $38, jump to PRG029_D608

PRG029_D605:
	LDA PipeTransit_YDelta,Y 	; Get delta

PRG029_D608:
	ADD <Player_X,X		; Apply delta to Player X or Y (as appropriate)
	AND #$fe	 	; Align to nearest 2 pixels
	STA <Player_X,X	 	; Store it

	BCC PRG029_D613	 	; If no carry, jump to PRG029_D613

	INC <Player_XHi,X	; Otherwise, apply carry

PRG029_D613:
	AND #$0f	 ; Lower 4 bits of Player's X or Y
	TAX		 ; -> 'X'

	CPY #$02
	BLS PRG029_D651	 ; If direction is right or left, jump to PRG029_D651

	; Down or up

	LDA <Player_X
	AND #$f0
	ORA #$08
	STA <Player_X	 ; Player_X = (Player_X & $F0) | 8  (nearest column, centered)

	LDA #$01
	STA <Scroll_LastDir ; Scroll_LastDir = 1 (down)

	LDA PipeTransit_YDelta,Y	; Get delta
	BPL PRG029_D630	 		; If delta is not negative, jump to PRG029_D630

	; Negative delta means up, so...

	DEC <Scroll_LastDir	 ; Scroll_LastDir = 0 (up)
	DEC Level_VertScrollH	 ; Level_VertScrollH--

PRG029_D630:
	STA Pipe_TransYDelta	 ; Store into Pipe_TransYDelta
	ADD Level_VertScroll	
	STA Level_VertScroll	 ; Level_VertScroll += Pipe_TransYDelta
	BCC PRG029_D63F	 	; If no carry, jump to PRG029_D63F

	INC Level_VertScrollH	 ; Otherwise, apply carry

PRG029_D63F:
	LDY Level_VertScrollH	 ; Y = Level_VertScrollH

	JSR LevelJct_GetVScreenH ; Adjust coordinates for vertical

	; Update scrolls
	STA <Vert_Scroll
	STY <Vert_Scroll_Hi

	LDA <Player_YZ
	SUB Level_VertScroll
	STA <Player_SpriteY	 ; Player_SpriteY = relative Y position

PRG029_D651:
	PLA		 ; Restore the lower 2 bits of Level_PipeMove (the direction)

	; 'X' was last left as lower 4 bits of Player's X or Y position
	; (i.e. distance across cell horizontally or vertically; a value
	; of zero indicates Player has just aligned with a new tile)
	CPX #$00
	BNE PRG029_D69B	 ; If Player has not reached a new tile, jump to PRG029_D69B

	; Player has reached a new tile...

	ASL A
	ASL A		 ; direction of pipe move, shifted left 2

	LDX #$01	 ; X = 1

	TAY		 ; Y = the direction of the pipe move, shifted left 2 (0, 4, 8, 12)

PRG029_D65B:
	LDA PipeTransit_XYOffsets,Y
	STA <Temp_Var10	 ; Temp_Var10 = Y offset

	LDA PipeTransit_XYOffsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 = X offset

	JSR Player_GetTileAndSlope	; Get tile
	STA <Temp_Var1		 ; Store into Temp_Var1

PRG029_D674:
	INY		 ; Y++
	INY		 ; Y++ (next Y/X offset pair)

	DEX		 ; X-- (if Player turned corner, this will result in a negative)
	BPL PRG029_D65B	 ; If X >= 0, loop!

PRG029_D69B:
	RTS		 ; Return


PRG029_D69C:

	; In-transit pipe, hit an end

	LDA Level_PipeMove
	AND #%00000011	 
	TAY		 	; Y = lower 2 bits of Level_PipeMove (the direction)
	BNE PRG029_D6AB	 	; If direction is not rightward, jump to PRG029_D6AB

	; Otherwise, add 16 to Player_X
	LDA <Player_X
	ADD #16
	STA <Player_X

PRG029_D6AB:

	; Set Level_PipeExitDir appropriately
	LDA Level_PipeExitDirTable,Y
	STA Level_PipeExitDir

	JMP PRG008_A38E	 ; Jump to PRG008_A38E

Player_Die_JumpTable:
	.word Player_Die_NotDying	; 0 - Player isn't dying!  Do nothing
	.word Player_Die_Dying		; 1 - Dying normal
	.word Player_Die_FellOff	; 2 - Dying by having fallen off screen
	.word Player_Die_TimeUp		; 3 - Dying due to time up

PRG029_D6BC:
	; Player is dying!

	LDA <Player_IsDying
	ASL A		 
	TAY		 ; Y = Player_IsDying << 1

	LDA Player_Die_JumpTable,Y
	STA <Temp_Var1
	LDA Player_Die_JumpTable+1,Y
	STA <Temp_Var2

	JMP [Temp_Var1]	 ; Jump to appropriate "Player is dying" routine...

Player_Die_Dying:
	LDA Player_AboveTop
	BNE PRG029_D6DA	 ; If Player is above top of screen, jump to PRG029_D6DA

	LDA <Player_SpriteY
	AND #$f0
	CMP #$b0
	BEQ PRG029_D6E5	 ; If Player_SpriteY >= $B0 && Player_SpriteY <= $BF (Player is halfway below status bar), jump to PRG029_D6E5

PRG029_D6DA:
	LDA Event_Countdown
	BNE PRG029_D6E2	 ; If Event_Countdown <> 0 (time until drop to map), jump to PRG029_D6E2
	JMP PRG029_D768	 ; Otherwise, jump to PRG029_D6E2

PRG029_D6E2:
	JMP PRG029_D771	 ; Jump to PRG029_D771 if Event_Countdown <> 0

PRG029_D6E5:
	LDA Event_Countdown
	BNE PRG029_D6EF	; If Event_Countdown > 0 (time until drop to map), jump to PRG029_D6EF

	; Reload Event_Countdown
	LDA #64
	STA Event_Countdown	; Event_Countdown = 64

PRG029_D6EF:
	CMP #$01
	BNE PRG029_D6F5	 ; If Event_Countdown <> 1, jump to PRG029_D6F5 (RTS)
	BEQ PRG029_D6FB	 ; If Event_Countdown = 1, jump to PRG029_D6FB

PRG029_D6F5:
	RTS		 ; Return


Player_Die_FellOff:
	LDA Event_Countdown
	BNE PRG029_D702	 ; If Event_Countdown <> 0, jump to PRG029_D702 (RTS)

PRG029_D6FB:
	INC <Level_ExitToMap	; Level_ExitToMap = 1

	LDA #$FF
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 1 (Player died, level is not clear)

PRG029_D702:
	RTS		 ; Return

	; Patterns for TIME-UP
TIMEUP_Sprites:
	.byte $21	; T
	.byte $23	; I
	.byte $25	; M
	.byte $27	; E
	.byte $29	; -
	.byte $1D	; U
	.byte $1F	; P

	; X positions for each letter in TIME-UP
TIMEUP_SpriteXs:
	.byte $60, $68, $70, $78, $80, $88, $90

Player_Die_TimeUp:
	LDA Player_AboveTop
	BNE PRG029_D71E	 ; If Player is off top of screen, jump to PRG029_D71E
	
	LDA <Player_SpriteY
	AND #$f0
	CMP #$b0
	BEQ PRG029_D729	 ; If Player_SpriteY >= $B0 && Player_SpriteY <= $BF (Player is halfway below status bar), jump to PRG029_D729

PRG029_D71E:
	LDA Event_Countdown
	BNE PRG029_D726	 ; If Event_Countdown <> 0, jump to PRG029_D726

	JMP PRG029_D768	 ; Jump to PRG029_D768

PRG029_D726:
	JMP PRG029_D771	 ; Jump to PRG029_D768 if Event_Countdown <> 0

PRG029_D729:
	DEC <Pipe_PlayerY	; Pipe_PlayerY--

	LDA <Pipe_PlayerX
	CMP #$60
	BLT PRG029_D73B	 ; If Pipe_PlayerX < $60, jump to PRG029_D73B

	ADD <Pipe_PlayerY
	STA <Pipe_PlayerX	; Pipe_PlayerX += Pipe_PlayerY

	LDA #112
	STA Event_Countdown	 ; Event_Countdown = 112

PRG029_D73B:
	LDA Event_Countdown
	BEQ PRG029_D6FB	 ; If Event_Countdown = 0, jump to PRG029_D6FB

	LDA #$32
	STA PatTable_BankSel+2	 ; Set sprites 1/4 VROM page for the TIME UP sprites

	LDY #$06	 ; Y = 6 (seven sprites for T I M E - U P)
	LDX Player_SprOff	 ; Starting from Player's sprite offset

PRG029_D74A:
	LDA <Pipe_PlayerX
	STA Sprite_RAM+$00,X

	LDA TIMEUP_Sprites,Y
	STA Sprite_RAM+$01,X

	LDA #$01
	STA Sprite_RAM+$02,X

	LDA TIMEUP_SpriteXs,Y
	STA Sprite_RAM+$03,X

	INX
	INX
	INX
	INX
	DEY		; Y--
	BPL PRG029_D74A	 ; While Y >= 0, loop

	RTS		 ; Return

PRG029_D768:
	; Player gravity while dying
	INC <Player_YVelZ
	INC <Player_YVelZ ; Player_YVelZ += 2

	LDX #$00	 ; X = 0 (?)

	JSR Player_ApplyYVelocity	 ; Applies Player's Y velocity

PRG029_D771:
	LDA #PF_DIE
	STA <Player_Frame ; Player_Frame = PF_DIE

	JSR Player_Draw	 ; Draw Player
	RTS		 ; Return


	; Move Player left/right within pipe
PipeMove_LeftRight:
	LDA Level_PipeMove 
	AND #$01	 ; Just determining left or right (see def for Level_PipeMove)
	TAY		 ; Y = 0 (right) or 1 (left) 

	LDA PipeMove_XVel,Y	 	; Get appropriate X velocity
	STA <Player_XVelZ	 	; Set it!

	JSR Player_ApplyXVelocity 	; Apply Player's X velocity

	; A little "step up" into the pipe
	DEC <Player_YZ
	DEC <Player_YZ	 ; Player_Y -= 2

	LDA <Counter_1
	AND #$0c	
	LSR A		
	LSR A		 
	STA <Temp_Var1	 ; Temp_Var1 = (Counter_1 & $C) >> 2 (0 to 3, walking animation)

	JSR PRG029_D47E	 ; Do walking animation and draw Player

	; Undo "step up"
	INC <Player_YZ
	INC <Player_YZ	 ; Player_Y += 2

	RTS		 ; Return


	; Move Player up/down within pipe
PipeMove_UpDown:
	LDA Level_PipeMove
	AND #$01	 ; Just determining up or down (see def for Level_PipeMove)
	TAY		 ; Y = 0 (down) or 1 (up)

	LDA PipeMove_YVel,Y	 	; Get appropriate Y velocity
	STA <Player_YVelZ	 	; Set it!

	JSR Player_ApplyYVelocity	; Apply Player's Y velocity

	JSR PipeMove_SetPlayerFrame	; Set appropriate frame for pipe traversal
	JMP Player_Draw	 		; Jump to draw Player!

Player_StopMovement:
	LDA #$00
	STA Level_PipeMove	; Not moving through a pipe
	STA <Player_XVelZ	; Player stopped horizontall
	STA <Player_YVelZ	; Player stopped vertically
	STA <Player_InAir	; Not mid-air
	RTS		 ; Return

SuitLost_Poof_Patterns:
	.byte $47, $45, $43, $41

Player_SuitLost_DoPoof:
	DEC Player_SuitLost	; Player_SuitLost-- 
	AND #$0c
	LSR A	
	LSR A	
	TAY		 ; Y = 0-3, changing every 4 ticks

	LDA SuitLost_Poof_Patterns,Y	; Get poof pattern
	STA <Temp_Var2		 ; Store into Temp_Var2

	LDY Player_SprOff	 ; Y = Player_SprOff (Player sprite beginning offset)

	LDA #%11000001	; Flipped horizontal and vertical, and palette 1
	STA <Temp_Var1	; -> Temp_Var1

PRG029_D7D3:
	; Sprite Y
	LDA <Player_SpriteY
	ADD #$08	 	; Start at 8 pixels below Player sprite Y pos
	STA Sprite_RAM+$00,Y	 ; Store into sprite Y

	; Poof pattern
	LDA <Temp_Var2
	STA Sprite_RAM+$01,Y

	; Attribute
	LDA <Temp_Var1
	STA Sprite_RAM+$02,Y

	; Sprite X
	LDA <Player_X
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	LDA <Temp_Var1
	AND #$f0	
	BEQ PRG029_D7FC	 ; If we're the unflipped one, jump to PRG029_D7FC

	; Otherwise, put it to the right of the first one
	LDA Sprite_RAM+$03,Y
	ADD #$08	
	STA Sprite_RAM+$03,Y

PRG029_D7FC:
	INY
	INY
	INY
	INY		 ; Y += 4

	; Other sprite is not H/V flipped
	LDA <Temp_Var1
	SUB #%11000000
	STA <Temp_Var1

	BCS PRG029_D7D3	 ; Loop if not the second sprite

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BlockChange_Do
;
; Performs a Block Change command, if one is needed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BlockChange_Do:
	LDA Block_NeedsUpdate	 
	STA Block_WasUpdated
	BEQ PRG029_DC7D	

PRG029_DC36:

	; Non-vertical level only...

	LDA Block_ChangeXHi
	ASL A		 ; Multiply by 2 (2 byte index per Tile_Mem_Addr)
	TAX		 ; -> 'X'

	; Set address in tile memory to Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	; Temp_Var7 = 0
	LDA #$00
	STA <Temp_Var7

	LDA Block_ChangeYHi
	BEQ PRG029_DC50	 ; If block change is not on the lower part of the screen, jump to PRG029_DC50

	INC <Map_Tile_AddrH	; Otherwise, jump to lower screen address

PRG029_DC50:

	; Construct a row/column offset -> Temp_Var5
	LDA Block_ChangeY
	AND #$f0
	STA <Temp_Var6
	
	LDA Block_ChangeX
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	LDA Block_ChangeYHi
	BNE PRG029_DC70	 ; If Block_ChangeYHi <> 0 (block change is down low on the lower screen space), jump to PRG029_DC70

	; Block change is on upper screen space... 

	LDA Block_ChangeY
	AND #$f0	 ; Align to grid
	CMP #$f0
	BNE PRG029_DC7C	 ; If not TOO low, jump to PRG029_DC7C

PRG029_DC70:

	; Block is on upper part of screen but at the 240 line
	; This logic calculates an alternate address because the code that actually
	; applies the tile change needs to have a 32 byte jump to the next line,
	; and use $F0 would overflow back to $10 and misalign the tile change!!

	; Temp_Var6 = 0-ish
	LDA Block_ChangeY
	ADD #$10
	STA <Temp_Var6

	; Temp_Var7 = 1 (carry)
	LDA #$01
	STA <Temp_Var7

PRG029_DC7C:
	JMP TileChng_OneTile	 ; If Block_NeedsUpdate <> 0, jump to PRG029_DC82

	; Otherwise, do nothing... seems like they should've checked for
	; this BEFORE bothering with all those calculations!  :)

PRG029_DC7D:
	RTS		 ; Return

Map16_ByTileSet:
	; A000 page selected per-Level_Tileset...
	.byte $16
	.byte $16
	.byte $16
	.byte $16
	.byte $16
	.byte $16
	.byte $16
	.byte $16
	.byte $17
	.byte $17
	.byte $17
	.byte $17
	.byte $17
	.byte $17
	.byte $17

Map16_OffsetByTileset:
	; Defines the 8x8 blocks to build a particular 16x16 "tile"

	.word $A000
	.word $A400
	.word $A800
	.word $AC00
	.word $B000
	.word $B400
	.word $B800
	.word $BC00
	.word $A000
	.word $A400
	.word $A800
	.word $AC00
	.word $B000
	.word $B400
	.word $B800
	.word $BC00
	

Map16Offsets:
	
TileChng_OneTile:
	LDA PAGE_A000	; save previous state
	PHA				
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	
	JSR PRGROM_Change_A000

	LDA Level_Tileset
	STA <Temp_Var14

	ASL <Temp_Var14

	LDY <Temp_Var14

	LDA Map16_OffsetByTileset, Y
	STA <Temp_Var14
	INY

	LDA Map16_OffsetByTileset, Y
	STA <Temp_Var15
	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	; Change the tile to the proper target tile
	LDA Block_UpdateValue
	STA [Map_Tile_AddrL],Y
	
	LDA Block_ChangeX
	SUB <Horz_Scroll
	STA TileCheckX
	
	LDA Block_ChangeXHi
	SBC <Horz_Scroll_Hi
	STA TileCheckXHi
	BPL PRG029_DD21

PRG029_DD20:
	JMP EndDynaTileDraw

PRG029_DD21:
	LDA TileCheckXHi
	BNE PRG029_DD20

	LDX #$00	 ; Y = 0
	LDY Block_UpdateValue

PRG029_DD22:
	LDA [Temp_Var14],Y	 ; Get pattern
	STA TileChng_Pats,X	 ; Copy into TileChng_Pats

	INC Temp_Var15
	INC Temp_Var15

	INX		 ; Y++ (count of patterns)
	
	LDA [Temp_Var14],Y	 ; Get pattern
	STA TileChng_Pats,X	 ; Copy into TileChng_Pats

	DEC Temp_Var15

	INX		 ; Y++ (count of patterns)

	LDA [Temp_Var14],Y	 ; Get pattern
	STA TileChng_Pats,X	 ; Copy into TileChng_Pats

	INC Temp_Var15
	INC Temp_Var15

	INX		 ; Y++ (count of patterns)

	LDA [Temp_Var14],Y	 ; Get pattern
	STA TileChng_Pats,X	 ; Copy into TileChng_Pats

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00001111	 ; Only keep lower 4 bits (bits 2 and 3 are still zero)
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7
	BEQ PRG029_DD41	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DD41

	ORA #$08	 ; Set $28 high address

PRG029_DD41:
	STA TileChng_VRAM_H	 ; Store the high byte of the tile change base address

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	STA <Temp_Var2	; -> Temp_Var2

	LDA Block_ChangeX
	LSR A
	LSR A
	LSR A		; A = Block_ChangeX / 8
	ORA <Temp_Var2	
	STA TileChng_VRAM_L	 ; Store the low byte of the tile change base address

EndDynaTileDraw:
	LDA #$00
	STA Block_NeedsUpdate
	PLA
	STA PAGE_A000	 
	JSR PRGROM_Change_A000
	RTS		 ; Return

Rainbow_Palette_Cycle:
	LDA <Counter_1;
	LSR A
	LSR A
	AND #$07
	TAX
	CLC

	LDA RAINBOW_PAL_CYCLE, X
	STA (Palette_Buffer + $11)

	ADC #$20
	STA (Palette_Buffer + $13)

	ADC #$10
	STA (Palette_Buffer + $12)
	RTS

Backup_Curr_Player_Pal:
	
	LDA (Palette_Buffer + $11)
	STA Player_Pal_Backup

	LDA (Palette_Buffer + $12)
	STA (Player_Pal_Backup + $01)

	LDA (Palette_Buffer + $13)
	STA (Player_Pal_Backup+ $02)
	RTS

Restore_Curr_Player_Pal:
	LDA Player_Pal_Backup
	STA (Palette_Buffer + $11)

	LDA (Player_Pal_Backup + $01)
	STA (Palette_Buffer + $12)

	LDA (Player_Pal_Backup+ $02)
	STA (Palette_Buffer + $13)

	; LDA #$00
	; STA Player_Pal_Backup
	; STA (Player_Pal_Backup + $01)
	; STA (Player_Pal_Backup + $01)
	RTS

Player_RainbowCycle:
	LDA Player_StarOff
	BNE Player_RainbowCycle1

	LDA Player_Invincible
	ORA Player_StarInv
	BEQ Player_RainbowCycle3

	LDA Player_StarInv
	BEQ Player_RainbowCycle1

	LDA Game_Counter
	AND #$03
	BNE Player_RainbowCycle1

	DEC Player_StarInv

	LDA Player_StarInv
	STA Player_Invincible
	CMP #$10
	BNE Player_RainbowCycle1	 ; If Player_StarInv <> 32, jump to PRG029_CF05

	; At precisely star invincibility tick 32...

	
	LDA Level_PSwitchCnt
	BNE Player_RainbowCycle1	 	; If P-Switch is active, jump to PRG029_CF05

	; Otherwise, restore level BGM music now that invincibility is wearing off
	LDA Level_MusicQueueRestore
	STA Sound_QMusic2

Player_RainbowCycle1:
	LDA Player_Pal_Backup	; Check the current palette backup, if it doens't exist, back it up
	BNE Player_RainbowCycle2

	JSR Backup_Curr_Player_Pal

Player_RainbowCycle2:
	JSR Rainbow_Palette_Cycle ; color cycle the palette for a rainbow effect!
	RTS

Player_RainbowCycle3:
	LDA Player_Pal_Backup
	BEQ Player_RainbowCycle4

	JSR Restore_Curr_Player_Pal
Player_RainbowCycle4:
	RTS

Flip_Override = Temp_Var16
Player_FrameOverride:

	LDA Wall_Jump_Enabled
	BEQ Player_FrameOverride1

	LDA <Player_FlipBits
	STA <Flip_Override
	EOR #SPR_HFLIP
	STA <Player_FlipBits
	

	LDA #$30
	STA <Player_Frame
	RTS

Player_FrameOverride1:
	LDA Player_Shell
	BEQ Player_FrameOverride2

	LDA Game_Counter
	LSR A
	AND #$03
	ADD #$51
	STA <Player_Frame
	RTS

Player_FrameOverride2:
	LDA Player_FireDash
	BEQ Player_FrameOverride3

	LDA Game_Counter
	LSR A
	AND #$03
	ADD #$55
	STA <Player_Frame

Player_FrameOverride3:
	RTS

Player_RecoverOverrides:
	LDA Wall_Jump_Enabled
	BEQ Player_RecoverOverrides1

	LDA <Flip_Override
	STA <Player_FlipBits

Player_RecoverOverrides1:
	RTS

Vehicle_PatternsTop:
	.byte $29, $01, $03, $37
	.byte $29, $05, $07, $37
	.byte $29, $05, $07, $37
	.byte $29, $09, $0B, $37
	.byte $29, $0D, $0F, $37
	.byte $29, $11, $13, $37
	.byte $29, $3D, $3F, $37
	.byte $29, $19, $1B, $37
	.byte $29, $1D, $1F, $37
	.byte $29, $21, $23, $37
	.byte $29, $21, $23, $37
	.byte $29, $21, $23, $37
	.byte $29, $21, $23, $37	

Plane_PatternsBottom:
	.byte $31, $33, $35, $39
	.byte $31, $33, $35, $3B

Subarmine_PatternsBottom:
	.byte $25, $2B, $2D, $2F
	.byte $27, $2B, $2D, $2F

Vehicle_Direction:
	.byte $00, $00, $01

Vehicle_Flip:
	.byte $00, $00, SPR_HFLIP

Player_DrawVehicle:
	JSR Player_RainbowCycle
	
	LDX Player_Vehicle
	LDA Vehicle_Direction, X
	STA Player_Direction

	LDA #SPR_HFLIP
	STA <Player_FlipBits
	
	LDA #$59
	STA PatTable_BankSel + 2

	LDA #$00
	STA <Temp_Var2

	LDA Player_Behind
	ORA Level_PipeMove
	BEQ Player_VehicleOverBg

	LDA #SPR_BEHINDBG
	STA <Temp_Var2

Player_VehicleOverBg:	
	LDA <Player_X
	SUB <Horz_Scroll
	SUB #$08
	STA <Player_SpriteX	 ; Player_SpriteX = Player_X - Horz_Scroll

	LDA <Player_YZ
	SUB Level_VertScroll
	STA <Player_SpriteY	; Player_SpriteY = Player_Y - Level_VertScroll

Submarine_Flash:
	LDA Player_Invulnerable
	BEQ Vehicle_NoFlash

	DEC Player_Invulnerable
	LDA Player_Invulnerable
	AND #$02
	BEQ Vehicle_NoFlash

	LDA #$E0
	STA <Player_SpriteY

Vehicle_NoFlash:

	LDA Player_SprOff
	SUB #$08
	TAY

	LDA #$03
	STA <Temp_Var1

	LDA <Player_SpriteX

Vehcile_XLoop:	
	STA Sprite_RAMX, Y
	STA Sprite_RAMX + $10, Y

	ADD #$08

	INY
	INY
	INY
	INY

	DEC <Temp_Var1
	BPL Vehcile_XLoop	

	LDA Player_SprOff
	SUB #$08
	TAY

	LDA <Player_SpriteY

	STA Sprite_RAMY, Y
	STA Sprite_RAMY + $04, Y
	STA Sprite_RAMY + $08, Y
	STA Sprite_RAMY + $0C, Y

	ADD #$10
	STA Sprite_RAMY + $10, Y
	STA Sprite_RAMY + $14, Y
	STA Sprite_RAMY + $18, Y
	STA Sprite_RAMY + $1C, Y

	LDA #SPR_PAL0
	ORA <Temp_Var2
	STA Sprite_RAMAttr + $04, Y
	STA Sprite_RAMAttr + $08, Y
	STA Sprite_RAMAttr + $0C, Y

	LDA #SPR_PAL3
	ORA <Temp_Var2
	STA Sprite_RAMAttr, Y
	STA Sprite_RAMAttr + $10, Y
	STA Sprite_RAMAttr + $14, Y
	STA Sprite_RAMAttr + $18, Y
	STA Sprite_RAMAttr + $1C, Y	

	LDA Player_EffectiveSuit
	ASL A
	ASL A
	TAX

	LDA #$03
	STA <Temp_Var1

Vehcile_PatternLoop:
	LDA Vehicle_PatternsTop, X
	STA Sprite_RAMTile, Y

	INX
	INY
	INY
	INY
	INY

	DEC <Temp_Var1
	BPL Vehcile_PatternLoop

	LDA <Pad_Holding
	AND #PAD_A
	BEQ Vehicle_NormPropeller

	LDA Game_Counter
	ASL A
	AND #$04
	TAX
	BPL Vehicle_DrawBottom

Vehicle_NormPropeller:	
	LDA Game_Counter
	AND #$04
	TAX

Vehicle_DrawBottom:
	LDA Player_Vehicle
	SUB #$01
	ASL A
	ASL A
	ASL A
	STX <Temp_Var1
	ADD <Temp_Var1

	TAX

	LDA #$03
	STA <Temp_Var1

	LDA Player_SprOff
	SUB #$08
	TAY

Vehicle_PatternBottomLoop:
	LDA Subarmine_PatternsBottom - 8, X
	STA Sprite_RAMTile + $10, Y

	INX
	INY
	INY
	INY
	INY 

	DEC <Temp_Var1
	BPL Vehicle_PatternBottomLoop

	LDA <Player_SpriteX
	ADD #$08
	STA <Player_SpriteX

	LDA Player_Vehicle
	CMP #$01
	BNE Vehicle_DrawRTS

	LDA #$01
	STA <Temp_Var1

	LDA Player_SprOff
	SUB #$08
	TAY

Vehicle_FlipTiles:
	LDA Sprite_RAMTile, Y
	PHA

	LDA Sprite_RAMAttr, Y
	ORA #SPR_HFLIP
	PHA

	LDA Sprite_RAMTile+4,Y
	PHA

	LDA Sprite_RAMAttr+4,Y
	ORA #SPR_HFLIP
	PHA

	LDA Sprite_RAMTile+8,Y
	PHA

	LDA Sprite_RAMAttr+8,Y
	ORA #SPR_HFLIP
	PHA

	LDA Sprite_RAMTile+12,Y	 
	PHA

	LDA Sprite_RAMAttr+12,Y
	ORA #SPR_HFLIP
	STA Sprite_RAMAttr, Y

	PLA
	STA Sprite_RAMTile,Y

	PLA
	STA Sprite_RAMAttr+4,Y

	PLA
	STA Sprite_RAMTile+4,Y

	PLA
	STA Sprite_RAMAttr+8,Y

	PLA
	STA Sprite_RAMTile+8,Y

	PLA
	STA Sprite_RAMAttr+12,Y

	PLA
	STA Sprite_RAMTile+12,Y	

	TYA
	ADD #$10
	TAY

	DEC <Temp_Var1
	BPL Vehicle_FlipTiles

Vehicle_DrawRTS:
	RTS