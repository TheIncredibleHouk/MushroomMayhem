; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

Check_Save:
	JSR Generate_SaveChecksum
	LDA <Temp_Var1
	ORA <Temp_Var2
	BEQ Checksum_Invalid

	LDA <Temp_Var1
	CMP Save_Ram_CheckSum
	BNE Checksum_Invalid

	LDA <Temp_Var2
	CMP Save_Ram_CheckSum + 1
	BNE Checksum_Invalid
 ;
	LDY #(Player_Stats_Boundary_End - Player_Stats_Boundary_Start)

LoadSave_Loop:
	LDA Save_Ram_Boundary_Start, Y
	STA Player_Stats_Boundary_Start, Y
	DEY
	BPL LoadSave_Loop

	SEC
	RTS

Checksum_Invalid:
	CLC
	RTS


Load_Save:
	JSR Check_Save
	BCS Map_Init
	
	LDX #$00

	LDA #$01
	STA World_Num

	LDA #$90
	STA Map_Entered_Y
	STA Map_Previous_Y
	
	LDA #$00
	STA Map_Entered_XHi

	; Set starting X position (forced to $20!)
	LDA #$20
	STA Map_Entered_X
	STA Map_Previous_X

	LDA #$FF
	STA SecondQuest

	LDA #$01
	STA Map_Previous_Dir

	LDA #$00
	STA Map_Prev_XOff2
	STA Map_Prev_XHi2
	STA Map_Prev_XOff
	STA Map_Prev_XHi

Map_Init:
	JSR World_Override
	RTS		 ; Return

World_Start_X:
	.byte $00, $20, $20, $30, $10, $20, $20, $30

World_Start_Y:
	.byte $00, $90, $40, $60, $70, $80, $50, $90

World_Start_Num:
	.byte $00, $10, $20, $30, $40, $50, $60, $70

World_Override:
	LDX World_Start
	BEQ World_OverrideRTS

	LDA World_Start_X, X
	STA Map_Entered_X
	STA Map_Previous_X

	LDA World_Start_Y, X
	STA Map_Entered_Y
	STA Map_Previous_Y

	LDA #$00
	STA Map_Entered_XHi
	STA Map_Previous_XHi

	STX World_Num

World_OverrideRTS:
	RTS


	; Offset to Player-specific inventory items


; PRG011_A2C8:
; 	LDX Map_Unused738	 ; X = Map_Unused738

; 	; Seems Map_Unused7DC6 was pretty interesting once?
; 	;LDA Map_Unused7DC6,X
; 	JSR DynJump

; 	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
; 	.word PRG011_B74A		; 0
; 	.word WorldMap_UpdateAndDrawInd	; 1
; 	.word WorldMap_UpdateAndDrawInd	; 2
; 	.word WorldMap_UpdateAndDrawInd	; 3
; 	.word WorldMap_UpdateAndDrawInd	; 4
; 	.word PRG011_B74A		; 5
; 	.word WorldMap_UpdateAndDrawInd	; 6
; 	.word Map_DoMap_WarpWind_FX	; 7
; 	.word WorldMap_UpdateAndDrawInd	; 8
; 	.word WorldMap_UpdateAndDrawInd	; 9
; 	.word PRG011_B74A		; 10
; 	.word PRG011_B74A		; 11
; 	.word PRG011_B74A		; 12
; 	.word PRG011_B74A		; 13
; 	.word PRG011_B74A		; 14
; 	.word PRG011_B74A		; 15

; WorldMap_UpdateAndDrawInd:
; 	JMP WorldMap_UpdateAndDraw

; Map_WW_StartX:	.byte 0, 240	; Map warp wind starting X position, depending which direction it comes from
; Map_WW_DeltaX:	.byte 2, -2	; Position change depending on the direction of travel
; Map_WW_TargetX:	.byte 240, 0	; The ending position, depending on direction of travel

; 	; Starting Y position depending on what world you came from
; Map_WW_IslandY:
; 	.byte $50, $70, $70	; World 1 - 3
; 	.byte $70, $70, $70	; World 4 - 6
; 	.byte $90, $90, $90	; World 7 - 9

; 	; Unused?  Guessing this was possible X Hi init values,
; 	; though always zero (maybe there would've been multiple
; 	; islands?  Per group of worlds?)
; 	.byte $00, $00, $00	; World 1 - 3
; 	.byte $00, $00, $00	; World 4 - 6
; 	.byte $00, $00, $00	; World 7 - 9

; 	; Starting X position depending on what world you came from
; Map_WW_IslandX:
; 	.byte $40, $40, $40	; World 1 - 3
; 	.byte $40, $40, $40	; World 4 - 6
; 	.byte $80, $80, $80  	; World 7 - 9


; Map_DoMap_WarpWind_FX:

; 	; Note: In original Japanese version, you could warp from a canoe and then
; 	; sail yourself off the warp island (but never get back on!)  This fixes 
; 	; that bug with a vengeance, since it will be called several times :)
; 	LDA #$00	 	
; 	STA Map_InCanoe_Flag	; Map_InCanoe_Flag = 0 (not in canoe)

; 	; NOTE: If Map_WarpWind_FX = 0,  Map_DoMap_WarpWind_FX is never called,
; 	; so state 0 is technically never used... that's okay, it actually
; 	; contains a "bug", which might just be unmaintained legacy code..

; 	; Dynamic jump based on current map special effect occurring..
; 	LDA <Map_WarpWind_FX	
; 	JSR DynJump

; 	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
; 	.word WWFX_WarpWhistleInit	; 0 - Initializes the warp whistle (NEVER USED, Inv_UseItem_WarpWhistle does this instead)
; 	.word WWFX_WarpWhistleFlash	; 1 - Does the "flash" effect of the whistle
; 	.word WWFX_WarpDoWind		; 2 - Does the wind effect, catches the Player, sets World_Num = 8 (World 9), and clears map objects
; 	.word WWFX_WarpIslandInit	; 3 - Initialize stuff for the warp island, including setting proper Player X/Y position
; 	.word WWFX_WarpLanding		; 4 - Does the wind effect, drops Player off
; 	.word WWFX_WarpWhistleFlash	; 5 - UNUSED; same as State 1, except it will crash by trying to go to undefined "State 6"!

; WarpWhistle_Flash:
; 	LDA <Map_WWOrHT_Cnt
; 	BNE PRG011_A333	 	; If Map_WWOrHT_Cnt <> 0, jump to PRG011_A333

; 	LDA #$20	 
; 	STA <Map_WWOrHT_Cnt	; Otherwise, Map_WWOrHT_Cnt = $20


; PRG011_A333:

; 	; Basically here's what does the white flashing effect
; 	LDY #%00011000		; Show BG + Sprites
; 	DEC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt--
; 	AND #$04	 
; 	BEQ PRG011_A33D	 	; Every 4 ticks, toggle mono effect
; 	LDY #%00011001		; Show BG + Sprites + Mono

; PRG011_A33D:
; 	STY <PPU_CTL2_Copy	; Update
; 	RTS		 	; Return...

; WWFX_WarpWhistleInit:

; 	; *** WWFX_WarpWhistleInit is NEVER USED, Inv_UseItem_WarpWhistle does this instead!

; 	LDY Player_Current	; Y = Player_Current
; 	LDX #$00	 	; X = 0 (come from left)
; 	LDA World_Map_X,Y	; Get Player's world map X coordinate
; 	SUB <Horz_Scroll
; 	CMP #$80	 	
; 	BGE PRG011_A351	 	; If map is scrolled halfway across, jump to PRG011_A351
; 	LDX #$01	 	; Otherwise X = 1 (come from right)

; PRG011_A351:
; 	STX <Map_WWOrHT_Dir	; Store 'X' as direction of warp wind travel

; 	LDA Map_WW_StartX,X
; 	STA <Map_WWOrHT_X	; Set appropriate starting X position

; 	LDA World_Map_Y,Y	
; 	STA <Map_WWOrHT_Y	; Set Y position equal to Player
; 	STA Map_PlyrSprOvrY	; Set Map_PlyrSprOvrY 

; 	LDX #$05	 	; X = 5 NOTE: This is broken (and seems unused anyway); see NOTE @ PRG011_A381

; 	LDA Map_WW_Backup_Y	; Load the backed up Y position
; 	BNE PRG011_A381	 	; If its non-zero, jump to PRG011_A381

; 	; Otherwise, we need to back up everything!  (Y is the only one that absolutely could not be zero)
; 	; But I don't know why?
; 	LDA World_Map_Y,Y
; 	STA Map_WW_Backup_Y	; Store Player's map Y position

; 	LDA World_Map_X,Y	
; 	STA Map_WW_Backup_X	; Store Player's map X position

; 	LDA World_Map_XHi,Y	
; 	STA Map_WW_Backup_XH	; Store Player's map X Hi position

; 	LDA Map_UnusedPlayerVal2,Y	
; 	STA Map_WW_Backup_UPV2	; Store Player's Map_WW_Backup_UPV2

; 	LDX #$01	 	; X = 1

; PRG011_A381:
; 	; NOTE: There's an alternate state 5 here that by the jump table is the same
; 	; as state 1, in theory if it flashes after the backup has already been performed.
; 	; Couple of problems: Why the backup already be performed?  And the other
; 	; problem is there's nothing after state 5, yet the state code will blindly
; 	; increment the state when it finishes, resulting in a crash!
; 	; I'm thinking that's some kind of lost state for something else?

; 	; But that's okay, because technically this routine isn't used anyway! :X

; 	STX <Map_WarpWind_FX		; Map_WarpWind_FX = ... 5 if backup already performed, 1 if not 
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; WWFX_WarpWhistleFlash:
; 	LDA Sound_QMusic2
; 	CMP #MUS2A_WARPWHISTLE	 
; 	BEQ PRG011_A396	 		; If Sound_QMusic2 <> MUS2A_WARPWHISTLE, jump to PRG011_A396

; 	JSR WarpWhistle_Flash		; Do the "flash" effect of the warp whistle

; 	LDA <Map_WWOrHT_Cnt
; 	BNE PRG011_A396	 		; If the counter isn't zero yet, jump to PRG011_A396

; 	INC <Map_WarpWind_FX		; Otherwise, next state!

; PRG011_A396:
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; WWFX_WarpDoWind:
; 	INC <Map_WWOrHT_Cnt		; Map_WWOrHT_Cnt++

; 	LDY Player_Current	 	; Y = Player_Current
; 	LDX <Map_WWOrHT_Dir		; X = Map_WWOrHT_Dir

; 	LDA <Map_WWOrHT_X
; 	ADD Map_WW_DeltaX,X
; 	STA <Map_WWOrHT_X		; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

; 	LDA World_Map_X,Y
; 	SUB <Horz_Scroll
; 	CMP <Map_WWOrHT_X
; 	BNE PRG011_A3BA	 		; If warp wind hasn't hit the Player yet, jump to PRG011_A3BA

; 	LDA #$f8
; 	STA Map_PlyrSprOvrY	 	; Map_PlyrSprOvrY = $F8 (will erase Player's map sprite)
; 	JMP PRG011_A3D9	 		; Jump to PRG011_A3D9...

; PRG011_A3BA:
; 	; Haven't hit the Player yet...
; 	LDA <Map_WWOrHT_X		
; 	CMP Map_WW_TargetX,X
; 	BNE PRG011_A3D9	 		; If Warp Wind hasn't reached its target edge yet, jump to PRG011_A3D9

; 	LDA World_Num	 	
; 	STA Map_Warp_PrevWorld	 	; Map_Warp_PrevWorld = World_Num (where you're coming FROM)

; 	LDA #$08	 
; 	STA World_Num	 		; World_Num = 8 (World 9)

; 	; Clears out map objects 
; 	LDY #(MAPOBJ_TOTAL-1) ; Y = (MAPOBJ_TOTAL-1)
; 	LDA #MAPOBJ_EMPTY ; A = MAPOBJ_EMPTY
; PRG011_A3D0:
; 	STA Map_Objects_IDs,Y
; 	DEY		 ; Y--
; 	BPL PRG011_A3D0	 ; If Y >= 0, loop..

; 	INC <Map_WarpWind_FX		; Next state...
; 	RTS		 ; Return

; PRG011_A3D9:
; 	JSR WorldMap_UpdateAndDraw	; Update and draw map

; 	LDA <Map_WWOrHT_X
; 	STA <Temp_Var2			; Temp_Var2 = Map_WWOrHT_X

; 	LDA #$01
; 	STA <Temp_Var3		 	; Temp_Var3 = 1 (uses palette 1, the white color; otherwise would use hand trap stuff)

; 	JMP WarpWindHandTrap_Draw	 		; Jump to WarpWindHandTrap_Draw...


; WWFX_WarpIslandInit:
; 	LDA #$00
; 	STA <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt = 0

; 	LDA #248
; 	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248 (overwritten further down... oops?)
; 	INC <Map_WarpWind_FX	; Next state...

; 	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld
; 	LDX Player_Current	; X = Map_Warp_PrevWorld

; 	; Clears all map X related variables
; 	LDA #$00
; 	STA Map_Prev_XOff,X
; 	STA Map_Prev_XHi,X
; 	STA <World_Map_XHi,X

; 	LDA Map_WW_IslandX,Y
; 	STA <World_Map_X,X	; Store appropriate X coordinate based on world you came from

; 	LDA #240
; LT0:	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 240 (oops, reassigned?)

; 	LDA Map_WW_IslandY,Y
; 	STA <Map_WWOrHT_Y	; Store appropriate Y coordinate based on world you came from

; 	LDA #$80	 
; 	STA Map_Intro_Tick	; Map_Intro_Tick = $80

; 	LDA #$01	
; 	STA Map_ReturnStatus	 ; Map_ReturnStatus = 3 (??)

; 	RTS		 ; Return

; WWFX_WarpLanding:
; 	LDA #$00	 
; 	STA Map_ReturnStatus 	; Map_ReturnStatus = 0 (was just set to 3?)

; 	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (reassigned not two instructions later!)
; 	LDX Player_Current	; X = Player_Current

; 	INC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt++

; 	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (assigned again??)
; 	LDX <Map_WWOrHT_Dir	; X = Map_WWOrHT_Dir

; 	LDA <Map_WWOrHT_X
; 	ADD Map_WW_DeltaX,X	; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

; 	STA <Map_WWOrHT_X
; 	CMP Map_WW_IslandX,Y
; 	BNE PRG011_A44C	 	; If wind hasn't reached your landing point, jump to PRG011_A44C

; 	LDX Player_Current	; X = Player_Current

; 	LDA Map_WW_IslandY,Y
; 	STA Map_PlyrSprOvrY	; Map_PlyrSprOvrY = Map_WW_IslandY[Y] (target Y) (restore map sprite)
; 	STA <World_Map_Y,X	; World_Map_Y = Map_WW_IslandY[Y] (target Y)

; 	JMP PRG011_A45B	 	; Jump to PRG011_A45B

; PRG011_A44C:
; 	; Wind hasn't reached landing point... (or is passed it already, as the case may be)

; 	CMP Map_WW_TargetX,X
; 	BNE PRG011_A45B	 	; If warp wind hasn't hit the appropriate edge, jump to PRG011_A45B

; 	; Otherwise, shut it down!
; 	LDA #$00	 
; 	STA <Map_WWOrHT_Cnt
; 	STA <Map_WarpWind_FX

; 	LDA #248
; 	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248

; PRG011_A45B:
; 	JMP PRG011_A3D9	 ; Jump to PRG011_A3D9


; MO_HandTrap:
; 	LDA Map_HandState
; 	JSR DynJump	 

; 	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
; 	.word HT_Init
; 	.word HT_Flash
; 	.word HT_GrabPlayer

; HT_Init:
; 	LDX Player_Current
; 	LDA <World_Map_Y,X
; 	STA Map_PlyrSprOvrY	; Reset Map_PlyrSprOvrY to the Player's current Y

; 	ADD #16
; 	STA <Map_WWOrHT_Y	; Start 16 pixels beneath Player

; 	; Match Player's X
; 	LDA <World_Map_XHi,X	 
; 	STA <Map_HandTrap_XHi	
; 	LDA <World_Map_X,X
; 	STA <Map_WWOrHT_X

; 	INC Map_HandState		; Next state...
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

; HT_Flash:
; 	JSR WarpWhistle_Flash	 	; Reused flashing effect

; 	LDA <Map_WWOrHT_Cnt
; 	BNE PRG011_A494	 		; If Map_WWOrHT_Cnt <> 0, the effect is not over, jump to PRG011_A494

; 	INC Map_HandState	 	; Next state...

; 	LDA #SND_LEVELRISE	 
; 	STA Sound_QLevel1		; "Rising" sound

; PRG011_A494:
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; HT_GrabPlayer:
; 	LDA #$01
; 	STA <Temp_Var1			; Temp_Var1 = 1

; 	JSR HT_DoRaiseAndFall	 	; Raise hand, take Player down with it

; 	LDA <Map_WWOrHT_Cnt
; 	CMP #32 
; 	BNE PRG011_A4B8	 		; If Map_WWOrHT_Cnt <> 32, jump to PRG011_A4B8

; 	LDA #$10
; 	STA Map_Operation	 	; Map_Operation = $10 (enter level)

; 	LDX Player_Current
; 	LDA #$00	 
; 	STA Map_Player_SkidBack,X	; Map_Player_SkidBack = 0
; 	STA World_EnterState		; World_EnterState = 0
; 	STA Map_HandState	 	; The multipurpose state variable is reset
; 	RTS		 		; Return...


; PRG011_A4B8:
; 	JSR WorldMap_UpdateAndDraw	; Do WorldMap_UpdateAndDraw

; 	LDX Player_Current
; 	LDA <World_Map_Y,X
; 	ADD #16
; 	STA <Temp_Var1		 	; Temp_Var1 = Player's map Y + 16

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	STA <Temp_Var2		 	; Temp_Var2 = Player's map X - Horz_Scroll

; 	LDA #$00
; 	STA <Temp_Var3		 	; Temp_Var3 = 0
; 	JMP PRG011_A503	 		; Jump to PRG011_A503

; 	; Hand Trap raises for 16 ticks (-1), then falls (1)
; HT_RaiseFall:	.byte -1, 1

; HT_DoRaiseAndFall:
; 	LDA <Counter_1
; 	AND #$01	
; 	BNE PRG011_A4FC	 	; Every other tic, jump to PRG011_A4FC

; 	; More specifically, 16 tics for the hand to come up, 16
; 	; tics for the hand to go down...
; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10	 	; Every 16 counter tics...
; 	LSR A	
; 	LSR A	
; 	LSR A	
; 	LSR A		 	; Amounts to 0/1 every 16 tics
; 	TAY		 	; Y = 0 or 1
; 	LDX Player_Current	; X = Player_Current

; 	LDA <Map_WWOrHT_Y
; 	ADD HT_RaiseFall,Y
; 	STA <Map_WWOrHT_Y	; Hand trap's Y += HT_RaiseFall[Y]

; 	INC <Map_WWOrHT_Cnt
; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10
; 	BEQ PRG011_A4FC	 	; If hand is still raising (pre 16 ticks), jump to PRG011_A4FC

; 	; As hand falls, it takes Player down with it!
; 	LDA <Map_WWOrHT_Y	
; 	STA Map_PlyrSprOvrY	

; PRG011_A4FC:
; 	RTS		 	; Return...

; 	; NOTE: These values are shared with the HAND TRAP of World 8
; Map_WW_Pal:	.byte $01, $03	; The former is a BROWN color (hand trap), the latter is its white color
; Map_WW_Pattern:
; 	.byte $59, $51	; Frame 0 (Hand, Wind)
; 	.byte $5D, $55	; Frame 1 (Hand, Wind)

; PRG011_A503:

; 	; This masks the bottom of the hand by deliberately drawing 8 junk sprites
; 	; 16 pixels beneath it to force the hardware to stop drawing at that 
; 	; scanline; it's dirty, but effective -- so long as no other sprites
; 	; are on that scanline to be noticeably effected :)
; 	LDX #$07	 ; X = 7
; PRG011_A505:
; 	TXA		 
; 	ASL A		 
; 	ASL A		 
; 	TAY		 	; Y = X << 2 (* 4, or for 7 sprites...)

; 	LDA <Temp_Var1
; 	STA Sprite_RAM+$00,Y	; Store Y

; 	LDA #$27	 
; 	STA Sprite_RAM+$01,Y	; Pattern

; 	LDA #%00100011
; 	STA Sprite_RAM+$02,Y	; Place sprite behind BG, flipped horizontally and vertically

; 	LDA #$00	 
; 	STA Sprite_RAM+$03,Y	; X = 0

; 	DEX		 	; X--
; 	BPL PRG011_A505	 	; While X >= 0, loop!

; WarpWindHandTrap_Draw:
; 	LDX <Temp_Var3		; X = Temp_Var3 (warp wind palette)

; 	; The warp wind sprite Y
; 	LDA <Map_WWOrHT_Y	; A = Map_WWOrHT_Y
; 	STA Sprite_RAM+$60
; 	STA Sprite_RAM+$64

; 	LDA <Temp_Var3		; A = Temp_Var3
; 	BEQ PRG011_A544	 	; If Temp_Var3 = 0, jump to PRG011_A544 (AFAIK, this is never the case)

; 	LDA Map_PlyrSprOvrY
; 	CMP #$f8
; 	BNE PRG011_A56B	 	; If Map_PlyrSprOvrY <> $f8, jump to PRG011_A56B

; 	; Disable Player map sprite!
; 	STA Sprite_RAM+$84
; 	STA Sprite_RAM+$88
; 	STA Sprite_RAM+$8C
; 	STA Sprite_RAM+$90

; 	JMP PRG011_A56B	 	; Jump to PRG011_A56B...

; PRG011_A544:
; 	; Otherwise, not disabling Player map sprite...

; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10
; 	BEQ PRG011_A56B

; 	; Restore Player's map sprite Y
; 	LDA Map_PlyrSprOvrY
; 	STA Sprite_RAM+$8C
; 	STA Sprite_RAM+$90
; 	SUB #16
; 	STA Sprite_RAM+$84
; 	STA Sprite_RAM+$88

; 	LDA Sprite_RAM+$85
; 	CMP #$27	 
; 	BNE PRG011_A56B	 	; If the pattern in use is not $27, jump to PRG011_A56B

; 	; Otherwise, disable half the sprite
; 	LDA #$f8	 
; 	STA Sprite_RAM+$84
; 	STA Sprite_RAM+$88

; PRG011_A56B:
; 	; Set the warp wind's attributes (white palette)
; 	LDA Map_WW_Pal,X
; 	STA Sprite_RAM+$62
; 	STA Sprite_RAM+$66

; 	; Set the warp wind's X
; 	LDA <Temp_Var2		; Map_WWOrHT_X
; 	STA Sprite_RAM+$63
; 	ADD #$08	 
; 	STA Sprite_RAM+$67	; Map_WWOrHT_X + 8

; 	LDY Map_WW_Pattern,X	; Get the pattern for the wind/hand

; 	LDA <Map_WWOrHT_Cnt
; 	AND #$10	 
; 	BEQ PRG011_A58B	 
; 	LDY Map_WW_Pattern+2,X	; Every 16 tics, use the second frame

; PRG011_A58B:
; 	; Store the pattern for the first sprite
; 	STY Sprite_RAM+$61

; 	INY	
; 	INY			; Pattern += 2
; 	STY Sprite_RAM+$65	; Store the pattern for the second sprite

; 	LDA <Map_WWOrHT_Dir
; 	BEQ PRG011_A5AA	 	; If Map_WWOrHT_Dir = 0, jump to PRG011_A5AA

; 	; Flip the wind patterns!
; 	STY Sprite_RAM+$61
; 	DEY		
; 	DEY		
; 	STY Sprite_RAM+$65

; 	; Set the flip attribute
; 	LDA Sprite_RAM+$62	; Get old attributes
; 	ORA #$40	 	; H-Flip attr
; 	STA Sprite_RAM+$62	
; 	STA Sprite_RAM+$66	

; PRG011_A5AA:

; 	; This draw a couple high-priority sprites at the border's edge 
; 	; using border patterns to clip the warp wind sprite!

; 	; Sprite set to Y
; 	LDA <Map_WWOrHT_Y
; 	STA Sprite_RAM+$00
; 	STA Sprite_RAM+$04

; 	; Pattern 1
; 	LDA #$01	 
; 	STA Sprite_RAM+$01

; 	; Pattern $B
; 	LDA #$0b	 
; 	STA Sprite_RAM+$05

; 	; Attributes
; 	LDA #$01	 
; 	STA Sprite_RAM+$02
; 	STA Sprite_RAM+$06

; 	; And X = 1
; 	STA Sprite_RAM+$07

; 	; And X = 8
; 	LDA #$08	 
; 	STA Sprite_RAM+$03

; 	LDA <Temp_Var2	 ; MapWWOrHT_X
; 	AND #$80	 
; 	BEQ PRG011_A5DC	 ; If MapWWOrHT_X is not in the right half of the screen, jump to PRG011_A5DC (RTS)

; 	; Otherwise, put the border patch on the RIGHT side!
; 	LDA #$f0	
; 	STA Sprite_RAM+$03
; 	LDA #$f8	 
; 	STA Sprite_RAM+$07

; PRG011_A5DC:
; 	RTS		 ; Return

; GameOver_TwirlToStart:
; 	LDX Player_Current	 

; 	LDA <Map_SkidBack
; 	BNE PRG011_A63D	 ; If Map_SkidBack is set, jump to PRG011_A63D

; 	LDY World_Num	 ; Y = World_Num

; 	LDA <World_Map_Y,X
; 	SUB Map_Y_Starts,Y
; 	STA <Map_Skid_DeltaY

; 	LDA <World_Map_X,X
; 	SUB #$20
; 	STA <Map_Skid_DeltaX

; 	LDA #$00
; 	STA <Map_Skid_TravDirs
; 	STA <Map_Skid_DeltaFracX
; 	STA <Map_Skid_DeltaFracY

; 	LDA <World_Map_X,X
; 	CMP #32
; 	BGE PRG011_A610	 ; If Player's Map X >= 32 (the common start X of all maps), jump to PRG011_A610

; 	; Player's Map X < 32...

; 	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
; 	LDA #$01
; 	STA <Map_Skid_TravDirs

; 	; Negate Map_Skid_DeltaX
; 	LDA #$ff
; 	EOR <Map_Skid_DeltaX
; 	TAY
; 	INY
; 	STY <Map_Skid_DeltaX

; PRG011_A610:
; 	LDY World_Num	 ; Y = World_Num

; 	LDA <World_Map_Y,X
; 	CMP Map_Y_Starts,Y
; 	BGE PRG011_A628	 ; If Player's Map Y >= the starting Y of the map, jump to PRG011_A628

; 	; Player's Map Y < the starting Y of the map...

; 	; Negate Map_Skid_DeltaY
; 	LDA #$ff
; 	EOR <Map_Skid_DeltaY
; 	TAY
; 	INY
; 	STY <Map_Skid_DeltaY

; 	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
; 	LDA <Map_Skid_TravDirs
; 	ORA #$02
; 	STA <Map_Skid_TravDirs

; PRG011_A628:

; 	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
; 	LDY #$04	 ; Y = 4
; PRG011_A62A:
; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
; 	ROR <Map_Skid_DeltaFracY		; Set as bit 7 of Map_Skid_DeltaFracY

; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
; 	ROR <Map_Skid_DeltaFracX		; Set as bit 7 of Map_Skid_DeltaFracX

; 	DEY			; Y--
; 	BPL PRG011_A62A		; While Y >= 0, loop!

; 	; Map_Skid_Counter = $20
; 	LDA #$20
; 	STA <Map_Skid_Counter

; 	INC <Map_SkidBack		 ; Set Map_SkidBack

; PRG011_A63D:

; 	; Skid sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A65E	 ; If Player is traveling left, jump to PRG011_A65E

; 	; Traveling to the right...

; 	; Map_Skid_FracX += Map_Skid_DeltaFracX
; 	LDA <Map_Skid_FracX
; 	ADD <Map_Skid_DeltaFracX
; 	STA <Map_Skid_FracX

; 	; Add and carry into the full X
; 	LDA <World_Map_X,X
; 	ADC <Map_Skid_DeltaX
; 	STA <World_Map_X,X

; 	; Any additional carry into Map XHi
; 	LDA <World_Map_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	JMP PRG011_A671	 ; Jump to PRG011_A671

; PRG011_A65E:

; 	; Traveling to the left

; 	; Map_Skid_FracX -= Map_Skid_DeltaFracX
; 	LDA <Map_Skid_FracX
; 	SUB <Map_Skid_DeltaFracX
; 	STA <Map_Skid_FracX

; 	; Subtract and carry into the full X
; 	LDA <World_Map_X,X
; 	SBC <Map_Skid_DeltaX
; 	STA <World_Map_X,X

; 	; Any additional carry into Map XHi
; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; PRG011_A671:
; 	LDA <Map_Skid_TravDirs
; 	AND #$02
; 	BEQ PRG011_A687	 ; If Player is traveling up, jump to PRG011_A65E

; 	; Traveling downward

; 	; Map_Skid_FracY += Map_Skid_DeltaFracY
; 	LDA <Map_Skid_FracY
; 	ADD <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	; Add and carry into the full Y
; 	LDA <World_Map_Y,X
; 	ADC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; 	JMP PRG011_A694	 ; Jump to PRG011_A694

; PRG011_A687:

; 	; Traveling downward

; 	; Map_Skid_FracY -= Map_Skid_DeltaFracY
; 	LDA <Map_Skid_FracY
; 	SUB <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	; Subtract and carry into the full Y
; 	LDA <World_Map_Y,X
; 	SBC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; PRG011_A694:
; 	DEC <Map_Skid_Counter	; Map_Skid_Counter--
; 	BNE PRG011_A6BC	 ; If Map_Skid_Counter <> 0, jump to PRG011_A6BC

; PRG011_A698:
; 	; GameOver_State = 8 (we've landed, we're done)
; 	LDA #$08
; 	STA GameOver_State

; 	LDX Player_Current	 ; X = Player_Current

; 	LDA #$00
; 	STA <Map_SkidBack
; 	STA World_Map_Twirl,X	 ; Twirling is done
; 	STA Map_Prev_XOff2,X
; 	STA Map_Prev_XHi2,X

; 	; Set the previous values at the twirl landing spot

; 	; Map_Previous_Y = World_Map_Y
; 	LDA <World_Map_Y,X
; 	STA Map_Previous_Y,X

; 	; Map_Previous_X/Hi = Map_Previous_X/Hi
; 	LDA <World_Map_XHi,X
; 	STA Map_Previous_XHi,X
; 	LDA <World_Map_X,X
; 	STA Map_Previous_X,X

; PRG011_A6BC:
; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; GameOver_TwirlFromAfar:
; 	LDX Player_Current	 ; X = Player_Current

; 	; Map X -= 2 (Player flying from way off goes directly left)
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X
; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	BNE PRG011_A6E4	 ; If Player Map X <> Horz_Scroll, jump to PRG011_A6E4

; 	LDA #$00
; 	STA Map_Prev_XOff,X
; 	STA Map_Prev_XHi,X
; 	STA Map_Entered_XHi,X

; 	INC GameOver_State	 ; GameOver_State++

; PRG011_A6E4:

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	JSR Map_DrawBorderForPlayer	 ; Draw border sprites to cover twirling Player

; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


; Map_DrawBorderForPlayer:
; 	LDX Player_Current	; X = Player_Current

; 	; Set Map Border Sprite Y
; 	LDA <World_Map_Y,X
; 	STA Sprite_RAM+$00
; 	STA Sprite_RAM+$04

; 	; Set Map Border Sprite left Pattern
; 	LDA #$01
; 	STA Sprite_RAM+$01

; 	; Set Map Border Sprite right Pattern
; 	LDA #$0b
; 	STA Sprite_RAM+$05

; 	; Set Map Border Sprite attributes
; 	LDA #SPR_PAL0
; 	STA Sprite_RAM+$02
; 	STA Sprite_RAM+$06

; 	; Set Map Border left Sprite X
; 	STA Sprite_RAM+$07

; 	; Set Map Border right Sprite X
; 	LDA #$08
; 	STA Sprite_RAM+$03

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	AND #$80
; 	BEQ PRG011_A727	 ; If difference is positive, jump to PRG011_A727 (RTS)

; 	; Set Map Border Sprite X
; 	LDA #240
; 	STA Sprite_RAM+$03
; 	LDA #248
; 	STA Sprite_RAM+$07

; PRG011_A727:
; 	RTS		 ; Return


; GameOver_AlignToStartY
; 	LDX Player_Current	 ; X = Player_Current

; 	; Enter from right side
; 	LDA #240
; 	STA <World_Map_X,X

; 	LDY World_Num		 ; Y = World_Num
; 	LDA Map_Y_Starts,Y	 ; Get start Y
; 	STA <World_Map_Y,X	 ; Set Player at start Y

; 	INC GameOver_State	 ; GameOver_State++
; 	JMP PRG011_A6E4	 	; Jump to PRG011_A6E4

; GameOver_ReturnToStartX:
; 	LDX Player_Current	 ; X = Player_Current

; 	; Player's Map X -= 2 (skidding towards Start panel)
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X

; 	CMP #$20
; 	BNE PRG011_A74E	 ; If Player is not at $20 (fixed start point X), jump to PRG011_A74E

; 	JMP PRG011_A698	 ; Jump to PRG011_A698

; PRG011_A74E:

; 	; Play skidding sound (actually pointless from where it jumps)
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	JMP PRG011_A6E4	 ; Jump to PRG011_A6E4

; MO_SkidToPrev:
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <Map_SkidBack
; 	BEQ PRG011_A760	 ; If Map_SkidBack is not set, jump to PRG011_A760

; 	JMP PRG011_A834	 ; Jump to PRG011_A834

; PRG011_A760:

; 	; Checks all map objects to see if Player has died while in a map object

; 	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1)
; PRG011_A762:
; 	LDA Map_Objects_IDs,Y
; 	BNE PRG011_A76D	 ; If this map object slot is not empty, jump to PRG011_A76D

; PRG011_A767:
; 	DEY		 ; Y--
; 	BNE PRG011_A762	 ; While Y > 0, loop!  (Ignores the HELP bubble)
; 	JMP PRG011_A79D	 ; Jump to PRG011_A79D

; PRG011_A76D:

; 	; If Player is not on top of the airship, jump to PRG011_A767
; 	LDA <World_Map_Y,X
; 	CMP Map_Objects_Y,Y
; 	BNE PRG011_A767

; 	LDA <World_Map_XHi,X
; 	CMP Map_Objects_XHi,Y
; 	BNE PRG011_A767

; 	LDA <World_Map_X,X
; 	CMP Map_Objects_XLo,Y
; 	BNE PRG011_A767

; 	JMP PRG011_A791

; 	; Player is on top of the airship
; 	; NOTE: Assumes Index 1 is the Airship!

; 	; Set airship count = $20 (orders it to scurry away)
; 	LDA #$20
; 	STA Map_March_Count+1

; 	JMP PRG011_A767	 ; Jump to PRG011_A767

; PRG011_A791:
; 	JMP PRG011_A767	 ; If this is NOT a Coin Ship, jump to PRG011_A767


; 	JMP PRG011_A767	 ; Jump to PRG011_A767

; PRG011_A79D:

; 	; Player died on top of something not an Airship or a Coin ship...

; 	LDA Map_Previous_Y,X
; 	SUB <World_Map_Y,X
; 	STA <Map_Skid_DeltaY

; 	LDA Map_Previous_XHi,X
; 	CMP <World_Map_XHi,X
; 	BEQ PRG011_A7B0	 ; If Player is on the same map screen as he was before, jump to PRG011_A7B0
; 	BGE PRG011_A7B7	 ; If Player is on a map screen to the right, jump to PRG011_A7B7
; 	BLT PRG011_A7CB	 ; If Player is on a map screen to the left, jump to PRG011_A7CB

; PRG011_A7B0:

; 	; Player is on the same map screen he was previously...

; 	LDA Map_Previous_X,X
; 	CMP <World_Map_X,X
; 	BLT PRG011_A7CB	 ; If Player is to the left from where he was, jump to PRG011_A7CB

; PRG011_A7B7:

; 	; Player is to the right from where he was...

; 	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
; 	LDA Map_Previous_X,X
; 	SUB <World_Map_X,X
; 	STA <Map_Skid_DeltaFracX

; 	; Map_Skid_DeltaX starts as straight difference in X Hi
; 	LDA Map_Previous_XHi,X
; 	SBC <World_Map_XHi,X	
; 	STA <Map_Skid_DeltaX

; 	; Do not set bit 0 on Map_Skid_TravDirs (travel left instead of right)
; 	LDY #$00	 ; Y = 0

; 	JMP PRG011_A7DC	 ; Jump to PRG011_A7DC

; PRG011_A7CB:

; 	; Player is to the left from where he was

; 	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
; 	LDA <World_Map_X,X
; 	SUB Map_Previous_X,X
; 	STA <Map_Skid_DeltaFracX

; 	; Map_Skid_DeltaX starts as straight difference in X Hi
; 	LDA <World_Map_XHi,X
; 	SBC Map_Previous_XHi,X
; 	STA <Map_Skid_DeltaX

; 	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
; 	LDY #$01	 ; Y = 1

; PRG011_A7DC:
; 	STY <Map_Skid_TravDirs	 ; Set Map_Skid_TravDirs

; 	LDA #$00
; 	STA <Map_Skid_FracX
; 	STA <Map_Skid_DeltaFracY

; 	LDA Map_Previous_Y,X
; 	CMP <World_Map_Y,X
; 	BGE PRG011_A7F9	 ; If Player is lower than he was before, jump to PRG011_A7F9

; 	; Player was higher than before... negate Map_Skid_DeltaY
; 	LDA #$ff
; 	EOR <Map_Skid_DeltaY
; 	TAY
; 	INY
; 	STY <Map_Skid_DeltaY

; 	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
; 	LDA <Map_Skid_TravDirs
; 	ORA #$02
; 	STA <Map_Skid_TravDirs

; PRG011_A7F9:
; 	LDA <Map_Skid_DeltaX
; 	BNE PRG011_A817	 ; If Player is left/right of where he was before, jump to PRG011_A817

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	TAY

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BNE PRG011_A811	 ; If Player is traveling right, jump to PRG011_A811

; 	TYA
; 	ADD <Map_Skid_DeltaFracX
; 	BCC PRG011_A81D	 ; If no carry, jump to PRG011_A81D
; 	BCS PRG011_A817	 ; Otherwise, jump to PRG011_A817

; PRG011_A811:
; 	TYA
; 	SUB <Map_Skid_DeltaFracX
; 	BCS PRG011_A81D	 ; If carry set, jump to PRG011_A81D

; PRG011_A817:
; 	INC Map_Operation	 ; Map_Operation++ (go to the "twirl from afar" state)
; 	JMP MO_SkidToPrevAfar	 ; Jump to MO_SkidToPrevAfar

; PRG011_A81D:

; 	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
; 	LDY #$04	 ; Y = 4
; PRG011_A81F:
; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
; 	ROR <Map_Skid_DeltaFracY	; Set as bit 7 of Map_Skid_DeltaFracY

; 	CLC		 ; Clear carry
; 	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
; 	ROR <Map_Skid_DeltaFracX	; Set as bit 7 of Map_Skid_DeltaFracX; Bit 0 -> Carry
; 	ROR <Map_Skid_FracX		; Set as bit 7 of <Map_Skid_FracX

; 	DEY			; Y--
; 	BPL PRG011_A81F		; While Y >= 0, loop!

; 	; Map_Skid_Counter = $20
; 	LDA #$20
; 	STA <Map_Skid_Counter

; 	INC <Map_SkidBack		 ; Set Map_SkidBack

; PRG011_A834:
; 	LDA <Map_Skid_Counter
; 	BEQ PRG011_A891	 ; If Map_Skid_Counter = 0, jump to PRG011_A891

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BNE PRG011_A859	 ; If Player is traveling right, jump to PRG011_A859

; 	LDA <Map_Skid_FracCarry
; 	ADD <Map_Skid_FracX
; 	STA <Map_Skid_FracCarry

; 	LDA <World_Map_X,X
; 	ADC <Map_Skid_DeltaFracX
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	ADC <Map_Skid_DeltaX
; 	STA <World_Map_XHi,X

; 	JMP PRG011_A86C	 ; Jump to PRG011_A86C

; PRG011_A859:
; 	LDA <Map_Skid_FracCarry
; 	SUB <Map_Skid_FracX
; 	STA <Map_Skid_FracCarry

; 	LDA <World_Map_X,X
; 	SBC <Map_Skid_DeltaFracX
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	SBC <Map_Skid_DeltaX
; 	STA <World_Map_XHi,X

; PRG011_A86C:
; 	LDA <Map_Skid_TravDirs
; 	AND #$02
; 	BNE PRG011_A882	 ; If Player is traveling down, jump to PRG011_A882

; 	LDA <Map_Skid_FracY
; 	ADD <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	LDA <World_Map_Y,X
; 	ADC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; 	JMP PRG011_A88F	 ; Jump to PRG011_A88F

; PRG011_A882:
; 	LDA <Map_Skid_FracY
; 	SUB <Map_Skid_DeltaFracY
; 	STA <Map_Skid_FracY

; 	LDA <World_Map_Y,X
; 	SBC <Map_Skid_DeltaY
; 	STA <World_Map_Y,X

; PRG011_A88F:
; 	DEC <Map_Skid_Counter		 ; Map_Skid_Counter--

; PRG011_A891:
; 	JSR WorldMap_UpdateAndDraw	 ; Update and draw map

; 	LDA <Map_Skid_Counter
; 	ORA Map_March_Count+1	; <--- Airship's movement counter
; 	ORA Map_Pan_Count
; 	BNE PRG011_A8C8	 ; If skidding, the airship is moving, or the map is panning, jump to PRG011_A8C8 (RTS)

; 	; Map_Operation = $0B (Hammer bros march around)
; 	LDA #$0b
; 	STA Map_Operation

; 	LDX Player_Current	 ; X = Player_Current

; 	; Ensure Player is precisely at his previous position
; 	LDA <World_Map_Y,X
; 	STA Map_Entered_Y,X
; 	LDA <World_Map_XHi,X
; 	STA Map_Entered_XHi,X
; 	LDA <World_Map_X,X
; 	STA Map_Entered_X,X

; 	LDA Map_Prev_XOff2,X
; 	STA Map_Prev_XOff,X

; 	LDA Map_Prev_XHi2,X
; 	STA Map_Prev_XHi,X

; 	; Clear skid vars
; 	LDA #$00
; 	STA <Map_SkidBack
; 	STA Map_Player_SkidBack,X

; PRG011_A8C8:
; 	RTS		 ; Return

; MO_SkidToPrevAfar:
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A8E9	 ; If Player is traveling left, jump to PRG011_A8E9

; 	; Far away Player skidding directly to the left; Map X -= 2
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X
; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	BEQ PRG011_A8FF	 ; If Player hit left edge, jump to PRG011_A8FF

; 	JMP PRG011_A90E	 ; Jump to PRG011_A90E

; PRG011_A8E9:

; 	; Far away Player skidding directly to the right; Map X += 2
; 	LDA <World_Map_X,X
; 	ADD #$02
; 	STA <World_Map_X,X
; 	LDA <World_Map_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	SUB <Horz_Scroll
; 	CMP #240
; 	BNE PRG011_A90E	 ; If Player has not hit right edge, jump to PRG011_A90E

; PRG011_A8FF:

; 	; Player hit edge of the screen

; 	LDA Map_Prev_XOff2,X
; 	STA Map_Prev_XOff,X

; 	LDA Map_Prev_XHi2,X
; 	STA Map_Prev_XHi,X

; 	INC Map_Operation	 ; Map_Operation++

; PRG011_A90E:

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	JSR Map_DrawBorderForPlayer	 ; Draw border to block Player sprite

; 	JMP WorldMap_UpdateAndDraw	 ; Update and draw map and don't come back!

; MO_SkidAfarPrep:
; 	LDX Player_Current	 ; X = Player_Current

; 	; Set Player's Y and XHi to their previous values
; 	LDA Map_Previous_Y,X
; 	STA <World_Map_Y,X
; 	LDA Map_Previous_XHi,X
; 	STA <World_Map_XHi,X

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A946	 ; If Player is traveling left, jump to PRG011_A946

; 	; Traveling rightward

; 	LDY #240	 ; Y = 240

; 	LDA <Horz_Scroll
; 	BEQ PRG011_A941		; If horizontal scroll = 0, jump to PRG011_A941

; 	LDA Map_Previous_X,X
; 	ADD <Horz_Scroll
	
; 	LDA Map_Previous_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	LDY #112	 ; Y = 112

; PRG011_A941:
; 	STY <World_Map_X,X ; Set proper World Map X to begin skidding from

; 	JMP PRG011_A95B	 ; Jump to PRG011_A95B

; PRG011_A946:

; 	; Traveling leftward

; 	LDA <Horz_Scroll
; 	BEQ PRG011_A957	 ; If Horz_Scroll = 0, jump to PRG011_A957

; 	LDA Map_Previous_X,X
; 	SUB <Horz_Scroll
; 	LDA Map_Previous_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; PRG011_A957:
; 	LDA <Horz_Scroll
; 	STA <World_Map_X,X

; PRG011_A95B:

; 	; Play skidding sound
; 	LDA #SND_LEVELSKID
; 	STA Sound_QLevel2

; 	INC Map_Operation	 ; Map_Operation++

; 	JMP PRG011_A90E	 ; Jump to PRG011_A90E

; MO_SkidAfarFinish:
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <Map_Skid_TravDirs
; 	AND #$01
; 	BEQ PRG011_A986	 ; If Player is traveling left, jump to PRG011_A946

; 	; Player traveling left

; 	; Map X -= 2
; 	LDA <World_Map_X,X
; 	SUB #$02
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	SBC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	CMP Map_Previous_X,X
; 	BEQ PRG011_A99A	 ; If Player Map X is at his previous X, jump to PRG011_A99A

; 	JMP PRG011_A9B5	 ; Otherwise, jump to PRG011_A9B5 (indirect to PRG011_A90E)

; PRG011_A986:

; 	; Player traveling right

; 	; Map X += 2
; 	LDA <World_Map_X,X
; 	ADD #$02
; 	STA <World_Map_X,X

; 	LDA <World_Map_XHi,X
; 	ADC #$00
; 	STA <World_Map_XHi,X

; 	LDA <World_Map_X,X
; 	CMP Map_Previous_X,X
; 	BNE PRG011_A9B5	 ; If Player Map X is not at his previous X, jump to PRG011_A9B5 (indirect to PRG011_A90E)

; PRG011_A99A:

; 	; Player has finally arrived at his "previous" position, completing the skid back from afar

; 	; Map_Operation = $0B (Hammer bros march around)
; 	LDA #$0b
; 	STA Map_Operation

; 	; Ensure Player is precisely at his previous position
; 	LDA <World_Map_Y,X
; 	STA Map_Entered_Y,X
; 	LDA <World_Map_XHi,X
; 	STA Map_Entered_XHi,X
; 	LDA <World_Map_X,X
; 	STA Map_Entered_X,X

; 	LDA #$00
; 	STA <Map_SkidBack
; 	STA Map_Player_SkidBack,X

; PRG011_A9B5:
; 	JMP PRG011_A90E	 ; Jump to PRG011_A90E

	; Indexed by Map_ClearLevelFXCnt * 2
Map_ClearLevelFXPatterns:

	; "Poof" effect
	.byte $45, $47	; 0
	.byte $45, $47	; 1
	.byte $49, $31	; 2
	.byte $49, $35	; 3
	.byte $49, $39	; 4
	.byte $49, $41	; 5

	; "Flip" effect
	.byte $B5, $B5	; 6
	.byte $A1, $A1	; 7
	.byte $B5, $B5	; 8

	; Indexed by Player and tile quadrant (except the last three which are hardcoded specific)

	; This just forces "poof" completion on the following tiles (in quadrant zero, since all other
	; quadrants always "poof" except fortress tiles)



; The old Coin Ship ruleset:
; 1.) End the stage with an even number on the clock.
; 2.) Coins must be a Multiple of 11.
; 3.) The 10â€²s digit of your score must be the multiple of 11 that corresponds to your coins.
; 4.) Finally it must be in World 1, 3, 5, and 6.
;	NOTE: The worlds that don't count are literally because there's no "Hammer Bro"
;	map objects there; the code doesn't actually care about the world number!

MapBonusChk_CoinShip:
	RTS

	; This will always appear at the same location!!
MAPOBJ_UNK0C_Y:	.byte $60
MAPOBJ_UNK0C_X:	.byte $60

MapBonusChk_MAPOBJ_UNK0C:
	RTS		 ; Return


	; This looks for an empty map object slot and returns the index in 'Y'
	; Assumes that the first two slots are always occupied...
	; NOTE: Dangerous!  If all slots are filled, this could loop for eternity
	; or return a bad index!  There's just an assumption of a free slot!
	;
	; A better implemention per what the rest of the engine would do is make
	; sure we don't loop beyond the last object ((MAPOBJ_TOTAL-1)) and in failure
	; "Do Not Return to Caller" (double PLA instruction), but oh well...
Map_FindEmptyObjectSlot:
	LDY #$02	 ; Y = 2
	
PRG011_AD9F:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADA8	 ; If this map object slot is empty, jump to PRG011_ADA8 (RTS)

	INY		 ; Y++
	JMP PRG011_AD9F	 ; Loop

PRG011_ADA8:
	RTS		 ; Return

Map_March_InitValues:
	; Initializes Map_March_Count values per Map_Object_ID
	; Generally the value is $20 (Marching time amount) and $00 (Don't march)
	; There's some restriction on these values because of internal ANDings.

	; Also, an object won't actually march unless it is tied into the march
	; function (check function pointer list @ PRG011_AE0B), but if it uses 
	; the Map_Object_Stationary function, it will briefly animate slightly
	; faster (as does a Hammer Brother marching around) due to a jump it
	; makes; this is used to make the World 7 Plant look ferocious (I suppose)
	; and would happen with World 8 stuff too, but they use $00 values so
	; the net effect is absolutely nothing.
	.byte $00	; None
	.byte $00	; HELP
	.byte $00	; Airship
	.byte $20	; Hammer Bro
	.byte $20	; Boomerang Bro
	.byte $20	; Heavy Bro
	.byte $20	; Fire Bro
	.byte $20	; World 7 Plant (doesn't really "go" anywhere, though!)
	.byte $20	; Unknown/unused marching glitch object
	.byte $00	; N-Spade
	.byte $00	; White Toad House
	.byte $20	; Coin Ship (does "sail" around the map)
	.byte $00	; Unknown white colorization of $0F (goes to World 7 level??)
	.byte $00	; World 8 Battleship
	.byte $00	; World 8 Tank
	.byte $00	; World 8 Airship
	.byte $00	; Canoe

	.byte $00, $00, $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Object_Do_All
;
; Runs update code on all map objects, e.g. what makes a 
; Hammer Brother march, an airship fly, etc.  Does NOT have
; anything to do with the interaction of the object, except
; for the canoe, which simply sets the "In Canoe" flag if
; the Player is standing in it.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Object_Do_All:

	LDY #(MAPOBJ_TOTAL-1) 	; Total map objects which may exist on the map (only 8 are defined at start)
	STY <Temp_Var13		; Temp_Var13 = $0D

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_ADE6	 	; If Map_Operation <> $0B (Hammer Bro marching around), jump to PRG011_ADE6

	LDA Map_MarchInit
	BNE PRG011_ADE6	 	; If Map_MarchInit is set, jump to PRG011_ADE6

PRG011_ADD2:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADDE	 	; If the object ID is zero, nothing to do, jump to PRG011_ADDE
	TAX		 	; X = A

	; Initialize all the map march values
	LDA Map_March_InitValues,X	; For this object's ID, get the init value
	STA Map_March_Count,Y	 	; Store it in this object's slot

PRG011_ADDE:
	DEY		 ; Y--
	CPY #$01	 
	BNE PRG011_ADD2	 ; While Y <> 1, loop!


	INC Map_MarchInit	 ; Set Map_MarchInit (March initialization complete!)

PRG011_ADE6:
	LDX <Temp_Var13		; X = Temp_Var13

	LDA Map_Objects_IDs,X
	BEQ PRG011_ADF0	 	; If the object ID is zero, nothing to do, jump to PRG011_ADF0

	JSR Map_Object_Do 	; Process this map object!

PRG011_ADF0:
	DEC <Temp_Var13		; Temp_Var13--
	BPL PRG011_ADE6	 	; While Temp_Var13 >= 0, loop!

PRG011_ADF4:
	RTS		 ; Return


Map_Object_Do:
	; Map object to do...
	JSR Map_Object_CheckVisibility	 ; Check and store if this object is visible

	LDA Map_Objects_IDs,X	; Get the ID

PRG011_AE0B:
	RTS
	; Based on the ID, jump to proper routine for how it should act on the map
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; None (Just RTS)
	.word PRG011_ADF4		; HELP (Just RTS)
	.word PRG011_ADF4	; Airship
	.word PRG011_ADF4		; Hammer Bro
	.word PRG011_ADF4		; Boomerang Bro
	.word PRG011_ADF4		; Heavy Bro
	.word PRG011_ADF4		; Fire Bro
	.word PRG011_ADF4	; World 7 Plant
	.word PRG011_ADF4		; Unknown marching glitch object
	.word PRG011_ADF4		; N-Spade
	.word PRG011_ADF4		; White Toad House
	.word PRG011_ADF4		; Coin Ship
	.word PRG011_ADF4	; Unknown white colorization of 15 (goes to World 7 level??)
	.word PRG011_ADF4	; World 8 Battleship
	.word PRG011_ADF4	; World 8 Tank
	.word PRG011_ADF4	; World 8 Airship
	.word PRG011_ADF4		; Canoe


MapObject_LeftTile:
	.byte $0D, $11, $15, $19	; 01=Rain
	.byte $2D, $31, $35, $39	; 02=Snow
	.byte $21, $21, $41, $41	; 03=Ship
	.byte $47, $47, $47, $47	; 04=wrecked Ship
	.byte $4D, $4D, $4D, $4D	; 05=Boo
	.byte $51, $51, $51, $51	; Red mushroom
	.byte $11, $11, $11, $11	;
	.byte $51, $51, $51, $51	; Green Mushroom
	.byte $51, $51, $51, $51	; Orange Mushroom
	.byte $61, $61, $63, $63	; Piranah Plant
	.byte $69, $6D, $6B, $6F	; Cheep
	.byte $71, $73, $75, $77	; Freezie
	.byte $55, $55, $55, $55	; Bullet Turret
	.byte $59, $5D, $5B, $5F	; Bobomb
	.byte $3D, $3D, $3D, $3D	; 0F = Piranha Stem
	.byte $FD, $1B, $FD, $1B	;
	.byte $71, $75, $71, $75	;

MapObject_RightTile:
	.byte $0F, $13, $17, $1B	; 01=Rain
	.byte $2F, $33, $37, $3B	; 02=Snow
	.byte $23, $23, $43, $43	; 03=Ship
	.byte $49, $49, $49, $49	; 04=wrecked Ship
	.byte $4F, $4F, $4F, $4F	; 05=Boo
	.byte $53, $53, $53, $53	; 06=Red mushroom
	.byte $11, $11, $11, $11	; 07=None
	.byte $53, $53, $53, $53	; 08=Blue Mushroom
	.byte $53, $53, $53, $53	; 09=Orange Mushroom
	.byte $61, $61, $63, $63	; 0A=Piranah Plant
	.byte $6B, $6F, $69, $6D	; 0B=Cheep
	.byte $4B, $4B, $4B, $4B	; 0C=Freezie
	.byte $57, $57, $57, $57	; 0D
	.byte $5B, $5F, $59, $5D	; 0E = Bobomb
	.byte $3D, $3D, $3D, $3D	; 0F = Piranha Stem
	.byte $FF, $BB, $FF, $BB	; 
	.byte $73, $77, $73, $77	; 

MapObject_AttrLeft:
	.byte $02, $02, $02, $02	; 01=Rain Cloud
	.byte $02, $02, $02, $02	; 02=Snow
	.byte $03, $03, $03, $03	; 03=Ship
	.byte $03, $03, $03, $03	; 04=wrecked Ship
	.byte $02, $02, $02, $02	; 05=Boo
	.byte $01, $01, $01, $01	; Red Mushroom
	.byte $02, $02, $02, $02	; None
	.byte $02, $02, $02, $02	; Blue Mushroom
	.byte $03, $03, $03, $03	; Orange Mushroom
	.byte SPR_PAL2, SPR_PAL2, SPR_PAL2, SPR_PAL2	; Piranha
	.byte SPR_PAL1, SPR_PAL1, (SPR_PAL1 | SPR_HFLIP), (SPR_PAL1 | SPR_HFLIP)	; Cheep
	.byte $02, $02, $02, $02	; Freezie
	.byte $03, $03, $03, $03	; Bullet Turret
	.byte SPR_PAL3, SPR_PAL3, (SPR_PAL3 | SPR_HFLIP), (SPR_PAL3 | SPR_HFLIP)	; 0E = Bobomb
	.byte SPR_PAL2, SPR_PAL2, SPR_PAL2, SPR_PAL2	; 0F = Piranha Stem
	.byte $01, $01, $01, $01	; 
	.byte $02, $02, $02, $02	; 

MapObject_AttrRight:
	.byte $02, $02, $02, $02	; 01=Rain Cloud
	.byte $02, $02, $02, $02	; 02=Snow
	.byte $03, $03, $03, $03	; 03=Ship
	.byte $03, $03, $03, $03	; 04=wrecked Ship
	.byte $02, $02, $02, $02	; 05=Boo
	.byte $01, $01, $01, $01	; Red Mushroom
	.byte $02, $02, $02, $02	; None
	.byte $02, $02, $02, $02	; Blue Mushroom
	.byte $03, $03, $03, $03	; Orange Mushroom
	.byte (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP)	; Piranha Plant
	.byte SPR_PAL1, SPR_PAL1, (SPR_PAL1 | SPR_HFLIP), (SPR_PAL1 | SPR_HFLIP)	; Cheep
	.byte $03, $02, $02, $02	; 
	.byte $03, $03, $03, $03	; 0E = Bobomb
	.byte SPR_PAL3, SPR_PAL3, (SPR_PAL3 | SPR_HFLIP), (SPR_PAL3 | SPR_HFLIP)	; 
	.byte (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP), (SPR_PAL2 | SPR_HFLIP)	; 0F = Piranha Stem
	.byte $01, $01, $01, $01	; 
	.byte $02, $02, $02, $02	; 

	; This is a rotated array of Sprite_RAM offsets, helps distribute
	; the map object display so even if there's scanline overflows,
	; there will be at least some visibility of all objects.
Map_SpriteRAM_Offset:
	.byte $08, $10, $18, $20, $28, $30, $38, $40, $08, $10, $18, $20, $28, $30, $38, $40


MapObjects_UpdateDrawEnter:
	JSR Map_Object_Do_All	 ; Runs update code for all map objects

	; Temp_Var13 = $0D
	LDA #14	 	; Total map objects which may exist on the map (only 8 are defined at start)
	STA <Temp_Var13

	; Map_SprRAMOffDistr runs from $00 to $0A, inclusive
	INC Map_SprRAMOffDistr

	LDA Map_SprRAMOffDistr
	AND #$07
	STA Map_SprRAMOffDistr

PRG011_B554:

	; Temp_Var6 = 0
	LDA #$00
	STA <Temp_Var6

	LDY <Temp_Var13	 ; Y = Temp_Var13 (current map slot index)
	LDA Map_SpriteRAM_Offset, Y	 ; A = Map_SprRAMOffDistr + Temp_Var13

PRG011_B568:
	STA <Temp_Var6		 	; -> Temp_Var6

PRG011_B56E:
	LDX <Temp_Var13		 ; X = Temp_Var13

	LDA Map_Objects_Vis,X
	BEQ PRG011_B578	 ; If this object isn't visible, jump to PRG011_B578

	JSR MapObject_DrawSleepEnter	 ; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered

PRG011_B578:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG011_B554	 ; While Temp_Var13 >= 0, loop!

PRG011_B57C:
	LDA Map_Operation
	CMP #$0d
	BNE PRG011_B58C	 ; If the map operation <> $0D (normal), jump to PRG011_B58C (RTS)

	LDA <Counter_1
	AND #$03
	BNE PRG011_B58C

	INC Map_March_Count	; Increment Map_March_Count every 4 ticks

PRG011_B58C:
	RTS		 ; Return


	; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered
MapObject_DrawSleepEnter:
	LDA Map_Objects_IDs,X
	; Map object slot 0 (typ. HELP bubble) or any object that is not in the Map_HideObj override slot

	; Jump by the Map Object ID (this is largely wasted here...)
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; 00=None (RTS)
	.word MapObj_DrawAndEnter	; 01=HELP
	.word MapObj_DrawAndEnter	; 02=Airship
	.word MapObj_DrawAndEnter	; 03=Hammer Bro
	.word MapObj_DrawAndEnter	; 04=Boomerang Bro
	.word MapObj_DrawAndEnter	; 05=Heavy Bro
	.word MapObj_DrawAndEnter	; 06=Fire Bro
	.word MapObj_DrawAndEnter	; 07=World 7 Plant
	.word MapObj_DrawAndEnter	; 08=Unknown marching glitch object
	.word MapObj_DrawAndEnter	; 09=N-Spade
	.word MapObj_DrawAndEnter	; 0A=White Toad House
	.word MapObj_DrawAndEnter	; 0B=Coin Ship
	.word MapObj_DrawAndEnter	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.word MapObj_DrawAndEnter	; 0D=World 8 Battleship
	.word MapObj_DrawAndEnter	; 0E=World 8 Tank
	.word MapObj_DrawAndEnter	; 0F=World 8 Airship
	.word MapObj_DrawAndEnter	; 10=Canoe

MapObj_DrawAndEnter:
	LDA <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)
	ADD #$90
	STA <Temp_Var6
	TAY

	LDA #$00	 ; A = 0 (no offset on map sprite)

	; Set Y for map object sprite
	ADD Map_Object_ActY,X
	STA Sprite_RAMY,Y
	STA Sprite_RAMY + 4,Y

	; Set X for map object sprite
	LDA Map_Object_ActX,X
	SUB <Horz_Scroll
	STA Sprite_RAMX,Y

	; Right half
	ADD #$08
	STA Sprite_RAMX + 4,Y

	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	; Map object ID -> Temp_Var8
	LDA Map_Objects_IDs,X
	STA <Temp_Var8

	LDA <Counter_1	 ; X = 8 (masking value against Counter_1 for animation)
	AND #$30
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var9	 ; -> Temp_Var9 (masking value for animation)

	LDA <Temp_Var8	 ; A = map object ID
	ASL A		 ; Multiply by 2
	ASL A		 ; Multiply by 4
	ADD <Temp_Var9
	TAX

PRG011_B630:
	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Load the patterns of the map object
	LDA MapObject_LeftTile-4,X
	STA Sprite_RAMTile,Y

	LDA MapObject_RightTile-4,X	
	STA Sprite_RAMTile + 4,Y	

	
	; Load the attributes of the map object
	LDA MapObject_AttrLeft-4,X	
	STA Sprite_RAMAttr,Y	

	LDA MapObject_AttrRight-4,X	
	STA Sprite_RAMAttr + 4,Y	

	RTS

;	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)
;
;	LDA Map_Objects_IDs,X
;	LDY <Temp_Var13		 ; Y = Temp_Var13 (the map object slot index)
;
;	; HELP bubble was already eliminated
;
;	; Map Object ID $03-$08  all jump to PRG011_B69C
;	; Otherwise, jump to PRG011_B6A1
;	LDA Map_Objects_IDs,Y
;	LDA Map_DrawPanState
;	BNE PRG011_B6F5	 ; If some kind of map drawing/panning activity is occurring, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Pan_Count
;	BNE PRG011_B6F5	 ; If the map is panning, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Operation
;	CMP #$0D
;	BNE PRG011_B6F5	 ; If Map_Operation <> $0D (something is going on), jump to PRG011_B6F5 (RTS)
;
;	LDX Player_Current	 ; X = Player_Current
;
;	; If the Player is not perfectly situated on top of the map object, jump to PRG011_B6F5 (RTS)
;
;	LDA Map_Objects_Y,Y
;	CMP <World_Map_Y,X
;	BNE PRG011_B6F5
;
;	LDA Map_Objects_XHi,Y
;	CMP <World_Map_XHi,X
;	BNE PRG011_B6F5
;
;	LDA Map_Objects_XLo,Y
;	CMP <World_Map_X,X
;	BNE PRG011_B6F5	
;
;	; Player is going to "enter" this map object...
;
;	LDX Player_Current	 ; X = Player_Current (needless reload?)
;
;	LDA #$00
;	STA Map_Player_SkidBack,X
;
;	LDA #$03
;	STA World_EnterState
;
;	; Store the object ID -> Map_EnterViaID
;	;LDA Map_Objects_IDs,Y
;	;STA <Map_EnterViaID
;
;	; If this is a N-Spade or White Toad house, jump to PRG011_B6E2
;	;CMP #MAPOBJ_NSPADE
;	BEQ PRG011_B6E2
;	;CMP #MAPOBJ_WHITETOADHOUSE
;	BNE PRG011_B6E5
;
;PRG011_B6E2:
;	; N-Spade and White Toad House only...
;	INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn
;
;PRG011_B6E5:
;	LDA Map_Objects_Itm,Y
;	STA Level_TreasureItem
;
;	; Begin level entry
;	LDA #$0f
;	STA Map_Operation
;
;	; Don't return to caller!
;	PLA
;	PLA
;
;	JMP PRG011_B57C	; Jump to PRG011_B57C
;
;PRG011_B6F5:
;	RTS		 ; Return
;
;	; FIXME: Anyone want to claim this?  (Exact same routine appears in PRG010 @ $D228)
;; $B6F6 
;	LDX Player_Current	 ; X = Player_Current
;
;	LDA <World_Map_Dir,X	; Get Player's map direction
;	EOR #$03
;	CMP #$03
;	BNE PRG011_B703	 	; If Player did not travel left or right, jump to PRG011_B703
;
;	EOR #$0f	 ; Otherwise invert all direction bits??
;
;PRG011_B703:
;	STA <World_Map_Dir,X	 ; -> World_Map_Dir
;
;	RTS		 ; Return

; 	; FIXME: Anyone want to claim this?
; 	; Gets a tile based on an input 'Y' value to pick from one of the offset sets below...
; PRG011_B706:	.byte -16, -16, 0, -32
; PRG011_B70A:	.byte $00, $FF, $00, $00	; 16-bit sign extensions
; PRG011_B70E:	.byte 16, -16, 0, 0

; ; $B712
; 	LDX Player_Current	 ; X = Player_Current

; 	LDA <World_Map_Y,X
; 	ADD PRG011_B706,Y
; 	STA <Temp_Var15	

; 	LDA <World_Map_X,X
; 	ADD PRG011_B70E,Y
; 	STA <Temp_Var16	

; 	LDA <World_Map_XHi,X
; 	ADC PRG011_B70A,Y
; 	ASL A		 ; 2 byte index per map screen
; 	TAX		 ; -> 'X'

; 	; Set pointer to map screen tiles
; 	LDA Tile_Mem_Addr,X
; 	STA <Map_Tile_AddrL
; 	LDA Tile_Mem_Addr+1,X
; 	STA <Map_Tile_AddrH
; 	INC <Map_Tile_AddrH	; Map is always on lower part

; 	; Form row/column offset
; 	LDA <Temp_Var16
; 	LSR A
; 	LSR A
; 	LSR A
; 	LSR A
; 	STA <Temp_Var16
; 	LDA <Temp_Var15
; 	AND #$f0
; 	ORA <Temp_Var16
; 	TAY	 ; -> 'Y'

; 	LDA [Map_Tile_AddrL],Y	; Get tile
; 	RTS		 ; Return


; PRG011_B74A:
; 	LDX Map_Unused738		; X =  Map_Unused738

; 	;LDA Map_Unused7DC6,X
; 	CMP #$09
; 	BLT MapStarsIntro_DoStarFX	; If Map_Unused7DC6[X] < 9, jump to MapStarsIntro_DoStarFX

; 	; Map_StarsState = 1
; 	LDA #$01
; 	STA <Map_StarsState

; 	LDX Player_Current	; X = Player_Current

; 	LDY Map_Unused7992
; 	INY
; 	TYA	; A = Map_Unused7992 + 1

; 	; ASL A
; 	; ASL A
; 	; ASL A
; 	; ASL A
; 	; ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
; 	; CMP <World_Map_Move,X	
; 	; BEQ MapStarsIntro_DoStarFX	 ; If movement is same as Player's current movement, jump to MapStarsIntro_DoStarFX

; 	JMP WorldMap_UpdateAndDraw	 ; Draw and update map and don't come back

; MapStarsIntro_DoStarFX:
; 	LDA Map_StarFX_State
; 	JSR DynJump

; 	.word MapStarsIntro_Init
; 	.word WWFX_WarpWhistleFlash	; THIS STATE IS NOT USED (accidentally/on-purpose skipped)
; 	.word MapStarsIntro_Do

; 	; Default "radius" values for each star on the world intro
; MSI_DefaultRadii:	.byte $14, $10, $0C, $08, $04, $00, $1C, $18

; 	; Per-radius size values
; MSI_RadSize:		.byte 0, 24, 48, 71, 90, 106, 118, 125, 128, 125, 118, 106, 90, 71, 48, 24


; 	; Patterns used by the "stars" in the intro
; MapStarsIntro_Patterns:	.byte $67, $69 

; MapStarsIntro_Init:
; 	LDA #SND_MAPENTERWORLD	
; 	STA Sound_QMap	; Play the starry entrance sound

; 	; Preload the default "radius" values for each star
; 	LDX #$07
; PRG011_B799:
; 	LDA MSI_DefaultRadii,X
; 	STA <Map_StarsRadius,X
; 	DEX		 	; X--
; 	BPL PRG011_B799	 	; While X >= 0, loop!

; 	LDX <Map_StarsState
; 	BNE PRG011_B7AD	 	; If Map_StarsState <> 0, jump to PRG011_B7AD

; 	; Stars emanating from center
; 	LDA #$80	 
; 	STA <Map_StarsCenterX	; Map_StarsCenterX = $80
; 	STA <Map_StarsCenterY	; Map_StarsCenterY = $80
; 	BNE PRG011_B800	 	; Jump (technically always) to PRG011_B800

; PRG011_B7AD:
; 	CPX #$01	 
; 	BNE PRG011_B7CC	 	; If Map_StarsState <> 1, jump to PRG011_B7CC

; 	; Stars emanating from Player start
; 	LDX Player_Current	; X = Player_Current

; 	LDA <World_Map_X,X
; 	ADD <Horz_Scroll
; 	STA <Map_StarsCenterX	; Map_StarsCenterX = Player's Map X + Horz_Scroll

; 	LDA <World_Map_Y,X	
; 	STA <Map_StarsCenterY	; Map_StarsCenterY = Player's Map Y

; 	LDA #$86
; 	STA Map_Stars_PRelX	; Map_Stars_PRelX = $86

; 	LDA #$d0	
; 	STA Map_Stars_PRelY	; Map_Stars_PRelY = $D0

; 	JMP PRG011_B7E6	 ; Jump to PRG011_B7E6

; PRG011_B7CC:
; 	; Map_StarsState = 2

; 	LDA #$88
; 	STA <Map_StarsCenterX	; Map_StarsCenterX = 136

; 	LDA #$5c
; 	STA <Map_StarsCenterY	; Map_StarsCenterY = 92

; 	LDX Player_Current	; X = Player_Current

; 	LDA <World_Map_X,X
; 	ADD <Horz_Scroll
; 	STA Map_Stars_PRelX	 	; Map_Stars_PRelX = Player's map X coordinate + Horz_Scroll

; 	LDA <World_Map_Y,X
; 	STA Map_Stars_PRelY	 	; Map_Stars_PRelY = Player's map Y coordinate

; 	INC <Map_StarFX_State	; Next state... (NOTE: Incremented again below!)

; PRG011_B7E6:

; 	; Calculate step and deltas
; 	LDX <Map_StarsCenterX
; 	LDA Map_Stars_PRelX
; 	JSR MSI_CalcDeltaAndSteps
; 	STA <Map_StarsXSteps
; 	STX Map_StarsDeltaX

; 	LDX <Map_StarsCenterY
; 	LDA Map_Stars_PRelY
; 	JSR MSI_CalcDeltaAndSteps
; 	STA <Map_StarsYSteps	
; 	STX Map_StarsDeltaY

; PRG011_B800:
; 	LDA #$00
; 	STA <Map_StarsFrame	; Map_StarsFrame = 0
; 	STA <Map_StarsLandRad	; Map_StarsLandRad = 0
; 	STA <Map_StarsOutRad	; Map_StarsOutRad = 0

; 	LDA #$67
; 	STA <Map_StarsPattern

; 	LDA #$09
; 	STA <Map_StarsConst9	; Map_StarsConst9 = 9 (forever?)

; 	INC Map_StarFX_State	; Next state... (technically, +2 before it gets back)

; 	LDX <Map_StarsState
; 	CPX #$02	 
; 	BEQ PRG011_B81C	 	; If Map_StarsState = 2, jump to PRG011_B81C (RTS)

; 	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

; PRG011_B81C:
; 	RTS		 	; Return


; 	; FIXME: Anyone want to claim this?
; ; $B81D
; 	JMP PRG011_B8B1	; Jump to PRG011_B8B1

; MapStarsIntro_Do:
; 	LDA <Map_StarsLandRad
; 	BNE PRG011_B834	 		; If Map_StarsLandRad <> 0 (we're doing the "landing" now), jump to PRG011_B834

; 	LDA <Map_StarsOutRad
; 	ADD #$04	 
; 	CMP #$5f	 
; 	BGE PRG011_B830	 	; If Map_StarsOutRad + 4 >= $5F, jump to PRG011_B830 (change direction)

; 	; Otherwise, jump to PRG011_B8AF
; 	JMP PRG011_B8AF	

; PRG011_B830:
; 	LDA #$01	 
; 	STA <Map_StarsLandRad		; Map_StarsLandRad = 1

; PRG011_B834:
; 	; Stars landing

; 	LDA <Map_StarsState
; 	BEQ PRG011_B874	 		; If Map_StarsState = 0, jump to PRG011_B874

; 	LDA <Map_StarsCenterX
; 	CMP Map_Stars_PRelX
; 	BGE PRG011_B84B	 		; If Map_StarsCenterX >= Map_Stars_PRelX (Player's landing is to the left), jump to PRG011_B84B

; 	; Player's landing is to the right...
; 	ADC Map_StarsDeltaX		; Map_StarsCenterX += Map_StarsDeltaX
; 	TAX		 		; X = A
; 	DEC <Map_StarsXSteps		; Map_StarsXSteps--
; 	BMI PRG011_B854			; If Map_StarsXSteps < 0, jump to PRG011_B854
; 	INX		 		; X++
; 	JMP PRG011_B854	 		; Jump to PRG011_B854

; PRG011_B84B:
; 	SBC Map_StarsDeltaX	 	; Map_StarsCenterX -= Map_StarsDeltaX
; 	TAX		 		; X = A
; 	DEC <Map_StarsXSteps		; Map_StarsXSteps--
; 	BMI PRG011_B854	 		; If Map_StarsXSteps < 0, jump to PRG011_B854
; 	DEX				; X--

; PRG011_B854:
; 	STX <Map_StarsCenterX		; Update Map_StarsCenterX

 
; 	LDA <Map_StarsCenterY
; 	CMP Map_Stars_PRelY
; 	BGE PRG011_B869	 		; If Map_StarsCenterY >= Map_Stars_PRelY (Player's landing is above), jump to PRG011_B869

; 	; Player's landing is below...
; 	ADC Map_StarsDeltaY		; Map_StarsCenterY += Map_StarsDeltaY
; 	TAX		 		; X = A
; 	DEC <Map_StarsYSteps		; Map_StarsYSteps--
; 	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
; 	INX		 		; X++
; 	JMP PRG011_B872	 		; Jump to PRG011_B872

; PRG011_B869:
; 	SBC Map_StarsDeltaY	 	; Map_StarsCenterY -= Map_StarsDeltaY
; 	TAX		 		; X = A
; 	DEC <Map_StarsYSteps		; Map_StarsYSteps--
; 	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
; 	DEX		 		; X--

; PRG011_B872:
; 	STX <Map_StarsCenterY		; Update Map_StarsCenterY

; PRG011_B874:
; 	LDA <Map_StarsOutRad
; 	SUB #$04	 
; 	BNE PRG011_B8AF	 		; If Map_StarsOutRad - 4 <> 0, jump to PRG011_B8AF

; 	LDA #$00	 
; 	STA Map_StarFX_State	 	; Map_StarFX_State = 0
; 	STA <Map_StarsLandRad		; Map_StarsLandRad = 0

; 	LDA <Map_StarsState
; 	CMP #$02	 
; 	BEQ PRG011_B8A5			; If Map_StarsState = 2, jump to PRG011_B8A5


; 	; FIXME: CHECKME: Might be some dead code here
; 	LDX Map_Unused738	 ; X = Map_Unused738

; 	;LDA Map_Unused7DC6,X
; 	CMP #$09
; 	BLT PRG011_B8A5	 ; If Map_Unused7DC6[X] FIXME < 9, jump to PRG011_B8A5

; 	; Map_Unused7992 -= 10 (FIXME)
; 	SUB #10
; 	STA Map_Unused7992

; 	LDX Player_Current	; X = Player_Current

; 	TAY
; 	INY
; 	TYA

; 	ASL A
; 	ASL A
; 	ASL A
; 	ASL A
; 	ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
; 	STA <World_Map_Move,X	; Player moves by this amount (but not during the stars display??)

; PRG011_B8A5:
; 	LDX <Map_StarsState
; 	CPX #$02	 
; 	BEQ PRG011_B8AE	 	; If Map_StarsState = 2, jump to PRG011_B8AE (RTS)

; 	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

; PRG011_B8AE:
; 	RTS		 ; Return

; PRG011_B8AF:
; 	; Stars taking off

; 	STA <Map_StarsOutRad	; Update Map_StarsOutRad

; PRG011_B8B1:
; 	; This just adds 32 each display frame and toggles the Map_StarsFrame when it overflows
; 	LDA <Map_StarsAnimCnt
; 	ADD #32
; 	STA <Map_StarsAnimCnt	; Map_StarsAnimCnt += 32
; 	BCC PRG011_B8C6		; If it hasn't overflowed, jump to PRG011_B8C6

; 	; So Map_StarsFrame toggles every 8 frames
; 	LDA <Map_StarsFrame	
; 	EOR #$01	 
; 	STA <Map_StarsFrame	; Toggle Map_StarsFrame (0/1)

; 	TAX		 
; 	LDA MapStarsIntro_Patterns,X	 ; Based on Map_StarsFrame, get the pattern number
; 	STA <Map_StarsPattern		 ; Store into Map_StarsPattern

; PRG011_B8C6:
; 	LDY #$00	 ; Y = 0

; 	LDX #$07	 ; X = 7

; 	; This just adds $70 each display frame and toggles the Map_StarsFrame when it overflows
; 	LDA <Map_StarsRadCnt
; 	ADD #$70
; 	STA <Map_StarsRadCnt	; Map_StarsRadCnt += $70
; 	BCC PRG011_B8D5	 	; If it hasn't overflowed, jump to PRG011_B8D5

; 	; So roughly every 2.29 display frames...
; 	LDY #$01	 	; Y = 1 (+1 to the rotation)

; PRG011_B8D5:
; 	STY <Map_StarsDeltaR	; Map_StarsDeltaR = Y (0 or 1)

; PRG011_B8D7:

; 	; Add to each star's radius 0 or 1, capping the value at 0-31
; 	LDA <Map_StarsRadius,X	
; 	ADD <Map_StarsDeltaR	
; 	AND #$1f	 
; 	STA <Map_StarsRadius,X	; Map_StarsRadius[X] = (Map_StarsRadius[X] + 1) & $1f

; 	JSR MSI_CalcStarsXY	; Calculate this star's X and Y (and Temp_Var10 contains the X for the second sprite)
; 	JSR MSI_DrawStar	; Draw this star!
; 	DEX		 	; X--
; 	BPL PRG011_B8D7	 	; If X >= 0, loop!

; 	LDX <Map_StarsState
; 	CPX #$02	 
; 	BEQ PRG011_B8F2		; If Map_StarsState = 2, jump to PRG011_B8F2
; 	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

; PRG011_B8F2:
; 	RTS		 ; Return

; ; MSI_CalcStarsXY
; ;
; ; Calculates the current X and Y position of each star
; MSI_CalcStarsXY:
; 	LDA <Map_StarsRadius,X
; 	AND #$0f		; Only using values 0-15 of the "radius"	 
; 	TAY
; 	LDA MSI_RadSize,Y
; 	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

; 	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
; 	LDY <Map_StarsConst9	; Y = Map_StarsConst9
; 	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

; 	LDA <Map_StarsRadius,X	
; 	AND #$18	 
; 	CMP #16
; 	BLT PRG011_B917	 	; If (Map_StarsRadius[X] & $18) < 16, jump to PRG011_B917

; 	; Otherwise...
; 	LDA #-1
; 	STA <Temp_Var1		; Temp_Var1 = -1

; 	LDA <Map_StarsCenterX
; 	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
; 	JMP PRG011_B91F	 	; Jump to PRG011_B91F

; PRG011_B917:
; 	LDA #$01
; 	STA <Temp_Var1		; Temp_Var1 = 1

; 	LDA <Map_StarsCenterX
; 	ADC <Temp_Var3		; A = Map_StarsCenterX + Temp_Var3

; PRG011_B91F:
; 	STA <Map_StarsX,X	; Set this as the star's X position
; 	STA <Temp_Var7		; Temp_Var7 = star's X position

; 	LDA <Map_StarsCenterX
; 	STA <Temp_Var8		; Temp_Var8 = all stars center X

; 	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

; 	LDA <Temp_Var6
; 	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

; 	LDA <Map_StarsX,X
; 	ADD #8
; 	STA <Temp_Var10		; Temp_Var10 = star's X + 8 (will be second sprite's offset)
; 	STA <Temp_Var7		; Temp_Var7 = Temp_Var10

; 	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

; 	LDA <Temp_Var6		
; 	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

; 	LDA <Map_StarsRadius,X	
; 	ADD #$08	 
; 	AND #$0f	 
; 	TAY		 	; Y = (radius value + 8) & $F
; 	LDA MSI_RadSize,Y
; 	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

; 	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
; 	LDY <Map_StarsConst9	; Y = Map_StarsConst9
; 	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

; 	LDA <Map_StarsRadius,X
; 	SUB #$08	
; 	AND #$18
; 	CMP #16
; 	BLT PRG011_B968	 	; If ((Map_StarsRadius[X] - 8) & $18) < 16, jump to PRG011_B968

; 	LDA #-1
; 	STA <Temp_Var1		; Temp_Var1 = -1

; 	LDA <Map_StarsCenterY
; 	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
; 	JMP PRG011_B970	 	; Jump to PRG011_B970

; PRG011_B968:
; 	LDA #1
; 	STA <Temp_Var1		; Temp_Var1 = 1

; 	LDA <Map_StarsCenterY
; 	ADC <Temp_Var3		

; PRG011_B970:
; 	STA <Map_StarsY,X	; star's Y = Map_StarsCenterY + Temp_Var3
; 	STA <Temp_Var7		; Temp_Var7 = star's Y

; 	LDA <Map_StarsCenterY	
; 	STA <Temp_Var8		; Temp_Var8 = all stars center Y

; 	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

; 	LDA <Temp_Var6	
; 	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980
; 	RTS		 	; Return

; PRG011_B980:
; 	LDA #$f8
; 	STA <Map_StarsY,X	; star's Y = $F8 (hides sprite)
; 	LDA #$00	 
; 	STA <Map_StarsX,X	; star's X = 0 (we're hiding the sprite)

; 	STA <Temp_Var10		; Temp_Var10 = star's X (0) (will be second sprite's offset)
; 	RTS		 	; Return

; MSI_CalcXOffset:
; 	; A = Map_StarsOutRad
; 	; Y = Map_StarsConst9 (9)

; 	; MAPOBJ_HAMMERBROFIXME: I don't really understand the algorithm (I think it's some kind of
; 	; division or fractional multiplication routine?), produces X offset in Temp_Var3

; 	STA <Temp_Var2	; Temp_Var2 = Map_StarsOutRad

; 	LDA #$00	
; 	STA <Temp_Var3	; Temp_Var3 = 0
; 	STA <Temp_Var4	; Temp_Var4 = 0

; PRG011_B993:
; 	ASL <Temp_Var4
; 	ROL <Temp_Var3
; 	ASL <Temp_Var1
; 	BCC PRG011_B9A6

; 	LDA <Temp_Var4
; 	ADD <Temp_Var2
; 	STA <Temp_Var4

; 	BCC PRG011_B9A6

; 	INC <Temp_Var3

; PRG011_B9A6:
; 	DEY		 ; Y--
; 	BNE PRG011_B993	 ; While Y >= 0, loop

; 	RTS		 ; Return

; ; MSI_DrawStar
; ;
; ; Generates the hardware sprites for a star
; MSI_DrawStar:
; 	TXA
; 	ASL A
; 	ASL A
; 	ASL A
; 	TAY		; Y = X << 3

; 	; Store the Y part of this star's sprites
; 	LDA <Map_StarsY,X	 
; 	STA Sprite_RAM+$98,Y	 
; 	STA Sprite_RAM+$9C,Y	 

; 	; Store the patterns for this star's sprites
; 	LDA <Map_StarsPattern	
; 	STA Sprite_RAM+$99,Y	
; 	STA Sprite_RAM+$9D,Y	

; 	; First sprite is palette 3
; 	LDA #$03	 
; 	STA Sprite_RAM+$9A,Y

; 	; Second sprite is same but also HV flipped
; 	LDA #$c3
; 	STA Sprite_RAM+$9E,Y

; 	; Store X coordinate for first sprite
; 	LDA <Map_StarsX,X
; 	STA Sprite_RAM+$9B,Y

; 	; Store X coordinate for second sprite
; 	LDA <Temp_Var10
; 	STA Sprite_RAM+$9F,Y

; 	RTS		 ; Return

; PRG011_SUB_B9D4:
; 	; Temp_Var1 = 1 or -1
; 	; Temp_Var7 = star's X position
; 	; Temp_Var8 = all stars center X

; 	LDA <Temp_Var7
; 	EOR <Temp_Var8
; 	AND #$80	 
; 	BEQ PRG011_B9EA	 	; If Temp_Var7 and Temp_Var8 are oppositely signed, jump to PRG011_B9EA

; 	LDA <Temp_Var1
; 	BPL PRG011_B9E6	 	; If Temp_Var1 >= 0, jump to PRG011_B9E6

; 	LDA <Temp_Var7
; 	BMI PRG011_B9EF	 	; If Temp_Var7 < 0, jump to PRG011_B9EF
; 	BPL PRG011_B9EA	 	; Otherwise, jump to PRG011_B9EA

; PRG011_B9E6:
; 	LDA <Temp_Var7
; 	BPL PRG011_B9EF	 	; If Temp_Var7 >= 0, jump to PRG011_B9EF

; PRG011_B9EA:
; 	LDA #1
; 	STA <Temp_Var6		; Temp_Var6 = 1
; 	RTS		 	; Return...

; PRG011_B9EF:
; 	LDA #-1
; 	STA <Temp_Var6		; Temp_Var6 = -1
; 	RTS		 	; Return...

; MSI_CalcDeltaAndSteps:

; 	; X = Map_StarsCenterX
; 	; A = Map_Stars_PRelX

; 	STX <Temp_Var4	; Temp_Var4 = Map_StarsCenterX
; 	STA <Temp_Var5	; Temp_Var5 = Map_Stars_PRelX
 
; 	SUB <Temp_Var4	
; 	STA <Temp_Var1	; Temp_Var1 = Temp_Var5 (Map_Stars_PRelX) - Temp_Var4 (Map_StarsCenterX)

; 	LDA <Temp_Var5	
; 	CMP <Temp_Var4	
; 	BGE PRG011_BA0B	; If Temp_Var5 >= Temp_Var4, jump to PRG011_BA0B

; 	; Otherwise, Temp_Var1 is negative; negate it!
; 	LDA <Temp_Var1
; 	EOR #$ff	
; 	ADC #$01	
; 	STA <Temp_Var1	

; 	; FIXME: I don't really understand the algorithm (I think it's some kind of
; 	; division routine?), but it finds the delta X/Y values for the star intro
; 	; and the number of steps to complete the move
; PRG011_BA0B:
; 	LDA #$00
; 	STA <Temp_Var3	; Temp_Var3 = 0

; 	LDY #$07	; Y = 7
; PRG011_BA11:
; 	ASL <Temp_Var3
; 	ROL <Temp_Var1
; 	ROL A		
; 	BCS PRG011_BA1C	

; 	CMP #$17
; 	BLT PRG011_BA20	

; PRG011_BA1C:
; 	SBC #$17	
; 	INC <Temp_Var3	; Temp_Var3++

; PRG011_BA20:
; 	DEY		 ; Y--
; 	BPL PRG011_BA11	 ; While Y >= 0, loop!

; 	LDX <Temp_Var3	 ; X = Temp_Var3
; 	RTS		 ; Return

Map_CompleteY:
	.byte $20, $30, $40, $50, $60, $70, $80
Map_CompleteY_End

Map_CompleteBit:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

Map_MarkLevelComplete:
	LDA Old_World_Map_Tile 	 ; X = Player_Current
	AND #$0F
	JSR MapGetTileBit
	;ORA World_Complete_Tiles,X
	;STA World_Complete_Tiles,X
	RTS


MapObject_X = Temp_Var2
MapLeft_Edge = Temp_Var3
MapRight_Edge = Temp_Var4

Map_Object_CheckVisibility:
	; For a given object, check if it's visible on the map.  This value is
	; stored into the Map_Objects_Vis array
	; X is the index to the map object we need to work with!
	LDY #$00	 	; Object is not visible until proven visible...

	LDA Map_Objects_XHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <MapObject_X		; Temp_Var2 = object's X Hi byte << 4

	LDA Map_Objects_XLo,X
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	ORA <MapObject_X		
	STA <MapObject_X		; OR'ing the low X >> 4; Temp_Var2 now contains a proper "column" position

	LDA <Horz_Scroll_Hi
	ASL A
	ASL A
	ASL A
	ASL A
	STA <MapLeft_Edge
	ADD #$10
	STA <MapRight_Edge

	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	PHA
	ORA <MapLeft_Edge
	STA <MapLeft_Edge

	PLA 
	ORA <MapRight_Edge
	STA <MapRight_Edge

	LDA <MapObject_X
	CMP <MapLeft_Edge
	BLT PRG011_BAB1	 	; If object is less than the right scroll column, jump to PRG011_BAB1

	CMP <MapRight_Edge	
	BGE PRG011_BAB1	 	; If object is greater-equal to the left scroll column, jump to PRG011_BAB1

	LDY #$01	 	; Object is visible!
PRG011_BAB1:
	TYA		 	; A = Y
	STA Map_Objects_Vis,X 	; Mark this object as visible or not
	RTS		 	; Return

Map_Object_Canoe:
	LDY Player_Current	; Y = Player_Current
	LDA Map_InCanoe_Flag
	BEQ PRG011_BAD9	 	; If Map_InCanoe_Flag = 0, jump to PRG011_BAD9

	; Otherwise, the Canoe is updated to match the Player's
	; position; this seems to only allow one canoe per map!
	; Though it could probably be fixed somehow...
	LDA World_Map_Y,Y 
	STA Map_Objects_Y,X
	STA Map_Object_ActY,X
	LDA World_Map_X,Y	
	STA Map_Objects_XLo,X	
	STA Map_Object_ActX,X	
	LDA World_Map_XHi,Y	
	STA Map_Objects_XHi,X	
	STA Map_Object_ActXH,X	

PRG011_BAD9:

	; Basically if Player is standing in Canoe, it activates the Map_InCanoe_Flag flag
	LDA World_Map_Move,Y
	ORA Map_Player_SkidBack,Y
	BNE PRG011_BAFE	 

	LDA World_Map_Y,Y
	CMP Map_Object_ActY,X
	BNE PRG011_BAFE

	LDA World_Map_XHi,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_BAFE	 

	LDA World_Map_X,Y
	CMP Map_Object_ActX,X
	BNE PRG011_BAFE	 

	; Map_InCanoe_Flag = 1 (In canoe!)
	LDA #$01
	STA Map_InCanoe_Flag

PRG011_BAFE:
	RTS		 ; Return

W8D_CircSprs:
	.byte $F8, $81, $01, $F0
	.byte $F0, $83, $01, $F8
	.byte $E8, $85, $01, $00
	.byte $E8, $85, $41, $08
	.byte $F0, $83, $41, $10
	.byte $F8, $81, $41, $18
	.byte $08, $81, $81, $F0
	.byte $10, $83, $81, $F8
	.byte $18, $85, $81, $00
	.byte $18, $85, $C1, $08
	.byte $10, $83, $C1, $10
	.byte $08, $81, $C1, $18
	.byte $E8, $0B, $01, $F0
	.byte $E8, $0B, $01, $18
	.byte $18, $0B, $01, $F0
	.byte $18, $0B, $01, $18
	.byte $F0, $0B, $01, $E8
	.byte $00, $0B, $01, $E8
	.byte $10, $0B, $01, $E8
	.byte $F0, $0B, $01, $20
	.byte $00, $0B, $01, $20
W8D_CircSprs_Unaligned

	.byte $10, $0B, $01, $20
	.byte $E0, $87, $01, $F8
	.byte $E0, $87, $01, $10
	.byte $20, $87, $81, $F8
W8D_CircSprs_Aligned

PRG011_BB63:
	.byte $20, $87, $81

PRG011_BB66:
	.byte $10, $E0, $E8, $D8, $F0, $D0, $F8

FX_World_8_Darkness:
	LDY World_8_Dark	; Y = World_8_Dark
	BEQ PRG011_BB7A	 	; If not in the World 8 darkness, jump to PRG011_BB7A (RTS)
	LDX Player_Current	; X = Player_Current
	LDA Map_Player_SkidBack,X
	BEQ PRG011_BB7B	 	; If Player's Map_Player_SkidBack = 0, jump to PRG011_BB7B

PRG011_BB7A:
	RTS		 	; Otherwise, return...

PRG011_BB7B:
	CPY #$07	 
	BGE PRG011_BB9A	 	; If World_8_Dark >= 7 (effect complete), jump to PRG011_BB9A
	LDA <World_Map_X,X	; Player's X coordinate -> A
	ADD PRG011_BB66,Y	; Add an offset based on World_8_Dark

	LDY <World_Map_Y,X	; Y = Player's Y coordinate
	LDX #$01	 	; X = 1

	;JSR Map_W8DarknessUpdate	; Update darkness around Player

	INC World_8_Dark	; World_8_Dark++

	LDA World_8_Dark	 
	LSR A		 	
	BCC FX_World_8_Darkness	; Loops if carry not set by the "LSR A" (so only loops on 2, 4, 6)

PRG011_BB9A:
	LDX Player_Current	; X = Player_Current

	LDY #$00	 ; Y = 0

	LDA <World_Map_Move,X
	AND #$07	; Cap 0-7
	CMP #$06
	BEQ PRG011_BBAC	 ; On "6" of every "0-7" jump to PRG011_BBAC

	CMP #$02
	BNE PRG011_BBBB	 ; If not "2" of every "0-7" jump to PRG011_BBBB

	INY		 ; Otherwise, Y++

PRG011_BBAC:
	LDA <World_Map_X,X
	PHA		 ; Save Player's map X

	LDY <World_Map_Y,X	 ; Y = Player's map Y

	LDA <World_Map_Dir,X
	TAX		 ; X = Player's map direction of travel

	PLA		 ; A = Player's map X

	; Update darkness around Player
	;JSR Map_W8DarknessUpdate

PRG011_BBBB:
	LDY #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	LDX Player_Current	 ; X = Player_Current

	; Temp_Var1/2 = Player's Map Y/X
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDX #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	AND #$0f	 ; Get lower 4 bits of X
	BNE PRG011_BBD0	 ; If Player is not perfectly aligned in column, jump to PRG011_BBD0

	LDX #(W8D_CircSprs_Aligned - W8D_CircSprs)

PRG011_BBD0:

	; Set circle sprite Y
	LDA <Temp_Var1
	ADD W8D_CircSprs,X
	STA Sprite_RAM+$08,Y

	; Set circle sprite pattern
	LDA W8D_CircSprs+1,X
	STA Sprite_RAM+$09,Y

	; Set circle sprite attribute
	LDA W8D_CircSprs+2,X
	STA Sprite_RAM+$0A,Y

	; Set circle sprite X
	LDA <Temp_Var2
	ADD W8D_CircSprs+3,X
	STA Sprite_RAM+$0B,Y

	DEY
	DEY
	DEY
	DEY	; Y -= 4 (previous sprite)

	DEX
	DEX
	DEX
	DEX	; X -= 4 (previous circle sprite def)

	BMI PRG011_BC00	 ; If out of sprites, jump to PRG011_BC00

	CPX #(W8D_CircSprs_Unaligned - W8D_CircSprs)
	BNE PRG011_BBD0	 ; If not at end of aligned circle sprites, loop

	LDX #$3c
	BNE PRG011_BBD0	 ; If X <> $3C (?), loop

PRG011_BC00:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoAnimations
;
; This subroutine takes care of the simplistic animations
; that occur on the world maps.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Map_Y_Starts:
	; Map Y start positions, World 1-8 (X is always $20)
	.byte $40, $A0, $A0, $40, $80, $60, $30, $50

Map_AnimCHRROM:
	; This sets the CHRROM page in use per animation frame (common to all worlds)
	.byte $70, $72, $74, $76

Map_DoAnimations:	; $BC29
	LDA <Counter_1
	AND #$60
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY
	LDA Map_AnimCHRROM,Y	; Get the correct CHRROM page
	STA PatTable_BankSel	  	; Put it to use
	RTS		  ; Return!

; ### RELOCATE THIS CODE!	
FindCompletedLevels:
	LDX #$00

FindCompletedLevels3:
	LDA MapPointers, X
	CMP #$FF
	BNE FindCompletedLevels0
	RTS

FindCompletedLevels0:
	STA LevelNumber
	JSR GetLevelBit
	AND Levels_Complete, Y
	BEQ FindCompletedLevels1

	LDA MapPointers + 1, X
	AND #$0F
	STA Block_ChangeXHi

	LDA MapPointers + 1, X
	AND #$F0
	STA Block_ChangeX

	LDA MapPointers + 2, X
	AND #$0F
	ASL A
	ASL A
	ASL A
	ASL A
	SUB #$10
	STA Block_ChangeY

	LDA #$01
	STA Block_ChangeYHi
	STX TempX

	JSR MarkCompletedLevels
	
	LDX TempX

FindCompletedLevels1:
	INX
	INX
	INX

	JMP FindCompletedLevels3

Completion_Tiles: 
	.byte $FF, $7C

MarkCompletedLevels:
	JSR GetMapTile
	TAY

	LDA TileProperties, Y
	CMP #MAP_PROP_COMPLETABLE
	BNE MarkCompletedLevelsRTS

	TYA

	AND #$E0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	
	TAX

	LDY <Temp_Var5
	LDA Completion_Tiles, X
	STA [Map_Tile_AddrL],Y

MarkCompletedLevelsRTS:	
	RTS

GetMapTile:
	LDA Block_ChangeXHi
	ASL A
	TAX	

	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL

	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	LDA #$00
	STA <Temp_Var7

	LDA Block_ChangeYHi
	BEQ MarkCompletedLevels1	

	INC <Map_Tile_AddrH	

MarkCompletedLevels1:

	LDA Block_ChangeY
	AND #$f0
	STA <Temp_Var6

	LDA Block_ChangeX
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	LDA Block_ChangeYHi
	BNE MarkCompletedLevels2	

	LDA Block_ChangeY
	AND #$f0
	CMP #$f0
	BNE MarkCompletedLevels3	 

MarkCompletedLevels2:
	LDA Block_ChangeY
	ADD #$10
	STA <Temp_Var6

	LDA #$01
	STA <Temp_Var7

MarkCompletedLevels3:
	LDY <Temp_Var5

	LDA [Map_Tile_AddrL],Y

Map_SaveMenuSCRTS:
	RTS	

Map_SaveMenu:
	LDA Map_Pan_Count
	BNE Map_SaveMenuSCRTS

	LDA Auto_Save
	BEQ Map_NoAutoSave

	JSR Save_Game

Map_NoAutoSave:	
	LDA Save_Menu_Showing
	BEQ Map_SaveMenuHidden

	JMP Map_SaveMenuShowing

Map_SaveMenuHidden:
	LDA <Pad_Input
	AND #PAD_START
	BEQ Map_SaveMenuHiddenRTS

	LDA #$01
	STA Save_Menu_Showing

	LDA #$00
	STA Save_Menu_YesNo

	LDA #PAUSE_STOPMUSIC
	STA Sound_QPause

Map_SaveMenuHiddenRTS:
	RTS


SAVE_MENU_YES = 0
SAVE_MENU_NO = 1
SAVE_MENU_SPRAM = $A0
SAVE_MENU_SPRAM_STOP = (4 * 10) + SAVE_MENU_SPRAM

Map_SaveMenuTiles:
Map_SaveMenuYes:
	.byte $C1, $C3, $C5, $C7, $C9
	.byte $EB, $ED, $EF, $F1, $F3

Map_SaveMenuNo:
	.byte $CB, $CD, $CF, $D1, $D3
	.byte $E1, $E3, $E5, $E7, $E9

Map_SaveMenuX:
	.byte $6C, $74, $7C, $84, $8C
	.byte $6C, $74, $7C, $84, $8C
	.byte $6C, $74, $7C, $84, $8C
	.byte $6C, $74, $7C, $84, $8C

Map_SaveMenuY:
	.byte $60, $60, $60, $60, $60
	.byte $70, $70, $70, $70, $70
	.byte $60, $60, $60, $60, $60
	.byte $70, $70, $70, $70, $70

Map_SaveMenuOffset:
	.byte 00, (Map_SaveMenuNo - Map_SaveMenuYes)

Map_SaveMenuShowing:
	JSR Cheat_Code
	
	LDY Save_Menu_YesNo 

	LDA Map_SaveMenuOffset, Y
	TAX

	LDY #SAVE_MENU_SPRAM
	
Map_SaveMenuLoop:
	LDA Map_SaveMenuTiles, X
	STA Sprite_RAMTile, Y

	LDA Map_SaveMenuX, X
	STA Sprite_RAMX, Y

	LDA Map_SaveMenuY, X
	STA Sprite_RAMY, Y

	LDA #SPR_PAL1
	STA Sprite_RAMAttr, Y

	INY
	INY
	INY
	INY

	INX

	CPY #SAVE_MENU_SPRAM_STOP
	BNE Map_SaveMenuLoop

	LDA <Pad_Input
	AND #PAD_START
	BEQ Map_SaveMenuToggleCheck

	LDA Save_Menu_YesNo
	BNE Save_MenuRTS

	JSR Save_Game

	LDA Sound_QMap
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

Save_MenuRTS:
	LDA #PAUSE_RESUMEMUSIC
	STA Sound_QPause

	LDA #$00
	STA Save_Menu_Showing
	RTS

Map_SaveMenuToggleCheck:
	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN | PAD_SELECT)
	BEQ Map_SaveMenuShowingRTS


	LDA Save_Menu_YesNo
	EOR #$01
	STA Save_Menu_YesNo

Map_SaveMenuShowingRTS:
	RTS	

U_ = PAD_UP
D_ = PAD_DOWN
L_ = PAD_LEFT
R_ = PAD_RIGHT
S_ = PAD_SELECT
B_ = PAD_B
A_ = PAD_A
__ = 00
X_ = $FF

Cheat_Codes:	
	.byte U_, U_, U_, U_, U_, U_, U_, U_, U_
	.byte U_, R_, D_, L_, U_, R_, D_, L_, __
	.byte L_, D_, R_, D_, L_, D_, R_, D_, L_
	.byte L_, R_, S_, B_, A_, B_, S_, R_, L_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, U_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, D_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, L_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, R_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, S_
	.byte B_, A_, B_, A_, B_, A_, B_, A_, B_
	.byte S_, B_, S_, B_, S_, B_, S_, B_, S_
	.byte U_, R_, S_, U_, L_, A_, S_, U_, B_
	.byte B_, U_, L_, B_, A_, S_, A_, U_, R_
	.byte B_, R_, A_, B_, B_, U_, L_, S_, __
	.byte U_, D_, L_, R_, U_, D_, L_, R_, A_
	.byte U_, D_, L_, R_, U_, D_, L_, R_, B_
	.byte A_, A_, A_, L_, L_, L_, L_, L_, L_
	.byte A_, A_, A_, R_, R_, R_, R_, R_, R_
	.byte A_, A_, A_, U_, U_, U_, U_, U_, U_
	.byte A_, A_, A_, D_, D_, D_, D_, D_, D_

Cheat_Index = Temp_Var1
Cheat_Offset = Temp_Var2
Cheat_Number = Temp_Var3
Cheat_Length = 9
Cheat_Count = 20

Cheat_Code:
	LDA <Pad_Input
	BNE Cheat_CodeInput

	RTS

Cheat_CodeInput:
	LDX #$0F

Cheat_InputLoop:
	LDA Cheat_Input - 1, X
	STA Cheat_Input, X

	DEX
	BNE Cheat_InputLoop

	LDA <Pad_Input
	STA Cheat_Input

	LDA #$00
	STA <Cheat_Index
	STA <Cheat_Number

Cheat_BeginSearch:
	LDA #(Cheat_Length)
	STA <Cheat_Offset

	LDX #$00
	
	LDA <Cheat_Index
	ADD #(Cheat_Length - 1)
	TAY

Cheat_CodeSearch:
	LDA Cheat_Codes, Y
	BEQ Cheat_CodeSkip

	CMP Cheat_Input, X
	BNE Cheat_CodeBad

	INX

Cheat_CodeSkip:
	DEY
	DEC <Cheat_Offset
	
	LDA <Cheat_Offset
	BNE Cheat_CodeSearch
	BEQ Cheat_CodeSuccess

Cheat_CodeBad:
	INC <Cheat_Number

	LDA <Cheat_Index
	ADD #(Cheat_Length)
	STA <Cheat_Index

	CMP #(Cheat_Count * Cheat_Length)
	BNE Cheat_BeginSearch
	RTS

Cheat_CodeSuccess:
	LDA Sound_QLevel1
	ORA #SND_LEVEL1UP
	STA Sound_QLevel1

	LDA #$00
	STA Save_Menu_Showing

	LDA #PAUSE_RESUMEMUSIC
	STA Sound_QPause

	LDA #$00
	LDX #(Cheat_Count)

Cheat_Clear:
	STA Cheat_Input, X
	DEX
	BPL Cheat_Clear
	
	LDA <Cheat_Number
	
	JSR DynJump

	.word Cheat_AbilityUp
	.word Cheat_250Coins
	.word Cheat_25Cherries
	.word Cheat_1000Exp
	.word Cheat_Badge1
	.word Cheat_Badge2
	.word Cheat_Badge3
	.word Cheat_Badge4
	.word Cheat_Badge5
	.word Cheat_Badge6
	.word Cheat_DebugMode
	.word Cheat_Sub
	.word Cheat_SecondQuest
	.word Cheat_ToggleMoonGravity
	.word Cheat_IncreaseStars1
	.word Cheat_IncreaseStars10
	.word Cheat_SkipMapLeft
	.word Cheat_SkipMapRight
	.word Cheat_SkipMapUp
	.word Cheat_SkipMapDown

Cheat_DoNothing:
	RTS

Cheat_AbilityUp:
	LDA Player_Level
	CMP #ABILITY_MAX
	BCS Cheat_AbilityUpRTS

	INC Player_Level

Cheat_AbilityUpRTS:
	RTS

Cheat_250Coins:
	LDA #250
	STA Coins_Earned
	RTS

Cheat_25Cherries:
	LDA Player_Cherries
	ADD #25
	CMP #99
	BCC Cheat_25CherriesRTS

	LDA #99

Cheat_25CherriesRTS:
	STA Player_Cherries
	RTS

Cheat_1000Exp:
	LDA Player_Experience
	STA <CalcParam1

	LDA Player_Experience + 1
	STA <CalcParam1 + 1

	LDA Player_Experience + 2
	STA <CalcParam1 + 2

	LDA #$E7
	STA <CalcParam2

	LDA #$03
	STA <CalcParam2 + 1

	LDA #$00
	STA <CalcParam2 + 2

	JSR Add3ByteValue

	LDA <CalcResult
	STA Player_Experience

	LDA <CalcResult + 1
	STA Player_Experience + 1

	LDA <CalcResult + 2
	STA Player_Experience + 2

	INC Exp_Earned
	RTS

Cheat_Badge1:
	LDA #BADGE_ITEMRESERVE
	BNE Cheat_BadgeApply

Cheat_Badge2:
	LDA #BADGE_XP
	BNE Cheat_BadgeApply

Cheat_Badge3:
	LDA #BADGE_RADAR
	BNE Cheat_BadgeApply

Cheat_Badge4:
	LDA #BADGE_PMETER
	BNE Cheat_BadgeApply

Cheat_Badge5:
	LDA #BADGE_COIN
	BNE Cheat_BadgeApply

Cheat_Badge6:
	LDA #BADGE_AIR
	BNE Cheat_BadgeApply

Cheat_BadgeApply:
	STA Player_Badge
	RTS

Cheat_DebugMode:
	LDA Player_Debug
	EOR #$01
	STA Player_Debug
	RTS

Cheat_Sub:
	LDA Player_CheatSub
	EOR #$01
	STA Player_CheatSub
	RTS
	
Cheat_SecondQuest:
	LDA SecondQuest
	EOR #$01
	STA SecondQuest
	RTS

Cheat_ToggleMoonGravity:
	LDA Moon_Gravity
	EOR #$01
	STA Moon_Gravity
	RTS

Cheat_IncreaseStars1:
	INC Paper_Stars
	RTS

Cheat_IncreaseStars10:
	LDA Paper_Stars
	ADD #10
	STA Paper_Stars
	RTS

Cheat_SkipMapLeft:
	LDA #$01
	STA Map_PrevMoveDir
	RTS

Cheat_SkipMapRight:	
	LDA #$02
	STA Map_PrevMoveDir
	RTS

Cheat_SkipMapUp:
	LDA #$04
	STA Map_PrevMoveDir
	RTS

Cheat_SkipMapDown:
	LDA #$08
	STA Map_PrevMoveDir
	RTS