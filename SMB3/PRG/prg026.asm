; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-12 22:48:24.881635889 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

; FIXME: Appears to be unused Video_Upd_Table format data??
	.byte $20, $E6, $05, $F1, $FC, $9D, $9C, $9E, $21, $26, $05, $F2, $FC, $9D, $9C, $9E ; $0000 - $000F
	.byte $21, $66, $05, $F3, $FC, $9D, $9C, $9E, $21, $A6, $05, $F4, $FC, $9D, $9C, $9E ; $0010 - $001F
	.byte $21, $E6, $05, $F5, $FC, $9D, $9C, $9E, $22, $26, $05, $F6, $FC, $9D, $9C, $9E ; $0020 - $002F
	.byte $22, $66, $05, $F7, $FC, $9D, $9C, $9E, $22, $A6, $05, $F8, $FC, $9D, $9C, $9E ; $0030 - $003F
	.byte $21, $14, $02, $F0, $F3, $22, $14, $03, $F1, $FC, $F2, $3F, $00, $20, $0F, $0F ; $0040 - $004F
	.byte $30, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $16 ; $0050 - $005F
	.byte $30, $0F, $0F, $0F, $30, $0F, $0F, $0F, $30, $0F, $0F, $0F, $30, $0F, $00, $00 ; $0060 - $006F


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoInventory_And_PoofFX
;
; This is a super major function which entirely handles the
; inventory flip and usage on the map (opening, closing,
; using items, cycling items, etc.) and also manages the 
; "poof" effect that occurs when a power-up is used or a
; special item takes effect (e.g. hammer breaking lock)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Map_DoInventory_And_PoofFX:
	LDA Map_Powerup_Poof
	BEQ PRG026_A078	 ; If Map_Powerup_Poof = 0 (no powerup being applied), jump to PRG026_A078
	JSR Map_Poof_Update	 ; If "poof" is active, update it!

PRG026_A078:
	LDA Inventory_Open
	BEQ PRG026_A082	 	; If Inventory_Open = 0, jump to PRG026_A082

	; If Inventory_Open >= 1, set "2" into Player_HaltTick (???)
	; This actually isn't used on the map... perhaps there was
	; to be in-level inventory usage once?
	LDA #$02	 
	STA Player_HaltTick	 ; Player_HaltTick = 2

PRG026_A082:
	LDA InvFlip_Counter	; Call a subroutine based on the value in InvFlip_Counter
	JSR DynJump	 	; Dynamic jump based on LUT below...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	; Jump destinations based on InvFlip_Counter:
	.word Inventory_DoHilites	; 0: When inventory panel is open, highlight items
	.word Inventory_Close		; 1: Updates video to close panel down during flip
	.word Inventory_DoFlipPalChange	; 2: Change colors
	.word Inventory_DoFlipVideoUpd	; 3: Performs video updates as panel flips open or closed (includes displaying inventory items!)
	.word Inventory_DoPowerupUse	; 4: Does the "poof" effect from using a power-up item (and closing the Inventory)

Inventory_DoHilites:
	LDA #$2b	 
	STA InvFlip_VAddrHi	; VRAM Hi-byte is $2B

	LDA #$00	 
	STA InvHilite_Item 	; Hilite on first column

	LDX Level_Tileset	; X = Level_Tileset
	CPX #$07	 
	BEQ PRG026_A0A6	 	; If Level_Tileset = $07 (Toad House), jump to PRG026_A0A6

	STA InvStart_Item	; If not Toad House, Start on first row, first item

PRG026_A0A6:
	LDA #$48	 
	STA InvHilite_X	 	; First item hilited

	LDX #$00	 
	STX InvFlip_Frame	; InvFlip_Frame = 0

	INC InvFlip_Counter	; InvFlip_Counter = 1
	LDA Inventory_Open	 
	BEQ PRG026_A0CA	 	; If Inventory_Open = 0 (it's not), jump to PRG026_A0CA (RTS)

	; Inventory is open...
	LDA InvStart_Item	; A = InvStart_Item

PRG026_A0C3:
	TAX		 	; X = A (InvStart_Item + offset)
	LDA Inventory_Items,X	; Get this item -> A
	JMP InvItem_SetColor 	; Jump to InvItem_SetColor

PRG026_A0CA:
	RTS		 ; Return

InvFlip_VAddrLo_LUT:
	.byte $00, $60, $20, $40

Inventory_Close:
	LDX Graphics_BufCnt		; X = current position in graphics buffer
	LDA InvFlip_VAddrHi		; A = VRAM High Address
	STA Graphics_Buffer,X		; Store into the buffer
	LDY InvFlip_Frame	 	; Y = InvFlip_Frame
	LDA InvFlip_VAddrLo_LUT,Y	; Get appropriate low byte for video address
	STA Graphics_Buffer+1,X	 	; Store into the buffer

	; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
	LDA #VU_REPEAT | 32 	
	STA Graphics_Buffer+2,X		; Repeat 32 times
	LDA #$fc	 	
	STA Graphics_Buffer+3,X		; Tile $FC
	LDA #$00	 	
	STA Graphics_Buffer+4,X		; Terminator

	LDA Graphics_BufCnt
	ADD #$04	 
	STA Graphics_BufCnt	; Graphics_BufCnt += 4

	INY			; Y++
	TYA			; A = Y
	AND #$03		; A is 0 to 3 
	STA InvFlip_Frame	; Next indexed low byte
	BNE PRG026_A10F	 	; If A <> 0, jump to PRG026_A10F
	LDX Inventory_Open	; X = Inventory_Open
	BEQ PRG026_A109	 	; If Inventory_Open = 0, jump to PRG026_A109
	LDA #$08	 	; Otherwise, A = 8 (?)

PRG026_A109:
	STA InvFlip_Frame	; Update the lo index
	INC InvFlip_Counter	; InvFlip_Counter = 2

PRG026_A10F:
	RTS		 ; Return

	; Palette changes for opening the Inventory
	; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
Inventory_DoFlipPalChange:

	INC InvFlip_Counter	; InvFlip_Counter = 3
	RTS		 	; Return...

; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
Flip_Video_Data_Opening:	; Inventory_Open = 1

Flip_TopBarInv:	
	vaddr $2B00
	.byte $02, $FC, $80

	vaddr $2B02
	.byte VU_REPEAT | $1C, $81

	vaddr $2B1E
	.byte $02, $82, $FC

	.byte $00


	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidTItems:	
	vaddr $2B20

	;                 |    W    O   R   LD   [x]
	.byte  32, $FC, $90, $FE
	.byte  "ITEMS "

	; Top of items start rendering here (replaced at runtime)
	;      Item 1         Item 2         Item 3         Item 4         Item 5         Item 6         Item 7
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       |
	.byte $92, $FC

	.byte $00

	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidBItems:	
	vaddr $2B40

	;                 |    < M >     x  [ Lives]
	.byte  32, $FC, $90, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	; Bottom of items start rendering here (replaced at runtime)
	;      Item 1         Item 2         Item 3         Item 4         Item 5         Item 6         Item 7
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       |
	.byte $92, $FC

	.byte $00

Flip_BottomBarInv:	
	vaddr $2B60
	.byte   2, $FC, $A0
	
	vaddr $2B62
	.byte VU_REPEAT | 28, $A1

	vaddr $2B7E
	.byte 2, $A2, $FC

	.byte $00

; ******************************************************************


; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
Flip_Video_Data_Closing:	; Inventory_Open = 0

Flip_TopBarMid:
	vaddr $2B20
	.byte 2, $FC, $80

	vaddr $2B22
	.byte VU_REPEAT | 28, $81

	vaddr $2B3E
	.byte 2, $A2, $FC

	.byte $00

Flip_BotBarMid:
	; Lower left corner
	vaddr $2B40
	.byte 2, $FC, $A8

	; Bottom bar
	vaddr $2B42
	.byte VU_REPEAT | 28, $A4

	; Upper right corner
	vaddr $2B5E
	.byte 2, $A5, $FC

	.byte $00

Flip_EraseTopBarMid:	
	vaddr $2B20
	.byte VU_REPEAT | 32, $FC

	.byte $00

Flip_EraseBotBarMid:	
	vaddr $2B40
	.byte VU_REPEAT | 32, $FC
	
	.byte $00

	; Sync with PRG030 "StatusBar" macro
Flip_TopBarCards:
	vaddr $2B00
	.byte 2, $FC, $80

	vaddr $2B02
	.byte VU_REPEAT | 18, $81	; Bar across the top

	vaddr $2B14
	.byte 12, $81, $81, $81, $81, $81, $81, $81, $81, $81, $81, $82, $FC	; TOP SLOT ON FLIP

	.byte $00

	; Sync with PRG030 "StatusBar" macro
	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidTStatCards:	
	vaddr $2B20

	.byte $20, $FE, $90, $FE, $D1, $D1, $D1, $D1, $D1, $D1, $FE, $E0, $E9, $E9, $E9, $E9	; [M/L]x  000000 c000| etc.
	.byte $EA, $48, $D0, $30, $30, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $92, $FC

	.byte $00

	; Sync with PRG030 "StatusBar" macro
	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidBStatCards:	
	vaddr $2B40

	; Discrepency --------v  (Pattern is ... $FE, $FE ... in PRG030 status bar)  Unimportant; inserts <M> which is replaced anyway
	.byte $20, $FE, $90, $FE, $30, $30, $30, $30, $30, $30, $FE, $D0, $30, $30, $30, $30	; [M/L]x  000000 c000| etc.
	.byte $FE, $D3, $30, $30, $30, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $92, $FC
	; Discrepency --------^  (Pattern is ... $F0, $F0 ... in PRG030 status bar graphics)

	.byte $00

	; Sync with PRG030 "StatusBar" macro
Flip_BottomBarCards:	
	vaddr $2B60
	.byte $02, $FC, $A0	; Lower corner

	vaddr $2B62
	.byte VU_REPEAT | 18, $A1	; Bottom bar

	vaddr $2B74
	.byte $0C, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A2, $FC	; lower corner and card bottoms

	.byte $00

Flip_END:
; ******************************************************************

InvGBuf_By_Open:	; Points to two different graphics buffer data blocks depending on Inventory_Open
	.word Flip_Video_Data_Closing, Flip_Video_Data_Opening

FVDC .func \1-Flip_Video_Data_Closing
FVDO .func \1-Flip_Video_Data_Opening

Flip_Video_Offsets:
	; Offsets into Flip_Video_Data_Closing
	.byte FVDC(Flip_TopBarMid)	;  0: Draw top bar (at middle)
	.byte FVDC(Flip_BotBarMid)	;  1: Draw bottom bar (at middle)
	.byte FVDC(Flip_EraseTopBarMid)	;  2: Erase top bar (at middle)
	.byte FVDC(Flip_EraseBotBarMid)	;  3: Erase bottom bar (at middle)
	.byte FVDC(Flip_MidTStatCards)	;  4: Draw top middle row of normal status bar/cards
	.byte FVDC(Flip_MidBStatCards)	;  5: Draw bottom middle row of normal status bar/cards
	.byte FVDC(Flip_TopBarCards)	;  6: Draw top bar (at top)
	.byte FVDC(Flip_BottomBarCards)	;  7: Draw bottom bar (at bottom)

	; Offsets into Flip_Video_Data_Opening (note reuse of Closing data)
	.byte FVDO(Flip_TopBarMid)	;  8: Draw top bar (at middle)
	.byte FVDO(Flip_BotBarMid)	;  9: Draw bottom bar (at middle)
	.byte FVDO(Flip_EraseTopBarMid)	; 10: Erase top bar (at middle)
	.byte FVDO(Flip_EraseBotBarMid)	; 11: Erase bottom bar (at middle)
	.byte FVDO(Flip_MidTItems)	; 12: Draw top middle row of inventory
	.byte FVDO(Flip_MidBItems)	; 13: Draw bottom middle row of inventory
	.byte FVDO(Flip_TopBarInv)	; 14: Draw top bar (at top)
	.byte FVDO(Flip_BottomBarInv)	; 15: Draw bottom bar (at bottom)

Flip_Video_Ends:
	; Ending data addresses per offset into Flip_Video_Data_Closing (when to stop copying!)
	.byte FVDC(Flip_BotBarMid)	; 0
	.byte FVDC(Flip_EraseTopBarMid)	; 1
	.byte FVDC(Flip_EraseBotBarMid)	; 2
	.byte FVDC(Flip_TopBarCards)	; 3
	.byte FVDC(Flip_MidBStatCards)	; 4
	.byte FVDC(Flip_BottomBarCards)	; 5
	.byte FVDC(Flip_MidTStatCards)	; 6
	.byte FVDC(Flip_END)		; 7

	; Ending data addresses per offset into Flip_Video_Data_Opening (when to stop copying!)
	.byte FVDO(Flip_BotBarMid)	; 8
	.byte FVDO(Flip_EraseTopBarMid)	; 9
	.byte FVDO(Flip_EraseBotBarMid)	; 10
	.byte FVDO(Flip_TopBarCards)	; 11
	.byte FVDO(Flip_MidBItems)	; 12
	.byte FVDO(Flip_BottomBarInv)	; 13
	.byte FVDO(Flip_MidTItems)	; 14
	.byte FVDO(Flip_TopBarMid)	; 15

InvFlip_TileLayout_Sel:
	; Based on Inventory_Open
	.word InvCard_Tile_Layout	; When inventory closing, render cards
	.word InvItem_Tile_Layout	; When inventory opening, render items

InvCard_Tile_Layout:	
	RTS

	;# INVENTORY ITEM CODE

InvItem_Tile_Layout:
	; Item tiles layout when closing/unselected
	; NOTE: See also InvItem_Hilite_Layout
	.byte $FE, $FE, $FE, $FE	; Empty
	.byte $B0, $B1, $C0, $C1
	.byte $B2, $B3, $C2, $C3
	.byte $BC, $BD, $CC, $CD
	.byte $B4, $B5, $C4, $C5
	.byte $BE, $BF, $CE, $CF
	.byte $B6, $B7, $C6, $C7
	.byte $B8, $B9, $C8, $C9
	.byte $DC, $DD, $EC, $ED
	.byte $BA, $BB, $CA, $CB
	.byte $DE, $DF, $EE, $EF
	.byte $84, $85, $94, $95
	.byte $86, $87, $96, $97
	.byte $88, $89, $98, $99
	.byte $8A, $8B, $9A, $9B
	.byte $8E, $8F, $9E, $9F
	.byte $A4, $A5, $A6, $A7
	.byte $A8, $A9, $AA, $AB
	; Shield
	.byte $00, $01, $10, $33


Inventory_DoFlipVideoUpd:
	LDA Inventory_Open
	ASL A
	TAX		 	; X = Inventory_Open << 1

	; Store address to video data into Temp_Var15 based on Inventory_Open status
	LDA InvGBuf_By_Open,X
	STA <Temp_Var15	
	LDA InvGBuf_By_Open+1,X
	STA <Temp_Var16

	; InvFlip_Frame indexes which block of video data we'll be using...

	LDY InvFlip_Frame		; Y = InvFlip_Frame
	LDA Flip_Video_Ends,Y		; Get offset value that is the END of the video data
	STA <Temp_Var13			; Store into Temp_Var13

	LDA Flip_Video_Offsets,Y	; Get offset value that is the BEGINNING of the video data
	TAY		 		; Y = A

	LDX Graphics_BufCnt	
	STX <Temp_Var9			; Temp_Var9 = Graphics_BufCnt (where in Graphics_Buffer we begin)

	; Copy all of the video update data into the Graphics_Buffer
PRG026_A2E4:
	LDA [Temp_Var15],Y	; Get next byte 
	STA Graphics_Buffer,X	; Store it into the buffer
	INX		 	; X++
	INY		 	; Y++
	CPY <Temp_Var13		
	BNE PRG026_A2E4	 	; While Y <> end of update data, loop!

	LDA Graphics_BufCnt
	ADD #12
	STA <Temp_Var13		; Temp_Var13 = Offset to 12 bytes in from where we started the graphics buffer
	DEX		 
	STX Graphics_BufCnt	; Update Graphics_BufCnt with where the buffer actually is

	LDA InvFlip_Frame
	AND #$07
	TAX
	DEX		 	; X = (InvFlip_Frame & 7) - 1
	SUB #$04	 	; A = (InvFlip_Frame & 7) - 4
	CMP #$02	 
	BGE PRG026_A30C	 	; If A >= 2, jump to PRG026_A30C
	JSR Inventory_DrawItemsOrCards	 	; Otherwise, JSR to Inventory_DrawItemsOrCards

PRG026_A30C:
	JSR InvFlipFrame_UpdateStatusBar ; Update status bar as needed for flip frame
	INC InvFlip_Frame	; InvFlip_Frame++
	LDA InvFlip_Frame	 
	AND #$07	 
	BNE PRG026_A327	 	; If InvFlip_Frame & 7 <> 0, jump to PRG026_A327 (RTS)

	; We've reached fully open or closed!
	LDA Inventory_Open
	BNE PRG026_A324		; If fully open, jump to PRG026_A324

	; Fully closed!
	LDA #$00	 	
	STA InvFlip_Counter	; InvFlip_Counter = 0
	RTS		 	; Return!

PRG026_A324:
	; Fully open...
	INC InvFlip_Counter	; InvFlip_Counter = 4

PRG026_A327:
	RTS		 	; Return

Inventory_DrawItemsOrCards:
	LDA Inventory_Open
	BNE PRG026_A344		; If Inventory_Open <> 0, jump to PRG026_A344

PRG026_A336:

	JMP PRG026_A355	 	; Jump to PRG026_A355...

PRG026_A344:
	; Inventory is opening!  Set up for inventory items!

	LDA #(Inventory_Items - Inventory_Items)	; Mario's inventory
	LDX Player_Current				; X = Player_Current
	BEQ PRG026_A34D					; If Player_Current = 0 (Mario), jump to PRG026_A34D
	LDA #(Inventory_Items2 - Inventory_Items)	; Luigi's inventory

PRG026_A34D:
	ADD InvStart_Item	; Offset to the starting item
	STA <Temp_Var14		; Store this into Temp_Var14 (offset to first pattern in item layout)
	LDA #$06	 	; Number of items to display minus one

PRG026_A355:
	STA <Temp_Var11		; Store number of items to display...

	; Set pointer to proper render items
	LDA Inventory_Open
	ASL A		 
	TAX		 ; X = Inventory_Open * 2 (2 byte index)
	LDA InvFlip_TileLayout_Sel,X
	STA <Temp_Var15	
	LDA InvFlip_TileLayout_Sel+1,X
	STA <Temp_Var16		; Temp_Var15/16 point to start of pattern data for inventory items / cards

PRG026_A366:
	LDY <Temp_Var14	; Starting item/card offset

	LDA Inventory_Items,Y	; Get this item
	BEQ PRG026_A38B	 	; If it's an empty slot, jump to PRG026_A38B

	; Item/card to process...
	ASL A		
	ASL A		
	TAY		 	; Y = item << 2

	LDA InvFlip_Frame
	AND #$07
	CMP #$04	 
	BEQ PRG026_A37D	 	; If currently on InvFlip_Frame = 4 or 12 (drawing the top half of items/cards), jump to PRG026_A37D

	; On frame 5, the bottom half of the object/card is drawn in
	TYA		 
	ORA #$02	 
	TAY		 	; Y (item offset) OR'd with 2 (do the bottom half of the object!)

PRG026_A37D:

	; This loop copies two bytes of the item/card
	; into the buffer; the graphic is made up of 4 bytes,
	; but in a single row of 8x8s, it's two at a time :)
	LDX <Temp_Var13		; X = Temp_Var13 (offset into the graphics buffer)
PRG026_A37F:
	LDA [Temp_Var15],Y	; Get next tile for this power-up
	STA Graphics_Buffer,X	; Store it into the graphics buffer
	INX		 	; X++
	INY		 	; Y++
	TYA		 	
	AND #$01	 	; A = Y & 1
	BNE PRG026_A37F	 	; If A <> 0, loop (loops for two bytes)

PRG026_A38B:
	LDA <Temp_Var13		; X = Temp_Var13 (offset into the graphics buffer)
	ADD #$03
	STA <Temp_Var13		; Temp_Var13 += 3 (2 for the power-up, 1 for spacing)
	INC <Temp_Var14	; Next item!
	DEC <Temp_Var11		; One less item left to display...
	BPL PRG026_A366	 	; While Temp_Var11 >= 0, loop!

PRG026_A398:

InvFlipFrame_DoNothing:
	RTS		 	; Return...


InvFlipFrame_UpdateStatusBar:
	LDA InvFlip_Frame
	AND #$07
	JSR DynJump

	; THESE MUST BE HERE FOR DynJump TO WORK!
	.word InvFlipFrame_DoNothing		; 0
	.word InvFlipFrame_DoNothing		; 1
	.word InvFlipFrame_DoNothing		; 2
	.word InvFlipFrame_DoNothing		; 3
	.word InvFlipFrame_DrawWorldCoins	; 4
	.word InvFlipFrame_DrawMLLivesScore	; 5
	.word InvFlipFrame_DoNothing		; 6
	.word InvFlipFrame_DoNothing		; 7

InvFlipFrame_DrawWorldCoins:
	RTS		 ; Return

InvFlipFrame_DrawMLLivesScore:
	RTS		 ; Return

; These tables really define a lot of behavior for the inventory item menu
InvItem_AddSub:		.byte 7, -7	; Press down to go forward 7 items, up to go back 7 items
InvItem_IndexOOR:	.byte 28, -7	; Out-of-range index values for wrap-around when pressing down/up
InvItem_Wrap:		.byte 0, 21	; Wrap-around values for Inventory start
InvItem_NextPrior:	.byte 24, -24	; Whether left or right was pressed, how to add/sub the highlight X position
InvItem_HiliteOORX:	.byte 240, 48	; Highlight out-of-range X position to tell when at ends, for right/left
InvItem_HiliteMinMax:	.byte 72, 216	; Highlight left min and right max for right/left overflows
InvItem_RightLeft:	.byte 1, -1	; Whether right or left was pressed, how to inc/dec the highlight index
InvItem_RightLeftMinMax:.byte 0, 6	; Right/left overflows wrap-around index value
InvItem_PerPlayerOff:	.byte $00, (Inventory_Items2 - Inventory_Items)	; Offset per player
Inventory_DoPowerupUse:
	LDA Map_Powerup_Poof
	BNE PRG026_A398	 	; If no power-up "poof" effect occurring, jump to PRG026_A398 (RTS)

	LDA <Map_UseItem
	BEQ PRG026_A41A	 	; If Map_UseItem = 0 (not using item), jump to PRG026_A41A
	JMP PRG026_A4FC	 	; Otherwise, jump to PRG026_A4FC

PRG026_A41A:
	; Not using item
	LDA Pad_Input	 ; Get Player 
	AND #(PAD_B | PAD_START)	; B or START close the Inventory panel
	BEQ PRG026_A436	 ; If neither B nor START are pressed, jump to PRG026_A436

	; Need to close the panel
	LDA #SND_MAPINVENTORYFLIP	 
	STA Sound_QMap	 	; Play inventory flip sound
Inventory_ForceFlip:
	LDA Inventory_Open	
	EOR #$01	 
	STA Inventory_Open	; Inventory_Open ^= 1 (set to opposite)
	LDA #$00	 
	STA InvFlip_Counter	; Reset Inventory_Open
	JMP Inventory_DoHilites	; Jump to Inventory_DoHilites

PRG026_A436:
	; Neither B nor START pressed
	LDA Pad_Input
	AND #(PAD_DOWN | PAD_UP)
	BEQ PRG026_A491	 	; If neither up nor down pressed, jump to PRG026_A491

	; Up or Down pressed...
	LSR A
	LSR A
	LSR A
	TAY		 	; Y = Pad_Input >> 3 (will be 0 if down, 1 if up)
	LDA #SND_LEVELBLIP	 
	STA Sound_QLevel1	; Play item select sound

	LDA InvStart_Item	; A = InvStart_Item
	ADD InvItem_AddSub,Y	; +/- 7 based on up/down

	STA InvStart_Item	; Update InvStart_Item
	CMP InvItem_IndexOOR,Y
	BNE PRG026_A45B	 	; If we haven't hit the max or min, jump to PRG026_A45B

	; We've hit a limit!
	LDA InvItem_Wrap,Y
	STA InvStart_Item	; Wrap-around

PRG026_A45B:
	LDX InvStart_Item	; X = InvStart_Item
	LDA Player_Current	; A = Player_Current
	BEQ PRG026_A468	 	; If Player_Current = 0 (Mario), jump to PRG026_A468
	TXA			; A = InvStart_Item
	ADD #(Inventory_Items2 - Inventory_Items)	 ; Offset to Luigi's items
	TAX			; X = offset to item

PRG026_A468:
	LDY Player_Current		; Y = Player_Current
	TXA		 		; A = starting of the row Inventory item
	CMP InvItem_PerPlayerOff,Y	; If it's the very first item of this player (just wrapped around)
	BEQ PRG026_A476	 		; If so, jump to PRG026_A476

	LDA Inventory_Items,X	 	; A = next item
	BEQ PRG026_A436	 		; Jump to PRG026_A436 if row is not empty

PRG026_A476:
	LDA Inventory_Items,X	 	; A = next item
	JSR InvItem_SetColor	 	; Properly set colors for this item

Inventory_ForceUpdate_AndFlip:
	LDA #$0c	 		
	STA InvFlip_Frame	 	; InvFlip_Frame = $0C
	LDA #$03	 	
	STA InvFlip_Counter	 	; InvFlip_Counter = 3
	LDA #$00	 
	STA InvHilite_Item	 	; InvHilite_Item = 0 (first item highlighted on new row)
	LDA #$48	 
	STA InvHilite_X			; InvHilite_X = $48 (first item highlighted on new row)
	RTS		 	; Return...

PRG026_A491:
	; Neither B nor START nor Up nor Down pressed...
	LDA Level_Tileset
	CMP #$07	 
	BEQ PRG026_A4A6	 	; If Level_Tileset = 7 (Toad House), jump to PRG026_A4A6 (RTS)
	LDY #$00		; Y = 0
	LDX Player_Current	; X = Player_Current
	BEQ PRG026_A4A1		; If Player_Current = 0 (Mario), jump to PRG026_A4A1
	LDY #(Inventory_Items2 - Inventory_Items)	 ; Offset to Luigi's items

PRG026_A4A1:
	LDA Inventory_Items,Y
	BNE PRG026_A4A7		; If first item is not empty, jump to PRG026_A4A7

PRG026_A4A6:
	RTS		 	; Otherwise, just return...

PRG026_A4A7:
	LDA <Pad_Input	 
	AND #(PAD_LEFT | PAD_RIGHT)	 
	BEQ PRG026_A4F6	 	; If neither left nor right is pressed, jump to PRG026_A4F6

	LSR A		 	; Diminish to 0/1 condition (right = 0, left = 1)
	TAX		 	; Move result to X

	LDA #SND_LEVELBLIP	 
	STA Sound_QLevel1	; Play item selection sound

PRG026_A4B4:
	LDA InvHilite_Item
	ADD InvItem_RightLeft,X	; Inc/Dec InvHilite_Item appropriately
	STA InvHilite_Item	; Update InvHilite_Item

	LDA InvHilite_X	
	ADD InvItem_NextPrior,X	; Add/Sub to highlight X as appropriate
	STA InvHilite_X	  	; Update InvHilite_X

	CMP InvItem_HiliteOORX,X	
	BNE PRG026_A4D9	 	; If we have NOT hit an item limit, jump to PRG026_A4D9

	; Properly wrap the item selection around to the left or right side
	LDA InvItem_RightLeftMinMax,X
	STA InvHilite_Item	
	LDA InvItem_HiliteMinMax,X
	STA InvHilite_X	 	

PRG026_A4D9:
	LDA InvHilite_Item
	ADD InvStart_Item
	TAY		 	; Y = InvHilite_Item + InvStart_Item
	LDA Player_Current	; A = Player_Current
	BEQ PRG026_A4EB	 	; If Player_Current = 0 (Mario), jump to PRG026_A4EB

	; Luigi...
	TYA		 	
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y = InvHilite_Item + InvStart_Item + Luigi offset

PRG026_A4EB:
	LDA Inventory_Items,Y	; Get the selected item
	BEQ PRG026_A4B4	 	; If item is zero (empty slot), jump to PRG026_A4B4 (moves inventory slot back)
	JSR InvItem_SetColor 	; Otherwise, set the color...
	JMP PRG026_A511	 	; Then jump to PRG026_A511

PRG026_A4F6:
	LDA <Pad_Input		
	AND #PAD_A
	BEQ PRG026_A511	 	; If Player is NOT pressing A, jump to PRG026_A511

PRG026_A4FC:
	LDA InvHilite_Item
	ADD InvStart_Item
	TAY		 	; Y = InvHilite_Item + InvStart_Item

	LDA Player_Current
	BEQ PRG026_A50E	 	; If Player_Current = 0 (Mario), jump to PRG026_A50E
	TYA		 	
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y += Luigi offset

PRG026_A50E:
	JMP Inv_UseItem	 ; Use item and don't come back!

PRG026_A511:
	JMP Inv_Display_Hilite	 ; Highlight item and don't come back!

;#INVENTORY ITEM PALETTE
InvItem_Pal: 
	; Per-Item LUT
	;	0    1    2    3    4    5    6    7    8    9   10   11   12   13
	.byte $FF, $0F, $30, $16
	.byte $FF, $0F, $30, $16
	.byte $FF, $0F, $30, $1A
	.byte $FF, $0F, $30, $1A
	.byte $FF, $0F, $36, $06
	.byte $FF, $0F, $30, $27
	.byte $FF, $0F, $30, $1A
	.byte $FF, $0F, $30, $1A
	.byte $FF, $0F, $36, $27
	.byte $FF, $0F, $30, $27
	.byte $FF, $0F, $30, $16
	.byte $FF, $0F, $30, $16
	.byte $FF, $0F, $30, $11
	.byte $FF, $0F, $30, $28
	.byte $FF, $0F, $36, $17
	.byte $FF, $0F, $30, $16
	.byte $FF, $0F, $30, $31
	.byte $FF, $0F, $30, $16
	; Shield
	.byte $FF, $0F, $36, $27

InvItem_SetColor:
	; Inventory is open ... assign proper color for item that is highlighted
	LDX Level_Tileset	; X = Level_Tileset
	CPX #$07	 	
	BEQ PRG026_A539	 	; If Level_Tileset = 7 (Toad House), jump to PRG026_A539 (RTS)

	ASL A
	ASL A
	TAX		 	; A = Current inventory item selected
	LDA InvItem_Pal + 1,X	; Get the color that will be used for this item
	STA Palette_Buffer+$15	; Store it into the palette buffer
	LDA InvItem_Pal + 2,X	; Get the color that will be used for this item
	STA Palette_Buffer+$16	; Store it into the palette buffer
	LDA InvItem_Pal + 3,X	; Get the color that will be used for this item
	STA Palette_Buffer+$17	; Store it into the palette buffer 

	LDA #$06		
	STA <Graphics_Queue	; Update the palette when capable

PRG026_A539:
	RTS		 ; Return


; #ITEM USE JUMP TABLE
Inv_UseItem:
	LDA Inventory_Items,Y		; Get which item to use
	JSR DynJump	 		; Dynamic jump based on item used

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	; Inventory per-item jump table!
	.word PRG026_A4A6			; Small
	.word Inv_UseItem_Powerup	; Big
	.word Inv_UseItem_Powerup	; Fire
	.word Inv_UseItem_Powerup	; Ice
	.word Inv_UseItem_Powerup	; Raccoon
	.word Inv_UseItem_Powerup	; Fox
	.word Inv_UseItem_Powerup	; Frog
	.word Inv_UseItem_Powerup	; Koopa
	.word Inv_UseItem_Powerup	; Boo
	.word Inv_UseItem_Powerup	; Hammer Suit
	.word Inv_UseItem_Powerup	; Ninja
	
InvItem_PerPowerUp_L1Sound:
	; Sound to play for each Power Up item when used...
	.byte $00				; Small
	.byte SND_LEVELPOWER	; Big
	.byte SND_LEVELPOWER	; Fire
	.byte SND_LEVELPOWER	; Ice
	.byte SND_LEVELPOOF		; Raccoon
	.byte SND_LEVELPOOF		; Fox
	.byte SND_LEVELPOOF		; Frog
	.byte SND_LEVELPOOF		; Koopa
	.byte SND_LEVELPOOF		; Boo
	.byte SND_LEVELPOOF		; Hammer Suit
	.byte SND_LEVELPOOF		; Ninja

InvItem_PerPowerUp_Disp:
	; Powerup to display on map per powerup used
	;      ES   SM   FF   L    FS   TS   HS   JC   PW 
	.byte $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B

	; These define the colors set per use of a power-up item.  Note that only the first three
	; bytes are actually used.  "Power-up zero" (which I guess would be small Mario) is 
	; present here, likely for simplicity, but it is also not used (there is no "power down")
	; See also PRG027 InitPals_Per_MapPUp
InvItem_PerPowerUp_Palette:
	; Mario
	.byte $16, $36, $0F, $FF	; Small
	.byte $16, $36, $0F, $FF	; Big
	.byte $30, $36, $06, $FF	; Fire
	.byte $30, $31, $01, $FF	; Ice
	.byte $16, $36, $0F, $FF	; Raccoon
	.byte $27, $36, $06, $FF	; Fox
	.byte $2A, $36, $0F, $FF	; Frog
	.byte $19, $36, $0F, $FF	; Koopa
	.byte $06, $30, $0F, $FF	; Boo
	.byte $30, $27, $0F, $FF	; Hammer Suit
	.byte $30, $27, $0F, $FF	; Ninja

Inv_UseItem_Powerup:
	LDA InvHilite_Item
	ADD InvStart_Item
	TAY		 	; Y = InvHilite_Item + InvStart_Item (currently highlighted item)

	LDX Inventory_Items,Y	; Get the item (should be a POWER-UP item, Super Mushroom to P-Wing only)
	TXA		 	
	ASL A		 
	ASL A		 
	TAY		 	; Y = X << 2
	 
	; Load the colors for this power-up into the palette buffer
	LDA InvItem_PerPowerUp_Palette,Y
	STA Palette_Buffer+17
	LDA InvItem_PerPowerUp_Palette+1,Y
	STA Palette_Buffer+18
	LDA InvItem_PerPowerUp_Palette+2,Y
	STA Palette_Buffer+19

	; Queue palette update
	LDA #$06
	STA <Graphics_Queue

	; Play the correct sound for this power up item
	LDA InvItem_PerPowerUp_L1Sound,X
	STA Sound_QLevel1

	LDA InvItem_PerPowerUp_Disp,X	; Store proper power-up to display -> A
	STA Map_Power_Disp	 	; Power-up to display -> Map_Power_Disp
	STA World_Map_Power	 	; Update appropriate player's "Map Power Up"

PRG026_A60B:
	LDA #$14	 
	STA Map_Powerup_Poof	 	; Map_Powerup_Poof = $14
	LDX Player_Current	 	; X = Player_Current

	; Target "Map Poof" on active Player
	LDA <World_Map_Y,X
	STA <MapPoof_Y	
	LDA <World_Map_X,X
	STA <MapPoof_X	

Inv_UseItem_ShiftOver:
	LDA #27
	STA <Temp_Var15	 	; Temp_Var15 = 27 (last index of items to shift)

	LDA InvHilite_Item
	ADD InvStart_Item
	TAY			; Y = InvHilite_Item + InvStart_Item

	LDA Player_Current	
	BEQ PRG026_A638	 	; If Player_Current = 0 (Mario), jump to PRG026_A638

	LDA #27
	ADD #(Inventory_Items2 - Inventory_Items)	; This could've been done as a constant, but oh well!
	STA <Temp_Var15		; Temp_Var15 += Luigi items offset (last index of Luigi items to shift)

	TYA		 
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y += Luigi items offset

	; This loop "removes" the used item by backing the other items over it
PRG026_A638:
	CPY <Temp_Var15
	BEQ PRG026_A646
	LDA Inventory_Items+1,Y
	STA Inventory_Items,Y	
	INY		
	JMP PRG026_A638	
PRG026_A646:
	LDA #$00	
	STA Inventory_Items,Y	 ; This clears the very last item

PRG026_A64B:
	LDY InvStart_Item	; Y = InvStart_Item
	BEQ PRG026_A66B	 	; If InvStart_Item = 0, jump to PRG025_A66B

	LDA Player_Current
	BEQ PRG026_A65A	 	; If Player_Current = 0, jump to PRG026_A65A
	TYA
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y is Offset to Luigi's items

PRG026_A65A:
	LDA Inventory_Items,Y	; Get item
	BNE PRG026_A66B	 	; If Y <> 0, jump to PRG026_A66B

	; If Player used first item on row, this backs it up one row
	LDA InvStart_Item
	SUB #$07
	STA InvStart_Item	; InvStart_Item -= 7
	JMP PRG026_A64B		; Jump to PRG026_A64B

PRG026_A66B:
	JSR Inventory_ForceUpdate_AndFlip	; Forces Inventory to flip back over
	JMP Inv_Display_Hilite	 	; Jump to Inv_Display_Hilite...

Inv_UseItem_Starman:
	INC Map_Starman	 		; Set Starman active (Nintendo's betting you never would have more than 255 on the map!)
	LDA Sound_QLevel1	 
	ORA #SND_LEVELPOWER	 	
	STA Sound_QLevel1		; Player "Power-up" noise
	JSR Inv_UseItem_ShiftOver	; Shift over all items over top of the Starman
	JMP Inventory_ForceFlip		; Force inventory to flip over

Inv_UseItem_Anchor: 
	LDA Map_Anchored
	BEQ PRG026_A690	 ; If Map_Anchored = 0, jump to PRG026_A690

Inv_UseItem_Denial:
	; Otherwise, play denial sound; prevents multiple usage
	LDA Sound_QMap
	ORA #SND_MAPDENY	
	STA Sound_QMap	 ; Denial sound
	RTS		 ; Return

PRG026_A690: 
	INC Map_Anchored 		; Set map as anchored
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF	 
	STA Sound_QLevel1		; Player powerup sound
	JSR Inv_UseItem_ShiftOver	; Shift over all items over top of the Anchor
	JMP Inventory_ForceFlip	 	; Force inventory to flip over

Inv_UseItem_MusicBox:
	LDA #$02
	STA Map_MusicBox_Cnt	 ; Map_MusicBox_Cnt = 2

	LDA #MUS2A_MUSICBOX
	STA Sound_QMusic2	 ; Play Music Box song

	JSR Inv_UseItem_ShiftOver	 ; Shift over all items over top of the Music Box
	JMP Inventory_ForceFlip	 ; Force inventory to flip and don't come back! 

RockBreak_Replace:	.byte $BF, $BF	; The path replacement tiles (NOTE: see also PRG012 Map_RemoveTo_Tiles)

RockBreak_TileFix:
	; These specify the tiles that replace the tiles of the rock.
	; Note for some reason these are interleved, meaning the first,
	; third, fifth, and seventh bytes are for rock $51, and the others
	; for rock $52...
	.byte $FE, $FE, $E1, $FE, $FE, $C0, $E1, $C0

Inv_UseItem_Hammer: 
	LDA #$03
	STA <Temp_Var1	 ; Temp_Var1 = 3 (checking all 4 directions around Player)

PRG026_A6BF:
	LDY <Temp_Var1	 		; Y = LDY <Temp_Var1
	JSR MapTile_Get_By_Offset	; Get map tile nearby player (on page 10)

	; Rock tiles:
	SUB #TILE_ROCKBREAKH	 ; Offset to rock tiles
	CMP #$02	 ; See if value is less than 2 (rock to break)
	BLT PRG026_A6D2	 ; If rock, jump to PRG026_A6D2

	DEC <Temp_Var1		; Temp_Var1--
	BPL PRG026_A6BF	 	; While directions to search, loop!

	JMP Inv_UseItem_Denial	; No way to use hammer; deny!

PRG026_A6D2:
	; Rock to break...

	STX <Temp_Var2		; Store screen high byte -> Temp_Var2
	LSR <Temp_Var2		; Temp_Var2 >>= 1 (previously used as index into Map_Tile_Addr, now back to just a screen index)
	PHA		 	; Save 'A' (map tile minus TILE_ROCKBREAKH, either 0 or 1)
	TAX		 	; X = A
	LDA RockBreak_Replace,X	; Get the tile number that replaces this rock
	STA [Map_Tile_AddrL],Y	; Store it in place!

	; "Poof" where the rock sits
	TYA
	ASL A
	ASL A
	ASL A
	ASL A		; Multiply by 16 for X
	STA <MapPoof_X
	STA <Temp_Var3	; Temp_Var3 = MapPoof_X

	TYA		
	AND #$f0	
	ADD #$10	; Decouple a Y
	STA <MapPoof_Y
	STA <Temp_Var1	; Temp_Var1 = MapPoof_Y

	JSR Map_SetCompletion_By_Poof	 ; Set completion bit based on location of map "poof"

	; Rock removal sets completion bit for BOTH Players!
	; The following will set it for whatever Player didn't get the 
	; completion bit set... pretty neat.
	TYA		 ; A = offset to map completion byte for this Player
	EOR #$40	 ; Flip to the OTHER Player
	TAY	

	; Take the Map poof coordinates and calculate what address in
	; Nametable 2 we need to modify to remove the rock...
	LDX <MapPoof_X		 ; X = MapPoof_X
	LDA <MapPoof_Y		 ; A = MapPoof_Y
	JSR Map_Calc_NT2Addr_By_XY

	PLA		 	; Retore 'A' (0 or 1, depending on which rock was busted)
	TAX		 	; X = A

	; Buffer in the rock replacement tiles
	LDY Graphics_BufCnt
	LDA <Temp_Var15	
	STA Graphics_Buffer,Y
	STA Graphics_Buffer+5,Y
	LDA <Temp_Var16	
	STA Graphics_Buffer+1,Y	
	ADD #$01
	STA Graphics_Buffer+6,Y
	LDA #$82
	STA Graphics_Buffer+2,Y
	STA Graphics_Buffer+7,Y
	LDA RockBreak_TileFix,X
	STA Graphics_Buffer+3,Y
	LDA RockBreak_TileFix+2,X
	STA Graphics_Buffer+4,Y	
	LDA RockBreak_TileFix+4,X
	STA Graphics_Buffer+8,Y
	LDA RockBreak_TileFix+6,X
	STA Graphics_Buffer+9,Y	

	; Terminator
	LDA #$00
	STA Graphics_Buffer+10,Y

	TYA		 
	ADD #10	 		
	STA Graphics_BufCnt	; Graphics_BufCnt += 10 (bytes added to buffer)

	; Play rock crumbling sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	; Do the poof!
	LDA #$14	
	STA Map_Powerup_Poof
	JSR Map_Poof_Update

	JMP Inv_UseItem_ShiftOver	 ; Shift all items over and don't come back 

Map_WWOrHT_StartX:
	; For the wind coming from the left or the right...
	.byte 0, 240

Inv_UseItem_WarpWhistle:
	LDY Player_Current	; Y = Player_Current
	LDX #$00	 	; X = 0 (Wind comes from the left)
	LDA World_Map_X,Y	; Get Player's X position on Map
	SUB <Horz_Scroll	; Offset it by the horizontal scroll
	CMP #$80	
	BGE PRG026_A771	 	
	LDX #$01		; Wind comes from the right
PRG026_A771:
	STX <Map_WWOrHT_Dir		; Store travel direction

	LDA Map_WWOrHT_StartX,X	; Get proper start position for the wind
	STA <Map_WWOrHT_X		; Set it as the wind's X
	LDA World_Map_Y,Y		; Get Player's Y position on map
	STA <Map_WWOrHT_Y		; Set it as the wind's Y
	STA Map_PlyrSprOvrY		; Clear the map sprite override Y

	; Back up the Player's map positioning (why??)
	LDA World_Map_Y,Y
	STA Map_WW_Backup_Y	; Store Player's map Y position

	LDA World_Map_X,Y	
	STA Map_WW_Backup_X	; Store Player's map X position

	LDA World_Map_XHi,Y	
	STA Map_WW_Backup_XH	; Store Player's map X Hi position

	LDA Map_UnusedPlayerVal2,Y	
	STA Map_WW_Backup_UPV2	; Store Player's Map_WW_Backup_UPV2


	LDX #$01	 ; X = 1

	LDA #$00
	; Clear all of the following:
	STA Map_Prev_XOff,Y
	STA Map_Prev_XHi,Y
	STA <Scroll_LastDir
	STA Map_InCanoe_Flag		; Not in a canoe

	STX <Map_WarpWind_FX		 ; Map_WarpWind_FX = 1 (Warp Whistle begin!)
	JSR Inv_UseItem_ShiftOver	 ; Shift out the Warp Whistle

	LDA #MUS2A_WARPWHISTLE	 
	STA Sound_QMusic2	 ; Play the Warp Whistle tune
	JMP Inventory_ForceFlip	 ; Flip over the inventory

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Poof_Update
;
; Updates map "poof" effect, including decrementing
; Map_Powerup_Poof and inserting the sprites to be
; displayed based on the current count...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Poof_Tiles:
	; "Outer" and "Inner" tiles for the map poof sprites
	.byte $49, $41
	.byte $49, $39
	.byte $49, $35
	.byte $49, $31
	.byte $45, $47
	.byte $45, $47

Map_Poof_Update:
	LDA <MapPoof_Y	
	SUB #$08	 	; Center Map Poof

	; Four pieces with identical Y
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64
	STA Sprite_RAM+$68
	STA Sprite_RAM+$6C

	; Four pieces with identical Y (offset 16 from the above)
	ADD #16			
	STA Sprite_RAM+$70
	STA Sprite_RAM+$74
	STA Sprite_RAM+$78
	STA Sprite_RAM+$7C

	LDY #$00	 	; Y = 0
	LDA <MapPoof_X	
	SUB <Horz_Scroll	; Offset poof effect based on horizontal scroll
	SUB #$08	 	; Center horizontally

	; This will loop through to position each piece of the poof sprite
	; horizontally, spaced 8 pixels apart.
PRG026_A7EA:
	STA Sprite_RAM+$63,Y	; Upper and...
	STA Sprite_RAM+$73,Y	; ... lower sprites with same X coordinate
	ADD #$08	 	; X coordinate += 8 (next poof sprite over)
	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)
	CPY #16
	BNE PRG026_A7EA	 ; Loop while Y < 16 (8 sprites total, doing 2 at a time)

	; The four "corners" of the poof, pieces of the sprite
	; flipped as appropriate...
	LDA #$03
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	LDA #$43
	STA Sprite_RAM+$6A
	STA Sprite_RAM+$6E

	LDA #$83
	STA Sprite_RAM+$72
	STA Sprite_RAM+$76

	LDA #$c3
	STA Sprite_RAM+$7A
	STA Sprite_RAM+$7E

	LDA Map_Powerup_Poof
	AND #$1c	 	; Constrain the value of Map_Powerup_Poof, only change every 4 units
	LSR A		 	; A >> 1 (2 tiles per valid change in Map_Powerup_Poof)
	TAY		 	; Y = A

	; Tile for "outer" poof sprites
	LDA Map_Poof_Tiles,Y
	STA Sprite_RAM+$61
	STA Sprite_RAM+$6D
	STA Sprite_RAM+$71
	STA Sprite_RAM+$7D

	; Tile for "inner" poof sprites
	LDA Map_Poof_Tiles+1,Y
	STA Sprite_RAM+$65
	STA Sprite_RAM+$69
	STA Sprite_RAM+$75
	STA Sprite_RAM+$79

	DEC Map_Powerup_Poof	; Decrease "poof" effect
	LDA Map_Powerup_Poof	
	BNE PRG026_A84B	 	; If Map_Powerup_Poof <> 0, jump to PRG026_A84B (RTS)

	JMP Inventory_ForceFlip	; When poof has completed, inventory is closed

PRG026_A84B:
	RTS		 ; Return
; #INVENTORY SPRITES
InvItem_Hilite_Layout:
	; Item sprite tiles layout when highlighted
	; NOTE: See also InvItem_Tile_Layout
	; NOTE: If both tile values are equal, the right
	;        half is horizontally flipped
	.byte $FF, $FF		; Empty
	.byte $C1, $C1
	.byte $C3, $C3
	.byte $C5, $C5
	.byte $C7, $C9
	.byte $EB, $ED
	.byte $CB, $CB
	.byte $CD, $CD
	.byte $CF, $CF
	.byte $D1, $D1
	.byte $D3, $D3
	.byte $D5, $D7
	.byte $EF, $F1
	.byte $F3, $F3
	.byte $DD, $DF
	.byte $E1, $E3
	.byte $E7, $E9
	.byte $E5, $E5
	; Shield
	.byte $D9, $DB

Inv_Display_Hilite:
	; Displays the hilited item
	LDY #$c8	 ; Y = $C8
	LDA <Map_UseItem 
	BEQ PRG026_A876	 ; If not using an item, jump to PRG026_A876

	LDA <Counter_1
	AND #$18
	BNE PRG026_A876	 ; Periodically jump to PRG026_A876

	LDY #$f8	 ; Y = $F8 (hilite is pushed off bottom of screen during item use)

PRG026_A876:
	STY Sprite_RAM+$00	; Store 'Y' position into left half
	STY Sprite_RAM+$04	; Store 'Y' position into right half
	LDA InvStart_Item
	ADD InvHilite_Item	; A = InvStart_Item + InvHilite_Item
	TAY		 	; Y = A

	LDA Player_Current
	BEQ PRG026_A88E		; If Player_Current = 0 (Mario), jump to PRG026_A88E
	TYA		 
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y += Luigi items offset

PRG026_A88E:
	LDX Inventory_Items,Y	; X = currently highlighted item

	; Use palette 3 for both
	LDA #$01
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	TXA
	ASL A
	TAX		 ; X << 1 (index into InvItem_Hilite_Layout)

	; Index highlight tiles
	LDA InvItem_Hilite_Layout,X
	STA Sprite_RAM+$01
	LDA InvItem_Hilite_Layout+1,X
	STA Sprite_RAM+$05

	LDA Sprite_RAM+$01
	CMP Sprite_RAM+$05
	BNE PRG026_A8B8	 	; If left half / right half tiles differ, jump to PRG026_A8B8

	; Otherwise, a horizontal flip is applied to the right half
	LDA Sprite_RAM+$06
	ORA #$40	 	; H-Flip
	STA Sprite_RAM+$06	

PRG026_A8B8:
	LDA InvHilite_X	 
	STA Sprite_RAM+$03	; Highlight X for left
	ADD #$08	 	; +8
	STA Sprite_RAM+$07	; Highlight X for right
	RTS		 	; Return...

Map_Poof_To_Row:
	; Convert a Map Poof Y coordinate to a row LUT
	.byte $20, $30, $40, $50, $60, $70, $80

Map_Completion_Bit:
	; Set proper map "completion" bit based on row
	.byte $80, $40, $20, $10, $08, $04, $02, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_SetCompletion_By_Poof
;
; Set completion bit on map for the CURRENT Player based on the location
; of the map "poof" effect (from using a hammer); does not actually do 
; graphics or RAM alteration to map, however.  Just marks completion bit 
; for future reloads of the map...
;
; 'X' is set to the row where the rock existed
; 'Y' is set to the offset for the map completion for the CURRENT Player
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_SetCompletion_By_Poof:	; $A8D4

	; This loop will determine what row to mark completion on based on
	; the Y coordinate of the "map poof"
	LDY #6	
	LDA <Temp_Var1		; A = Temp_Var1 (Map Poof Y)
PRG026_A8D8:
	CMP Map_Poof_To_Row,Y	; Compare Map Poof Y to this value
	BEQ PRG026_A8E2		; If it matches, jump to PRG026_A8E2
	DEY			; Y--
	BPL PRG026_A8D8		; While Y >= 0, loop!

	; If it doesn't match, use Y = 7 (which amounts to the last row anyway, but SHOULDN'T HAPPEN)
	LDY #7
PRG026_A8E2:
	STY <Temp_Var5		; Temp_Var5 = Y
	LDA <Temp_Var2		; A = current screen (map X Hi byte)
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var4		; Temp_Var4 = Temp_Var2 << 4
	LDA <Temp_Var3		
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var4	 	; A = Temp_Var3 >> 3 (Map Poof X, div 16) OR'd with Temp_Var4 (row is upper 4 bits, column is lower 4 bits)
	TAY		 	; Y = A
	LDX Player_Current	; X = Player_Current
	BEQ PRG026_A8FF	 	; If Player_Current = 0 (Mario), jump to PRG026_A8FF
	TYA		 	; 
	ADD #$40	 	; 
	TAY		 	; Y += $40 for Luigi (Luigi's clear bits are 64 ahead of Mario's)

PRG026_A8FF:
	LDX <Temp_Var5		; X = row on which the rock existed
	RTS		 	; Return!

	; Per-world Big [?] block areas
LevelJctBQ_Layout:	.word BigQBlock1L, BigQBlock2L, BigQBlock3L, BigQBlock4L, BigQBlock5L, BigQBlock6L, BigQBlock7L, BigQBlock8L
LevelJctBQ_Objects:	.word BigQBlock1O, BigQBlock2O, BigQBlock3O, BigQBlock4O, BigQBlock5O, BigQBlock6O, BigQBlock7O, BigQBlock8O
LevelJctBQ_Tileset:	.byte 14, 14, 14, 14, 14, 14, 14, 14	; All use "Underground (14)" style


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HandleLevelJunction
;
; Fades out the screen, sets up the pointers, and loads a new
; area!  And some other tedious things as required to swap out
; to a different level and potentially swap back in later...
;
; Used for all bonus areas, alternate exits, whatever!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HandleLevelJunction:
	; Fades out the screen
	JSR Palette_PrepareFadeOut	 ; Prepare
PRG026_A936:
	JSR GraphicsBuf_Prep_And_WaitVSync	; Wait VSync
	JSR Palette_DoFadeOut	; Fade
	LDA Fade_Level
	BNE PRG026_A936	 ; While Fade_Level > 0, loop

	LDA #%00011000	 	; Show sprites + BG
	STA <PPU_CTL2_Copy

	JSR GraphicsBuf_Prep_And_WaitVSync	; Wait VSync

	LDA #$00
	STA PPU_CTL2	 	; Disable display
	STA Level_AScrlConfig	; Level_AScrlConfig = 0

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	JSR LevelJct_General	 ; Do what's appropriate for the Level Junction!

	LDA <Horz_Scroll
	STA Level_Jct_HS	 ; Level_Jct_HS = Horz_Scroll

	LDA <Horz_Scroll_Hi
	STA Level_Jct_HSHi	 ; Level_Jct_HSHi = Horz_Scroll_Hi

	LDA <Vert_Scroll
	STA Level_Jct_VS	 ; Level_Jct_VS = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_Jct_VSHi	 ; Level_Jct_VSHi = Vert_Scroll_Hi

	LDA #$01
	STA Map_ReturnStatus	; Map_ReturnStatus = 1 (??)

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd


	; For this next part, the appropriate scroll column counter 
	; (based on which way the system last scrolled) is faked out
	; to think it is behind a whole screen (how mean!) to force
	; a "dirty" update after we transition...

	LDX <Scroll_LastDir
	BNE PRG026_A982	 	; If screen last moved left (1), jump to PRG026_A982

	; X = Scroll_LastDir = 0 (Screen last moved right)

	LDA <Scroll_ColumnR
	SUB #16
	STA <Scroll_ColumnR	; Scroll_ColumnR -= 16 (pretend we have a whole screen to the right to update)

	JMP PRG026_A989	 ; Jump to PRG026_A989

PRG026_A982:

	; X = Scroll_LastDir = 1 (Screen last moved left)

	LDA <Scroll_ColumnL
	ADD #16
	STA <Scroll_ColumnL	; Scroll_ColumnL += 16 (pretend we have a whole screen to the left to update)

PRG026_A989:
	LDA Level_JctCtl
	CMP #$02
	BEQ PRG026_A995	 ; If Level_JctCtl = 2 (Big Question Block bonus area), jump to PRG026_A995

	; The Big Question Block bonus area locks horizontal scrolling,
	; but everyone else is free to set it correctly!
	;LDA Level_Jct_HS
	;STA <Horz_Scroll	 ; Horz_Scroll = Level_Jct_HS

PRG026_A995:
	JMP PRG030_897B	 ; Jump to PRG026_897B (continue preparation of display!)


LevelJct_General:	

	LDA #$00
	STA Level_7Vertical
		; Toggle Level_JctFlag
	LDA Level_JctFlag
	EOR #$01
	STA Level_JctFlag

PRG026_AB0E:
	
	; Common (regular and vertical level) continue point...

	LDA <Horz_Scroll
	STA <Scroll_Temp	; Scroll_Temp = Horz_Scroll
	LDA <Horz_Scroll_Hi	; A = Horz_Scroll_Hi

	JMP Scroll_Update_Ranges ; Set scrolling appropriately!

	; For levels which employ the "generic exit" pipe at the end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Palette_PrepareFadeIn
;
; This subroutine is called prior to performing a palette
; fade-in.  It configures the initial version of the buffer
; with all of the darkest shades of colors.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Palette_PrepareFadeIn:
	CLC			; signals to use "fade in" prep code 

Palette_PrepareFadeOut_Entry:	; entry point when preparing to fade out!

	; Set the palette address to the beginning of palettes, $3F00
	LDA #$3f	 
	STA Palette_AddrHi
	LDA #$00	 
	STA Palette_AddrLo

	STA Palette_Term	 ; Palette_Term = 0, Terminate the palette data

	LDA #32
	STA Palette_BufCnt	 ; Loading 32 colors

	; Prepare all 31 colors in their darkest shades!
	LDY #31		 ; Y = 31
PRG026_ABB8:
	PHP		 ; Save processor status

	LDA Pal_Data,Y	 ; Get next byte of target palette data

	BCS PRG026_ABC5	 ; If carry is set (fade out), jump to PRG026_ABC5 (fade out needs the colors as they're to be targeted!)

	SUB #$30	 ; Otherwise, A -= $30 (darkest shade of this color)
	BCS PRG026_ABC5	 ; If we didn't go "less than black", jump to PRG026_ABC5
	LDA #$0f	 ; Otherwise, A = $F (black)

PRG026_ABC5:
	PLP		 ; Restore processor status

	STA Palette_Buffer,Y	; Copy this byte of palette data to the buffer
	DEY		 	; Y--
	BPL PRG026_ABB8	 	; While Y >= 0, loop!

	LDA #$04
	STA Fade_Level	 ; Fade_Level = 4
	STA Fade_Tick	 ; Fade_Tick = 0
	INC Fade_State	 ; Fade_State = 1 (Fade in)

	LDA #$06	 
	STA <Graphics_Queue	 ; Reset the graphics buffer
	RTS		 ; Return

Palette_DoFadeIn:
	LDA Fade_Tick	 
	BEQ PRG026_ABE4	 ; If Fade_Tick = 0, jump to PRG026_ABE4
	DEC Fade_Tick	 ; Otherwise, Fade_Tick--

PRG026_ABE4:
	LDA Fade_Level	 
	BEQ PRG026_AC1A	 ; If Fade_Level = 0, jump to PRG026_AC1A

	LDA Fade_Tick	 
	BNE PRG026_AC19	 ; If Fade_Tick <> 0, jump to PRG026_AC19

	LDA #$04	
	STA Fade_Tick	 ; Fade_Tick = 4 (reload) 

	DEC Fade_Level	 ; Fade_Level--

	LDY #31		 ; Y = 31
PRG026_ABF8:
	LDA Palette_Buffer,Y	; Get next byte of palette data 
	CMP #$0f	 	; Is this color black?
	BNE PRG026_AC07	 	; If not, jump to PRG026_AC07

	LDA Pal_Data,Y	 ; Get the target byte
	AND #$0f	 ; Gets the darkest shade of this color
	JMP PRG026_AC0F	 ; Jump to PRG026_AC0F

PRG026_AC07:
	CMP Pal_Data,Y	 ; Compare this against the target palette byte
	BEQ PRG026_AC12	 ; If we reached the target, jump to PRG026_AC12
	ADD #$10	 ; Otherwise, add $10 (brighter)

PRG026_AC0F:
	STA Palette_Buffer,Y	 ; Update the buffer!

PRG026_AC12:
	DEY		 ; Y--
	BPL PRG026_ABF8	 ; While Y >= 0, loop!

	LDA #$06	 
	STA <Graphics_Queue	 ; Queue graphics routine 6

PRG026_AC19:
	RTS		 ; Return


PRG026_AC1A:
	LDA #$00	 
	STA Fade_State	 ; Fade_State = 0
	RTS		 ; Return


Palette_PrepareFadeOut:
	LDA FadeOut_Cancel
	BNE PRG026_AC29	 	; If FadeOut_Cancel <> 0, jump to PRG026_AC29 (RTS)

	SEC			; signals to use "fade out" prep code		 
	JMP Palette_PrepareFadeOut_Entry

PRG026_AC29:
	RTS		 ; Return

Palette_DoFadeOut:
	LDA FadeOut_Cancel
	BNE PRG026_AC60	 ; If FadeOut_Cancel <> 0, jump to PRG026_AC60

	LDA Fade_Tick
	BEQ PRG026_AC37	 ; If Fade_Tick = 0, jump to PRG026_AC37

	DEC Fade_Tick	 ; Fade_Tick--

PRG026_AC37:
	LDA Fade_Level
	BEQ PRG026_AC60	 ; If Fade_Level = 0, jump to PRG026_AC60

	LDA Fade_Tick
	BNE PRG026_AC5F	 ; If Fade_Tick <> 0, jump to PRG026_AC5F

	LDA #$04
	STA Fade_Tick	 ; Fade_Tick = 4

	DEC Fade_Level	 ; Fade_Level--

	; For all palette colors...
	LDY #31
PRG026_AC4B:
	LDA Palette_Buffer,Y	; Get this color
	SUB #16		 	; Subtract 16 from it
	BPL PRG026_AC55	 	; If we didn't go below zero, jump to PRG026_AC55

	LDA #$0f	 	; Otherwise, set it to safe minimum

PRG026_AC55:
	STA Palette_Buffer,Y	; Update palette color
	DEY		 	; Y--
	BPL PRG026_AC4B	 	; While Y >= 0, loop!

	; Update palette
	LDA #$06
	STA <Graphics_Queue

PRG026_AC5F:
	RTS		 ; Return

PRG026_AC60:
	; Fade out cancellation request

	LDA #$00
	STA Fade_State
	STA FadeOut_Cancel
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Palette_FadeIn
;
; This performs the palette fade-in routine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Palette_FadeIn:		; AC69
	JSR Palette_PrepareFadeIn	 ; Prepare to fade in!

	; Some kind of hardware thing??
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

PRG026_AC8C:
	LDA PPU_STAT	 ; Get PPU_STAT
	AND #$80	 
	BNE PRG026_AC8C	 ; If VBlank is NOT occurring, loop!

	LDA #%10101000	 ; PT2 is sprites, use 8x16 sprites, generate VBlanks

	; Update PPU_CTL1 and local copy
	STA PPU_CTL1	 
	STA <PPU_CTL1_Copy

	LDA #%00011000	 	; Show sprites + BG
	STA <PPU_CTL2_Copy

PRG026_AC9E:
	; Update the palette based on the buffer
	JSR GraphicsBuf_Prep_And_WaitVSync

	JSR Palette_DoFadeIn	; Do the fade in
	LDA Fade_Level	 
	BNE PRG026_AC9E	 	; If fade-in not complete, go around again!

	RTS		 	; Return...


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Palette_FadeOut
;
; This performs the palette fade-out routine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Palette_FadeOut:
	JSR Palette_PrepareFadeOut	; Prepare to fade out!

	; Wait for V-Blank
PRG026_ACAD:
	LDA PPU_STAT
	AND #$80	
	BNE PRG026_ACAD	

	LDA #%10101000	 ; PT2 is sprites, use 8x16 sprites, generate VBlanks
	; Update PPU_CTL1 and local copy
	STA PPU_CTL1	 
	STA <PPU_CTL1_Copy

	LDA #%00011000	 	; Show sprites + BG
	STA <PPU_CTL2_Copy

PRG026_ACBF:
	; Update the palette based on the buffer
	JSR GraphicsBuf_Prep_And_WaitVSync

	JSR Palette_DoFadeOut	; Do the fade out
	LDA Fade_Level	 	
	BNE PRG026_ACBF	 	; If fade-out not complete, go around again!

	RTS		 ; Return
 

PRG026_ACCB:	.byte $40, $40, $20, $00, $00, $00

Map_EnterLevel_Effect:		; routine called while entering a level
	LDA PPU_STAT
	LDX Map_EntTran_BorderLoop	; X = current border index (0-3: Top 0, bottom 1, right 2, left 3)

	; Copy this border's VRAM addresses to Map_EntTran_VAddrH/L
	LDA Map_EntTran_BVAddrH,X
	STA Map_EntTran_VAddrH	 
	LDA Map_EntTran_BVAddrL,X
	STA Map_EntTran_VAddrL	 

	LDA Map_EntTran_BorderLoop	; Get current border loop index
	AND #$02	 
	BEQ PRG026_ACF6	 		; If not updating left/right (i.e. doing top/bottom), jump to PRG026_ACF6

	LDY Map_EntTran_LRCnt	 	; Y = Map_EntTran_LRCnt

	; Set vertical update mode (left/right edges benefit from this)
	LDA <PPU_CTL1_Copy
	ORA #$04	 
	STA <PPU_CTL1_Copy

	JMP PRG026_ACFF	 ; Jump to PRG026_ACFF

PRG026_ACF6:
	LDY Map_EntTran_TBCnt	 	; Y = Map_EntTran_TBCnt

	; Set horizontal update mode (top/bottom edges benefit from this)
	LDA <PPU_CTL1_Copy
	AND #$fb	 
	STA <PPU_CTL1_Copy

PRG026_ACFF:
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1	 	; Commit changes to PPU_CTL1

	; Set this border's VRAM addresses
	LDA Map_EntTran_VAddrH
	STA PPU_VRAM_ADDR	
	LDA Map_EntTran_VAddrL
	STA PPU_VRAM_ADDR	

PRG026_AD10:
	LDA #$ff		; black pattern	
	STA PPU_VRAM_DATA	; Store into VRAM

	LDA Map_EntTran_BorderLoop
	AND #$02
	BNE PRG026_AD26	 	; If updating left/right, jump to PRG026_AD26

	; top/bottom update...
	INC Map_EntTran_VAddrL	; Map_EntTran_VAddrL++

	LDA Map_EntTran_VAddrL
	AND #$1f
	BEQ PRG026_AD2B	 	; If Map_EntTran_VAddrL has covered 32 bytes, jump to PRG026_AD2B

PRG026_AD26:
	DEY		 	; Y--
	BPL PRG026_AD10	 	; While Y >= 0, loop!
	BMI PRG026_AD37	 	; If loop has ended, jump to PRG026_AD37

PRG026_AD2B:
	; After covering 32 bytes, reset
	LDA Map_EntTran_VAddrL
	SUB #32
	STA Map_EntTran_VAddrL	; Map_EntTran_VAddrL -= 32
	DEY		 	; Y--
	BPL PRG026_ACFF	 	; While Y >= 0, loop! (and reset VRAM address, since autoincrement needs reset too)

PRG026_AD37:
	JSR Border_Do	 ; Update this edge of the border

	INC Map_EntTran_BorderLoop
	LDA Map_EntTran_BorderLoop
	AND #$03	 
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = (Map_EntTran_BorderLoop + 1) & 3

	LDY Map_EntTran_Cnt		; Y = Map_EntTran_Cnt
	CPY #$06
	BGE PRG026_AD67	 		; If Map_EntTran_Cnt >= 6, jump to PRG026_AD67

	LDA <PPU_CTL1_Copy
	AND #$04	 
	BNE PRG026_AD67	 		; If vertical update bit is set (?), jump to PRG026_AD67 (RTS)

	; Pump in final black tiles
	LDX #31

	; Set VRAM address to [$2B][PRG026_ACCB[Y]]
	LDA #$2b
	STA PPU_VRAM_ADDR
	LDA PRG026_ACCB,Y
	STA PPU_VRAM_ADDR
PRG026_AD5F:
	LDA #$ff	 
	STA PPU_VRAM_DATA
	DEX		 ; X--
	BPL PRG026_AD5F	 ; While X >= 0, loop!

PRG026_AD67:
	RTS		 ; Return


Border_Do:
	LDA Map_EntTran_BorderLoop
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Border_Top
	.word Border_Bottom
	.word Border_Right
	.word Border_Left

Border_Top:
	LDX Map_EntTran_BorderLoop	; X = current border index
	LDA Map_EntTran_BVAddrL,X
	AND #$1f
	CMP #$1f
	BEQ PRG026_AD94	 		; If Map_EntTran_BVAddrL is at the 31st byte, jump to PRG026_AD94

	; Otherwise... Map_EntTran_BVAddrH/L += 33 (causes it to shift over, creating the diagonals)
	LDA Map_EntTran_BVAddrL,X
	ADD #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	 
	STA Map_EntTran_BVAddrH,X
	RTS		 ; Return

PRG026_AD94:
	; 31st byte, top
	; Map_EntTran_BVAddrH/L += 1
	LDA Map_EntTran_BVAddrL,X
	ADD #$01	
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	 
	STA Map_EntTran_BVAddrH,X
	RTS		 ; Return

Border_Right:
	LDX Map_EntTran_BorderLoop	; X = current border index

	; Map_EntTran_BVAddrH/L += 31
	LDA Map_EntTran_BVAddrL,X
	ADD #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	
	STA Map_EntTran_BVAddrH,X
	RTS		 ; Return

Border_Bottom:
	LDX Map_EntTran_BorderLoop	; X = current border index

	; Map_EntTran_BVAddrH/L -= 31 (causes it to shift over, creating the diagonals)
	LDA Map_EntTran_BVAddrL,X
	SUB #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00	 
	STA Map_EntTran_BVAddrH,X

	DEC Map_EntTran_TBCnt
	DEC Map_EntTran_TBCnt	 ; Map_EntTran_TBCnt -= 2
	RTS		 ; Return

Border_Left:
	LDX Map_EntTran_BorderLoop	; X = current border index

	; Map_EntTran_BVAddrH/L += 33
	LDA Map_EntTran_BVAddrL,X
	ADD #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	
	STA Map_EntTran_BVAddrH,X
	DEC Map_EntTran_LRCnt	 
	DEC Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt -= 2
	RTS		 ; Return

Level_Opening_Effect:	; Unused in the US release; this is the reverse effect of the map entry

	LDA PPU_STAT
	LDA Map_EntTran_BorderLoop	; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
	AND #$02
	BEQ PRG026_AE07	 		; If updating top/bottom, jump to PRG026_AE07

	; left/right update..
	LDY Map_EntTran_LRCnt

	; Set vertical update mode (left/right edges benefit from this)
	LDA <PPU_CTL1_Copy
	ORA #$04	 
	STA <PPU_CTL1_Copy
	JMP PRG026_AE10	 		; Jump to PRG026_AE10

PRG026_AE07:
	LDY Map_EntTran_TBCnt	 	; Y = Map_EntTran_TBCnt

	; Set horizontal update mode (top/bottom edges benefit from this)
	LDA <PPU_CTL1_Copy
	AND #$fb	 
	STA <PPU_CTL1_Copy

PRG026_AE10:
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1	 	; Commit changes to PPU_CTL1
	LDX Map_EntTran_BorderLoop	; X = current border index 

	; Set VRAM address for this border
	LDA Map_EntTran_BVAddrH,X
	STA PPU_VRAM_ADDR	 
	LDA Map_EntTran_BVAddrL,X
	STA PPU_VRAM_ADDR	 

PRG026_AE24:
	LDA Scroll_ColorStrip,Y	 
	STA PPU_VRAM_DATA	 ; Store attribute data to VRAM

	CPY Map_EntTran_Temp
	BEQ PRG026_AE35	 	; If Y = Map_EntTran_Temp, jump to PRG026_AE35

	DEY		 	; Y--
	BPL PRG026_AE24	 	; While Y >= 0, loop
	JMP PRG026_AE51	 	; Jump to PRG026_AE51

PRG026_AE35:
	LDA #$ff	 
	STA Map_EntTran_Temp	; Map_EntTran_Temp = $FF

	; Set VRAM address to [$28][Map_EntTran_BVAddrL & $1f]
	LDA #$28	 
	STA PPU_VRAM_ADDR
	LDA Map_EntTran_BVAddrL,X
	AND #$1f	 
	STA PPU_VRAM_ADDR	

	DEY		 	; Y--

PRG026_AE48:
	LDA Scroll_ColorStrip,Y	 
	STA PPU_VRAM_DATA	 ; Store attribute data to VRAM
	DEY		 	; Y--
	BPL PRG026_AE48	 ; While Y >= 0, loop

PRG026_AE51:
	JSR BorderOut_Do	 ; Update this edge of the border!

	INC Map_EntTran_BorderLoop
	LDA Map_EntTran_BorderLoop
	AND #$03	
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = (Map_EntTran_BorderLoop + 1) & 3

	INC Map_EntTran_Cnt		; Map_EntTran_Cnt++
	RTS		 ; Return

BorderOut_VHLimitTRL:	.byte $20, $00, $00, $00, $28
BorderOut_VHLimitB:	.byte $23, $00, $00, $00, $2A

BorderOut_Do:
	LDA Map_EntTran_BorderLoop
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BorderOut_Top
	.word BorderOut_Bottom
	.word BorderOut_Right
	.word BorderOut_Left

BorderOut_Top:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitTRL,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AE92	 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitTRL[Map_EntTran_InitValIdx], jump to PRG026_AE92

	; Otherwise...
	LDA Map_EntTran_BVAddrL,X
	CMP #$20
	BGE PRG026_AE92	 ; If Map_EntTran_BVAddrL >= $20, jump to PRG026_AE92
	BLT PRG026_AEA6	 ; Otherwise, jump to PRG026_AEA6

PRG026_AE92:
	; Map_EntTran_BVAddrL >= $20

	LDX Map_EntTran_BorderLoop	; X = border index

	; Map_EntTran_BVAddrH/L -= 33
	LDA Map_EntTran_BVAddrL,X
	SUB #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00	
	STA Map_EntTran_BVAddrH,X

PRG026_AEA6:
	LDA Map_EntTran_BVAddrH,X
	CMP #$27
	BNE PRG026_AEBB			; If Map_EntTran_BVAddrH <> $27, jump to PRG026_AEBB (RTS)

	; Map_EntTran_BVAddrH = $23
	LDA #$23
	STA Map_EntTran_BVAddrH,X

	; Map_EntTran_BVAddrL -= $40
	LDA Map_EntTran_BVAddrL,X
	SUB #$40	
	STA Map_EntTran_BVAddrL,X

PRG026_AEBB:
	RTS

BorderOut_Right:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitTRL,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AED7 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitTRL[Map_EntTran_InitValIdx], jump to PRG026_AED7

	LDA Map_EntTran_BVAddrL,X
	CMP #$1e
	BNE PRG026_AED7			; If Map_EntTran_BVAddrL <> $1e, jump to PRG026_AED7

	INC Map_EntTran_BVAddrL,X	; Map_EntTran_BVAddrL++
	JMP PRG026_AEE8	 		; Jump to PRG026_AEE8

PRG026_AED7:

	; Map_EntTran_BVAddrH/L -= 31
	LDA Map_EntTran_BVAddrL,X
	SUB #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00	 
	STA Map_EntTran_BVAddrH,X

PRG026_AEE8:
	LDA Map_EntTran_BVAddrH,X
	CMP #$27	 
	BNE PRG026_AEFD	 		; If Map_EntTran_BVAddrH <> $27, jump to PRG026_AEFD (RTS)

	LDA #$23
	STA Map_EntTran_BVAddrH,X

	; Map_EntTran_BVAddrL -= $40
	LDA Map_EntTran_BVAddrL,X
	SUB #$40	
	STA Map_EntTran_BVAddrL,X

PRG026_AEFD:
	RTS		 ; Return

BorderOut_Bottom:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitB,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AF1C 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitB[Map_EntTran_InitValIdx], jump to PRG026_AF1C

	LDA Map_EntTran_InitValIdx
	CMP #$04	 
	BLT PRG026_AF33	 		; If Map_EntTran_InitValIdx < 4, jump to PRG026_AF33

	LDA Map_EntTran_BVAddrL,X
	CMP #$e0	 
	BLT PRG026_AF1C	 		; If Map_EntTran_BVAddrL < $e0, jump to PRG026_AF1C
	BGE PRG026_AF33	 		; Otherwise, jump to PRG026_AF33

PRG026_AF1C:
	; Map_EntTran_BVAddrH/L += 31
	LDA Map_EntTran_BVAddrL,X
	ADD #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	
	STA Map_EntTran_BVAddrH,X

	INC Map_EntTran_TBCnt	
	INC Map_EntTran_TBCnt		; Map_EntTran_TBCnt += 2

PRG026_AF33:
	LDA Map_EntTran_BVAddrH,X
	CMP #$23
	BNE PRG026_AF4E	 		; If Map_EntTran_BVAddrH <> $23, jump to PRG026_AF4E (RTS)

	LDA Map_EntTran_BVAddrL,X
	CMP #$c0	
	BLT PRG026_AF4E	 		; If Map_EntTran_BVAddrL < $c0, jump to PRG026_AF4E (RTS)

	LDA #$28	 
	STA Map_EntTran_BVAddrH,X	; Map_EntTran_BVAddrH = $28

	LDA Map_EntTran_BVAddrL,X
	AND #$1f	
	STA Map_EntTran_BVAddrL,X	; Map_EntTran_BVAddrL &= $31

PRG026_AF4E:
	RTS		 ; Return

BorderOut_Left:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitTRL,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AF70 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitTRL[Map_EntTran_InitValIdx], jump to PRG026_AF70

	LDA Map_EntTran_BVAddrL,X
	CMP #$02
	BNE PRG026_AF70	 		; If Map_EntTran_BVAddrL <> 2, jump to PRG026_AF70

	DEC Map_EntTran_BVAddrL,X	; PRG026_AF70--

	LDA Map_EntTran_InitValIdx	 
	CMP #$04	
	BLT PRG026_AF84	 		; If Map_EntTran_InitValIdx < 4, jump to PRG026_AF84
	BEQ PRG026_AF87	 		; If Map_EntTran_InitValIdx = 4, jump to PRG026_AF87

PRG026_AF70:

	; Map_EntTran_BVAddrH/L -= 33
	LDA Map_EntTran_BVAddrL,X
	SUB #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00
	STA Map_EntTran_BVAddrH,X

	INC Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt++

PRG026_AF84:
	INC Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt++

PRG026_AF87:
	LDA Map_EntTran_BVAddrH,X
	CMP #$27
	BNE PRG026_AF9C		; If Map_EntTran_BVAddrH <> $27, jump to PRG026_AF9C

	LDA #$23	 
	STA Map_EntTran_BVAddrH,X	; Map_EntTran_BVAddrH = $23

	LDA Map_EntTran_BVAddrL,X
	SUB #$40
	STA Map_EntTran_BVAddrL,X	; Map_EntTran_BVAddrL -= $40

PRG026_AF9C:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_Time
;
; Fills the StatusBar_Time array with tiles representing
; the current time remaining; also updates the clock
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_Time:

	RTS		 ; Return


; FIXME: Anybody want to claim this?
; Uses graphics buffer to push out the 3 digits of timer unlike the special buffers used by status bar
; $AFFE 
	LDX Graphics_BufCnt	; X = graphics buffer count

	LDA #$2b	; VRAM High in non-vertical level

	LDY Level_7Vertical
	BEQ PRG026_B00A

	LDA #$27	; VRAM High in vertical level

PRG026_B00A:
	; VRAM High address
	STA Graphics_Buffer,X

	; VRAM Low address
	LDA #$51
	STA Graphics_Buffer+1,X

	; Run length of 3
	LDA #$03
	STA Graphics_Buffer+2,X

	; 3 timer digits
	LDA Level_TimerMSD
	ORA #$30
	STA Graphics_Buffer+3,X
	LDA Level_TimerMid
	ORA #$30
	STA Graphics_Buffer+4,X
	LDA Level_TimerLSD
	ORA #$30
	STA Graphics_Buffer+5,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+6,X

	; Add to graphics buffer count
	TXA
	ADD #$06
	STA Graphics_BufCnt

	RTS		 ; Return

StatusBar_Fill_Air_MT:
	LDA Status_Bar_Mode
	BNE Fill_Air_MT_Done
	LDY #$00
	LDA Air_Time
	LSR A
	LSR A
	LSR A
	LSR A
	TAX
	BEQ Paritial_Air

Full_Air_Loop:				; #DAHRKDAIZ fill parts that display as full 8 pixels
	LDA #$E9
	STA Status_Bar_Top + 9, Y
	INY
	DEX
	BNE Full_Air_Loop
	
	CPY #$04				; Did it fill all the way? we're done!
	BEQ Fill_Air_MT_Done

Paritial_Air:
							; Not filled all the way, let's fill the partial bar
	LDA Air_Time
	AND #$0F
	LSR A
	ADC #$E1				; offset the tile number
	STA Status_Bar_Top + 9, Y
	INY

	LDA #$E1

Empty_Air_Loop:
	CPY #$04				
	BEQ Fill_Air_MT_Done		; Did it fill all the way? we're done!
	STA Status_Bar_Top + 9, Y	; no? let's fill empty tiles
	INY
	BNE Empty_Air_Loop
	
Fill_Air_MT_Done: 
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_Coins
;
; Fills the StatusBar_CoinsL/H values with tiles representing
; the current coins held by the player; also applies the
; Coins_Earned value to the active total and issues 1-ups
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_Coins:

; #DAHRKDAIZ rewritten to account for 2 byte coins, up to 9999 coins

StatusBar_Fill_Coin:
	LDA Coins_Earned
	BNE UpdateCoins
	LDA Force_Coin_Update
	BNE Update_Draw_Coin
	RTS

UpdateCoins:

	JSR Clear_Calc
	LDX #$03

Fill_Coins:
	LDA Player_Coins, X
	STA (Calc_From + 4), X
	DEX
	BPL Fill_Coins
	LDA Coins_Earned
	STA Calc_Value + 7
	JSR Add_Values
	LDA Calc_From + 3
	BEQ Coins_Loop 
	LDX #$03
	LDA #$09

Max_Coins:
	STA Player_Coins,X
	DEX
	BPL Max_Coins
	BMI Do_Game_Coins
Coins_Loop:
	LDX #$03

Coins_Loop2:
	LDA (Calc_From + 4), X
	STA Player_Coins, X
	DEX
	BPL Coins_Loop2

Do_Game_Coins:
	LDX #$06

FillGame_Coins:
	LDA Game_Coins, X
	STA (Calc_From + 1), X
	DEX
	BPL FillGame_Coins
	LDA Coins_Earned
	STA Calc_Value + 7
	JSR Add_Values
	LDX #$06

GameCoins_Loop2:
	LDA (Calc_From + 1), X
	STA Game_Coins, X
	DEX
	BPL GameCoins_Loop2
	LDA #$00
	STA Coins_Earned

Update_Draw_Coin:
	LDA Status_Bar_Mode
	BEQ DrawCurrentCoins
	BNE DrawTotalCoins	

DrawCurrentCoins:
	LDX #$03

Coin_Loop2:
	LDA Player_Coins, X
	ORA #$30
	STA Status_Bar_Bottom+ 9, X
	DEX
	BPL Coin_Loop2
	RTS

DrawTotalCoins:
	LDX #$06
Coin_Loop3:
	LDA Game_Coins, X
	ORA #$30
	STA Status_Bar_Top + 1, X
	DEX
	BPL Coin_Loop3
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_World
;
; Simply puts the correct world number in the status bar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_World:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_MorL
;
; Simply puts the correct <M> or <L> in the status bar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG026_B104:
	.byte $74, $75, $76, $77  ; Two tiles each, for <M> or <L>, respectively

StatusBar_Fill_MorL:
	LDA Player_Current
	ASL A		 	; A = Player_Current << 1
	TAX		 	; X = A
	LDA #$01	 	; A = 1
	STA <Temp_Var15		; Temp_Var15 = 1
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt

	; Loop to copy the two tiles
PRG026_B114:
	LDA PRG026_B104,X	; Get player-relevant tile
	STA Graphics_Buffer+3,Y ; -> graphics buffer
 
	INX		 	; X++
	INY		 	; Y++
	DEC <Temp_Var15		; Temp_Var15--
	BPL PRG026_B114	 	; While Temp_Var15 > 0, loop!

	LDA #$00	 	
	STA Graphics_Buffer+3,Y	; Add a terminator

	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX #$27	 	; X = $27 (VRAM address high if vertical)

	LDA Level_7Vertical
	BNE PRG026_B13E	 	; If level is vertical, jump to PRG026_B13E

	LDX #$2b	 	; X = $2B (VRAM address high if non-vertical)

	LDA Level_Tileset	

	CMP #16	 
	BEQ PRG026_B13C	 	; If Level_Tileset = 16 (Spade game), jump to PRG026_B13C

	CMP #17
	BNE PRG026_B13E	 	; If Level_Tileset = 17 (N-Spade game), jump to PRG026_B13E

PRG026_B13C:
	LDX #$23	 ; X = $23 (VRAM Address high for Spade/N-Spade bonus games only)

PRG026_B13E:

	; VRAM Address High
	TXA
	STA Graphics_Buffer,Y

	; VRAM Address low
	LDA #$42
	STA Graphics_Buffer+1,Y

	; Run length of 2
	LDA #$02
	STA Graphics_Buffer+2,Y

	; Update buffer count appropriately
	LDA Graphics_BufCnt	
	ADD #$05	 
	STA Graphics_BufCnt	
	RTS		 ; Return


PRG026_B156:
	.byte $2B, $48, $06, $00, $00, $00, $00, $00, $00, $00 

StatusBar_Fill_Exp:
	LDA Exp_Earned
	BEQ Exp_Done
	DEC Exp_Earned
	LDX #$05

IncExpMore:
	INC Player_Experience, X
	LDA Player_Experience, X
	CMP #$0A
	BCC Try_Update
	LDA #$00
	STA Player_Experience, X
	DEX
	BPL IncExpMore

Try_Update:
	LDA Status_Bar_Mode
	BNE Exp_Done

Exp_Update:
	LDX #$05

Exp_Loop3:
	LDA Player_Experience, X
	ORA #$30
	STA Status_Bar_Bottom + 1, X
	DEX
	BPL Exp_Loop3

Exp_Done:
	RTS		 ; Return


Ability_Tiles1:
	.byte $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E, $0F, $6C, $6D

Ability_Tiles2:
	.byte $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1A, $1B, $1C, $1D, $1E, $1F, $7C, $7D

StatusBar_Ability_Level:
	LDA Status_Bar_Mode
	CMP #$00
	BNE Dont_Draw_Current_Ability
	LDA Player_Level
	ORA #$30
	STA (Status_Bar_Top + 20)
	LDA Status_Bar_Mode
	CMP #$00
	BNE Dont_Draw_Current_Ability
	LDA Player_Ability
	BEQ Dont_Draw_Current_Ability
	SEC
	SBC #$01
	ASL A
	TAX
	LDA Ability_Tiles1, X
	STA (Status_Bar_Top + 26)
	LDA (Ability_Tiles1 + 1), X
	STA (Status_Bar_Top + 27)
	LDA Ability_Tiles2, X
	STA (Status_Bar_Bottom + 26)
	LDA (Ability_Tiles2 + 1), X
	STA (Status_Bar_Bottom + 27)

Dont_Draw_Current_Ability:
	RTS	

PUp_Reserve_Tiles1:
	.byte $FE, $FE, $B0, $B1, $B2, $B3, $B4, $B5, $B6, $B7, $B8, $B9, $BA, $BB, $BC, $BD, $BE, $BF, $00, $00, $00, $00, $00, $00

PUp_Reserve_Tiles2:
	.byte $FE, $FE, $C0, $C1, $C2, $C3, $C4, $C5, $C6, $C7, $C8, $C9, $CA, $CB, $CC, $CD, $CE, $CF, $00, $00, $00, $00, $00, $00

Status_Bar_Draw_Item_Reserve:
	LDA Status_Bar_Mode
	CMP #$00
	BNE Item_ReserveRTS
	LDA PowerUp_Reserve
	LDX Player_Ability
	CPX #$07
	BEQ Draw_ItemReserve
	LDA #$00

Draw_ItemReserve:
	ASL A
	TAX
	LDA PUp_Reserve_Tiles1, X
	STA (Status_Bar_Top + 23)
	LDA (PUp_Reserve_Tiles1 + 1), X
	STA (Status_Bar_Top + 24)
	LDA PUp_Reserve_Tiles2, X
	STA (Status_Bar_Bottom + 23)
	LDA (PUp_Reserve_Tiles2 + 1), X
	STA (Status_Bar_Bottom + 24)

Item_ReserveRTS:
	RTS

; FIXME: Anybody want to claim this?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_PowerMT
;
; Fills the StatusBar_PMT array with tiles representing
; the current "charge" of the power meter in the status bar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_PowerMT:
	LDA Status_Bar_Mode
	BNE StatusBar_Fill_PowerMT5

	LDY #$00
	LDA Player_Power
	BEQ StatusBar_Fill_PowerMT3
	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A
	TAX
	CPX #$05
	BCC StatusBar_Fill_PowerMT1

	LDX #$05

StatusBar_Fill_PowerMT1:
	LDA #$D2

StatusBar_Fill_PowerMT2:
	STA (Status_Bar_Top + 1),Y	; Store this tile into the buffer
	INY
	DEX
	BPL StatusBar_Fill_PowerMT2

StatusBar_Fill_PowerMT3:
	CPY #$06
	BCS StatusBar_Fill_PowerMT5

	LDA #$D1

StatusBar_Fill_PowerMT4:
	STA (Status_Bar_Top + 1),Y
	INY
	CPY #$06
	BCC StatusBar_Fill_PowerMT4

StatusBar_Fill_PowerMT5:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; Video_Misc_Updates
;
; This routine appears to be responsible for all video updates
; OTHER than scrolling, which includes palettes, clearing the
; "WORLD x" thing from a world map introduction, updating the
; status bar, printing "COURSE CLEAR!", etc...
;
; Loads data as specified from table Video_Upd_Table in PRG030 (see there for format and data source!)
; Cloned in its entirety in PRG024 (i.e. Video_Misc_Updates2)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Video_Misc_Updates:

	LDY #$00	 	; Y = 0
	LDA [Video_Upd_AddrL],Y	; Get byte
	BEQ StatusBar_Fill_PowerMT5	 	; If 0, jump to PRG026_B292 (RTS)

	LDX PPU_STAT	 	; Flush video

	STA PPU_VRAM_ADDR	; Store byte into video address high
	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_ADDR	; Store byte into video address low

	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte...

	ASL A		 	; Its uppermost bit dictates whether to use horizontal (1B) or vertical (32B) advancement
	PHA		 	; Save A

	LDA <PPU_CTL1_Copy	; Get PPU_CTL1 settings
	ORA #$04	 	; Set PPU update vertical (each write advances by 32)
	BCS PRG026_B2B2		; If bit 7 was set, jump to PRG026_B2B2
	AND #$fb		; Otherwise, use horizontal updates! (clears vertical bit)

PRG026_B2B2:
	STA PPU_CTL1		; Update PPU_CTL1
	STA <PPU_CTL1_Copy	; Update PPU_CTL1_Copy

	PLA		; Restore A

	ASL A		 ; Check next bit...
	BCC PRG026_B2BE	 ; If not set, jump to PRG026_B2BE
	ORA #$02	 ; Otherwise, remaining value gets bit 1 set (forces skip of first increment)
	INY		 ; Y++ 

PRG026_B2BE:
	; Restore remainder of byte read (6-bits for value)
	LSR A
	LSR A
	TAX		 ; Keep it in X

	; The following will continuously write bytes from the stream
	; directly into the PPU 'X+1' times
PRG026_B2C1:
	BCS PRG026_B2C4	 ; If carry set, jump to PRG026_B2C4
	INY		 ; Y++
PRG026_B2C4:
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_DATA	; Store into PPU
	DEX		 	; X--
	BNE PRG026_B2C1	 	; While X <> 0, loop! 

	; This advances the current position of the pointer so 'Y' can go
	; back to zero and we begin again...
	INY		 ; Y++
	TYA		 ; A = Y
	ADD <Video_Upd_AddrL
	STA <Video_Upd_AddrL
	LDA <Video_Upd_AddrH
	ADC #$00	 
	STA <Video_Upd_AddrH	; Entire video address value has 'Y' added to it
	JMP Video_Misc_Updates	; Jump back to start to process next command or terminate!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Commit_Column
;
; This subroutine takes the buffered set of tiles in Scroll_PatStrip
; and commits them to actual VRAM, OR it takes the buffer attribute
; bytes and commits those.
; Used by both the world map and a standard horizontally scrolling level
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Commit_Column:
	LDA PPU_STAT

	LDA Scroll_ToVRAMHi	; A = Scroll_ToVRAMHi
	BEQ PRG026_B354	 	; If Scroll_ToVRAMHi = 0, jump to PRG030_B354
	LDX #$00	 	; X = 0
	LDA Scroll_ToVRAMHi	; A = Scroll_ToVRAMHi
	STA PPU_VRAM_ADDR	; Write as high byte to VRAM address
	LDA Scroll_LastCol8	
	STA PPU_VRAM_ADDR	; Low byte is Scroll_LastCol8
	LDA <PPU_CTL1_Copy	; Get the PPU_CTL1
	ORA #$04	 	; Use vertical update mode
	STA PPU_CTL1	 	; Set PPU_CTL1

PRG026_B2F9:

	; Push 5 blocks in
	LDA Scroll_PatStrip,X	 
	STA PPU_VRAM_DATA	 
	LDA Scroll_PatStrip+1,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+2,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+3,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+4,X
	STA PPU_VRAM_DATA	

	INX
	INX
	INX
	INX
	INX		; X += 5

	CPX #30	
	BNE PRG026_B2F9	; While X < 30, loop!

	; Begin update on Nametable 2
	LDA Scroll_ToVRAMHi	
	ORA #$08	 	
	STA PPU_VRAM_ADDR	
	LDA Scroll_LastCol8	
	STA PPU_VRAM_ADDR	

PRG026_B32E:
	; Push another 4
	LDA Scroll_PatStrip,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+1,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+2,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+3,X
	STA PPU_VRAM_DATA	 

	INX		
	INX		
	INX		
	INX		 ; X += 4

	CPX #30+24	 ; 24 more rows...!
	BNE PRG026_B32E	 ; While X < 54, loop! (54 rows of 8 gets down to the status bar in the NTSC model)

	LDA #$00	 
	STA Scroll_ToVRAMHi	 ; Scroll_ToVRAMHi = 0
	RTS		 ; Return

PRG026_B354:
	; If Scroll_ToVRAMHi = 0 ... do we need to commit any attribute updates??
	LDA Scroll_ToVRAMHA
	BEQ PRG026_B38E	 ; If Scroll_ToVRAMHA = 0, jump to PRG026_B38E (RTS)

	; Commiting attribute updates...
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1	 	; Update PPU_CTL1

	LDX #$00	 	; X = 0
	LDY Scroll_LastAttr	; Y = Scroll_LastAttr (low part)
PRG026_B363:
	LDA Scroll_ToVRAMHA	; A = Scroll_ToVRAMHA (high part)
	STA PPU_VRAM_ADDR	; Set high address
	STY PPU_VRAM_ADDR	; Set low address
	LDA Scroll_AttrStrip,X	; Get next attribute byte
	STA PPU_VRAM_DATA	; Commit it!
	TYA		 
	ADD #$08	 
	TAY		 	; Y += 8
	BCC PRG026_B384	 	; If we haven't overflowed, jump to PRG026_B384

	; Update high byte 
	LDA Scroll_ToVRAMHA
	EOR #$08	 	; Flips to attribute table 2
	STA Scroll_ToVRAMHA
	LDY Scroll_LastAttr	; Get low byte
PRG026_B384:
	INX		 	; X++
	CPX #14
	BNE PRG026_B363	 	; If X <> 14, loop!

	LDA #$00	 
	STA Scroll_ToVRAMHA	 ; Scroll_ToVRAMHA = 0 (update complete!)

PRG026_B38E:
	RTS		 ; Return


Scroll_ToVRAM_Apply:
	LDA PPU_STAT

	LDA Scroll_ToVRAMHi
	BEQ PRG026_B3BD	 ; If Scroll_ToVRAMHi = 0 (no scrolled pattern update required), jump to PRG026_B3BD

	LDX #$00	 ; X = 0

	; Set high byte of VRAM address
	LDA Scroll_ToVRAMHi
	STA PPU_VRAM_ADDR

	; Set low byte of VRAM address
	LDA Scroll_LastCol8
	STA PPU_VRAM_ADDR

	; Do increment by 1
	LDA <PPU_CTL1_Copy
	AND #~$04
	STA PPU_CTL1

PRG026_B3AC:
	LDA Scroll_PatStrip,X	; Get next block
	STA PPU_VRAM_DATA	; Write to VRAM
	INX		 	; X++
	CPX #32			
	BNE PRG026_B3AC		; While X < 32, loop!

	; Scroll_ToVRAMHi = 0 (update complete)
	LDA #$00	 
	STA Scroll_ToVRAMHi	 ; Scroll_ToVRAMHi = 0

	RTS		 ; Return


PRG026_B3BD:
	LDA Scroll_ToVRAMHA
	BEQ PRG026_B3E5	  ; If Scroll_ToVRAMHA = 0 (no scrolled attribute update required), jump to PRG026_B3E5 (RTS)

	; Reset PPU_CTL1
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1

	LDX #$00	 ; X = 0
	; Set high byte of VRAM address
	LDA Scroll_ToVRAMHA
	STA PPU_VRAM_ADDR

	; Set low byte of VRAM address
	LDA Scroll_LastAttr
	STA PPU_VRAM_ADDR

PRG026_B3D5:
	; Set next byte of attribute data
	LDA Scroll_AttrStrip,X
	STA PPU_VRAM_DATA

	INX		 ; X++ (next attribute byte)
	CPX #$08
	BLT PRG026_B3D5	 ; While X < 8, loop!

	; Scroll_ToVRAMHA = 0 (update complete)
	LDA #$00
	STA Scroll_ToVRAMHA

PRG026_B3E5:
	RTS		 ; Return

TileChng_VRAMCommit:
	LDY TileChng_VRAM_H
	BEQ PRG026_B38E	 ; If TileChng_VRAM_H = 0 (no tile change to do), jump to PRG026_B38E (RTS)

	LDA PPU_STAT

	; Switch to +1 increment mode
	LDA <PPU_CTL1_Copy
	AND #~$04
	STA PPU_CTL1

	LDA TileChng_VRAM_L	; Get VRAM low address
	STY PPU_VRAM_ADDR	; Set VRAM high address
	STA PPU_VRAM_ADDR	; Set VRAM low address

	; Commit the top two patterns
	LDA TileChng_Pats
	STA PPU_VRAM_DATA
	LDA TileChng_Pats+1
	STA PPU_VRAM_DATA

	; Set VRAM address at base +32
	LDA TileChng_VRAM_L
	ADD #32		; +32 to jump to next line
	STY PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

	; Commit the lower two patterns
	LDA TileChng_Pats+2
	STA PPU_VRAM_DATA
	LDA TileChng_Pats+3
	STA PPU_VRAM_DATA

	; TileChng_VRAM_H = 0 (Tile update commit completed!)
	LDA #$00
	STA TileChng_VRAM_H

	RTS		 ; Return

; Same format as data from Video_Upd_Table in PRG030, check there for details
; This is used as a template, but actual values will be overwritten below...
StatusBar_UpdTemplate:
	vaddr $2B28
	.byte $0C, $EF, $EF, $EF, $EF, $EF, $EF, $AE, $AF, $FE, $EC, $F0, $F0
	vaddr $2B45
	.byte $0F, $FE, $F0, $FE, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $FE, $ED, $F0, $F0, $F0
	.byte $00 ; Terminator

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_UpdateValues
;
; This subroutine basically handles all of the status bar updates
; besides cards; it inserts all of the following data:
; Power meter, coins, lives, score, time
; ... and performs updates where relevant, and even pushes it to the
; graphics buffer for commitment later on!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_UpdateValues:
	LDA Status_Bar_Mode
	CMP #$80
	BEQ NoBarUpdates

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ No_Switch
	LDA Status_Bar_Mode
	EOR #$FF
	STA Status_Bar_Mode

No_Switch:
	JSR Initialize_Status_Bar
	JSR StatusBar_Fill_PowerMT	
	JSR StatusBar_Fill_Air_MT	
	JSR Draw_HBros_Coin
	JSR Draw_Cherries
	JSR Update_Game_Timer
	JSR Do_Odometer
	JSR Draw_DayNightMeter

	; Fill in StatusBar_PMT with tiles of current Power Meter state
	JSR StatusBar_Fill_Coins	; Fill in StatusBar_CoinsL/H with tiles for coins held; also applies Coins_Earned
	;
	JSR StatusBar_Fill_Exp 	; Fill in StatusBar_Score with tiles for score; also applies Exp_Earned
	JSR StatusBar_Ability_Level
	JSR Status_Bar_Draw_Item_Reserve

NoBarUpdates:
	LDX #$00	 	; X = 0
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	BEQ PRG026_B466	 	; If graphics buffer is empty, jump to PRG026_B466

	; Graphics buffer has content... skips delay functionality:
	STX StatusBar_UpdFl	; StatusBar_UpdFl = 0
	JMP PRG026_B47A	 	; Jump to PRG026_B47A

PRG026_B466:
	; No data in graphics buffer, adds delay functionality

	; Basically, only one of two frames update the status
	; bar if the buffer is otherwise empty... I guess the
	; contrary is "well, they'll be processing update data
	; anyway, so we might as well get in there..."

	INC StatusBar_UpdFl	; StatusBar_UpdFl++
	LDA StatusBar_UpdFl	; A = StatusBar_UpdFl
	AND #$01	 	; going for a toggle
	BNE PRG026_B47A	 	; If set, jump to PRG026_B47A

	LDA #$00	 	
	STA StatusBar_UpdFl	; StatusBar_UpdFl = 0
	LDA #$06	 	;
	STA <Graphics_Queue	; Set Graphics_Queue = 6 (6?? Does it matter?)
	RTS		 ; Return

	; Arriving, X = 0, Y = Graphics_BufCnt
	; Copy StatusBar_UpdTemplate into the graphics buffer, which makes
	; room for everything to be done to the status bar, and includes
	; things like the video addresses and whatnot...
PRG026_B47A:
	; #DAHRKDAIZ new status bar rendiner
	LDA Status_Bar_Render_Toggle
	INC Status_Bar_Render_Toggle		; #DAHRKDAIZ Toggle between rendering top and bottom
	AND #$01
	BNE Do_Bottom

	; #DAHRKDAIZ render top
	LDX Graphics_BufCnt
	LDA #$2B
	STA Graphics_Buffer, X
	LDA #$22
	STA Graphics_Buffer + 1, X
	LDA #$1C
	STA Graphics_Buffer + 2, X
	LDY #$00

Status_Top_Loop:
	LDA Status_Bar_Top,Y	; Get next byte from StatusBar_UpdTemplate
	STA Graphics_Buffer + 3,X		; Store it into the graphics buffer
	INY				; Y++
	INX				; X++
	CPY #$1C
	BNE Status_Top_Loop	 		
	LDA #$00
	STA Graphics_Buffer + 3, X
	LDA Graphics_BufCnt
	CLC
	ADC #$1F
	STA Graphics_BufCnt
	RTS

	; #DAHRKDAIZ render bottom
Do_Bottom:
	
	LDX Graphics_BufCnt
	LDA #$2B
	STA Graphics_Buffer, X
	LDA #$42
	STA Graphics_Buffer + 1, X
	LDA #$1C
	LDY #$00
	STA Graphics_Buffer + 2, X

Status_Bottom_Loop:
	LDA Status_Bar_Bottom,Y	; Get next byte from StatusBar_UpdTemplate
	STA Graphics_Buffer + 3,X		; Store it into the graphics buffer
	INY				; Y++
	INX				; X++
	CPY #$1C
	BNE Status_Bottom_Loop	 		
	LDA #$00
	STA Graphics_Buffer + 3, X
	LDA Graphics_BufCnt
	CLC
	ADC #$1F
	STA Graphics_BufCnt
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_CopyObjectList
;
; Copies the level's object list in from ROM to RAM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_CopyObjectList:
;	LDY #$00	 ; Y = 0
;
;	LDA [Level_ObjPtr_AddrL],Y	; Get first byte from object layout data
;	STA Level_Objects,Y	 	; Copy to beginning of Level_Objects array
;
;PRG026_B506:
;
;	; Next byte is ID of object (or $FF to terminate the list)
;	INY
;	LDA [Level_ObjPtr_AddrL],Y
;	STA Level_Objects,Y
;
;	CMP #$ff	 
;	BEQ PRG026_B51F	 	; If terminator hit, jump to PRG026_B51F (RTS)
;
;	; Copy in start column of object
;	INY		 
;	LDA [Level_ObjPtr_AddrL],Y
;	STA Level_Objects,Y
;
;	; Copy in start row of object
;	INY
;	LDA [Level_ObjPtr_AddrL],Y
;	STA Level_Objects,Y
;
;	JMP PRG026_B506		; Loop!
;
;PRG026_B51F:
;	RTS		 ; Return

; Rest of ROM bank was empty...
Initial_Bar_Display1:
	.byte $FE, $D1, $D1, $D1, $D1, $D1, $D1, $FE, $E0, $E1, $E1, $E1, $E1, $EA, $D7, $30, $30, $30, $FE, $D5, $30, $FE, $83, $FE, $FE, $83, $FE, $FE
	.byte $FE, $30, $30, $30, $30, $30, $30, $FE, $D0, $30, $30, $30, $30, $FE, $D3, $30, $30, $30, $FE, $FE, $FE, $FE, $93, $FE, $FE, $93, $FE, $FE

Initial_Bar_Display2:
	.byte $D0, $30, $30, $30, $30, $30, $30, $30, $FE, $D3, $30, $30, $D4, $30, $30, $D4, $20, $20, $20, $20, $20, $F0, $F0, $F0, $F0, $F0, $F0, $F0
	.byte $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20

Draw_World_Name:

	LDX #$00

DrawName:
	LDA LevelName, X
	STA Status_Bar_Bottom, X
	INX
	CPX #28
	BNE DrawName
	RTS


Initialize_Status_Bar:
	LDA Status_Bar_Mode
	CMP Last_Status_Bar_Mode
	BEQ No_Init
	STA Last_Status_Bar_Mode
	LDY #$00
	LDA Status_Bar_Mode
	BNE Init_Bar_2
	LDA #LOW(Initial_Bar_Display1)
	STA <Temp_Var1
	LDA #HIGH(Initial_Bar_Display1)
	STA <Temp_Var2
	BNE Init_Bar_Loop

Init_Bar_2:
	JSR DrawTotalCoins
	LDA #LOW(Initial_Bar_Display2)
	STA <Temp_Var1
	LDA #HIGH(Initial_Bar_Display2)
	STA <Temp_Var2

Init_Bar_Loop:
	LDA [Temp_Var1], Y
	STA Status_Bar_Top, Y
	INY
	CPY #$38
	BNE Init_Bar_Loop

	LDA Status_Bar_Mode
	BNE Draw_Update2
	JSR DrawCurrentCoins
	JSR Exp_Update
	RTS

Draw_Update2:
	JSR DrawTotalCoins
	JSR Update_Odometer
	JSR Draw_World_Name
	JSR Update_Game_Timer
No_Init:
	RTS

Do_Odometer:
	LDA Odometer_Increase
	CMP #$80
	BCC No_Odometer
	SBC #$80
	STA Odometer_Increase
	LDX #$06
	 
Increase_Odometer:
	INC Odometer, X
	LDA Odometer, X
	CMP #$0A
	BCC Next_Odometer
	LDA #$00
	STA Odometer, X
	DEX
	BPL Increase_Odometer

Next_Odometer:
	JSR DoBankInterest
	LDA Status_Bar_Mode
	BEQ No_Odometer

Update_Odometer:
	LDY #$06
	
Odometer_Loop:
	LDA Odometer, Y
	ORA #$30
	STA Status_Bar_Top + 21,Y
	DEY
	BPL Odometer_Loop

No_Odometer:
	RTS

Draw_HBros_Coin:
	LDA Status_Bar_Mode
	BNE No_HBros_Update
	LDA Magic_Stars
	JSR ToThreeDigits
	LDX #$02

MS_Next_Digit:
	LDA <Temp_Var1, X
	ORA #$30
	STA Status_Bar_Top + 15, X
	DEX
	BPL MS_Next_Digit
	
	JSR GetLevelBit
	PHA
	LDX #$D6
	AND Magic_Stars_Collected1, Y
	BEQ Draw_Game_Timer1
	INX

Draw_Game_Timer1:
	STX Status_Bar_Bottom + 15
	LDX #$D6
	PLA
	PHA
	AND Magic_Stars_Collected2, Y
	BEQ Draw_Game_Timer2
	INX

Draw_Game_Timer2:
	STX Status_Bar_Bottom + 16
	LDX #$D6
	PLA
	AND Magic_Stars_Collected3, Y
	BEQ Draw_Game_Timer3
	INX

Draw_Game_Timer3:
	STX Status_Bar_Bottom + 17

No_HBros_Update:
	RTS

DayNightIcon:
	.byte $D8, $D9
DayNightTiles:
	.byte $60, $74, $61, $74, $62, $74, $63, $74, $64, $65, $66, $67, $70, $71, $72, $73, $74, $60, $74, $61, $74, $62, $74, $63

Draw_DayNightMeter:
	LDA Status_Bar_Mode
	CMP #$00
	BNE NoDayNightMeter
	LDX #$00
	LDA DayNight
	BPL Draw_DayNightMeter2
	INX

Draw_DayNightMeter2:
	LDA DayNightIcon, X
	STA Status_Bar_Bottom + 19
	LDA DayNightTicker
	ASL A
	TAX
	LDA DayNightTiles, X
	STA Status_Bar_Bottom + 20
	LDA DayNightTiles + 1,X
	STA Status_Bar_Bottom + 21

NoDayNightMeter: 
	RTS

DoBankInterest:
	STX TempX
	JSR Clear_Calc
	LDX #$05

CopyBC:
	LDA BankCoins, X
	STA Calc_From + 2,X
	DEX
	BPL CopyBC
	LDX #$03

CopyPC100:
	LDA BankCoins, X
	STA Calc_Value + 4, X
	DEX
	BPL CopyPC100
	JSR Add_Values
	LDA Calc_From + 1
	CMP #$01
	BCS NoInterest
	LDX #$05

CopyCF:
	LDA Calc_From + 2, X
	STA BankCoins, X
	DEX
	BPL CopyCF
	LDX TempX

NoInterest:
	RTS

Draw_Cherries:
	LDA Status_Bar_Mode
	BMI Draw_Cherries1
	LDA Cherries
	JSR ToThreeDigits
	LDA <Temp_Var2
	ORA #$30
	STA Status_Bar_Top + 20
	LDA <Temp_Var3
	ORA #$30
	STA Status_Bar_Top + 21

Draw_Cherries1:
	RTS


Update_Game_Timer:
	LDA Status_Bar_Mode
	BPL Update_Game_Timer1

	LDA Game_Timer
	ORA #$30
	STA Status_Bar_Top + 10
	LDA Game_Timer + 1
	ORA #$30
	STA Status_Bar_Top + 11

	LDA Game_Timer + 2
	ORA #$30
	STA Status_Bar_Top + 13
	LDA Game_Timer + 3
	ORA #$30
	STA Status_Bar_Top + 14

	LDA Game_Timer + 4
	ORA #$30
	STA Status_Bar_Top + 16
	LDA Game_Timer + 5
	ORA #$30
	STA Status_Bar_Top + 17

Update_Game_Timer1:
	RTS