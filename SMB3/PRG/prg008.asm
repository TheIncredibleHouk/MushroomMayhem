; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-05 22:51:55.464428532 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

	; Defines 4 frames of animation to use while Player walks
Player_WalkFramesByPUp:
	.byte PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1, PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1	; 0 - Small
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 1 - Big
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 2 - Fire
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 3 - Leaf
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 4 - Frog
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 5 - Tanooki
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 6 - Hammer

	; Frames used during the "power up" sequence from small -> Big
Player_GrowFrames:
	.byte PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2
	.byte PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY
	.byte PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY

	; Stores frame to be used while traversing a pipe
	; Order is small, small + kuribo, other, other + kuribo
PipeMove_Frame:
	.byte PF_INPIPE_SMALL, PF_INPIPE_SMALLKURIBO, PF_INPIPE_BIG, PF_INPIPE_BIGKURIBO

	; Frame used when Player is "skidding"
Player_SkidFrame:
	.byte PF_SKID_SMALL, PF_SKID_BIG	; First value is for small, the other for everything else

Player_SwimActiveFrames:
	; Everything but small
	.byte PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2, PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2	
	; Small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2

	; Player sprite frames for swimming; first four are all power-up/suits
	; EXCEPT small, and the other four are for small
Player_SwimIdleFrames:
	.byte PF_SWIMIDLE_BIG, PF_SWIMIDLE_BIG+1, PF_SWIMIDLE_BIG-8, PF_SWIMIDLE_BIG+1	; Everything but small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+3, PF_SWIMIDLE_SMALL+3	; Small

	; Player's tail attack frames
Player_TailAttackFrames:
	.byte PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+1, PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+2, PF_TAILATKGROUND_BASE	; On ground
	.byte PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-5, PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-4, PF_TAILATKINAIR_BASE	; In air

	; Frames for when Player is in Kuribo's shoe
	; Player duck frame
Player_DuckFrame:
	; First value is for everything EXCEPT Raccoon power; value on right is for raccoon power
	.byte PF_DUCK_NOTRACCOON,  PF_DUCK_RACCOON

	; The three sprite frames for when Player shoots a fireball/hammer
Player_FireOnGround:	.byte PF_THROWONGROUND_BASE, PF_THROWONGROUND_BASE+3, PF_THROWONGROUND_BASE+2
Player_FireInAir:	.byte PF_THROWINAIR_BASE, PF_THROWINAIR_BASE+1, PF_THROWINAIR_BASE+2

	; Frames used while frog hopping
Player_FrogHopFrames:
	.byte PF_FROGHOP_BASE, PF_FROGHOP_BASE+2, PF_FROGHOP_BASE+1, PF_FROGHOP_BASE

	; Frames used when Player is running at high speed!
Player_SpreadEagleFrames:
	.byte PF_RUNBIG_BASE, PF_RUNBIG_BASE+1, PF_RUNBIG_BASE+2, PF_RUNBIG_BASE+1	; Player is not small
	.byte PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1, PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1	; Player is small


	; The raccoon power uses rotations of three frames based on different conditions
Player_TailWagFlyFrames:
	.byte PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE	; Flying
	.byte PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE	; Flying, apex
	.byte PF_JUMPRACCOON, PF_JUMPRACCOON, PF_JUMPRACCOON			; Jump/fall
	.byte PF_TAILWAGFALL+2, PF_TAILWAGFALL+1, PF_TAILWAGFALL		; Flutter wag

Player_HoldingFrames:
	.byte PF_HOLDBIG_BASE, PF_HOLDBIG_BASE+1, PF_HOLDBIG_BASE+2, PF_HOLDBIG_BASE+1	; Player is not small
	.byte PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1, PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1	; Player is small

	; Airship "caught anchor" frame or general vine climbing
Player_ClimbFrame:
	.byte PF_CLIMB_SMALL	; Small
	.byte PF_CLIMB_BIG	; Big
	.byte PF_CLIMB_BIG	; Fire
	.byte PF_CLIMB_BIG	; Leaf
	.byte PF_CLIMB_FROG	; Frog
	.byte PF_CLIMB_BIG	; Tanooki
	.byte PF_CLIMB_BIG	; Hammer

	; Airship jump frame used by power up
Airship_JumpFrameByPup:

Player_VibeDisableFrame:
	.byte PF_WALKSMALL_BASE		; Small
	.byte PF_WALKBIG_BASE+2		; Big
	.byte PF_WALKBIG_BASE+2		; Fire
	.byte PF_WALKSPECIAL_BASE+2	; Leaf
	.byte PF_WALKSPECIAL_BASE	; Frog
	.byte PF_WALKBIG_BASE+2	; Tanooki
	.byte PF_WALKBIG_BASE+2		; Hammer


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoGameplay
;
; This subroutine is MAJOR; it performs a LOT of tasks which make
; the Player gameplay; too much to discuss here, so go through it!
; About the only thing it doesn't cover is colliding with other
; objects; this is handled elsewhere...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoGameplay:
	JSR Increase_Game_Timer

	JSR Level_Initialize	 ; Initialize level if needed
	JSR LevelJunction_PartialInit	 
	
	
	LDA DayNightActive
	BNE Clear_WeatherSprites

	JSR Sprite_RAM_Clear
	JMP Player_DoUpdate

Clear_WeatherSprites:
	JSR Sprite_RAM_Clear_NotWeather

Player_DoUpdate:
	JSR Player_Update	 ; WHERE THE PLAYER DOES EVERYTHING!! (Except touch other objects)

	; If Player is...
	LDA <Player_IsDying	; ... dying ....
	ORA Level_PipeMove	; ... moving through a pipe ...
	ORA Player_SuitLost	; ... just lost his suit ...
	ORA Player_StarOff	; ... starman is wearing off ...
	ORA Player_Grow		; ... is growing/shrinking ...
	STA <Player_HaltGameZ	; ... means he's halting the gameplay for now

	BNE PRG008_A1C1	 	; And if that's the case, jump to PRG008_A1C1
	
	JSR CheckForLevelEnding
	LDA CompleteLevelTimer
	BPL GameIsHalted

	JSR CoinsEarnedBuffer
	JSR Do_Air_Timer
	JSR Do_PowerChange
	JSR Try_Item_Reserve_Release
	JSR Try_Use_Equipped

	LDA DayNightActive
	BEQ NoTransition

	LDA NightTransition
	BEQ NotNight

	JSR DoNightTransition

NotNight:
	LDA DayTransition
	BEQ NoTransition
	JSR DoDayTransition

NoTransition:

GameIsHalted:
	JSR Player_Refresh
	INC Game_Counter	; As long as none of the above is happening, continue the "no stop" counter...

PRG008_A1C1:
	; Decrement several adjacent counters!
	LDX #$05	 ; X = 7

PRG008_A1DE:
	LDA Event_Countdown,X
	BEQ PRG008_A1E6	 ; If counter is = 0, jump to PRG008_A1E6

	DEC Event_Countdown,X	 ; Otherwise, decrement it!

PRG008_A1E6:
	DEX		 ; X--
	BPL PRG008_A1DE	 ; While X >= 0, loop!

	LDA Level_PSwitchCnt
	BEQ PRG008_A20C	 ; If Level_PSwitchCnt = 0 (P-Switch not active), jump to PRG008_A20C
	
	CMP #$FF
	BEQ PRG008_A20C

	CMP #$01
	BNE PRG008_A203	 ; If Level_PSwitchCnt <> 1, jump to PRG008_A203

	STA Block_WasUpdated

	LDY #$0A	 ; Y = $0A (Invincibility song)

	LDA Player_StarInv
	CMP #$20
	BGE PRG008_A1FE	 ; If Player_StarInv >= $20, jump to PRG008_A1FE

	LDY Level_MusicQueueRestore	 ; Y = regular BGM

PRG008_A1FE:
	STY Sound_QMusic2 ; Restore appropriate music
	BNE PRG008_A209	 ; If Level_PSwitchCnt > 0, jump to PRG008_A209

PRG008_A203:
	LDA <Counter_1
	AND #$03	 ; Cap 0 - 3
	BNE PRG008_A20C	 ; If 1 - 3, jump to PRG008_A20C (RTS)

PRG008_A209:
	DEC Level_PSwitchCnt	 ; Level_PSwitchCnt--

PRG008_A20C:
	RTS		 ; Return


	; Just amounts to calling Player_Draw, but takes care of switching to page 29 and back
Player_Draw29:
	JSR PChg_C000_To_29	 ; Change page @ C000 to 29
	JSR Player_Draw	 	; Draw Player
	JMP PChg_C000_To_0	 ; Change page @ C000 to 0 and don't come back!

Player_DrawAndDoActions29:
	JSR PChg_C000_To_29	 ; Change page @ C000 to 29

	LDA #$00	 
	STA Player_InPipe 	; Player_InPipe = 0

	JSR Player_DrawAndDoActions	 ; Draw Player and do actions (going to coin heaven, the airship intro, going through pipes, ...)

	INC Player_InPipe	 ; Player_InPipe = 1

PRG008_A224:

	; If Player did NOT enter a pipe, we jump here...

	PLA
	PLA

	JMP PChg_C000_To_0	 ; Jump to PChg_C000_To_0 (switch C000 back to page 0 and return)

PChg_C000_To_29:
	; Change page @ C000 to 29
	LDA #29
	STA PAGE_C000
	JMP PRGROM_Change_C000

PChg_C000_To_0:
	; Change page @ C000 to 0
	LDA #$00
	STA PAGE_C000
	JMP PRGROM_Change_C000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_Initialize
; 
; If level has not yet initialized, this does so, otherwise it
; simply exits and does nothing...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Level_Initialize:

	LDA <Player_XStart	
	BEQ PRG008_A242	 ; If Player_XStart = 0 (not yet initialized), jump to PRG008_A242
	RTS		 ; Return


PRG008_A242:
	STA Level_ObjectsInitialized ; Set Level_ObjectsInitialized = 0 (trigger scene-change reset)

	LDA #$18
	STA Player_SprOff ; Player sprite rooted at offset $28


	; Set player power up based on current suit on 
	LDX World_Map_Power
	BNE Super_MarioStandard
	INX

Super_MarioStandard:	
	INX
	STX Player_QueueSuit 

	LDA #$40
	STA Air_Time
	STA Tile_Anim_Enabled

	LDA #$FF
	STA CompleteLevelTimer

	LDA Player_Coins
	STA Previous_Coins

	LDA Player_Coins+1
	STA Previous_Coins+1

	LDA Player_Coins+2
	STA Previous_Coins+2

	LDA Cherries
	STA Previous_Cherries

	LDA Magic_Stars
	STA Previous_Stars

	JSR GetLevelBit
	
	LDA Magic_Stars_Collected1, Y
	STA Previous_Stars_Collected1

	LDA Magic_Stars_Collected2, Y
	STA Previous_Stars_Collected2

	LDA Magic_Stars_Collected3, Y
	STA Previous_Stars_Collected3

	; Set power up's correct palette
	JSR Level_SetPlayerPUpPal

	LDA #SPR_HFLIP
	STA <Player_FlipBits	 ; Player_FlipBits = $40 (face right)

	; Set Player_X based on Level_SelXStart

	LDA <Player_X
	STA <Player_XStart	; Also set Player_XStart

	JSR Level_InitAction_Do	; Do whatever action this level wants at the start, if any

PRG008_A277:

PRG008_A27A:
PRG008_A29E:
	LDA <Vert_Scroll
	STA Level_VertScroll	; Level_VertScroll = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_VertScrollH	; Level_VertScrollH = Vert_Scroll_Hi

LevelInit_DoNothing:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_InitAction_Do
;
; Performs whatever is requested by the level as an initial action
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_InitAction_JumpTable:
	.word LevelInit_DoNothing	; 0 - Do nothing
	.word LevelInit_DoNothing	; 1 - Start level sliding (if able by power-up)
	.word LevelInit_PipeExitTop	; 2 - Start by exiting top of pipe
	.word LevelInit_PipeExitBottom	; 3 - Start by exiting bottom of pipe
	.word LevelInit_PipeExitRight	; 4 - Start by exiting right of pipe
	.word LevelInit_PipeExitLeft	; 5 - Start by exiting left of pipe

Level_InitAction_Do:
	LDA Level_InitAction
	ASL A		
	TAY		; Y = Level_InitAction << 1 (2 byte index)

	; Copy jump address into Temp_Var1/2
	LDA Level_InitAction_JumpTable,Y
	STA <Temp_Var1
	LDA Level_InitAction_JumpTable+1,Y
	STA <Temp_Var2

	LDA #$00
	STA Level_InitAction	; Level_InitAction = 0 (same memory gets used as Player_Slide after this!)

	JMP [Temp_Var1]		; Jump appropriately...


LevelInit_PipeExitTop:
	LDA #$83	 ; A = $83 (sets Level_PipeMove)
	LDY #$01	 ; Y = 1 (come out pipe from the top, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitBottom:
	LDA #$82	 ; A = $82 (sets Level_PipeMove)
	LDY #$02	 ; Y = 2 (come out pipe from the bottom, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitRight:
	LDA #$80	 ; A = $80 (sets Level_PipeMove)
	LDY #$03	 ; Y = 3 (come out pipe to the right, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitLeft:
	LDA #$81	 ; A = $81 (sets Level_PipeMove)
	LDY #$04	 ; Y = 4 (come out pipe to the left, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_Airship:


LevelInit_Airship_Board:

PRG008_A324:
	; Set as appropriate from entry
	STA Level_PipeMove
	STY Level_PipeExitDir
	JMP PRG008_A38E	 ; Jump to PRG008_A38E


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelJunction_PartialInit
; 
; Performs some re-initialization required after entering a door
; or pipe and handles some airship intro stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelJunction_PartialInit:
	LDA LevelPartialInit
	BEQ PRG008_A388	 ; If LevelPartialInit = 0, jump to PRG008_A388

	LDA #$00
	STA LevelPartialInit	 ; LevelPartialInit = 0
	STA ForcedSwitch
	STA Level_HAutoScroll	 ; Disable auto horizontal scrolling
	STA Level_AScrlConfig	 ; Clear auto scroll configuration (no auto scroll)
	STA Level_ObjectsInitialized	 ; Do level scene change reset

	JSR Level_SetPlayerPUpPal  ; Set power up's correct palette
	JSR PRG008_A27A		   ; Partial level initialization (basically continues after setting the power up)

PRG008_A379:
	LDA Level_InitAction
	CMP #$06
	BNE PRG008_A383	 	; If Level_InitAction <> 6 (Run & Jump for the airship), jump to PRG008_A383

	JSR LevelInit_Airship	 ; Run & Jump for the airship
PRG008_A383:

	JSR PRG008_A38E	 

	; Pulls prior return address, meaning this function
	; will return to the caller's caller!
	PLA
	PLA

PRG008_A388:
	RTS		 ; Return

Event_Countdown_Init:
	; 0 = Not used, 1 = Up, 2 = Down, 3 = Right, 4 = Left
	; Ticks to initialize Event_Countdown
	.byte $00, $3F, $07, $20, $20

PRG008_A38E:
	; Common point for exiting and entering from pipe
	; and some other routines... (if Level_PipeMove = 0,
	; then clearly there's no pipe action going on)

	LDA Level_PipeMove
	BEQ PRG008_A3C9	 ; If Level_PipeMove = 0, jump to PRG008_A3C9 (RTS)

	; Queue pipe sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA <Player_X	
	STA <Pipe_PlayerX	 ; Pipe_PlayerX = Player_X

	LDA <Player_YZ
	AND #$F0	
	STA <Pipe_PlayerY
	DEC <Pipe_PlayerY 	; Pipe_PlayerY = Player_Y aligned to nearest 16, minus 1

	; For non-vertical levels...
	LDA <Vert_Scroll
	STA Level_VertScroll	; Level_VertScroll = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_VertScrollH	; Level_VertScrollH = Vert_Scroll_Hi

PRG008_A3B6:
	LDA Level_PipeExitDir
	BNE PRG008_A3C0	 	; If Level_PipeExitDir <> 0, jump to PRG008_A3C0

	LDA #$02	 
	STA Level_PipeExitDir	 ; If Level_PipeExitDir is not set, assume we're coming out the bottom

PRG008_A3C0:
	AND #$0f	 ; Ensure Level_PipeExitDir is capped (note, though, only 0-3 is valid)
	TAY		 
	LDA Event_Countdown_Init,Y
	STA Event_Countdown	 ; Event_Countdown = Event_Countdown_Init[Y]

PRG008_A3C9:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Update
;
; Responsible for ALL of the magic; does everything
; needed to make a functional Player object!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Update:
	LDA <Player_IsDying
	BNE Player_Update3

	LDA Player_QueueSuit
	BEQ Player_Update1	 ; If we don't have a suit change queued, jump to PRG008_A3FA

	JSR Player_SuitChange
	
Player_Update1:
	JSR Player_PitDeath
	JSR Player_SetHolding

Player_Update3:
	; The following are always called, dead or alive...


	JSR Debug_Code
	JSR Player_DrawAndDoActions29	; Draw Player and perform reactions to various things (coin heaven, pipes, etc lots more)

	LDA #$04
	STA Air_Change

	JSR Player_Control	 	; Controllable actions
	JSR VScreenTransitions
	JSR Player_DetermineAir

PRG008_A473:
	JSR Player_RunMeterUpdate	 	; Update "Power Meter"
	JSR Player_UpdateRunPower
	
	LDA <Horz_Scroll
	STA LastHorzScroll
	
	LDA <Horz_Scroll_Hi
	STA LastHorzScrollHi

	JSR Player_DoScrolling	 	; Scroll relative to Player against active rules
	JSR SetLastScrollDirection
	JSR Player_TailAttack_HitBlocks	; Do Tail attack against blocks
	JSR Player_DetectSolids		; Handle solid tiles, including slopes if applicable
	JSR Player_CheckForeground
	JSR Player_HandlePipe
	JSR Check_Timers
	JSR Player_DoVibration		; Shake the screen when required to do so!
	JSR Player_SetSpecialFrames	; Set special Player frames
	JSR Player_Draw29	 	; ... and if you get through all that, draw the Player!!
	JSR Player_Events


	RTS		 ; Return

VibrationOffset:
	.byte 0,  2,  3,  1	; For when 0 >= Vert_Scroll >= $7F
	.byte 0, -2, -3, -1	; For when $80 >= Vert_Scrol >= $FF

	; Simple function which updates the "Shake" effect from something heavy
Player_DoVibration:
	LDA Level_Vibration	 
	BEQ PRG008_A4BE		; If level is NOT vibrating, jump to PRG008_A4BE

	DEC Level_Vibration	 ; Level_Vibration--
	AND #$03	 	; Cap 0 - 3

	LDY <Vert_Scroll
	BPL PRG008_A4B1	 ; If Vert_Scroll < $80, jump to PRG008_A4B1

	ORA #$04	 ; Otherwise, use value 4 - 7

PRG008_A4B1:
	TAY		 	; index value -> 'Y'
	LDA VibrationOffset,Y	; Get offset 
	PHA		 	; Save it
	ADD Level_VertScroll	
	STA Level_VertScroll	; Level_VertScroll += offset
	PLA		 	; Restore it

PRG008_A4BE:
	STA Vert_Scroll_Off	 ; Update Vert_Scroll_Off
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_RunMeterUpdate
;
; Handles updating the "Power Meter" as appropriate,
; and plays the annoying "ringing" noise :)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_RunMeterUpdate:
	LDY Player_FlyTime	 
	BEQ PRG008_A4E4	 ; If Player is not flying (or at least high-speed jumping), jump to PRG008_A4E4

	CPY #$ff
	BEQ Sound_FullPowerRing	 ; If Player_FlyTime = $FF (P-Wing active), jump to Sound_FullPowerRing

	LDA <Counter_1
	AND #$01
	BEQ PRG008_A4D5	 ; Every other tick, jump to PRG008_A4D5

	DEY			 
	STY Player_FlyTime ; Player_FlyTime--

	LDA Player_EffectiveSuit
	CMP #$03
	BNE PRG008_A4D5

	STY Player_Power

PRG008_A4D5:
	TYA		 ; Y (Player_FlyTime) -> A 
	BNE Sound_FullPowerRing	 ; If Player_FlyTime <> 0, jump to Sound_FullPowerRing

	STY Player_RunMeter ; Otherwise, clear Player_RunMeter

Sound_FullPowerRing:

	; Full power ringing sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPOWER
	STA Sound_QPlayer

	RTS		 ; Return


PRG008_A4E4:
	LDA Player_RunMeter
	CMP #$7f
	BNE PRG008_A4F8	 ; If Player_RunMeter <> $7F (max power), jump to PRG008_A4F8

	JSR Sound_FullPowerRing	 ; Play full power ringing sound

	LDA Player_RunFlag
	BEQ PRG008_A4F8	 ; If Player is not running, jump to PRG008_A4F8

	LDY #$10	 ; Y = $10
	JMP PRG008_A51A	 ; Jump to PRG008_A51A

PRG008_A4F8:
	LDA Player_PMeterCnt
	BNE PRG008_A523	 ; If Player_PMeterCnt <> 0, jump to PRG008_A523

	SEC		 ; Set carry
	ROL Player_RunMeter ; Player_RunMeter is shifted left 1, its old bit 7 in the carry, and '1' introduced at bit 0

	LDA Player_RunFlag
	BNE PRG008_A50C	 ; If Player is running, jump to PRG008_A50C

	ROR Player_RunMeter ; Restore Player_RunMeter
	LSR Player_RunMeter ; Shift it 1 to the right

PRG008_A50C:
	LDY #$18	 ; Y = $18

	LDA Player_RunMeter
	BEQ PRG008_A520	 ; If Player_RunMeter = 0, jump to PRG008_A520

	LDA Player_RunFlag
	BEQ PRG008_A51A	 ; If Player is not running, jump to PRG008_A51A

	LDY #$08	 ; Otherwise, Y = $8
PRG008_A51A:
	STY Player_PMeterCnt	 ; Set Player_PMeterCnt

	JMP PRG008_A523	 ; Jump to PRG008_A523

PRG008_A520:
	STA Player_FlyTime ; Clear Player_FlyTime

PRG008_A523:

	LDA #$00
	STA Player_RunFlag ; Player_RunFlag = 0

	RTS		 ; Return


Player_FullMeter:
	LDA #$50
	STA Player_Power
	RTS

Player_UpdateRunPower:
	LDA Player_FlyTime
	BMI Player_FullMeter
	BNE Player_UpdateRunPowerRTS

	LDA Player_EffectiveSuit
	CMP #$03
	BNE Player_UpdateRunPowerRTS

	LDY #$00

	LDA Player_RunMeter
	BEQ RunMeter_StoreEmpty
	
RunMeter_NextBit:
	LSR A
	BCC RunMeter_Store

	INY
	BNE RunMeter_NextBit

RunMeter_Store:
	TYA
	
	ASL A
	ASL A
	ASL A
	ASL A

	TAY
	DEY

RunMeter_StoreEmpty:
	STY Player_Power

Player_UpdateRunPowerRTS:
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SetPlayerPUpPal
;
; Puts the palette required by the Player's current power-up into
; the graphics buffer.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Palette colors per power up level -- first byte is never used!
PowerUp_Palettes:
	.byte $00, $0F, $16, $36	; 0 - Mario default palette
	.byte $00, $0F, $16, $36	; 1 - Mario default palette
	.byte $00, $06, $30, $36	; 2 - Fire Flower
	.byte $00, $0F, $16, $36	; 3 - Leaf (Not used, uses 0 or 1 as appropriate)
	.byte $00, $0F, $28, $36	; 4 - Frog Suit
	.byte $00, $0F, $19, $36	; 5 - Koopa Suit
	.byte $00, $0F, $30, $27	; 6 - Hammer Suit
	.byte $00, $01, $30, $31	; 7 - Ice Mario
	.byte $00, $06, $27, $36	; 8 - Fire Fox Mario
	.byte $00, $01, $30, $31	; 9 - Unused
	.byte $00, $0F, $25, $36	; A - Boo Mario
	.byte $00, $0F, $36, $36	; B - Ninja Mario
	.byte $00, $0F, $0B, $2B	; infected
	.byte $00, $27, $28, $30	; yolked
	.byte $00, $0F, $0F, $03	; yolked

Level_SetPlayerPUpPal:
	LDA Player_Oiled
	BEQ CheckYolked

	LDA #$0E
	BNE Skipped_Palette

CheckYolked:	
	LDA Player_Yolked
	BEQ CheckInfection

	LDA #$0D
	BNE Skipped_Palette

CheckInfection:
	LDA LeftRightInfection
	BEQ Normal_Palette

	LDA #$0C
	BNE Skipped_Palette

Normal_Palette:
	LDA Player_EffectiveSuit

Skipped_Palette:
	TAY
	LDX Graphics_BufCnt
	TXA
	ADD #$06
	STA Graphics_BufCnt	 ; Graphics_BufCnt += 6 more bytes coming in...

	; Going to send in a palette update

	; PPU Address $3F11 (make sure to match with Palette_Buffer offsets below!)
	LDA #$3f
	STA Graphics_Buffer,X
	LDA #$11
	STA Graphics_Buffer+1,X

	; Run of 3 bytes
	LDA #$03
	STA Graphics_Buffer+2,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+6,X

	TYA
	ASL A
	ASL A
	TAY	; Y <<= 2 (4 bytes per index)

	LDA PowerUp_Palettes+1,Y
	STA Graphics_Buffer+3,X
	STA Palette_Buffer+$11	 ; Also put into Palette_Buffer

	LDA PowerUp_Palettes+2,Y
	STA Graphics_Buffer+4,X
	STA Palette_Buffer+$12	 ; Also put into Palette_Buffer

	LDA PowerUp_Palettes+3,Y
	STA Graphics_Buffer+5,X
	STA Palette_Buffer+$13	 ; Also put into Palette_Buffer

	RTS		 ; Return


	; This is the main value of X acceleration applied
Player_XAccelMain:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button	With B button
	;      F   N   S   X     F   N   S   X
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Normal
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Big
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Fire
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Leaf
	.byte -1,  2,  2,  0, 	-1,  2,  2,  0	; Frog
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Tanooki
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Hammer


Player_XAccelMain_UW:
	; If on the ground	If swimming above the ground
	.byte -1,  1,  1,  0, 	-1,  0,  0,  0

	.byte -1,  0,  0,  0, 	-1,  0,  1,  0
	.byte -1,  0,  0,  0, 	-1,  0,  0,  0


	; The following values are added to the "Counter_Wiggly"
	; value in an attempt to push the likelihood of a carry
	; which gives just a slight boost to the Player's X
	; velocity acceleration; way of making it sort of a
	; fractional increase while he moves...
Player_XAccelPseudoFrac:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button		With B button
	;       F    N    S    X          F    N    S    X
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Small
	.byte $20, $E0, $00, $00,	$20, $E0, $00, $00	; Big
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Fire
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Leaf
	.byte $00, $00, $00, $00, 	$00, $00, $00, $00	; Frog
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Tanooki
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Hammer

Player_XAccelPseudoFrac_UW:
	; If on the ground		If swimming above the ground
	.byte $30, $00, $00, $00, 	$E0, $30, $80, $00

	.byte $A0, $E0, $C0, $00, 	$A0, $E0, $20, $00
	.byte $D0, $E0, $60, $00, 	$D0, $E0, $C0, $00

	.byte $10, $F0


	; Maximum tick count for walking animation tick counter
	; (i.e. what tick value to reach to go to next anim frame)
Player_WalkAnimTickMax:
	; 0-15 POSSIBLE, but only 0-7 defined (due to game's max X vel of $38)
	; Index is Player_XVelZ >> 3
	.byte $07, $06, $05, $04, $03, $02, $01, $01, $01	; Lower number = faster animation


	; Root jump velocity
Player_RootJumpVel:	.byte PLAYER_JUMP

	; Based on how fast Player is running, the jump is
	; increased just a little (this is subtracted, thus
	; for the negative Y velocity, it's "more negative")
Player_SpeedJumpInc:	.byte $00, $02, $04, $08

;; FIXME: Anybody want to claim this?
;	.byte $00, $03, $06, $08, $08, $08, $08, $06, $03, $00, $04, $08, $12, $16, $16, $12
;	.byte $08, $04

	; This sets the sprite's H/V flip bits for the somersault
Player_SomersaultFlipBits:
	.byte $00, $00, $00, $00, $C0, $C0, $C0, $C0, $80, $01


	; Bit which must be set in FloatLevel_PlayerWaterStat to override 
	; system and assume that we're underwater no matter what tile detected

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_CheckIfTileUnderwater
;
; This checks if the given tile in Temp_Var1/2 (depending on 'X')
; is "underwater", based on Temp_Var3 (Level_TilesetIdx << 2) and
; the tile's "quadrant", which index "Level_MinTileUWByQuad"
;
; The result can be overridden if the proper bit in 
; FloatLevel_PlayerWaterStat is set, which will force the
; report to say underwater...
;
; CARRY: The "carry flag" will be set and the input tile not
; otherwise tested if the tile is in the "solid floor" region!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_CheckIfTileUnderwater:

	AND #$F0
	CMP #$C0
	BCS PRG008_A6A9	 ; If tile is solid floor, jump to PRG008_A6A9 (RTS)

PRG008_A68D:

	LDY #$00	 ; Y = 0 (Not under water)

	AND #TILE_PROP_WATER
	BEQ PRG008_A6A6	 ; If the starting underwater tile is greater than the detected tile, jump to PRG008_A6A6

PRG008_A6A5:
	INY		 ; Y = 1 (Underwater)

PRG008_A6A6:
	STY <Temp_Var15	 ; Store Y -> Temp_Var15 (0, 1, or 2)

PRG008_A6A8:
	CLC		 ; Clear carry (tile was not in the solid floor region)

PRG008_A6A9:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Control
;
; Pretty much all controllable Player actions like ducking,
; sliding, tile detection response, doors, vine climbing, and 
; including basic power-up / suit functionality (except the actual 
; throwing of fireballs / hammers for some reason!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Control:
	LDA #$00
	STA Top_Of_Water

	LDA <Player_FlipBits
	STA Player_FlipBits_OLD

	LDA <Player_InAir
	STA Player_InAir_OLD

	LDA Player_VibeDisable
	BEQ PRG008_A6DA	 	; If Player is not "vibrationally disabled", jump to PRG008_A6DA

	DEC Player_VibeDisable	 ; Otherwise Player_VibeDisable--

PRG008_A6D2:

	; Remove horizontal velocity and cancel controller inputs
	LDA #$00
	STA <Player_XVelZ
	STA <Pad_Holding
	STA <Pad_Input	


PRG008_A6DA:

	LDA Player_FireDash		; if in fireball mode, disable, all but select and start
	BEQ PRG008_A6F2

	LDA <Pad_Input		
	AND #(PAD_START | PAD_SELECT | PAD_B)
	STA <Pad_Input

	LDA <Pad_Holding
	AND #(PAD_START | PAD_SELECT | PAD_B)
	STA <Pad_Holding

PRG008_A6F2:
	LDY <Player_Suit
	BEQ PRG008_A70E	 	; If Player is small, jump to PRG008_A70E

	CPY #PLAYERSUIT_FROG
	BEQ PRG008_A70E	 	; If Player is Frog, jump to PRG008_A70E

	LDA Player_IsHolding
	BNE PRG008_A70E	 	; If Player is holding something, sliding down a slope, or in a Kuribo's shoe, jump to PRG008_A70E 

	LDA <Player_InAir
	BEQ PRG008_A71C	 	; If Player is NOT mid air, jump to PRG008_A71C

	LDA Player_InWater
	BEQ PRG008_A715	 	; If Player is NOT in water, jump to PRG008_A715

PRG008_A70E:
	; Forcefully disable any ducking
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

	BEQ PRG008_A736	 	; Jump (technically always) to PRG008_A736

PRG008_A715:
	LDA Player_IsDucking
	BNE PRG008_A733	 	; If Player is ducking down, jump to PRG008_A733
	BEQ PRG008_A736	 	; Otherwise, jump to PRG008_A736

PRG008_A71C:
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

PRG008_A72B:
	;LDA Player_ForcedSlide
	;BNE PRG008_A736

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	CMP #PAD_DOWN
	BNE PRG008_A736	 	; If Player is not just holding down, jump to PRG008_A736

PRG008_A733:
	STY Player_IsDucking	; Set ducking flag (uses non-zero suit value)

PRG008_A736:
PRG008_A743:
PRG008_A77E:
	LDA Player_InAir
	ORA Player_Shell
	BNE PRG008_A7AD_2

	LDA Level_Tile_Prop_Body
	CMP #TILE_PROP_SOLID_ALL
	BCC PRG008_A7AC	 	; If Player is mid air, in water, or moving in a pipe, jump to PRG008_A7AD

PRG008_A7AB:
	JSR Player_GetHurt

PRG008_A7AC:
	LDA Player_ForcedSlide
	BEQ PRG008_A7AC1

	;LDA <Player_X
	;AND #$0F
	;BNE PRG008_A7AD_2

PRG008_A7AC1:
	LDX #$00
	LDA Level_Tile_Prop_Head
	CMP #TILE_PROP_SOLID_ALL
	BCC PRG008_A7AD

	INX

PRG008_A7AD:
	STX Player_ForcedSlide

PRG008_A7AD_2:

	JSR Player_HandleWater
	JSR Player_HandleClimbing

PRG008_A906:
	JSR Player_ApplyXVelocity	 ; Apply Player's X Velocity
	
	LDA #$00
	STA Player_Direction


Player_FaceOrientation:	
	LDA <Player_FlipBits
	BEQ PRG008_A916

Player_FaceLeft:
	INC Player_Direction

PRG008_A916:

	LDY #$02	 ; Y = 2 (moving right)

	LDA <Player_XVelZ
	BPL PRG008_A925	 ; If Player's X Velocity is rightward, jump to PRG008_A925

	JSR Negate	 ; Negate X Velocity (get absolute value)

	DEY		 ; Y = 1 (moving left)

PRG008_A925:
	BNE PRG008_A928	 ; If Player's X Velocity is not zero (what is intended by this check), jump PRG008_A928

	; Player's velocity is zero
	TAY		 ; And thus, so is Y (not moving left/right)

PRG008_A928:
	STA <Temp_Var3	 ; Temp_Var3 = absolute value of Player's X Velocity

	STY Player_MoveLR	; Set Player_MoveLR appropriately
 
	;LDA <Player_InAir
	;BEQ PRG008_A940	 ; If Player is not mid air, jump to PRG008_A940

	;LDA <Player_YHiZ
	;BPL PRG008_A93D	 ; If Player is on the upper half of the screen, jump to PRG008_A93D

	; Player is mid air, lower half of screen...

	;LDA <Player_YZ
	;BMI PRG008_A93D	 ; If Player is beneath the half point of the lower screen, jump to PRG008_A93D

	;LDA <Player_YVelZ
	;BMI PRG008_A940	 ; If Player is moving upward, jump to PRG008_A940

PRG008_A93D:
	JSR Player_ApplyYVelocity	 ; Apply Player's Y velocity

	LDA <Temp_Var1
	STA <Player_EffYVel
	
	LDA #$00
	STA <Player_CarryXVel
	STA <Player_CarryYVel	

PRG008_A940:
	LDA Player_Vehicle
	BEQ Player_GroundNoVehicle
	JMP Swim_Frog

Player_GroundNoVehicle:
	LDA #$00
	JSR Player_CommonGroundAnims	 ; Perform common ground animation routines

PRG008_A94C:
	LDA <Player_Suit

	LDY Player_InWater
	BEQ PRG008_A956	 ; If Player is not under water, jump to PRG008_A956

	ADD #$07	 ; Otherwise, add 7 (underwater code pointers)

PRG008_A956:
	ASL A		 ; 2-byte pointer
	TAY		 ; -> Y


	; Get proper movement code address for power-up 
	; (ground movement, swimming, Kuribo's shoe)
	LDA PowerUpMovement_JumpTable,Y
	STA <Temp_Var1
	
	LDA PowerUpMovement_JumpTable+1,Y
	STA <Temp_Var2


	JMP [Temp_Var1]	 ; Jump into the movement code!

PowerUpMovement_JumpTable:
	; Ground movement code
	.word GndMov_Small	; 0 - Small
	.word GndMov_Big	; 1 - Big
	.word GndMov_FireHammer	; 2 - Fire
	.word GndMov_Leaf	; 3 - Leaf
	.word GndMov_Frog	; 4 - Frog
	.word GndMov_Tanooki	; 5 - Tanooki
	.word GndMov_FireHammer	; 6 - Hammer

	; Underwater movement code
	.word Swim_SmallBigLeaf	; 0 - Small
	.word Swim_SmallBigLeaf	; 1 - Big
	.word Swim_FireHammer	; 2 - Fire
	.word Swim_SmallBigLeaf	; 3 - Leaf
	.word Swim_Frog		; 4 - Frog
	.word Swim_Tanooki	; 5 - Tanooki
	.word Swim_FireHammer	; 6 - Hammer

GndMov_Small:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	LDA Player_SandSink
	LSR A		 
	BCS PRG008_A9A3	 ; If bit 0 of Player_SandSink was set, jump to PRG008_A9A3 (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_A9A3	 ; If Player_AllowAirJump, jump to PRG008_A9A3 (RTS)

	LDA <Player_InAir
	BEQ PRG008_A9A3	 ; If Player is not mid air, jump to PRG008_A9A3 (RTS)

	; Player is mid-air...

	LDA #PF_JUMPFALLSMALL	; Standard jump/fall frame

	LDY Player_FlyTime
	BEQ PRG008_A9A1	 ; If Player_FlyTime = 0, jump to PRG008_A9A1

	LDA #PF_FASTJUMPFALLSMALL	 ; High speed jump frame

PRG008_A9A1:
	STA <Player_Frame ; Set appropriate frame

PRG008_A9A3:
	RTS		 ; Return

Swim_SmallBigLeaf:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	RTS		 ; Return

GndMov_Big:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	RTS		 ; Return

GndMov_FireHammer:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	JSR Player_ShootAnim ; Do Player shooting animation
	RTS		 ; Return

Swim_FireHammer:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	JSR Player_ShootAnim ; Do Player shooting animation
	RTS		 ; Return

GndMov_Leaf:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_AnimTailWag ; Do Player's tail animations
	JSR Player_TailAttackAnim ; Do Player's tail attack animations
	JSR Fox_BurnMode
	RTS		 ; Return

GndMov_Frog:
	JSR Player_PoisonMode
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	LDA Player_IsHolding
	BNE PRG008_AA23	 ; If Player is holding something, jump to PRG008_AA23

	LDA <Player_InAir
	BEQ PRG008_AA00	 ; If Player is NOT in mid air, jump to PRG008_AA00

	LDA Player_SandSink
	LSR A
	BCS PRG008_AA00	 ; If bit 0 of Player_SandSink is set, jump to PRG008_AA00

	LDA #$00
	STA Player_FrogHopCnt	 ; Player_FrogHopCnt = 0

	LDY #$01	 ; Y = 1
	JMP PRG008_AA1E	 ; Jump to PRG008_AA1E

PRG008_AA00:
	LDA Player_RunMeter
	CMP #$60
	BCC Player_RunMeterNoCap

	LDA #$60
	STA Player_RunMeter

Player_RunMeterNoCap:	
	LDA Player_FrogHopCnt
	BNE PRG008_AA1A	 ; If Player_FrogHopCnt <> 0, jump to PRG008_AA1A

	LDA <Pad_Holding	
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE Player_KeepHopping

	STA <Player_XVelZ
	BEQ PRG008_AA1A	 ; If Player is not pressing left/right, jump to PRG008_AA1A

Player_KeepHopping:
	; Play frog hop sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERFROG
	STA Sound_QPlayer

	LDA #$1f
	STA Player_FrogHopCnt ; Player_FrogHopCnt = $1f

PRG008_AA1A:
	LSR A
	LSR A
	LSR A
	TAY	 ; Y = Player_FrogHopCnt >> 3

PRG008_AA1E:
	LDA Player_FrogHopFrames,Y	; Get frog frame
	STA <Player_Frame		; Store as frame

PRG008_AA23:
	RTS		 ; Return

Frog_SwimSoundMask:
	.byte $03, $07

	; Base frame for the different swimming directions of the frog
Frog_BaseFrame:
	; Down, Up, Left/Right
	.byte PF_FROGSWIM_DOWNBASE, PF_FROGSWIM_UPBASE, PF_FROGSWIM_LRBASE

	; Frame offset to frames above
Frog_FrameOffset:
	.byte $02, $02, $02, $01, $00, $01, $02, $02

	; Base velocity for frog swim right/down, left/up
Frog_Velocity:
	.byte 16, -16

Swim_Frog:
	LDA Player_Vehicle
	BNE Swim_FrogNoPoison

Swim_FrogNoPoison:	
	JSR Player_PoisonMode
	LDX #$ff	 ; X = $FF

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_AA61	 ; If Player is NOT pressing up/down, jump to PRG008_AA61

	; 
	STA <Player_InAir

	LSR A
	LSR A
	LSR A
	TAX		 ; X = 1 if pressing up, else 0

	LDA Frog_Velocity,X	; Get base frog velocity
	BPL PRG008_AA4D	 ; If value >= 0 (if pressing down), jump to PRG008_AA4D

	LDY Player_AboveTop
	BPL PRG008_AA4D	 ; If Player is not off top of screen, jump to PRG008_AA4D

	LDA #$00	 ; A = 0

PRG008_AA4D:
	LDY <Pad_Holding
	BPL PRG008_AA52	 ; If Player is not pressing 'A', jump to PRG008_AA52

	ASL A		 ; Double vertical speed

PRG008_AA52:
	CMP #(PLAYER_FROG_MAXYVEL+1)
	BLT PRG008_AA5C	 

	LDY <Player_InAir
	BNE PRG008_AA5C	 ; If Player is swimming above ground, jump to PRG008_AA5C

	LDA #PLAYER_FROG_MAXYVEL	 ; Cap swim speed

PRG008_AA5C:
	STA <Player_YVelZ ; Set Y Velocity
	JMP PRG008_AA6E	 ; Jump to PRG008_AA6E

PRG008_AA61:
	LDY <Player_YVelZ
	BEQ PRG008_AA6E	 ; If Y Velocity = 0, jump to PRG008_AA6E

	INY		 ; Y++

	LDA <Player_YVelZ
	BMI PRG008_AA6C	 ; If Player_YVelZ < 0, jump to PRG008_AA6C

	DEY
	DEY		 ; Y -= 2

PRG008_AA6C:
	STY <Player_YVelZ ; Update Y Velocity

PRG008_AA6E:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AA84	 ; If Player is not pressing left or right, jump to PRG008_AA84

	; Player is pressing left/right...

	LSR A
	TAY
	LDA Frog_Velocity,Y	; Get base frog velocity

	LDY <Pad_Holding
	BPL PRG008_AA7E	 ; If Player is not pressing 'A', jump to PRG008_AA7E

	ASL A		 ; Double horizontal velocity

PRG008_AA7E:
	STA <Player_XVelZ ; Update X Velocity

	LDX #$02	 ; X = 2
	BNE PRG008_AA9C	 ; Jump (technically always) to PRG008_AA9C

PRG008_AA84:
	LDY <Player_XVelZ
	BEQ PRG008_AA94	 ; If Player is not moving horizontally, jump to PRG008_AA94

	INY		 ; Y++

	LDA <Player_XVelZ
	BMI PRG008_AA8F	 ; If Player_XVelZ < 0, jump to PRG008_AA8F

	DEY
	DEY		 ; Y -= 2

PRG008_AA8F:
	STY <Player_XVelZ ; Update X Velocity
	JMP PRG008_AA9C	 ; Jump to PRG008_AA9C

PRG008_AA94:
	LDA <Player_InAir
	BNE PRG008_AA9C	 ; If Player is swimming above ground, jump to PRG008_AA9C

	LDA #$15	 ; A = $15
	BNE PRG008_AAD2	 ; Jump (technically always) to PRG008_AAD2

PRG008_AA9C:
	TXA		 
	BMI PRG008_AAC8	 ; If X < 0, jump to PRG008_AAC8

	LDA <Counter_1
	LSR A
	LSR A

	LDY #$00	 ; Y = 0

	BIT <Pad_Holding
	BMI PRG008_AAAB	 ; If Player is holding 'A', jump to PRG008_AAAB

	LSR A		 ; Otherwise, reduce velocity adjustment
	INY		 ; Y++

PRG008_AAAB:
	AND #$07
	TAY	
	BNE PRG008_AABF	

	LDA Player_Vehicle
	BNE PRG008_AABF

	LDA <Counter_1
	AND Frog_SwimSoundMask,Y
	BNE PRG008_AABF	 ; If timing is not right for frog swim sound, jump to PRG008_AABF

	; Play swim sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

PRG008_AABF:
	LDA Frog_BaseFrame,X
	ADD Frog_FrameOffset,Y
	BNE PRG008_AAD2

PRG008_AAC8:
	LDY #PF_FROGSWIM_IDLEBASE

	LDA <Counter_1
	AND #$08
	BEQ PRG008_AAD1

	INY

PRG008_AAD1:
	TYA

PRG008_AAD2:
	STA <Player_Frame ; Update Player_Frame
	RTS		 ; Return

GndMov_Tanooki:
	JSR Player_Koopa_Shell  ; Change into/maintain Koopa shell mode
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	RTS		 ; Return

Swim_Tanooki:	
	LDA Player_InWater
	BEQ Dont_Kill_Shell
	
	LDA #$00
	STA Player_Shell

Dont_Kill_Shell:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	RTS		 ; Return

Player_GroundHControl:
	
	LDA Player_Shell
	ORA Player_FireDash
	BEQ Player_GroundHControl1
	RTS

Player_GroundHControl1:
	LDY #Pad_Input

	BIT <Pad_Holding
	BVC PRG008_AB83	; If Player is NOT holding 'B', jump to PRG008_AB83

	; Player is holding B...

	LDA <Player_InAir
	BNE PRG008_AB78	 ; If Player is mid air or sliding, jump to PRG008_AB78

	LDA <Temp_Var3
	CMP #PLAYER_TOPRUNSPEED
	BMI PRG008_AB78	 ; If Player's X Velocity magnitude is less than PLAYER_TOPRUNSPEED, jump to PRG008_AB78

	; Player is going fast enough while holding B on the ground; flag running!
	INC Player_RunFlag ; Player_RunFlag = 1

PRG008_AB78:
	; Start with top run speed
	LDY #PLAYER_TOPRUNSPEED ; Y = PLAYER_TOPRUNSPEED

	LDA Player_RunMeter
	CMP #$7f
	BNE PRG008_AB83	 ; If Player has not hit full power, jump to PRG008_AB83

	; Otherwise, top power speed
	LDY #PLAYER_TOPPOWERSPEED	 ; Y = PLAYER_TOPPOWERSPEED

PRG008_AB83:
	STY <Temp_Var14	 ; Store top speed -> Temp_Var14

	LDY Player_Slippery
	BEQ PRG008_AB98	 ; If ground is not slippery at all, jump to PRG008_AB98

	INC Player_WalkAnimTicks ; Player_WalkAnimTicks++

	DEY
	TYA
	ASL A
	ASL A
	ASL A
	ADD #$40
	TAY		 ; Y = ((selected top speed - 1) << 3) + $40 ??
	BNE PRG008_AB9E	 ; And as long as that's not zero, jump to PRG008_AB9E

PRG008_AB98:
	LDA <Player_Suit
	ASL A
	ASL A
	ASL A
	TAY		 ; Y = Player_Suit << 3

PRG008_AB9E:
	BIT <Pad_Holding
	BVC PRG008_ABA6	 ; If Player is NOT pressing 'B', jump to PRG008_ABA6

	; Otherwise...
	INY
	INY
	INY
	INY	; Y += 4 (offset 4 inside Player_XAccel* tables)

PRG008_ABA6:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_ABB8	 ; If Player is pressing LEFT or RIGHT, jump to PRG008_ABB8

	; Player not pressing LEFT/RIGHT...

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01 (RTS)

	LDA <Player_XVelZ
	BEQ PRG008_AC01	 ; If Player is not moving horizontally, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABD3	 ; If Player is moving leftward, jump to PRG008_ABD3
	BPL PRG008_ABEB	 ; If Player is moving rightward, jump to PRG008_ABEB

PRG008_ABB8:

	; Player is pressing left/right...

	INY
	INY		 ; Y += 2 (offset 2 within Player_XAccel* tables, the "skid" rate)

	AND Player_MoveLR
	BNE PRG008_ABCD	  ; If Player suddenly reversed direction, jump to PRG008_ABCD

	DEY		 ; Y-- (back one offset, the "normal" rate)

	LDA <Temp_Var3	 
	CMP <Temp_Var14	 
	BEQ PRG008_AC01	 ; If Player's current X velocity magnitude is the same as the selected top speed, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABCD	 ; If it's less, then jump to PRG008_AC01

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01

	DEY		 ; Y-- (back one offset, the "friction" stopping rate)

PRG008_ABCD:


	; At this point, 'Y' contains the current power-up in bits 7-3, 
	; bit 2 is set if Player pressed B, bit 1 is set if the above
	; block was jumped, otherwise bit 0 is set if the X velocity is
	; less than the specified maximum, clear if over the max


	LDA <Pad_Holding
	AND #PAD_RIGHT
	BNE PRG008_ABEB	 ; If Player is holding RIGHT, jump to PRG008_ABEB (moving rightward code)

PRG008_ABD3:

	; Player moving leftward

	LDA #$00	 
	SUB Player_XAccelPseudoFrac,Y ; Negate value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get Player_XAccelMain[Y]
	EOR #$ff	 ; Negate it (sort of)
	STA <Temp_Var2	 ; -> Temp_Var2

	LDA <Temp_Var1
	BNE PRG008_ABF5	 ; If Temp_Var1 <> 0, jump to PRG008_ABF5

	INC <Temp_Var2	 ; Otherwise, Temp_Var2++
	JMP PRG008_ABF5	 ; Jump to PRG008_ABF5

PRG008_ABEB:

	; Player moving rightward

	LDA Player_XAccelPseudoFrac,Y ; Get value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get value from Player_XAccelMain[Y]
	STA <Temp_Var2	  ; -> Temp_Var2

PRG008_ABF5: 
	LDA <Temp_Var1
	ADD RandomN	; actual value not used, looking for a semi-random carry

	LDA <Player_XVelZ
	ADC <Temp_Var2
	STA <Player_XVelZ	; Player_XVelZ += Temp_Var2 (and sometimes carry)

PRG008_AC01:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_UnderwaterHControl
;
; Routine to control based on Player's left/right pad input underwater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_UnderwaterHControl:
	LDY #(Player_XAccelMain_UW - Player_XAccelMain)	; Y = index to appropriate under water values

	LDA #%00001000
	STA <Temp_Var14	 ; Temp_Var14 = pretend like Player is definitely hitting UP

	LDA <Player_InAir
	BEQ PRG008_AC14	 ; If Player is not in the air, jump to PRG008_AC14

	LDA #Pad_Input
	STA <Temp_Var14	 ; Temp_Var14 = actual Pad_Input (as compared to what happened above)

	INY
	INY
	INY
	INY		 ; Y += 4 (offset into Player_XAccel* tables)
 
PRG008_AC14:
	LDA <Player_InAir
	PHA		 ; Save Player_InAir

	LDA #$00
	STA <Player_InAir ; Player_InAir= 0

	JSR PRG008_ABA6	 ; Reuses part of normal movement code

	PLA		 
	STA <Player_InAir ; Restore Player_InAir

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_JumpFlyFlutter
;
; Controls the acts of jumping, flying, and fluttering (tail wagging)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Player_JumpFlyFlutter:
	LDA #$00
	STA <Player_Jumped

	LDA Wall_Jump_Enabled
	BNE PRG008_AC30

	LDA Player_AllowAirJump
	BEQ PRG008_AC30	 ; If Player_AllowAirJump = 0, jump to PRG008_AC30

	DEC Player_AllowAirJump ; Player_AllowAirJump--

PRG008_AC30:

	LDA Player_ForcedSlide
	BNE PRG008_AC31

	LDA <Pad_Input
	AND #PAD_A
	STA <Temp_Var1	 ; Temp_Var1 = $80 if Player is pressing 'A', otherwise 0
	BNE Jump_Over_PRG008_AC9E

PRG008_AC31:
	JMP PRG008_AC9E	 ;

Jump_Over_PRG008_AC9E:
	LDA Wall_Jump_Enabled
	BNE PRG008_AC41

	LDA Player_AllowAirJump
	BNE DIRECT_TO_JUMP	 ; If Player_AllowAirJump <> 0, jump to PRG008_AC41

	LDA <Player_InAir
	BEQ DIRECT_TO_JUMP
	JMP PRG008_AC9E	 ; If Player is mid air, jump to PRG008_AC9E

PRG008_AC41:

	JSR Do_Wall_Jump

DIRECT_TO_JUMP:

	LDA <Player_Suit
	BNE STORE_BIG_JUMP

	LDA #SND_SMALLJUMP
	BNE STORE_SMALL_JUMP

STORE_BIG_JUMP:
	LDA Sound_QPlayer

STORE_SMALL_JUMP:
	ORA #SND_PLAYERJUMP	 
	STA Sound_QPlayer

	LDA Player_StarInv
	BEQ PRG008_AC6C	 ; If Player is not invincible by star, jump to PRG008_AC6C

	LDA Player_RunMeter
	CMP #$7f
	BEQ PRG008_AC6C	 ; If Player is at max power, jump to PRG008_AC6C

	LDA Player_IsHolding
	BNE PRG008_AC6C	 ; If Player is holding something, jump to PRG008_AC6C

	LDA Player_EffectiveSuit
	BEQ PRG008_AC6C

	CMP #$03
	BEQ PRG008_AC6C

	CMP #$08
	BEQ PRG008_AC6C

	; Otherwise, mark as mid air AND backflipping
	STA <Player_InAir

	LDA #$00
	STA Player_AllowAirJump	 ; Cut off Player_AllowAirJump

PRG008_AC6C:

	; Get absolute value of Player's X velocity
	LDA <Player_XVelZ
	BPL PRG008_AC73
	JSR Negate

PRG008_AC73:

	LSR A
	LSR A
	LSR A
	LSR A
	TAX	 ; X = Magnitude of Player's X Velocity >> 4 (the "whole" part)

	LDA Player_RootJumpVel	 	; Get initial jump velocity
	SUB Player_SpeedJumpInc,X	; Subtract a tiny bit of boost at certain X Velocity speed levels
	
	LDY Wall_Jump_Enabled
	BEQ Normal_Jump

	LDA #$D0
	STA Player_Flip

Normal_Jump:
	STA <Temp_Var1

	LDA Player_Equip
	CMP #BADGE_JUMP
	BNE Jump_Normal

	LDA <Temp_Var1
	SEC
	SBC #$06
	STA <Temp_Var1

Jump_Normal:

	LDA Player_EffectiveSuit
	CMP #MARIO_FROG
	BNE Jump_NotFrog

	LDA <Temp_Var1
	SUB #$08
	STA <Temp_Var1

Jump_NotFrog:
	LDA <Temp_Var1
	STA <Player_YVelZ		; -> Y velocity

	LDA #$01
	STA <Player_InAir ; Flag Player as mid air
	STA <Player_Jumped

	LDA #$00	
	STA Player_WagCount	 ; Player_WagCount = 0
	STA Player_AllowAirJump	 ; Player_AllowAirJump = 0

	LDA Player_RunMeter
	CMP #$7f
	BNE PRG008_AC9E		; If Player is not at max power, jump to PRG008_AC9E

	LDA Player_FlyTime
	BNE PRG008_AC9E	 	; If Player still has flight time left, jump to PRG008_AC9E

	LDA #$80
	STA Player_FlyTime	; Otherwise, Player_FlyTime = $80


PRG008_AC9E:
	LDA <Player_InAir
	BNE PRG008_ACB3		; If Player is mid air, jump to PRG008_ACB3

	LDY <Player_Suit		
	CPY #$03	
	BEQ PRG008_AD1A	 	; If power up has flight ability, jump to PRG008_AD1A

	LDA #$00
	STA Player_FlyTime	; Otherwise, Player_FlyTime = 0 :(
	JMP PRG008_AD1A	 ; Jump to PRG008_AD1A

PRG008_ACB3:

	; Player is mid air...

	LDY #$05	 ; Y = 5

	LDA <Player_YVelZ
	CMP #-$20
	BGS PRG008_ACC8	 ; If Player's Y velocity >= -$20, jump to PRG008_ACC8

	LDA <Pad_Holding
	BPL PRG008_ACC8	 ; If Player is NOT pressing 'A', jump to PRG008_ACC8

	LDY #$01	 ; Y = 1
	BNE PRG008_ACCD	 ; Jump (technically always) to PRG008_ACCD

PRG008_ACC8:

PRG008_ACCD:
	TYA	
	ADD <Player_YVelZ

	LDX Player_FireDash
	BNE Skip_YVel
	STA <Player_YVelZ ; Player_YVelZ += Y

Skip_YVel:
	LDA <Player_WagCount
	BEQ PRG008_ACD9	 ; If Player_WagCount = 0, jump to PRG008_ACD9

	DEC <Player_WagCount ; Otherwise, $F0--

PRG008_ACD9:

	LDA Player_EffectiveSuit
	CMP #$03
	BNE PRG008_ACEF	 	; If this power up does not have flight, jump to PRG008_ACEF

	LDY <Temp_Var1		; Y = $80 if Player was pressing 'A' when this all began
	BEQ PRG008_ACEF	 	; And if he wasn't, jump to PRG008_ACEF

	LDA #$10	 
	STA <Player_WagCount 	; Otherwise, Player_WagCount = $10

PRG008_ACEF:
	LDA <Player_WagCount
	BEQ PRG008_AD1A	 	; If Player has not wag count left, jump to PRG008_AD1A

	; RACCOON / TANOOKI TAIL WAG LOGIC

	LDA <Player_YVelZ
	CMP #PLAYER_FLY_YVEL
	BLS PRG008_AD1A	 ; If Player's Y velocity is < PLAYER_FLY_YVEL, jump to PRG008_AD1A

	LDY #PLAYER_FLY_YVEL	 ; Y = PLAYER_FLY_YVEL

	LDA Player_FlyTime
	BEQ PRG008_AD0E	 ; If Player is not flying, jump to PRG008_AD0E

	CMP #$0f
	BGE PRG008_AD18	 ; If Player has a great amount of flight time left, jump to PRG008_AD18

	; Player has a small amount of flight time left

	LDY #$F0
	AND #$08	 
	BNE PRG008_AD18	 ; Every 8 ticks, jump to PRG008_AD18

	LDY #$00	 ; Y = 0 (at apex of flight, Player no longer rises)
	BEQ PRG008_AD18	 ; Jump (technically always) to PRG008_AD18

PRG008_AD0E:
	LDA <Player_YVelZ
	BMI PRG008_AD1A	 ; If Player's Y velocity < 0 (moving upward), jump to PRG008_AD1A

	CMP #PLAYER_TAILWAG_YVEL
	BLT PRG008_AD1A	 ; If Player's Y velocity < PLAYER_TAILWAG_YVEL, jump to PRG008_AD1A

	LDY #PLAYER_TAILWAG_YVEL ; Y = PLAYER_TAILWAG_YVEL

PRG008_AD18:
	STY <Player_YVelZ ; Set appropriate Y velocity

PRG008_AD1A:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimV
;
; Controls the acts of swimming (the up/down part only), not
; including the Frog Suit style (which is totally different)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SwimV:
	
	LDA Player_Frozen
	BNE PRG008_AD4C

	LDA <Pad_Input		 
	BPL PRG008_AD4C	 ; If Player is NOT pressing 'A', jump to PRG008_AD4C

	; Player swimming sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	LDY <Player_InAir
	BNE PRG008_AD45	 ; If Player is swimming above ground, jump to PRG008_AD4A

	LDA #PLAYER_SWIMSTART_YVEL
	STA <Player_InAir ; "mid air" underwater
	BNE PRG008_AD4A	 ; Jump (technically always) to PRG008_AD4A

PRG008_AD45:

	; Swimming speed the rest of the time

	LDA <Player_YVelZ
	SUB #PLAYER_SWIM_YVEL	 ; A = Player_YVelZ - PLAYER_SWIM_YVEL

PRG008_AD4A:
	STA <Player_YVelZ ; Set Player_YVelZ appropriately

PRG008_AD4C:
	LDA <Player_InAir
	BEQ PRG008_AD7E	 ; If Player is on the ground, jump to PRG008_AD7E

	LDA <Player_YVelZ
	BMI PRG008_AD5A	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD5A

	LDA <Counter_1
	AND #$02
	BNE PRG008_AD5C	 ; Every 4 ticks, jump to PRG008_AD5C

PRG008_AD5A:

	; Player's sink rate...

	INC <Player_YVelZ ; Player_YVel++

PRG008_AD5C:
	LDY #PLAYER_SWIM_YVEL	 ; Y = PLAYER_SWIM_YVEL

	LDA <Player_YVelZ
	BPL PRG008_AD75	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD75

	LDY #PLAYER_SWIMSTART_YVEL	 ; Y = PLAYER_SWIMSTART_YVEL

PRG008_AD75:
	ADD #PLAYER_SWIM_YVEL
	CMP #PLAYER_MAXSPEED
	BLT PRG008_AD7E	 ; If result is less than Player's max speed, jump to PRG008_AD7E

	STY <Player_YVelZ ; Otherwise, update it

PRG008_AD7E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimAnim
;
; Animates Player for swimming
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SwimAnim:
	LDA <Player_InAir
	BEQ PRG008_ADBC	 ; If Player is NOT swimming above ground, jump to PRG008_ADBC (RTS)

	LDA <Pad_Input
	BPL PRG008_AD9A	 ; If Player is NOT pressing 'A', jump to PRG008_AD9A

	LDA Player_SwimCnt
	BNE PRG008_AD97	 ; If Player_SwimCnt <> 0, jump to PRG008_AD97

PRG008_AD8C:
	LDA #$00
	STA Player_SwimCnt	 ; Player_SwimCnt = 0
	STA Counter_ByPlayerSpd	 ; Counter_ByPlayerSpd = 0
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

PRG008_AD97:
	INC Player_SwimCnt	 ; Player_WalkAnimTicks++

PRG008_AD9A:
	LDA Player_SwimCnt
	BNE PRG008_ADBD	 ; If Player_SwimCnt <> 0, jump to PRG008_ADBD

	LDA <Player_XVelZ
	BNE PRG008_ADAD	 ; If Player is moving left or right, jump to PRG008_ADAD

	; Player NOT moving left/right

	LDA <Counter_1
	AND #$30
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	STA <Player_WalkFrame	 ; Choose a "walk" (swim) relative frame based on game counter

PRG008_ADAD:
	LDY <Player_WalkFrame

	LDA <Player_Suit
	BNE PRG008_ADB7	 ; If Player is not small, jump to PRG008_ADB7

	INY
	INY
	INY
	INY	; Otherwise, use Player_WalkFrame + 4

PRG008_ADB7:
	LDA Player_SwimIdleFrames,Y	 ; Get appropriate swim frame
	STA <Player_Frame	 ; Set it!

PRG008_ADBC:
	RTS		 ; Return


PRG008_ADBD:
	LDA Counter_ByPlayerSpd
	CMP #$06
	BLT PRG008_ADCB	 ; If Counter_ByPlayerSpd < 6, jump to PRG008_ADCB

	DEC Player_SwimCnt	; Player_SwimCnt--
	BNE PRG008_AD8C	 	; If Player_SwimCnt > 0, jump to PRG008_AD8C

	LDA #$05	 ; A = 5

PRG008_ADCB:
	LDY <Player_Suit ; Y = Player_Suit
	BNE PRG008_ADD2	 ; If Player is not small, jump to PRG008_ADD2

	ADD #$06	 ; For small, A = 11

PRG008_ADD2:
	TAY		 ; Y = 5 or 11

	; Set Player swimming frame
	LDA Player_SwimActiveFrames,Y
	STA <Player_Frame

	RTS		 ; Return

PowerUp_Ability:
	;     Small, Big, Fire, Leaf, Frog, Tanooki, Hammer
	.byte $00,   $00, $00,  $01,  $02,  $00,     $00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_CommonGroundAnims
;
; Performs "common" animations for walking around on the ground
; (walking/standing, ducking, sliding) and, for some reason, also
; contains the debug mode power-up cycle logic (SELECT to cycle
; through all available power-ups and toggle Kuribo's shoe)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_CommonGroundAnims:

	; Get absolute value of Player_XVelZ
	LDA <Player_XVelZ
	BPL PRG008_ADE0
	JSR Negate

PRG008_ADE0:

	LSR A
	LSR A
	LSR A
	TAY		 ; Y = Absolute value of Player's X Velocity shifted right by 3 (1 bit left of "whole" part)

	INC Player_WalkAnimTicks
	LDA Player_WalkAnimTicks
	CMP Player_WalkAnimTickMax,Y
	BMI PRG008_AE03	 ; If we haven't reached the rollover point in the walking animation ticks, jump to PRG008_AE03

	LDA #$00
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

	INC <Player_WalkFrame	 ; Next Player frame
	INC Counter_ByPlayerSpd	 ; Increment Player-speed-based counter

	; Cap Player_WalkFrame at 0-3 (why not just AND it?)
	LDA <Player_WalkFrame
	CMP #$04
	BMI PRG008_AE03

	LDA #$00
	STA <Player_WalkFrame

PRG008_AE03:

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_AE11	 ; If Player is pressing left or right, jump to PRG008_AE11

	; Player NOT pressing left/right

	LDA <Player_XVelZ
	BNE PRG008_AE11	 ; If Player_XVelZ <> 0, jump to PRG008_AE11

	LDA #$02
	STA <Player_WalkFrame	 ; Otherwise, force Player_WalkFrame to 2 (standing still)

PRG008_AE11:
	LDA Player_TailAttack
	BNE PRG008_AE26	 ; If Player is performing tail attack, jump to PRG008_AE26

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AE26	 ; If Player is NOT pressing left or right, jump to PRG008_AE26

	; Player is pressing left/right

	LDY #$00	; No flip
	STY Player_LastDirection

	AND #%00000010
	BNE PRG008_AE24	 ; If Player is pressing left, jump to PRG008_AE24

Player_ForceFaceRight:
	LDY #SPR_HFLIP	; Horizontal flip
	INC Player_LastDirection

PRG008_AE24:
	STY <Player_FlipBits	; Set appropriate flip

PRG008_AE26:
	LDA <Player_Suit
	ASL A
	ASL A
	ORA <Player_WalkFrame	 ; Take the walk frame and push the current power-up to bit 2
	TAY		 ; -> Y
	LDA Player_WalkFramesByPUp,Y	 ; Get appropriate sprite frame
	STA <Player_Frame		 ; -> Player_Frame

	LDA Player_InWater
	BNE PRG008_AE90	 ; If Player is in water, jump to PRG008_AE90

	; Player not in water...

	LDA <Player_XVelZ
	ADD #$01
	CMP #$03
	BLT PRG008_AE90	 ; If (Player_XVelZ + 1) < 3, jump to PRG008_AE90

	LDA Player_MoveLR
	AND <Pad_Holding
	BEQ PRG008_AE90	 ; If Player is pressing the opposite direction from his movement, jump to PRG008_AE90

	LDY <Player_Suit
	BEQ PRG008_AE7F	 ; If Player is small, jump to PRG008_AE7F

	LDY #$01	 ; Otherwise, Y = 1

PRG008_AE7F:
	LDA <Player_InAir
	BNE PRG008_AE90	 ; If Player is mid air, jump to PRG008_AE90

	; Play "skid" sound
	LDA Sound_QLevel2
	ORA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA Player_SkidFrame,Y
	STA <Player_Frame ; Set skid frame

PRG008_AE90:
	LDA Player_IsDucking
	BEQ PRG008_AEA2	 ; If Player is not ducking

	LDY <Player_Suit
	LDA PowerUp_Ability,Y	; Get "ability" bits for suit
	AND #$01	 	; Bit 0 specifies that the power up can do raccoon style flying and fluttering
	TAY		 
	LDA Player_DuckFrame,Y	; Get appropriate duck frame
	STA <Player_Frame	; Set frame!

PRG008_AEA2:

PRG008_AEC0:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SetSpecialFrames
;
; Set one of the "special" frames, i.e. "spread eagle" running,
; somersaulting, holding, pipe facing, kicking, twirling, and
; even the forced-to-standing frame of "vibrationally disabled"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SetSpecialFrames:

	; Get absolute value of Player_XVelZ
	LDA <Player_XVelZ
	BPL PRG008_AECA
	JSR Negate

PRG008_AECA:

	CMP #$37
	BLT PRG008_AEF0	 ; If magnitude of Player's horizontal velocity is < $37, jump to PRG008_AEF0

	LDA Player_FlyTime
	BNE PRG008_AEF0	 ; If Player already has flight time, jump to PRG008_AEF0

	LDA Player_IsDucking
	ORA Player_IsClimbing
	BNE PRG008_AEF0	 ; If Player is ducking, in a Kuribo's shoe, climbing a vine, or sliding, jump to PRG008_AEF0!!

	LDY <Player_WalkFrame	; Y = Player_WalkFrame (0 - 3)

	LDA <Player_Suit
	BNE PRG008_AEEB	 ; If Player is NOT small, jump to PRG008_AEEB

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG008_AEEB:
	LDA Player_SpreadEagleFrames,Y	 ; Get cooresponding spread-eagle frame
	STA <Player_Frame		 ; Store that!

PRG008_AEF0:
	LDA Player_Flip
	BEQ PRG008_AF0F	 ; If Player is NOT somersaulting, jump to PRG008_AF0F

	LDA <Counter_1
	LSR A		; A = Counter_1 >> 1
	PHA		 ; Save it

	AND #$07	 ; Cap 0 - 7
	TAY		 ; -> 'Y'

	LDA Player_SomersaultFlipBits,Y	 ; Get proper somersault flip bits

	LDY <Player_XVelZ
	BPL PRG008_AF05	 ; If Player_XVelZ >= 0, jump to PRG008_AF05

	EOR #SPR_HFLIP	 ; Otherwise, horizontally flip!

PRG008_AF05:
	STA <Player_FlipBits		 ; Update Player flip bits
	PLA		 ; Restore Counter_1 >> 1

	AND #$03	 ; Cap 0 - 3
	ADD #PF_SOMERSAULT_BASE	 ; Add base somersault frame
	STA <Player_Frame ; Update Player_Frame!

PRG008_AF0F:
	LDA Player_IsHolding
	BEQ PRG008_AF2F	 ; If Player is NOT holding something, jump to PRG008_AF2F

	LDY <Player_WalkFrame	 ; Y = PRG008_AF2F

	LDA Player_InAir_OLD
	BEQ PRG008_AF22	 ; If Player was NOT in air, jump to PRG008_AF22

	LDY #$00	; Otherwise, Y = 0

	LDA <Player_Suit
	BNE PRG008_AF22	
	INY		 ; ... unless small, in which case, Y = 1

PRG008_AF22:
	LDA <Player_Suit
	BNE PRG008_AF2A	 ; If Player is NOT small, jump to PRG008_AF2A

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG008_AF2A:
	LDA Player_HoldingFrames,Y ; Get appropriate "holding" frame
	STA <Player_Frame	 ; Update Player frame!

PRG008_AF2F:
	LDA Player_PipeFace
	BNE PRG008_AF45	 ; If Player is facing forward, jump to PRG008_AF45

	LDA Player_IsHolding
	BEQ PRG008_AF52	 ; If Player is NOT holding something, jump to PRG008_AF52

	LDA <Player_FlipBits
	CMP Player_FlipBits_OLD
	BEQ PRG008_AF52	 ; If Player's flip bits haven't changed, jump to PRG008_AF52

	LDA #$07
	STA Player_PipeFace ; Otherwise, Player_PipeFace = 7 (Player briefly faces forward while turning around holding something)

PRG008_AF45:
	DEC Player_PipeFace	 ; Player_PipeFace--

	LDA #PF_INPIPE_BIG	; Face-forward frame when Player is NOT small

	LDY <Player_Suit
	BNE PRG008_AF50	 ; If Player is NOT small, jump to PRG008_AF50

	LDA #PF_INPIPE_SMALL	 ; Face-forward frame when Player is small

PRG008_AF50:
	STA <Player_Frame ; Update Player frame !

PRG008_AF52:
	LDA Player_Kick
	BEQ PRG008_AF69	 ; If Player is NOT kicking something, jump to PRG008_AF69

	LDA #$00
	STA Player_TailAttack	 ; Player_TailAttack = 0 (stop tail attack effect if active!)

	LDY #PF_KICK_SMALL	 ; Kick frame when small

	LDA <Player_Suit
	BEQ PRG008_AF64	 ; If Player is small, jump to PRG008_AF64

	LDY #PF_KICK_BIG	 ; Kick frame when NOT small

PRG008_AF64:
	STY <Player_Frame ; Update Player frame!

	DEC Player_Kick	 ; PRG008_AF64--

PRG008_AF69:
PRG008_AFA1:
	LDA Player_VibeDisable
	BEQ PRG008_AFAD	 ; If Player is not "vibrationally disabled", jump to PRG008_AFAD

	LDY <Player_Suit
	LDA Player_VibeDisableFrame,Y	 ; Get appropriate "vibrationally disabled" frame (typ. standing)
	STA <Player_Frame	; Update Player frame!

PRG008_AFAD:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Koopa_Shell
;
; Change into or maintain Tanooki statue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Koopa_Shell:
	LDA Player_EffectiveSuit
	CMP #$05
	BNE Inc_PowerRTS

	LDA Player_Shell
	BEQ Try_Shell

	LDA <Player_InAir
	BNE Inc_PowerRTS

	LDA <Pad_Holding
	AND #(PAD_DOWN)
	BEQ Kill_Shell

	LDA Player_Power
	BEQ Kill_Shell

	LDA #$FC
	STA Power_Change
	RTS

Try_Shell:
	LDA <Player_XVelZ
	CMP #$1C
	BCC Kill_Shell

	CMP #$E4
	BCS Kill_Shell

	LDA <Player_InAir
	BNE Inc_PowerRTS

	LDA <Pad_Holding
	AND #(PAD_DOWN)
	BEQ Kill_Shell

	LDA Player_Power
	CMP #$50
	BCC Kill_Shell
	
	LDA Player_IsHolding
	BNE Kill_Shell
	
	LDA #$01
	STA Player_Shell
	RTS

Kill_Shell:
	LDA #$00

NoShellRTS:
	STA Player_Shell

Inc_Power:
	LDA Player_Power
	CMP #$50
	BCS Inc_PowerRTS

	LDA #$08
	STA Power_Change

Inc_PowerRTS:
	RTS

	; Player's climb "animation", which is really just flipping the sprite
Player_DoClimbAnim:
	LDA Player_IsClimbing
	BEQ PRG008_B035	 ; If Player is NOT climbing, jump to PRG008_B035 (RTS)

	LDY <Player_Suit
	LDA Player_ClimbFrame,Y	 ; Get appropriate climbing frame
	STA <Player_Frame	 ; Store into Player_Frame

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN | PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_B035	 ; If Player is NOT pressing UP or DOWN, jump to PRG008_B035

	; Every 8 ticks, flip Player horizontally
	LDA <Counter_1
	AND #$08
	ASL A	
	ASL A	
	ASL A	
	STA <Player_FlipBits

PRG008_B035:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_AnimTailWag
;
; Animates the Player's tail wag for flying and fluttering
; Also plays the "wag" sound as appropriate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_AnimTailWag:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B09F	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B09F (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_B09F	 ; If Player_AllowAirJump, jump to PRG008_B09F (RTS)

	LDA <Player_InAir
	BEQ PRG008_B09F	 ; If Player is NOT mid air, jump to PRG008_B09F (RTS)

	LDA Player_IsDucking
	BNE PRG008_B082	 ; If Player is ducking, jump to PRG008_B082

	LDA Special_Suit_Flag		; Doesn't apply to  fire fox
	BNE PRG008_B062
	LDA <Pad_Input
	BPL PRG008_B062	 ; If Player is NOT pressing A, jump to PRG008_B062


	; The following replaces what would be a queued jump sound with the "wag" sound
	LDA Sound_QPlayer
	CMP #SND_PLAYERJUMP
	BEQ PRG008_B05D	 ; If jump sound is NOT queued, jump to PRG008_B05D

	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B05D:
	LDA #10
	STA Player_TailCount	 ; Player_TailCount = $10

PRG008_B062:
	LDA Player_TailCount
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = Player_TailCount >> 2

	LDA #$00	; A = 0 (flying!)

	LDY Player_FlyTime
	BNE PRG008_B072	 ; If flying, jump to PRG008_B072

	LDA #$06	 ; A = 6 (fluttering/falling)

PRG008_B072:
	LDY <Player_YVelZ
	BMI PRG008_B079	 ; If Player Y velocity < 0, jump to PRG008_B079

	ADD #$03	 ; Otherwise, add 3 (apex, when just running out of power, flying steady)

PRG008_B079:
	ADD <Temp_Var1	 ; Add specific frame offset
	TAY		 ; A -> Y
	LDA Player_TailWagFlyFrames,Y	 ; Get correct frame
	STA <Player_Frame ; And set it!

PRG008_B082:
	LDA Player_FlyTime
	ORA Player_WagCount
	BEQ PRG008_B09F	 ; If flying or fluttering, jump to PRG008_B09F (RTS)

	LDY #-1		 ; Y = -1
	LDA <Player_XVelZ
	BPL PRG008_B095	 ; If Player_XVelZ >= 0, jump to PRG008_B095

	LDY #1		 ; Y = 1
	JSR Negate	 ; Negate Player_XVelZ (get absolute value)

PRG008_B095:

	; Y = -1 and Player_XVelZ >= 0
	;    OR
	; Y = 1 and Player_XVelZ < 0
	;    (but magnitude is in 'A' either way)

	CMP #PLAYER_TOPWALKSPEED	
	BLS PRG008_B09F	 ; If X Velocity magnitude is < PLAYER_TOPWALKSPEED, jump to PRG008_B09F (RTS)

	; Otherwise add 'Y', which gives a slow acceleration up to that speed when in air as raccoon
	TYA
	ADD <Player_XVelZ
	STA <Player_XVelZ

PRG008_B09F:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SoarJumpFallFrame
;
; Sets Player's frame appropriate for "soaring" (high speed jump),
; standard jumping, or falling...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SoarJumpFallFrame:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B0C5	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B0C5

	LDA Player_AllowAirJump
	BNE PRG008_B0C5	 ; If Player_AllowAirJump, jump to PRG008_B0C5 (RTS)

	LDA <Player_InAir
	BEQ PRG008_B0C5	 ; If Player is mid air, jump to PRG008_B0C5 (RTS)

	LDA Player_IsDucking
	BNE PRG008_B0C5	 ; If Player is ducking, jump to PRG008_B0C5 (RTS)

	LDA #PF_FASTJUMPBIG	 ; High speed "soar" jump frame

	LDY Player_FlyTime
	BNE PRG008_B0C3	 ; If Player has jumped at high speed, jump to PRG008_B0C3

	LDA #PF_JUMPBIG	 ; Normal "fist pump" jump frame

	LDY <Player_YVelZ
	BMI PRG008_B0C3	 ; If Player is moving upward, jump to PRG008_B0C3

	LDA #PF_FALLBIG	 ; Standard "fall" frame

PRG008_B0C3:
	STA <Player_Frame ; Set appropriate frame

PRG008_B0C5:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttackAnim
;
; Animate tail attack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttackAnim:
	LDA Player_ForcedSlide
	BNE PRG008_B109

	LDA <Pad_Holding
	AND #PAD_DOWN
	BNE PRG008_B109	 ; If Player is holding down, jump to PRG008_B109

	BIT <Pad_Input
	BVC PRG008_B0E2	 ; If Player is NOT pressing 'B', jump to PRG008_B0E2

	LDA Player_TailAttack
	BNE PRG008_B0E2	 ; If Player is performing tail attack, jump to PRG008_B0E2

	LDA Player_Direction
	STA Player_TailDirection

	LDA #$12
	STA Player_TailAttack	 ; Player_TailAttack = $12

	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B0E2:
	LDA Player_TailAttack
	BEQ PRG008_B109	 ; If Player is not performing tail attack, jump to PRG008_B109

	LSR A
	LSR A
	TAY		 ; Y = Player_TailAttack >> 2

	LDA <Player_InAir
	BEQ PRG008_B0F3	 ; If Player is NOT in mid air, jump to PRG008_B0F3

	INY
	INY
	INY
	INY
	INY		 ; Y += 5 (use mid air tail attack frames)

PRG008_B0F3:
	LDA Player_TailAttackFrames,Y	 ; Get appropriate tail attack frame
	STA <Player_Frame		 ; Store it


	; Flips player at particular times

	LDA Player_TailAttack
	CMP #$0B
	BEQ PRG008_B103

	CMP #$03
	BNE PRG008_B109

PRG008_B103:
	LDA <Player_FlipBits
	EOR #SPR_HFLIP
	STA <Player_FlipBits

PRG008_B109:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ShootAnim
;
; Animate shooting a fireball / hammer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ShootAnim:
	LDA Player_FireCount
	BEQ PRG008_B11E	 ; If Player has not just shot something, jump to PRG008_B11E

	LSR A
	LSR A		; A = Player_FireCount >> 2

	LDY <Player_InAir
	BEQ PRG008_B118	 ; If Player is mid air, jump to PRG008_B118

	ADD #(Player_FireInAir - Player_FireOnGround)	 ; Otherwise, offset to "on ground" frames

PRG008_B118:
	TAY		 ; A -> Y
	LDA Player_FireOnGround,Y ; Get appropriate frame
	STA <Player_Frame	 ; Set it!

PRG008_B11E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoScrolling
;
; Scrolls screen horizontally and vertically (including Raster
; Effects) as appropriate for Player's position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoScrolling:
	LDA Level_JctCtl
	BEQ PRG008_B127

PRG008_B126:
	RTS

PRG008_B127:
    LDA Level_HorzScrollLock
    BEQ PRG008_B12F     ; If we're NOT in a Big Question Block area, jump to PRG008_B12F

    JMP PRG008_B1CE     ; Otherwise, jump to PRG008_B1CE

PRG008_B12F:

	LDY Level_AScrlConfig
	BEQ PRG008_B150	 ; If no raster effects, jump to PRG008_B150
	BMI PRG008_B150	 ; If ASCONFIG_HDISABLE is set, jump to PRG008_B150

	; Sets horizontal scroll to auto scroll alternate values

	LDA Level_AScrlPosH
	PHA		 ; Save Level_AScrlPosH

	SUB <Horz_Scroll
	STA Level_ScrollDiffH	 ; Difference between horizontal scroll and Level_AScrlPosH

	PLA		 ; Restore Level_AScrlPosH
	STA <Horz_Scroll ; Set as new horizontal scroll

	LDA Level_AScrlPosHHi
	STA <Horz_Scroll_Hi	 ; Set proper "high" position for raster

	LDA Level_AScrlSclLastDir
	STA <Scroll_LastDir	 ; Set "Scroll_LastDir" as appropriate for raster

	JMP PRG008_B208		; Jump to PRG008_B208

PRG008_B150:

	; No raster effects or horizontal auto scroll not desired

	LDA <Player_X
	SUB <Horz_Scroll
	BPL PRG008_B195	 ; If Player_X >= Horz_Scroll, jump to PRG008_B195

	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$80
	ADD <Horz_Scroll
	STA <Temp_Var2	 ; Temp_Var2 = $80 + Horz_Scroll
	BCC PRG008_B166	 ; If no carry, jump to PRG008_B166

	INC <Temp_Var1	 ; Apply carry

PRG008_B166:
	LDA <Player_XHi
	CMP <Temp_Var1
	BLS PRG008_B1CE	 ; If Player_XHi < Temp_Var1 (Horizontal scroll as appropriate when adding $80), jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BEQ PRG008_B1CE	 ; If Player_X = Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE
	BMI PRG008_B1CE	 ; If Player_X < Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE

	STA Level_ScrollDiffH	 ; Result stored into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	 ; Horz_Scroll += Level_ScrollDiffH
	BCC PRG008_B181	 	; If no carry, jump to PRG008_B181
	INC <Horz_Scroll_Hi	 ; Otherwise, apply carry

PRG008_B181:

	LDA <Horz_Scroll_Hi
	CMP <Level_Width
	BLS PRG008_B1CE	 	; If Horz_Scroll_Hi < Level_Width, jump to PRG008_B1CE

	; Otherwise...
	LDA #$00
	STA <Horz_Scroll	 ; Horz_Scroll = 0
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	JMP PRG008_B1CE	 	; Jump to PRG008_B1CE

PRG008_B195:
	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$70
	ADD <Horz_Scroll
	STA <Temp_Var2		; Temp_Var2 = $70 + Horz_Scroll
	BCC PRG008_B1A4	 	; If no carry, jump to PRG008_B1A4
	INC <Temp_Var1		 ; Otherwise, apply carry

PRG008_B1A4:
	LDA <Temp_Var1
	CMP <Player_XHi
	BLS PRG008_B1CE	 	; If Temp_Var1 < Player_XHi, jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BPL PRG008_B1CE	 	; If Player_X >= Temp_Var2, jump to PRG008_B1CE

	STA Level_ScrollDiffH	; Store difference into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	; Horz_Scroll += Level_ScrollDiffH
	BCS PRG008_B1BD	 	; If carry set, jump to PRG008_B1BD
	DEC <Horz_Scroll_Hi	; Otherwise, remove carry

PRG008_B1BD:

	LDA <Horz_Scroll_Hi
	BPL PRG008_B1CE	 	; If Horz_Scroll_Hi >= 0, jump to PRG008_B1CE

	; Clear a bunch
	LDA #$00	 
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA Level_ScrollDiffH

PRG008_B1CE:
	LDA <Player_SpriteX
	BEQ PRG008_B208

	LDY <Player_XVelZ
	BMI PRG008_B1DD	 ; If Player X velocity < 0 (moving leftward), jump to PRG008_B1DD

	; Player moving rightward...

	CMP #$F0
	BLT PRG008_B208	 ; If Player_SpriteX < 232, jump to PRG008_B1DD

	LDA #$F0	; Cap max at 232
	JMP PRG008_B1E3	 ; Jump to PRG008_B1E3

PRG008_B1DD:
	CMP #09
	BGE PRG008_B208	 ; If Player_SpriteX >= 17, jump to PRG008_B208
	
	LDA #08	 	

PRG008_B1E3:
	STA <Player_SpriteX ; Update Player_SpriteX

	LDY #$00	 ; Y = 0 (offset of Player_XHi)

	SUB <Player_X
	BPL PRG008_B1EE	 ; If Player_SpriteX >= Player_X, jump to PRG008_B1EE

	LDY #$ff	 ; Y = $FF (offset of Player_XHi, sign extended high part of negative)

PRG008_B1EE:
	ADD <Player_X	 
	STA <Player_X	 ; Player_X += difference between this and Player_SpriteX
	BCC PRG008_B1F6	 ; If no carry, jump to PRG008_B1F6

	INY		 ; Otherwise, apply carry

PRG008_B1F6:
	TYA		 ; A = Y ("high" part offset)
	ADD <Player_XHi	 ; Apply high adjustment
	STA <Player_XHi	 ; And store it!

	LDA <Player_XVelZ
	PHP		 ; Save processor status

	AND #%00001111	 ; Just take lower 4 bits (the "fractional" part)

	PLP		 ; Restore processor status

	BPL PRG008_B206	 ; If Player_XVelZ >= 0, jump to PRG008_B206

	ORA #$F0	 ; Otherwise, provide negative sign extention for fractional part

PRG008_B206:
	STA <Player_XVelZ ; Revise Player_XVelZ with only signed fractional part!

PRG008_B208:
	LDA Level_FreeVertScroll
	BEQ PRG008_B214	 ; If Level_FreeVertScroll = 0 (not freely scrolling), jump to PRG008_B214

	AND #$01
	BNE PRG008_B258	 ; If Level_FreeVertScroll = 1 (freely scrolling), jump to PRG008_B258

	; Otherwise, arbitrarily locked (whatever Vert_Scroll is)...
	JMP PRG008_B2A0	 ; Jump to PRG008_B2A0

PRG008_B214:

	; Not freely vertical scrolling (which persists as "NEVER" if 
	; Auto Scroll is active, but otherwise MAY be overridden)

	LDA Level_AScrlConfig
	BEQ PRG008_B246	 ; If auto scroll effect active, jump to PRG008_B246

	; Calculates Player Y based on auto scroll position
AutoScroll_CalcPlayerY:
	LDA Level_AScrlPosV
	PHA		 ; Save "Level_AScrlPosV"

	SUB <Vert_Scroll
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = difference of current scroll position from Level_AScrlPosV

	PLA		 	; Restore "Level_AScrlPosV"
	STA <Vert_Scroll 	; Becomes the new Vert_Scroll
	STA Level_VertScroll	; Becomes the new Level_VertScroll

	LDA <Player_InAir
	BEQ PRG008_B245	 ; If Player is not mid-air, jump to PRG008_B245 (RTS)

	LDA Player_IsClimbing
	BNE PRG008_B245	 ; If Player is climbing or diagonal autoscroller is wrapping, jump to PRG008_B245

	LDA Level_ScrollDiffV
	BPL PRG008_B23C	 ; If Level_ScrollDiffV >= 0, jump to PRG008_B23C

	DEC <Player_YHiZ	; Player_YHiZ--

PRG008_B23C:
	ADD <Player_YZ
	STA <Player_YZ	 ; Player_Y = Level_ScrollDiffV + Player_Y

	BCC PRG008_B245	 ; If no carry, jump to PRG008_B245

	INC <Player_YHiZ	 ; Otherwise, carry into Player_YHiZ

PRG008_B245:
	RTS		 ; Return


PRG008_B246:

	; VERTICAL SCROLL LOCK LOGIC

	; Checking whether vertical scrolling should be allowed in levels that explicitly disable it.
	; When set to not allow it by default, so long as no raster effects are going on (see above),
	; then we may allow it if the Player is flying (or high speed jumping) or climbing a vine.

	; Once the scroll point has reached Vert_Scroll = $EF (lowest scroll point) it stays there
	; unless one of the above specified overrides occur.  And here we go...

	LDA <Vert_Scroll
	CMP #$ef
	BNE PRG008_B258	 ; If Vert_Scroll <> $EF (lowest scroll point), jump to PRG008_B258 (allow free while Vert_Scroll < $EF)

	LDA Player_FlyTime
	ORA Player_IsClimbing
	PHP		 ; Save processor status

	LDA #$ef	 ; A = $EF (locked vertical scroll value)

	PLP		 ; Restore processor status

	; Optional free vertical scroll override...

	BEQ PRG008_B2A2	 ; If Player is not flying or climbing, jump to PRG008_B2A2

PRG008_B258:

	; Free vertical scrolling allowed

	LDA <Player_YZ
	SUB Level_VertScroll
	STA <Temp_Var1		; Temp_Var1 = Player_Y - Level_VertScroll (difference between Player_Y and vertical scroll)

	LDA <Player_YHiZ
	SBC Level_VertScrollH
	BMI PRG008_B272	 ; If (Player_YHiZ - Level_VertScrollH) < 0, jump to PRG008_B272

	LDA <Temp_Var1
	SUB #$30
	BCS PRG008_B284	 ; If there was no borrow, jump to PRG008_B284

	; Minimum vertical scroll delta is -3
	CMP #-3
	BGE PRG008_B274	 ; If difference is -3 or above, jump to PRG008_B274

PRG008_B272:
	LDA #-3	 	; Otherwise, enforce -3 minimum

PRG008_B274:
	STA Level_ScrollDiffV ; Store as vertical difference

	ADD <Vert_Scroll   ; Add Vert_Scroll 
	BCS PRG008_B281	   ; If carry occurred, jump to PRG008_B281

	LDA #$00
	STA Level_ScrollDiffV	; Level_ScrollDiffV = 0

PRG008_B281:
	JMP PRG008_B29E	 ; Jump to PRG008_B29E

PRG008_B284:
	LDA <Temp_Var1
	SUB #$58
	BCC PRG008_B2A0	 ; If borrow occurred, jump to PRG008_B2A0

	STA Level_ScrollDiffV	; Store as vertical difference

	ADD <Vert_Scroll
	BCS PRG008_B297	 ; If carry occurred, jump to PRG008_B297

	CMP #$ef
	BLT PRG008_B29E	 ; If calculated value is less than $EF, we're not at the bottom yet, and so jump to PRG008_B29E

PRG008_B297:
	LDA #$00
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$ef	 ; Bottom scroll position is $EF

PRG008_B29E:
	STA <Vert_Scroll	 ; Update Vert_Scroll

PRG008_B2A0:
	LDA <Vert_Scroll	

PRG008_B2A2:

	; Entry point if free vertical scrolling is disabled and Player did not override it

	STA Level_VertScroll	 ; Set Level_VertScroll

	LDA #$00
	STA Level_VertScrollH	 ; Level_VertScroll = 0

	RTS		 ; Return


	; Offsets used for tile detection in non-sloped levels
	; +16 if moving downward
	; +8 if on the right half of the tile
TileAttrAndQuad_OffsFlat:
	;     Yoff Xoff

	; Not small or ducking moving downward - right half
	.byte $0A, $08  ; 00 head
	.byte $18, $08  ; 02 body
	.byte $20, $04	; 04 Ground left
	.byte $20, $0B	; 06 Ground right
	.byte $0E, $0E	; 08 In-front upper
	.byte $1B, $0E	; 0A In-front lower

	; Not small or ducking moving downward - left half
	.byte $0A, $08  ; 0C head
	.byte $18, $08  ; 0E body
	.byte $20, $04	; 10 Ground left
	.byte $20, $0B	; 12 Ground right
	.byte $0E, $01	; 14 In-front upper
	.byte $1B, $01	; 16 In-front lower

	; Not small or ducking moving upward - right half
	.byte $0A, $08 ; head
	.byte $18, $08  ; body
	.byte $06, $04	; Ground left
	.byte $06, $0B	; Ground right
	.byte $0E, $0E	; In-front upper
	.byte $1B, $0E	; In-front lower

	; Not small or ducking moving upward - left half
	.byte $0A, $08 ; head
	.byte $18, $08  ; body
	.byte $06, $04	; Ground left
	.byte $06, $0B	; Ground right
	.byte $0E, $01	; In-front upper
	.byte $1B, $01	; In-front lower


TileAttrAndQuad_OffsFlat_Sm:
	; Small or ducking moving downward - right half
	.byte $11, $08 ; head
	.byte $18, $08  ; body
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $14, $0E	; In-front upper
	.byte $1B, $0E	; In-front lower

	; Small or ducking moving downward - left half
	.byte $11, $08 ; head
	.byte $18, $08  ; body
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $14, $02	; In-front upper
	.byte $1B, $02	; In-front lower

	; Small or ducking moving upward - right half
	.byte $11, $08 ; head
	.byte $18, $08  ; body
	.byte $10, $04	; Ground left
	.byte $10, $0B	; Ground right
	.byte $14, $0E	; In-front upper
	.byte $1B, $0E	; In-front lower

	; Small or ducking moving upward - left half
	.byte $11, $08 ; head
	.byte $18, $08  ; body
	.byte $10, $04	; Ground left
	.byte $10, $0B	; Ground right
	.byte $14, $02	; In-front upper
	.byte $1B, $02	; In-front lower

	; If $01, this is treated as a "not floor" tile, which means to watch out
	; for the Player to hit his head rather than track the sloped floor...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileAndSlope
;
; Gets tile and attribute of tile for either non-vertical or
; vertical levels based on Player's position
;
; Temp_Var10 is a Y offset (e.g. 0 for Player's feet, 31 for Player's head)
; Temp_Var11 is an X offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileAndSlope:

	LDA #$00
	STA Temp_VarNP0 ; Temp_VarNP0 = 0

	LDA <Player_YHiZ
	STA <Temp_Var13	 ; Temp_Var13 = Player_YHiZ

	LDA <Temp_Var10	 ; Temp_Var10 is the Y offset 
	ADD <Player_YZ	 
	STA <Temp_Var14	 ; Temp_Var14 = Temp_Var10 + Player_Y

	BCC PRG008_B406	 ; If no carry, jump to PRG008_B406

	INC <Temp_Var13	 ; Apply carry to Temp_Var13

PRG008_B406:
	LDA <Player_XHi
	STA <Temp_Var15	 ; Temp_Var15 = Player_XHi

	LDA <Temp_Var11
	BPL PRG008_B423	 ; If Temp_Var11 >= 0, jump to PRG008_B423

	DEC <Temp_Var15	 ; Temp_Var15--

PRG008_B423:
	LDA <Player_X
	ADD <Temp_Var11
	STA <Temp_Var16	 ; Temp_Var16 = Player_X + Temp_Var11
	BCC PRG008_B42E	 ; If no carry, jump to PRG008_B42E

	INC <Temp_Var15	 ; Temp_Var15++ (apply carry to Temp_Var15)

PRG008_B42E:

	; So in total we've calculated:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	; X/Y were not modified, so as inputs:
	; X = 0 (going down) or 1 (going up)
	; Y = Player_YVel

	STY <Temp_Var10	 ; Temp_Var10 = Player_YVel
	STX <Temp_Var11	 ; Temp_Var11 = 0 or 1

	JSR Player_GetTile	 ; Set Tile_LastValue and Player_Slopes

	LDX <Temp_Var11	 	; Temp_Var11 = 0 (going down) or 1 (going up)
	LDY Level_PipeMove	; Y = Level_PipeMove (movement command in $8x form)
	BNE PRG008_B43F	 	; If Level_PipeMove <> 0, jump to PRG008_B43F


PRG008_B43F:

	LDY <Temp_Var10	 ; Y = Player_YVel
	RTS		 ; Return

TileSolidOffset:
	.byte $00, $0E
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DetectSolids
;
; Handles Player's collision against solid tiles (wall and ground,
; handles slopes and sliding on them too!\
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DetectSolids:
	LDA #$00
	STA Player_HitWall
	STA Player_HitCeiling ; Clear Player_HitCeiling
	STA Player_Slippery	 
	STA TrapSet
	STA Wall_Jump_Enabled

	LDA Player_Oiled
	BEQ Player_CheckPipeMove

	LDA #$02
	STA Player_Slippery


Player_CheckPipeMove:
	LDA Level_PipeMove
	BEQ Player_DetectSolids1	 ; If not going through a pipe, jump to PRG008_B47E

No_Detection:
	RTS		 ; Return

Player_DetectSolids1:
DetectSolids:
	LDA #10

	LDY <Player_Suit
	BEQ PRG008_B4B1	 ; If Player is small, jump to PRG008_B4B2

	LDY Player_IsDucking
	BEQ PRG008_B4B2	 ; If Player is ducking, jump to PRG008_B4B2

PRG008_B4B1:
	LDA #58  		; 6 = 3 * 2 (the offset we start on below) and work backwards from

PRG008_B4B2:
	LDY <Player_YVelZ 
	BPL PRG008_B4BD	 ; If Player_YVelZ >= 0 (moving downward), jump to PRG008_B4BD

	ADD #24

PRG008_B4BD:
	STA <TileYIndexBase

	LDA <Player_EffXVel
	BNE PRG008_B4BE_2

	LDA Player_Direction
	BEQ PRG008_B4BF

PRG008_B4BE_2:
	BPL PRG008_B4C9
	BMI PRG008_B4BF

PRG008_B4BE:
	LDA <Player_X
	ADD #$08
	AND #$0F
	CMP #$08
	BCS PRG008_B4C9	 ; If Player is on the left half of the tile, jump to PRG008_B4CA

PRG008_B4BF:
	; If on the right half, add 8 to index
	LDA <TileYIndexBase
	ADD #12
	STA <TileYIndexBase

PRG008_B4C9:
	LDA <TileYIndexBase
	STA <TileYIndex
	LDA #$05
	STA <TileXIndex

PRG008_B4CA:
	JSR Player_NextTile

	LDA Player_ForcedSlide
	BNE PRG008_B4CB

	JSR Player_DetectWall

PRG008_B4CB:
	JSR Player_NextTile	

	LDA Player_ForcedSlide
	BNE Player_DetectSolids5

	JSR Player_DetectWall

Player_DetectSolids5:

	LDA <Player_EffYVel
	BPL Player_DetectSolids2	 ; If Player Y velocity >= 0 (moving downward), jump to PRG008_B55B
	
	LDA Player_OnObject
	BNE Player_DetectSolids2

	LDA #$01
	STA <Player_InAir

	JSR Player_NextTile	
	JSR Player_DetectCeiling
	
	JSR Player_NextTile	

	LDA <Player_X
	AND #$0F
	CMP #$05
	BCC Player_SkipUpperLeft

	CMP #$0B
	BCS Player_SkipUpperLeft

	JSR Player_DetectCeiling

Player_SkipUpperLeft:
	LDA Player_HitCeiling
	BEQ Player_NoCeilStop

	LDA #$01
	STA <Player_YVelZ

	LDA #$10
	SUB Tile_DetectionY
	AND #$0F

	ADD <Player_YZ
	STA <Player_YZ

	LDA <Player_YHiZ
	ADC #$00
	STA <Player_YHiZ
	
Player_NoCeilStop:	
	JMP Player_DetectSolids3

Player_DetectSolids2:
	JSR Player_NextTile	
	JSR Player_NextTile	
	JSR Player_DetectFloor

Player_DetectSolids3:
	JSR Player_NextTile
	JSR Player_NextTile	
	RTS

Player_TileInteractions:
	LDA Tile_LastProp
	AND #$F0
	CMP #TILE_PROP_SOLID_BOTTOM
	BEQ Player_TileInteractions3

	CMP #TILE_PROP_ITEM
	BCS Player_TileInteractions3

	CMP #TILE_PROP_SOLID_TOP
	BCS Player_TileInteractions2

	LDX <TileXIndex
	CPX #HEAD_FEET_LEFT_INDEX
	BCS Player_TileInteractions1
	JMP Player_BodyHeadTileInteract

Player_TileInteractions1:

	JMP Player_BgTileInteract

Player_TileInteractions2:
	AND #$0F
	JMP Player_SolidTileInteract

Player_TileInteractions3:
	RTS

Level_DoBumpBlocks:
	LDA Block_NeedsUpdate
	BEQ DoBumps
	RTS

DoBumps:
	LDA #$00 
	STA ObjectBump

	LDA Tile_LastProp
	STA Bump_Prop

	LDA Tile_LastValue
	STA Bump_Value

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tiles_BumpBlocks
;
; Ever wondered where the code was that makes ? blocks emerge 
; powerups, music note blocks bounce you around, and bricks bust?
; Well, here it is!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Bump_Value	= Temp_Var11
Bump_Prop	= Temp_Var12
Bump_Y		= Temp_Var14
Bump_YHi	= Temp_Var13
Bump_X		= Temp_Var16
Bump_XHi	= Temp_Var15

Tiles_BumpBlocks:

	LDA Bump_Prop
	AND #$0F
	JSR DynJump

BumpBlock_JumpTable:
	.word BumpBlock_Coin
	.word BumpBlock_Flower	; 1 = Mushroom/Flower
	.word BumpBlock_Leaf		; 2 = Mushroom/Leaf
	.word BumpBlock_IceFlower; 5 = Coin/Star
	.word BumpBlock_Frog     ;
	.word BumpBlock_FoxLeaf	; A = Fox Leaf
	.word BumpBlock_Koopa	;
	.word BumpBlock_Event	; 8 = 10 coin
	.word BumpBlock_Sledge   ;
	.word BumpBlock_NinjaShroom		; 9 = 1-up
	.word BumpBlock_CheckPoint		; 3 = Star-
	.word BumpBlock_Vine		; 7 = Vine
	.word BumpBlock_PSwitch	; B = P-Switch
	.word BumpBlock_Brick	; 6 = Standard brick behavior
	.word BumpBlock_Spinner
	.word BumpBlock_Key
	
Bumps_CheckExistingPowerUps:
	LDX #$05

Bumps_CheckNextExisting:
	LDA Objects_State, X
	BEQ Bump_NotPowerUp

	LDA Objects_ID, X
	CMP #OBJ_ITEMBLOCK
	BNE Bump_CheckObjPowerUp

	LDA ItemBlock_PowerUp, X
	CMP #POWERUP_MUSHROOM
	BCC Bump_NotPowerUp

	CMP #POWERUP_VINE
	BCS Bump_NotPowerUp

Bump_IsPowerUp:
	LDA <Objects_XZ, X
	STA Poof_X

	LDA <Objects_YZ, X
	STA Poof_Y

	LDA <Objects_YHiZ, X
	STA Poof_YHi

	JSR Common_MakePoof

	LDA #$00
	STA ItemBlock_PowerUp, X
	RTS

Object_IsPowerUp:
	LDA <Objects_XZ, X
	STA Poof_X

	LDA <Objects_YZ, X
	STA Poof_Y

	LDA <Objects_YHiZ, X
	STA Poof_YHi

	JSR Common_MakePoof

	LDA #$00
	STA Objects_ID, X
	STA Objects_State, X
	RTS

Bump_CheckObjPowerUp:
	CMP #OBJ_POWERUP
	BNE Bump_NotPowerUp

	LDA PowerUp_Type, X
	CMP #POWERUP_COIN
	BCC Bump_NotPowerUp

	CMP #POWERUP_VINE
	BCC Object_IsPowerUp

Bump_NotPowerUp:
	INX
	CPX #$08
	BNE Bumps_CheckNextExisting
	RTS


Bumps_PowerUpBlock:
	LDX #$05

Bumps_PowerUpBlock1:
	LDA Objects_State, X
	BEQ Bumps_PowerUpBlock2
	INX
	CPX #$08
	BNE Bumps_PowerUpBlock1

	PLA
	PLA
	RTS

Bumps_CoinBlock:
	LDX #$05

Bumps_CoinBlock1:
	LDA Objects_State, X
	BEQ Bumps_PowerUpBlock2

	INX
	CPX #$08
	BNE Bumps_CoinBlock1

	PLA
	PLA
	RTS

Bumps_PowerUpBlock2:
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	JSR Object_New
	
	LDA #$04
	STA Objects_SpritesRequested, X

	LDA #OBJ_ITEMBLOCK 
	STA Objects_ID, X

	LDA #OBJSTATE_FRESH
	STA Objects_State, X

	LDA #SPR_PAL3
	STA Objects_SpriteAttributes, X

	LDA Bump_X
	AND #$F0
	STA <Objects_XZ, X

	LDA Bump_Y
	AND #$F0
	STA <Objects_YZ, X

	LDA Bump_XHi
	STA <Objects_XHiZ, X

	LDA Bump_YHi
	STA <Objects_YHiZ, X
	RTS

BumpBlock_CheckMushroom:
	LDY <Player_Suit
	BNE BumpBlock_CheckMushroom1

	LDA #POWERUP_MUSHROOM

BumpBlock_CheckMushroom1:
	STA ItemBlock_PowerUp, X
	RTS

BumpBlock_Coin:
	JSR Bumps_CoinBlock
	LDA #POWERUP_COIN
	STA ItemBlock_PowerUp, X
	RTS		 ; Return

BumpBlock_Flower:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_FIREFLOWER
	JSR BumpBlock_CheckMushroom
	RTS

BumpBlock_None:
	LDY #$01		; Y = 1 (spawn .. nothing?) (index into PRG001 ItemBlock_PUp)
	RTS		 ; Return


BumpBlock_IceFlower:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_ICEFLOWER
	JSR BumpBlock_CheckMushroom
	RTS		 ; Return

;;;;;;;;;;;;
BumpBlock_CheckPoint:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_CHECKPOINT
	STA ItemBlock_PowerUp, X
	RTS		 ; Return

BumpBlock_Leaf:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_SUPERLEAF
	JSR BumpBlock_CheckMushroom
	RTS		 ; Return

BumpBlock_Event:
	INC EventSwitch
	JSR Bumps_PowerUpBlock
	LDA #00
	STA ItemBlock_PowerUp, X
	LDA Tile_LastValue
	STA ItemBlock_ReplaceTile, X
	RTS		 ; Return

BumpBlock_Empty:
	JSR Bumps_PowerUpBlock
	LDA #00
	STA ItemBlock_PowerUp, X
	RTS		 ; Return

BumpBlock_Spinner:
	LDA Player_FireDash
	BEQ BumpBlock_Spinner1
	JMP  BumpBlock_Brick

BumpBlock_Spinner1:

	LDA Bump_X
	STA Block_ChangeX

	LDA Bump_XHi
	STA Block_ChangeXHi

	LDA Bump_Y
	STA Block_ChangeY

	LDA Bump_YHi
	STA Block_ChangeYHi

	JSR Tile_WriteTempChange
	BCC BumpBlock_SpinnerRTS
	
	JSR Bumps_PowerUpBlock
	
	LDA Tile_LastValue
	EOR #$01
	STA ItemBlock_ReplaceTile, X

	LDA #$00
	STA ItemBlock_PowerUp, X

	LDA #$02
	STA ItemBlock_Frame, X

BumpBlock_SpinnerRTS:
	RTS

BumpBlock_Brick:
	LDA Player_Suit
	ORA ObjectBump
	BNE BumpBlock_Brick1

	JSR Bumps_PowerUpBlock
	LDA #$01
	STA ItemBlock_Frame, X

	LDA #$00
	STA ItemBlock_PowerUp, X

	LDA ActualTile_LastValue
	STA ItemBlock_ReplaceTile, X
	RTS

BumpBlock_Brick1:

	LDA Bump_X
	AND #$F0
	STA Debris_X

	LDA Bump_Y
	AND #$F0
	STA Debris_Y

	JSR Common_MakeBricks

	LDA Tile_LastValue
	AND #$C0
	ORA #$01
	
	JSR Level_QueueChangeBlock
	
Bump_BrickRTS:
	RTS		 ; Return


BumpBlock_Vine:
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_VINE
	STA ItemBlock_PowerUp, X
	RTS		 ; Return

BumpBlock_NinjaShroom:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_NINJASHROOM
	JSR BumpBlock_CheckMushroom
	RTS		 ; Return

BumpBlock_Key:
	JSR Bumps_PowerUpBlock
	LDA #$80
	STA ItemBlock_PowerUp, X
	RTS		 ; Return

BumpBlock_FoxLeaf:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_FOXLEAF
	JSR BumpBlock_CheckMushroom
	RTS		 ; Return

BumpBlock_Frog:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_FROGSUIT
	JSR BumpBlock_CheckMushroom
	RTS		 ; Return


BumpBlock_Koopa:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_SHELL
	JSR BumpBlock_CheckMushroom
	RTS


BumpBlock_Sledge:
	JSR Bumps_CheckExistingPowerUps
	JSR Bumps_PowerUpBlock
	LDA #POWERUP_HAMMERSUIT
	JSR BumpBlock_CheckMushroom
	RTS

BumpBlock_PSwitch:      
	LDA Block_NeedsUpdate
	BNE BumpBlock_PSwitch1

	JSR Bumps_PowerUpBlock

	LDA Tile_Y
	SUB #$10
	STA Tile_Y

	LDA Tile_YHi
	SBC #$00
	STA Tile_YHi

	JSR Player_GetTile
	TYA
	SUB #$01
	JSR Level_QueueChangeBlock

	LDA Tile_Y
	AND #$F0
	STA Poof_Y

	LDA Tile_YHi
	STA Poof_YHi

	LDA Tile_X
	AND #$F0
	STA Poof_X
	JSR Common_MakePoof

BumpBlock_PSwitch1:
	RTS

Player_TailAttack_Offsets: ; (Y and X)
	.byte 28, -6	; Player not horizontally flipped
	.byte 28, 21	; Player horizontally flipped

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttack_HitBlocks
;
; Short routine that handles the tail attack hitting blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttack_HitBlocks:
    LDA Player_TailAttack
    CMP #$09
    BNE PRG008_B979        ; If Player_TailAttack <> 9, jump to PRG008_B979

	LDY #$00         ; Y = 0 (Player not flipped)

	LDA <Player_FlipBits
	BNE PRG008_B95F	 ; If Player is horizontally flipped, jump to PRG008_B95F

	LDY #$02	 ; Y = 2 (Player flipped)

PRG008_B95F:
	LDA Player_TailAttack_Offsets,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)

	LDA Player_TailAttack_Offsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

Do_Tile_Attack:
	JSR Player_GetTileAndSlope	 ; Get tile near tail
	
	CMP #TILE_ITEM_COIN
	BCC PRG008_B979

	JSR Level_DoBumpBlocks	 ; Handle blocks that can be "bumped"

PRG008_B979:
	RTS		 ; Return

Tile_MoveTable_XCarry:
	;	   L    R    U    D
	.byte $00, $00, $00, $00 ; X Air
	.byte $F0, $10, $00, $00 ; X Water
	.byte $F0, $10, $00, $00 ; X Ground
	.byte $00, $00, $00, $00 ; X Wall

Tile_MoveTable_XVel:
	;	   L    R    U    D
	.byte $D0, $30, $00, $00 ; X Air
	.byte $00, $00, $00, $00 ; X Water
	.byte $00, $00, $00, $00 ; X Ground
	.byte $00, $00, $00, $00 ; X Wall

Tile_MoveTable_YCarry:
	.byte $00, $00, $00, $00 ; Y Air
	.byte $00, $00, $00, $0C ; Y Water
	.byte $00, $00, $00, $00 ; Y Ground
	.byte $00, $00, $E8, $F8 ; Y Wall


Tile_MoveTable_YVel:
	.byte $00, $00, $E0, $20 ; Y Air
	.byte $00, $00, $FE, $00 ; Y Water
	.byte $00, $00, $00, $00 ; Y Ground
	.byte $00, $00, $01, $00 ; Y Wall


Tile_MoveTable_Offset:
	.byte $FF, $00, $02, $02, $03, $FF

Move_Offset = Temp_Var1

ApplyTileMove:
	LDA Tile_LastProp
	AND #$0F
	SUB #$03
	STA <Move_Offset

	CPX #$01
	BNE Try_Ground_Move

	LDA Tile_LastProp
	CMP #TILE_PROP_WATER
	BCC Apply_Move
	
	LDA Player_InWater
	BEQ Apply_Move_RTS

	LDA Player_EffectiveSuit
	CMP #$04
	BEQ Apply_Move_RTS

	LDA #$04
	ADD <Move_Offset
	STA <Move_Offset
	JMP Apply_Move

Try_Ground_Move:
	CPX #$02
	BEQ Do_Ground_Move

	CPX #$03
	BNE Try_Wall_Move

Do_Ground_Move:
	LDA Player_FireDash
	BNE Apply_Move_RTS

	LDA #$08
	ADD <Move_Offset
	STA <Move_Offset
	JMP Apply_Move

Try_Wall_Move:
	CPX #$04
	BNE Apply_Move_RTS

	LDA Wall_Jump_Enabled
	BEQ Apply_Move_RTS

	LDA #$0C
	ADD <Move_Offset
	STA <Move_Offset

Apply_Move:
	LDX <Move_Offset

	LDA Tile_MoveTable_XCarry, X
	BEQ Apply_Move1
	STA <Player_CarryXVel

Apply_Move1:
	LDA Tile_MoveTable_XVel, X
	BEQ Apply_Move2

	STA <Player_XVelZ

Apply_Move2:
	LDA Tile_MoveTable_YCarry, X
	BEQ Apply_Move3

	STA <Player_CarryYVel
	INC <Player_InAir

	LDA #$00
	STA Objects_YVelFrac,X

Apply_Move3:

	LDA Tile_MoveTable_YVel, X
	BEQ Apply_Move_RTS

	CPX #$05
	BCC Apply_Move4

	CPX #$09
	BCS Apply_Move4

	LDY Player_IsHolding
	BNE Apply_Move_RTS

Apply_Move4:
	ADD <Player_YVelZ
	STA <Player_YVelZ
	INC <Player_InAir

Apply_Move_RTS:
	RTS

PipeMove_SetPlayerFrame:
	LDY <Player_Suit
	BEQ PRG008_BF0A	 ; If small, jump to PRG008_BF0A

	LDY #$02	 ; Otherwise, Y = 2

PRG008_BF0A:
PRG008_BF10:
	LDA PipeMove_Frame,Y ; Get appropriate pipe traversal frame
	STA <Player_Frame	  ; Store as Player frame
	RTS		 ; Return


	; X and Y offsets to "correct" Player masking sprite when entering pipe
PipeEnter_XYOffs:
	.byte 16,   0	; right
	.byte  0,   0	; left
	.byte  0,  32	; up
	.byte  0, -16	; down	<-- not applied if Player is small


	; Does common stuff to prepare to enter a pipe!
PipeEntryPrepare:
	STX Level_PipeMove	 ; Set appropriate pipe movement

	; Play pipe sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA Level_ExitToMap	; A = 1 (pipe will exit level)
	BNE PRG008_BF49		; If pipes in this level do NOT exit to map, jump to PRG008_BF47

PRG008_BF47:
	LDA #$03	 ; A = 3 (regular pipe mechanics)

PRG008_BF49:

	; Construct pipe movement
	ASL A
	ASL A
	ORA Level_PipeMove
	STA Level_PipeMove

	; Set timer while in pipe
	LDA #$3c
	STA Event_Countdown

	; X <<= 1 (pipe movement, shifted left 1)
	TXA
	ASL A
	TAX

	LDA <Player_X
	ADD PipeEnter_XYOffs,X	 ; Add appropriate X offset
	CPX #$04	 
	BGS PRG008_BF65	 	; If pipe movement is up/down, jump to PRG008_BF65

	AND #$F0	 ; Otherwise, align Player_X to grid

PRG008_BF65:
	STA <Pipe_PlayerX	; Update Player_X

	LDA <Player_YZ
	CPX #$06	
	BNE PRG008_BF71	 ; If not a downward pipe, jump to PRG008_BF71

;	LDY <Player_Suit
;	BEQ PRG008_BF75	 ; If Player is small, jump to PRG008_BF75

PRG008_BF71:
	ADD PipeEnter_XYOffs+1,X ; Add appropriate Y offset

PRG008_BF75:
	AND #$F0	 ; Align Player_Y to grid

	CPX #$04	 
	BLS PRG008_BF7E	 ; If left/right pipe, jump to PRG008_BF7E

	SUB #$01	 ; Move Player up one pixel 

PRG008_BF7E:
	STA <Pipe_PlayerY ; Set Pipe_PlayerY

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_QueueChangeBlock
;
; Changes a block, used for tiles which appear/disappear
;
; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
; Temp_Var15 / Temp_Var16 -- X Hi and Lo
;
; Register 'A' as input sets Block_NeedsUpdate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_QueueChangeBlock:
	STA Block_UpdateValue
	LDA #$80
	STA Block_NeedsUpdate	 ; Store type of block change!

	; Store change Y Hi and Lo
	LDA <Temp_Var13
	STA Block_ChangeYHi

	LDA <Temp_Var14
	AND #$F0		; Align to nearest grid coordinate
	STA Block_ChangeY

	; Store change X Hi and Lo
	LDA <Temp_Var15
	STA Block_ChangeXHi

	LDA <Temp_Var16	
	AND #$F0	 	; Align to nearest grid coordinate
	STA Block_ChangeX

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyXVelocity
;
; Applies Player's X velocity and makes sure he's not moving
; faster than the cap value (PLAYER_MAXSPEED)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ForceDirection:
	.byte $F0, $10

Player_ApplyXVelocity:
	LDA Player_ForcedSlide
	BEQ Player_ApplyXVelocity1

	LDY #$00
	LDA Player_LastXVel
	BPL ForceLeft

	INY

ForceLeft:	
	LDA ForceDirection, Y
	STA <Player_CarryXVel

	LDA #$00
	STA <Player_XVelZ

Player_ApplyXVelocity1:
	LDX #$00	; X = 0
	LDY #PLAYER_MAXSPEED	; Y = PLAYER_MAXSPEED

	LDA <Player_XVelZ
	BPL PRG008_BFAC	 ; If Player_XVelZ >= 0, jump to Player_ApplyXVelocity 

	LDY #-PLAYER_MAXSPEED	 ; Y = -PLAYER_MAXSPEED

	; Negate Player_XVelZ (get absolute value)
	NEG

PRG008_BFAC:
	STA <Temp_Var16		; Store absolute value Player_XVelZ -> Temp_Var166
	CMP #PLAYER_MAXSPEED
	BLS Player_DoXApply ; If we haven't hit the PLAYER_MAXSPEED yet, apply it!
	STY <Player_XVelZ	 ; Otherwise, cap at max speed!

Player_DoXApply:
	JSR Player_ApplyVelocity

	LDA <Temp_Var1
	STA <Player_EffXVel

	LDA Player_ForcedSlide
	ORA Player_Shell
	BNE Player_DoXApplyRTS

	LDA <Player_EffXVel
	BEQ Player_DoXApplyRTS

	STA Player_LastXVel

Player_DoXApplyRTS:	
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyVelocity
;
; Applies Player's velocity for X or Y (depending on register 'X')
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyVelocity:
	; X may specify offset to YVel, or else be zero
	LDA <Player_XVelZ,X	; Get velocity
	STA <Temp_Var1
	
	CPX #$00
	BNE No_Weather_Vel

	LDA Player_EffectiveSuit
	CMP #$04
	BNE Check_WeatherOther

	LDA <Player_InAir
	BEQ No_Weather_Vel

Check_WeatherOther:
	LDA Player_InWater
	ORA Level_PipeMove
	BNE No_Weather_Vel

	LDA Wind
	BEQ No_Weather_Vel

	ADD <Temp_Var1
	STA <Temp_Var1

No_Weather_Vel:
	LDA <Temp_Var1
	ADD <Player_CarryXVel, X

PRG008_BFBF:
	PHA		 ; Save result

	ASL A
	ASL A
	ASL A
	ASL A		 ; Get "fractional" part of velocity
	STA <Temp_Var12	 ; Store into Temp_Var12

	LDY #$00	 ; Y = 0

	PLA		 ; Restore prior result

	LSR A
	LSR A
	LSR A
	LSR A		 ; Get "whole" part of velocity

	; "Whole" part is like a 4-bit signed integer
	; $0 - $7 is therefore rightward
	; $8 - $F is therefore leftward
	CMP #$08
	BLT PRG008_BFD3	 ; If whole part is less than 8, jump to PRG008_BFD3

	DEY		 ; Y = $FF (sign extended negative)

	; Turn "whole part" into a full 8-bit signed
	ORA #$F0

PRG008_BFD3:
	STA <Temp_Var11	 ; Store velocity into Temp_Var11 (low part)
	STY <Temp_Var13	 ; Temp_Var13 = 0 or $FF (High part)

	; Accumulating fractional component
	LDA Player_XVelZFrac,X
	ADD <Temp_Var12	
	STA Player_XVelZFrac,X

	; Apply velocity to X if there's carry
	LDA <Player_X,X
	ADC <Temp_Var11
	STA <Player_X,X
	
	
	; Apply velocity to XHi if there's carry
	LDA <Player_XHi,X
	ADC <Temp_Var13	
	STA <Player_XHi,X
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyYVelocity
;
; Applies Player's Y velocity and makes sure he's not falling 
; faster than the cap value (FALLRATE_MAX)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyYVelocity:
	LDA <Player_YVelZ
	BMI Player_CapYVel	 ; If Player_YVelZ < 0, jump to PRG008_BFF9

	CMP #FALLRATE_MAX
	BLS PRG008_BFF9	 ; If Player_YVelo < FALLRATE_MAX, jump to PRG008_BFF9

	; Cap Y velocity at FALLRATE_MAX
	LDA #FALLRATE_MAX
	STA <Player_YVelZ ; Player_YVelZ = FALLRATE_MAX
	JMP PRG008_BFF9

Player_CapYVel:
	CMP #$A8
	BCS PRG008_BFF9

	LDA #$A8
	STA <Player_YVelZ ; Player_YVelZ = FALLRATE_MAX

PRG008_BFF9:
	LDX #(Player_YVelZ - Player_XVelZ) ; Do the Y velocity
	JSR Player_ApplyVelocity	 ; Apply it!

	RTS		 ; Return

Do_Air_Timer:				; Added code to increase/decrease the air time based on water
	LDA Player_Vehicle
	BNE AirTimerRTS

	LDA Air_Change
	BNE CheckAirChange

AirTimerRTS:	
	RTS

AirTicker: .byte $0B, $12

CheckAirChange:
	LDA Air_Time
	BPL Change_Air

Air_Kill:
	JSR Player_Die
	JMP Level_SetPlayerPUpPal

Change_Air:
	ADD Air_Change
	BMI Air_Kill
	CMP #$40
	BCC NotMaxAir
	LDA #$40
	STA Air_Time
	RTS

NotMaxAir:
	STA TempA
	INC Air_Time_Frac

	LDA Air_Time_Frac
	LDY #$00
	LDX Player_Equip
	CPX #BADGE_AIR
	BNE NotMaxAir1
	INY

NotMaxAir1:
	CMP AirTicker, Y
	BCC NoChange

	LDA #$00
	STA Air_Time_Frac

	LDA TempA
	STA Air_Time
	CMP #$10
	BGE NoChange

	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

NoChange:
	RTS

Power_TickChange:
	.byte $07, $0A

Do_PowerChange:				; Added code to increase/decrease the air time based on water
	INC Power_Tick
	LDX #$00
	LDA Player_Equip
	CMP #BADGE_PMETER
	BNE Do_PowerChange01
	INX

Do_PowerChange01:
	LDA Power_Tick
	CMP Power_TickChange, X
	BNE Do_PowerChange0
	LDA #$00
	STA Power_Tick
	LDA Power_Change
	BNE Do_PowerChange1

Do_PowerChange0:
	RTS

Do_PowerChange1:

	LDA Player_Power
	ADD Power_Change
	BPL Do_PowerChange2

	LDA #$00
	BEQ Do_PowerChange3

Do_PowerChange2:
	CMP #$50
	BCC Do_PowerChange3
	
	LDA #$00
	STA Power_Change

	LDA #$50

Do_PowerChange3:
	STA Player_Power
	RTS

Do_PUp_Proper:
	LDA Player_Equip
	CMP #BADGE_NOSHOORMS
	BEQ PUp_RTS

	LDA <Player_Suit
	BNE PUp_RTS

	LDY #$05
PUp_RTS:
	RTS

VScreenTransitions:
	LDA Level_FreeVertScroll
	CMP #$03

	BEQ CheckPlayer_Y
	RTS

CheckPlayer_Y:
	JSR CheckPlayer_YLow
	JSR CheckPlayer_YHiZ
	RTS
		
CheckPlayer_YHiZ:
	LDA <Player_XHi
	CMP <Level_Width
	BEQ NotYHi

	LDA <Player_YHiZ
	BPL NotYHi

	LDA <Player_YZ
	LDX Player_IsClimbing

	BEQ NormalYHiCheck
	SUB #$10
	
NormalYHiCheck:
	CMP #$F4
	BCS NotYHi

	LDX <Player_XHi
	INX
	STX <Player_XHi
	LDX #$A1
	LDA <Player_Suit
	BNE NotSmallMario

	LDX #$98

NotSmallMario:
	STX <Player_YZ
	LDA #$01
	STA <Player_YHiZ

	INC Level_JctCtl
	INC Level_KeepObjects
	PLA
	PLA

	LDX #$07
	
ClearSprite:
	LDA Objects_Global, X
	BNE Check_GlobalHold

	LDA #$00
	STA Objects_State, X

	LDY Objects_SpawnIdx,X	

	LDA Level_ObjectsSpawned,Y
	AND #$7f
	STA Level_ObjectsSpawned,Y

NextSprite:
	DEX
	BPL ClearSprite

NotYHi:
	RTS

Check_GlobalHold:
	LDA Objects_BeingHeld, X
	BEQ NextSprite

	LDA <Player_X
	STA <Objects_XZ, X

	LDA <Player_XHi
	STA <Objects_XHiZ, X

	LDA <Player_YZ
	STA <Objects_YZ, X

	LDA <Player_YHiZ
	STA <Objects_YHiZ, X
	JMP NextSprite

CheckPlayer_YLow:
	LDA <Player_XHi
	BEQ NotYLo

	LDA <Player_YHiZ
	CMP #$01
	BNE NotYLo
	
	LDA <Player_YZ
	CMP #$A8
	BCC NotYLo

	LDX <Player_XHi
	DEX
	STX <Player_XHi

	LDA #$00
	STA <Player_YZ
	STA <Player_YHiZ

	INC Level_JctCtl
	PLA
	PLA

NotYLo:
	RTS

CheckForLevelEnding:
	LDA CompleteLevelTimer
	BPL DoCountDown

	CMP #$80
	BEQ StartCountDown
	RTS

StartCountDown:
	LDA <Player_InAir
	BNE NoCountDown
	
	LDA #$00
	STA <Player_XVelZ
	
	LDA #MUS1_BOSSVICTORY
	STA Sound_QMusic1
	
	DEC CompleteLevelTimer
	RTS

DoCountDown:
	LDA #$FF
	STA Player_HaltTick

	LDA <Counter_1
	AND #$01
	BNE NoCountDown

	DEC CompleteLevelTimer
	BMI EndLevel

NoCountDown:
	RTS

EndLevel:
	LDA #$00
	STA Map_ReturnStatus
	STA CheckPoint_Flag

	LDA #$01
	STA Level_ExitToMap

	JSR GetLevelBit
	ORA Levels_Complete, Y
	STA Levels_Complete, Y
	RTS

CoinsEarnedBuffer:
	LDA Coins_Earned_Buffer
	BEQ CoinsEarnedBufferRTS

	LDA <Counter_1
	AND #$01
	BNE CoinsEarnedBufferRTS

	DEC Coins_Earned_Buffer

	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	INC Coins_Earned

CoinsEarnedBufferRTS:
	RTS

DoPaletteEffect:
	RTS

PlayerRainbow:
	LDA <Counter_1
	AND #$07
	BEQ PlayerRainbow1

	RTS

PlayerRainbow1:

	INC EffectCounter

	LDA EffectCounter
	CMP #$09
	BNE PlayerRainbow2

	LDA #$00
	STA EffectCounter

PlayerRainbow2
	RTS

Player_Events:
	LDA EventSwitch
	BEQ Player_EventsRTS

	LDA PAGE_C000
	PHA
	LDA #13
	STA PAGE_C000

	JSR PRGROM_Change_C000 
	JSR HandleLevelEvent
	PLA 
	STA PAGE_C000
	JSR PRGROM_Change_C000 

Player_EventsRTS:
	RTS

Player_Refresh:
	RTS


Player_DetectWall:
	LDA Player_ForcedSlide
	BNE Player_DetectWallRTS0

	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_ALL
	BCC Player_DetectWallRTS0


Player_DetectWall1:
	INC Player_HitWall
	LDA Player_Shell
	BEQ Player_DetectWall2

	LDA Sound_QPlayer 
	ORA #SND_PLAYERBUMP 
	STA Sound_QPlayer

	LDA Tile_LastProp
	CMP #TILE_PROP_ITEM
	BCC Player_DetectWall1_1

	JSR Level_DoBumpBlocks

Player_DetectWall1_1:
	LDA Tile_LastProp
	CMP #TILE_ITEM_BRICK
	BEQ Player_DetectWall1_2

	LDA <Player_XVelZ
	EOR #$FF
	ADD #$01
	STA <Player_XVelZ
	
	JSR Player_ApplyXVelocity
	RTS

Player_DetectWall1_2:
	LDA Sound_QPlayer 
	EOR #SND_PLAYERBUMP 
	STA Sound_QPlayer
	RTS

Player_DetectWall2:
	LDA Player_FireDash
	BEQ Player_DetectWall4

	LDA Tile_LastProp
	CMP #TILE_PROP_ITEM
	BCC Player_DetectWall3

	JSR Level_DoBumpBlocks

	LDA Tile_LastProp
	CMP #TILE_ITEM_BRICK
	BEQ Player_DetectWallRTS

	CMP #TILE_ITEM_SPINNER
	BEQ Player_DetectWallRTS

Player_DetectWall3:
	JSR Player_DetectWall4
	JMP Player_KillDash

Player_DetectWallRTS0:
	RTS

Player_DetectWall4:
	LDA Player_ForcedSlide
	BNE Player_DetectWallRTS

	LDA Tile_DetectionX
	AND #$0F
	CMP #$08
	BCS Hit_LeftWall
	
	STA <Temp_Var1

	LDA <Player_X
	SUB <Temp_Var1
	STA <Player_X

	LDA <Player_XHi
	SBC #$00
	STA <Player_XHi
	
	JMP Wall_Hit

Hit_LeftWall:
	LDA #$10
	SUB Tile_DetectionX
	AND #$0F
	STA <Temp_Var1

	LDA <Player_X
	ADD <Temp_Var1
	STA <Player_X

	LDA <Player_XHi
	ADC #$00
	STA <Player_XHi

Wall_Hit:
	LDA <Player_XVelZ
	EOR <Player_EffXVel
	BMI Wall_NoHit

	LDA #$00
	STA <Player_XVelZ
	STA Player_CarryXVel

Wall_NoHit:
	JSR Player_CheckWallJump

Player_DetectWallRTS:
	RTS

WallClingXVel: .byte $00, $01, $FF
			   .byte $00, $00, $FF

WallPressSign: .byte $00, $80, $00			   

Player_CheckWallJump:
	LDA Player_InWater
	BNE No_Wall_Jump

	LDA Player_EffectiveSuit
	CMP #$0B
	BNE No_Wall_Jump

	LDA Player_IsHolding
	ORA Player_IsClimbing
	BNE No_Wall_Jump

	LDA <Player_YHiZ
	BMI No_Wall_Jump

	LDA <Player_YVelZ
	BMI No_Wall_Jump

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ No_Wall_Jump

	TAX

	LDA <Player_InAir
	BEQ No_Wall_Jump			; can only wall jump if in the air and against  a wall

	LDA <Player_EffXVel
	AND #$80
	CMP WallPressSign, X

	LDA <Player_X
	ADD WallClingXVel, X
	STA <Player_X

	LDA <Player_XHi
	ADC WallClingXVel + 3, X
	STA <Player_XHi

	LDA WallClingXVel, X
	STA Wall_Jump_Enabled

	LDA #$00
	STA Player_Flip

	LDA Tile_LastProp
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_SLICK)
	BEQ Wall_Jump_Done

	LDA <Player_YVelZ
	CLC
	SBC #$20			; slow down decsent during wall jump mode

	BMI No_Wall_Jump
	STA <Player_YVelZ

Wall_Jump_Done:
	SEC
	RTS

No_Wall_Jump:
CLC
	RTS

;	LDA Player_Shell
;	BEQ PRG008_B53A_2
;	JSR Shell_Bounce
;	JMP PRG008_B53B
;
;PRG008_B53A_2:
;	JSR Can_Wall_Jump
;	
;	
;	BNE PRG008_B53B
;
;	LDA <Player_X
;	STA TempA
;	ADD #$08
;	AND #$F0
;	STA <Player_X
;
;	LDA <Player_XHi
;	STA TempY
;	ADC #$00
;	STA <Player_XHi
;
;	LDX #$00
;	LDA <Player_Suit
;	BEQ PRG008_B530
;
;	INX
;
;PRG008_B530:
;	LDA TempA
;	AND #$0F
;	CMP #$08
;	BCS PRG008_B531
;
;	LDA <Player_XVelZ
;	ADD Player_CarryXVel, X
;	ADD Wind
;	BMI PRG008_B53C
;
;	LDA <Player_XVelZ
;	BPL PRG008_B530_1
;
;	LDA <Pad_Holding
;	AND #PAD_LEFT
;	BNE PRG008_B530_2
;
;PRG008_B530_1:
;	LDA #$00
;	STA <Player_XVelZ
;
;PRG008_B530_2:
;	LDA <Player_X
;	ADD Wall_Clip, X
;	STA <Player_X
;
;	LDA <Player_XHi
;	ADC #$00
;	STA <Player_XHi
;	RTS

;PRG008_B531:
;	LDA <Player_XVelZ
;	ADD Player_CarryXVel, X
;	ADD Wind
;	BEQ PRG008_B531_2
;	BPL PRG008_B53C
;
;PRG008_B531_2:
;	LDA <Player_XVelZ
;	BMI PRG008_B531_3
;
;	LDA <Pad_Holding
;	AND #PAD_RIGHT
;	BNE PRG008_B531_4
;
;PRG008_B531_3:
;	LDA #$00
;	STA <Player_XVelZ
;
;PRG008_B531_4:
;
;	LDA <Player_X
;	SUB Wall_Clip, X
;	STA <Player_X
;
;	LDA <Player_XHi
;	SBC #$00
;	STA <Player_XHi
;
;PRG008_B53B:
;	RTS

;PRG008_B53C:
;	LDA TempA
;	STA <Player_X
;	LDA TempY
;	STA <Player_XHi
;	RTS

SetLastScrollDirection:
	LDA <Horz_Scroll
	CMP LastHorzScroll
	BEQ SetLastScrollDirection2

	SUB LastHorzScroll

	LDA <Horz_Scroll_Hi
	SBC LastHorzScrollHi
	BPL SetLastScrollDirection1

	LDA #$01
	STA <Scroll_LastDir
	RTS

SetLastScrollDirection1:
	LDA #$00
	STA <Scroll_LastDir

SetLastScrollDirection2:
EquipNoUse:
	RTS


Try_Use_Equipped:
	LDA Player_Equip
	BEQ SetLastScrollDirection2
	CMP #BADGE_COIN
	BCS SetLastScrollDirection2

	LDA <Pad_Holding
	AND #PAD_DOWN
	BEQ SetLastScrollDirection2

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ SetLastScrollDirection2

	LDA Player_Equip
	JSR DynJump

	.word EquipNoUse
	.word StopWatch
	.word StopWatch
	.word SlowWatch
	.word SlowWatch
	.word PowBlock
	.word PowBlock
	.word PowBlock
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word StarManItem
	.word StarManItem

StopWatch:
	DEC Player_Equip
	LDA #$FF
	STA Stop_Watch
	RTS

SlowWatch:
	LDA #$FF
	STA Slow_Watch
	LDA Player_Equip
	CMP #ITEM_SLOW2
	BNE SlowWatch1
	DEC Player_Equip
	RTS

SlowWatch1:
	LDA #$00
	STA Player_Equip
	RTS
	
PowBlock:
	LDA #$10
	STA Level_Vibration
	LDX #$04

PowBlock0:
	LDA Objects_State, X
	CMP #OBJSTATE_NORMAL
	BNE PowBlock1

	LDA Objects_WeaponAttr, X	 ; Get this object's attribute flags
	AND #ATTR_SHELLPROOF	 
	BNE PowBlock1

	JSR Object_PoofDie

PowBlock1:
	DEX
	BPL PowBlock0


	STA Slow_Watch
	LDA Player_Equip
	CMP #ITEM_POW1
	BEQ PowBlock2
	DEC Player_Equip
	RTS

PowBlock2:
	LDA #$00
	STA Player_Equip
	RTS

StarManItem:
	;LDA Sound_QLevel1
	;ORA #SND_LEVELPOWER
	;STA Sound_QLevel1

	;LDA Sound_QMusic2
	;ORA #MUS2A_INVINCIBILITY
	;STA Sound_QMusic2
	; Player_StarInv = $E0
	;LDA #$e0
	;STA Player_StarInv
	
	;LDA Player_Equip
	;CMP #ITEM_STAR2
	;BNE StarManItem1
	;DEC Player_Equip
	RTS

StarManItem1:
	;LDA #$00
	;STA Player_Equip
	RTS


Player_SuitChange:
	BMI Player_SuitChange7

	CMP #$0f
	BLS Player_SuitChange2	 ; If Player_QueueSuit < $0F (statue enable), jump to PRG008_A3EC

	CMP #$40
	BEQ Player_SuitChange1	 ; If Player_QueueSuit = $40 (make a splash), jump to PRG008_A3E7


Player_SuitChange1:
	INC Player_InWater	; Set "in water" flag
	
	BNE Player_SuitChange7	 	; Jump (technically always) to PRG008_A3F2

Player_SuitChange2:
	; Suit queue
	AND #$0f
	
	LDY #$00
	STY LeftRightInfection
	STY Player_Power
	STY Power_Change

	CMP #$05
	BEQ Player_SuitChange3

	CMP #$09
	BNE Player_SuitChange4

Player_SuitChange3:
	LDY #$06
	STY Power_Change

Player_SuitChange4:
	STA Player_EffectiveSuit
	CMP #$08 
	BCC Player_SuitChange5

	SBC #$05
	STA Special_Suit_Flag
	BNE Player_SuitChange6

Player_SuitChange5:
	LDY #$00
	STY Special_Suit_Flag

Player_SuitChange6:
	TAY	
	DEY		 ; Y = Player_QueueSuit - 1
	STY <Player_Suit ; Store into Player_Suit
	DEC Player_EffectiveSuit

Player_SuitChange7:
	LDX #$00
	STX Player_QueueSuit	  ; Clear Player_QueueSuit
	STX Player_Shell
	STX Poison_Mode
	STX Player_FireDash

Player_SuitChange8:
	LDA Player_Frozen
	BNE Player_SuitChange9

	JSR Level_SetPlayerPUpPal ; Set power up's correct palette

Player_SuitChange9:
	RTS

Player_DetectCeiling:
	LDA Player_ForcedSlide
	BNE Player_HitBlocks1

	LDA Level_Tile_Prop_Head, X
	CMP #TILE_PROP_SOLID_BOTTOM
	BCC Player_SuitChange9

Player_DetectCeiling1:

	LDY Player_Suit
	BEQ Player_DetectCeiling1_1

	LDY Player_IsDucking
	BNE Player_DetectCeiling1_1

Player_DetectCeiling1_1:
	
	LDA Player_BoundTop
	AND #$0F
	CMP #$07
	BCS Player_DetectCeiling2

	LDA #$01
	STA Player_HitCeiling

	LDA Level_Tile_Prop_Head, X
	STA Tile_LastProp
	AND #$F0
	CMP #TILE_PROP_SOLID_BOTTOM
	BEQ Player_HitBlocks

	CMP #TILE_PROP_ITEM
	BNE Player_DetectCeiling2

Player_HitBlocks:
	JSR Level_DoBumpBlocks

Player_HitBlocks1:
	RTS		 ; Return

Player_DetectCeiling2:
	RTS

Player_DetectFloor:
	LDA <Player_YVelZ
	BMI Player_DetectFloorRTS

	LDA Level_Tile_Prop_Floor_Ceiling_Right
	AND #$F0
	CMP #TILE_PROP_SOLID_TOP
	BEQ Player_DetectFloor1

	CMP #TILE_PROP_SOLID_ALL
	BCS Player_DetectFloor1

	LDA Level_Tile_Prop_Floor_Ceiling_Left
	AND #$F0
	CMP #TILE_PROP_SOLID_TOP
	BEQ Player_DetectFloor1

	CMP #TILE_PROP_SOLID_ALL
	BCC Player_DetectFloor2

Player_DetectFloor1:

	LDA <Player_YZ
	SEC
	AND #$0F
	CMP #$06
	BGE Player_DetectFloor2


	LDA <Player_YZ
	AND #$F0
	STA <Player_YZ

	LDA #$00	 
	STA <Player_InAir ; Player NOT mid air
	STA <Player_YVelZ  ; Halt Player vertically
	STA Player_Flip

	LDA <Player_FlipBits
	AND #~SPR_VFLIP
	STA <Player_FlipBits

Player_DetectFloorRTS:
	RTS

Player_DetectFloor2:
	LDA <Player_OnObject
	BNE Player_DetectFloorRTS

	LDA #$01
	STA <Player_InAir
	RTS

Player_PitDeath:
	LDA <Player_SpriteX
	BEQ Player_CheckPit

	CMP #$04
	BCS Player_CheckPit

	JMP Player_Die

Player_CheckPit:
	LDA <Player_YHiZ
	BEQ Player_PitDeath2
	BMI Player_PitDeath2

	LDA <Player_YZ
	CMP #$C0
	BCC Player_PitDeath2

	LDA Player_Equip
	CMP #ITEM_CATCH
	BNE Player_PitDeath1

	LDA #$00
	STA Player_Equip

	LDA #$80
	STA Player_FlyTime

	LDA #$04
	STA Player_QueueSuit

	LDA #$80
	STA <Player_YVelZ
	STA <Player_YZ
	BNE Player_PitDeath2

Player_PitDeath1:
	JSR Player_Die	 ; Begin death sequence

	LDA #$00
	STA Player_EffectiveSuit
	; This jumps the initial part of the death sequence
	LDA #$c0
	STA Event_Countdown ; Event_Countdown = $C0

	LDA #$02
	STA <Player_IsDying	; Player_IsDying = 2 (already dropped off screen)

Player_PitDeath2:
	RTS

Player_DetermineAir:
	LDA Player_InWater
	ORA Player_Vehicle
	BEQ Player_AirChanges1

	LDA Top_Of_Water
	BNE Player_AirChanges1

	LDA Player_EffectiveSuit
	CMP #$04
	BEQ Player_AirChanges1

Player_AirChanges0:
	LDA #$FF
	STA Air_Change
	RTS

Player_AirChangesFast:
	LDA #$FE
	STA Air_Change
	RTS

Player_AirChanges1:
	LDA Level_Tile_Prop_Head
	CMP #TILE_PROP_DEPLETE_AIR
	BEQ Player_AirChangesFast

	CMP #(TILE_PROP_DEPLETE_AIR | TILE_PROP_FOREGROUND)
	BEQ Player_AirChangesFast

Player_AirChanges2:
	RTS

Player_ToggleBlock:
	LDY <Temp_Var12		 
	LDA Tile_LastValue	; prevent double collecting
	EOR #$01
	STA [Map_Tile_AddrL],Y	; prevent double collecting
	
	JSR Level_QueueChangeBlock
	RTS

Tile_NoInteract:
	RTS

Player_BgTileInteract:
	LDA Tile_LastProp
	AND #$0F

	JSR DynJump

	.word Tile_NoInteract	;
	.word Bg_HurtPlayer		; TILE_PROP_HARMFUL		= $01 ;
	.word Tile_NoInteract	; TILE_PROP_DEPLETE_AIR	= $02 ;
	.word Tile_NoInteract	; TILE_PROP_MOVE_LEFT		= $03 ;
	.word Tile_NoInteract	; TILE_PROP_MOVE_RIGHT	= $04 ;
	.word Tile_NoInteract	; TILE_PROP_MOVE_UP		= $05 ;
	.word Tile_NoInteract	; TILE_PROP_MOVE_DOWN		= $06 ;
	.word Tile_NoInteract	; TILE_PROP_TREASURE		= $07 ;
	.word Tile_NoInteract	; TILE_PROP_LOCK			= $08 ;
	.word Tile_NoInteract	; TILE_PROP_OBJECTINTERACT			= $09; 
	.word Bg_ActivateTrap	; TILE_PROP_TRAP			= $0A ;
	.word Tile_NoInteract	; TILE_PROP_CLIMBABLE		= $0B ;
	.word Bg_Coin			; TILE_PROP_COIN			= $0C ;
	.word Tile_NoInteract	; TILE_PROP_DOOR			= $0D ;
	.word Bg_Cherry			; TILE_PROP_CHERRY		= $0E ;
	.word Bg_PowerCoin	; TILE_PROP_HIDDEN_BLOCK	= $0F ;

Bg_HurtPlayer:
	LDA Tile_LastProp
	CMP #TILE_PROP_WATER
	BCC Bg_HurtPlayer1

	LDA Player_EffectiveSuit
	CMP #$08
	BEQ Bg_HurtPlayer2

Bg_HurtPlayer1:
	JMP Player_GetHurt

Bg_HurtPlayer2:
	RTS

Bg_ActivateTrap:
	LDA #$01
	STA TrapSet
	RTS

Bg_Coin:
	LDA Block_NeedsUpdate
	BNE Bg_CoinRTS

	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	INC Coins_Earned
	LDA #$00
	STA Tile_LastProp
	
	JSR SpecialObject_FindEmpty
	BCC Bg_CoinToggleBlock

	LDA #SOBJ_COINSPARKLE
	STA SpecialObj_ID, Y

	LDA #$0C
	STA SpecialObj_Timer, Y

	LDA Tile_X
	AND #$F0
	ORA #$04
	STA SpecialObj_X, Y

	LDA Tile_Y
	AND #$F0
	STA SpecialObj_Y, Y

Bg_CoinToggleBlock:
	JMP Player_ToggleBlock

Bg_CoinRTS:
	RTS

Bg_Cherry:
	LDA Block_NeedsUpdate
	BNE Bg_CherryRTS

	LDA Cherries
	CMP #99
	BCS Bg_CherryRTS

	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1

	INC Cherries

	LDA #$00
	STA Tile_LastProp
	JMP Player_ToggleBlock

Bg_CherryRTS:
	RTS

Bg_PowerCoin:
	LDA Block_NeedsUpdate
	BNE Bg_PowerCoinRTS

	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

	LDA #$50
	STA Player_Power
	
	LDA #$00
	STA Tile_LastProp

	JMP Player_ToggleBlock

Bg_PowerCoinRTS:
	RTS


Player_BodyHeadTileInteract:

	LDA Tile_LastProp
	AND #$0F

	JSR DynJump

	.word Tile_NoInteract	;
	.word Tile_NoInteract		; TILE_PROP_HARMFUL		= $01 ;
	.word Tile_NoInteract	; TILE_PROP_DEPLETE_AIR		= $02 ;
	.word ApplyTileMove		; TILE_PROP_MOVE_LEFT		= $03 ;
	.word ApplyTileMove		; TILE_PROP_MOVE_RIGHT		= $04 ;
	.word ApplyTileMove		; TILE_PROP_MOVE_UP			= $05 ;
	.word ApplyTileMove		; TILE_PROP_MOVE_DOWN		= $06 ;
	.word Body_Treasure		; TILE_PROP_TREASURE		= $07 ;
	.word Tile_NoInteract	; TILE_PROP_LOCK			= $08 ;
	.word Tile_NoInteract	; TILE_PROP_OBJECTINTERACT			= $09; 
	.word Tile_NoInteract	; TILE_PROP_TRAP			= $0A ;
	.word BodyHead_Climb	; TILE_PROP_CLIMBABLE		= $0B ;
	.word Bg_Coin			; TILE_PROP_COIN			= $0C ;
	.word BodyHead_Door	; TILE_PROP_DOOR					= $0D ;
	.word Bg_Cherry			; TILE_PROP_CHERRY			= $0E ;
	.word Bg_PowerCoin	; TILE_PROP_HIDDEN_BLOCK	= $0F ;

Body_Treasure:
	LDA TreasureBox_Disabled
	BNE Body_TreasureRTS

	LDX <TileXIndex
	CPX #BODY_INDEX
	BNE Body_TreasureRTS

	LDA <Pad_Input
	AND #PAD_B
	BEQ Body_TreasureRTS

	LDA Block_NeedsUpdate
	BNE Body_TreasureRTS
	
	LDA Tile_Y
	AND #$F0
	SUB #$08
	STA Coin_Y

	LDA Tile_X
	AND #$F0
	ORA #$04
	STA Coin_X

	JSR Produce_Coin

	LDA #$04
	ADD Coins_Earned_Buffer
	STA Coins_Earned_Buffer
	JMP Player_ToggleBlock

Body_TreasureRTS:
	RTS

BodyHead_Climb:
	RTS

BodyHead_Door:

	CPX #$01
	BNE Door_Done 

	LDA Player_IsHolding
	BEQ Door_PadUp
	
	CMP #OBJ_KEY
	BNE Door_Done

Door_PadUp:
	LDA <Pad_Input
	AND #PAD_UP
	BEQ Door_Done	 ; If Player is not pressing up in front of a door, jump to PRG008_A86C

	LDA Player_OnPlatform
	BNE Door_PlayerStanding

	LDA <Player_InAir
	BNE Door_Done	 ; If Player is mid air, jump to PRG008_A86C

Door_PlayerStanding:
	LDA <Player_X
	ADD #$08
	STA <Player_X

	LDA <Player_XHi
	ADC #$00
	STA <Player_XHi

	LDA <Player_X
	AND #$F0	 ; Lock to nearest column (place directly in doorway)
	STA <Player_X	 ; Update Player_X

	LDA #$00
	STA <Player_XVelZ

	INC Level_JctCtl ; Set appropriate value to Level_JctCtl

	LDA #$00
	STA Level_PipeMove

	JMP Do_Pointer_Effect

Door_Done:
	RTS

Player_SolidTileInteract: 
	LDA Tile_LastProp
	AND #$0F
	JSR DynJump

	.word Solid_CheckBump	;
	.word Solid_CheckHurt	; TILE_PROP_HARMFUL		= $01
	.word Solid_Slick		; TILE_PROP_SLICK		= $02
	.word ApplyTileMove		; TILE_PROP_MOVE_LEFT	= $03
	.word ApplyTileMove		; TILE_PROP_MOVE_RIGHT	= $04
	.word ApplyTileMove		; TILE_PROP_MOVE_UP		= $05
	.word ApplyTileMove		; TILE_PROP_MOVE_DOWN	= $06
	.word Solid_ThinIce	; TILE_PROP_THIN_ICE	= $07
	.word Tile_NoInteract	; TILE_PROP_VPIPE_LEFT	= $08
	.word Tile_NoInteract	; TILE_PROP_VPIPE_RIGHT	= $09
	.word Tile_NoInteract	; TILE_PROP_HPIPE_BOTTOM= $0A
	.word Tile_NoInteract	; TILE_PROP_CLIMBABLE	= $0B
	.word Solid_MushroomBlock	; TILE_PROP_SOLID_OBJECTINTERACT	= $0C
	.word Tile_NoInteract	; TILE_PROP_STONE		= $0D
	.word Solid_PSwitch		; TILE_PROP_PSWITCH		= $0E
	.word Solid_ESwitch		; TILE_PROP_ESWITCH		= $0F

Solid_CheckBump:
	LDX <TileXIndex
	CPX #HEAD_FEET_LEFT_INDEX
	BEQ Solid_CheckBump1

	CPX #HEAD_FEET_RIGHT_INDEX
	BNE Solid_CheckBumpRTS

Solid_CheckBump1:
	LDA Tile_LastValue
	AND #$3F
	BNE Solid_CheckBumpRTS

	
	LDA <Player_InAir
	BNE Solid_CheckBumpRTS

	LDA #$D0
	STA <Player_YVelZ
	STA <Player_InAir

Solid_CheckBumpRTS:
	RTS

Solid_CheckHurt:
	LDA Player_Shell
	BEQ Solid_GetHurt

	LDA <Player_YVelZ
	BMI Solid_GetHurt

	LDX <TileXIndex
	CPX #HEAD_FEET_LEFT_INDEX
	BEQ  Solid_HurtBump

	CPX #HEAD_FEET_RIGHT_INDEX
	BNE Solid_GetHurt

Solid_HurtBump:
	LDA #$D0
	STA <Player_YVelZ
	STA <Player_InAir

	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer
	INC Player_FlashInv
	RTS

Solid_GetHurt:
	JMP Player_GetHurt

Solid_Slick:
	LDA #$02
	STA Player_Slippery
	RTS

Solid_ThinIce:
	LDX <TileXIndex
	CPX #HEAD_FEET_LEFT_INDEX
	BCC Solid_ThinBreakIce

	CPX #HEAD_WALL_INDEX
	BCS Solid_ThinIceRTS
	
	LDA <Player_YVelZ
	BPL Solid_ThinIceGround

Solid_ThinBreakIce:
	LDA Block_NeedsUpdate
	BNE Solid_ThinIceRTS

	LDA Tile_X
	AND #$F0
	STA Debris_X

	LDA Tile_Y
	AND #$F0
	SUB #$08
	STA Debris_Y

	JSR Common_MakeIce
	
	LDA Tile_LastValue
	ADD #$01
	JSR Level_QueueChangeBlock

Solid_ThinIceRTS:
	RTS

Solid_ThinIceGround:
	LDA #$02
	STA Player_Slippery

	LDA Player_IsHolding
	BEQ Solid_ThinIceRTS
	JMP Solid_ThinBreakIce

Solid_MushroomBlock:

	LDA MushroomBlocks_Enabled
	BEQ Solid_MushroomBlockRTS

	LDA <TileXIndex
	CMP #HEAD_FEET_LEFT_INDEX
	BEQ Solid_MushroomBlockGrab

	CMP #HEAD_FEET_RIGHT_INDEX
	BNE Solid_MushroomBlockRTS

Solid_MushroomBlockGrab:
	LDA Block_NeedsUpdate
	BNE Solid_MushroomBlockRTS

	LDA <Pad_Input
	AND #PAD_B
	BEQ Solid_MushroomBlockRTS

	LDX #$02

Solid_MushroomBlockNext:	
	LDA Objects_State + 5, X
	BEQ Solid_MushroomBlockMake

	DEX
	BPL Solid_MushroomBlockNext
	BMI Solid_MushroomBlockRTS

Solid_MushroomBlockMake:
	LDA #OBJ_MUSHROOMBLOCK
	STA Objects_ID + 5, X

	LDA #OBJSTATE_INIT
	STA Objects_State + 5, X

	LDA <Player_X
	STA <Objects_XZ + 5, X

	LDA <Player_XHi
	STA <Objects_XHiZ + 5, X

	LDA <Player_YZ
	ADD #$08
	STA <Objects_YZ + 5, X

	LDA <Player_YHiZ
	ADC #$00
	STA <Objects_YHiZ + 5, X

	JMP Player_ToggleBlock

Solid_MushroomBlockRTS:
	RTS	

Solid_PSwitch:
	LDA <Player_YVelZ
	BNE Solid_PSwitchRTS

	LDA <TileXIndex
	CMP #HEAD_FEET_LEFT_INDEX
	BEQ Solid_PSwitch1

	CMP #HEAD_FEET_RIGHT_INDEX
	BNE Solid_PSwitchRTS

Solid_PSwitch1:
	LDA Block_NeedsUpdate
	BNE Solid_PSwitchRTS

	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #$80	 
	STA Level_PSwitchCnt	 ; Level_PSwitchCnt = $80 (duration of switch)

	LDA #$08
	STA Level_Vibration

	; Play P-Switch song
	LDA #MUS2B_PSWITCH
	STA Sound_QMusic2

	JMP Player_ToggleBlock

Solid_PSwitchRTS:
	RTS

Solid_ESwitch:
	LDA <TileXIndex
	CMP #HEAD_FEET_LEFT_INDEX
	BEQ Solid_ESwitch1

	CMP #HEAD_FEET_RIGHT_INDEX
	BNE Solid_ESwitchRTS

Solid_ESwitch1:
	LDA Block_NeedsUpdate
	BNE Solid_ESwitchRTS

	LDA Tile_LastValue
	STA EventSwitch

	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1
	
	LDA #$08
	STA Level_Vibration

	JMP Player_ToggleBlock

Solid_ESwitchRTS:
	RTS


Player_NextTile:
	LDY <TileYIndex
	LDX <TileXIndex

	LDA TileAttrAndQuad_OffsFlat,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)

	LDA TileAttrAndQuad_OffsFlat+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope
	JSR Player_TileInteractions

	LDX <TileXIndex
	LDA Tile_LastProp
	STA Level_Tile_Prop_Head,X	 ; Store it

	DEC <TileYIndex
	DEC <TileYIndex
	DEC <TileXIndex
	RTS


Fox_DashDir: .byte $D0, $30, SPR_HFLIP, $00, $01, $00
Player_KillDash_NoFXJump:
	JMP Player_KillDash_NoFX

Fox_BurnMode:
	LDA Player_FireDash			; we're already in fireball mode, let's continue doing velocity checks
	BEQ Try_FireBall

	LDA Player_EffectiveSuit
	CMP #MARIO_FOX
	BEQ Fox_BurnModeCont
	JMP Player_KillDash_NoFX

Fox_BurnModeCont:
	LDA Player_InWater			; if we're a fireball and hit water, kill it		
	BEQ Fox_BurnModeCont1
 	
	JMP Player_KillDash_NoFX

Fox_BurnModeCont1:
	LDA <Pad_Holding
	AND #PAD_B
	BEQ Player_KillDash_NoFXJump

	LDA Player_Power
	BEQ Player_KillDash_NoFXJump

	JMP ContinueDash

Try_FireBall:					; not a fireball, so let's try it!
	LDA Player_EffectiveSuit
	CMP #MARIO_FOX
	BNE Fox_BurnModeRTS

	LDA Player_Power
	BEQ Fox_BurnModeRTS

	LDA Player_InWater			
	BNE Fox_BurnModeRTS		; can't go into burning mode in sand or water

	LDA Player_TailAttack
	BEQ Fox_BurnModeRTS

	CMP #$12
	BCS Fox_BurnModeRTS
		
	LDA <Pad_Input			; we have! This finds the direction to send based on input
	AND #(PAD_B)
	BEQ	Fox_BurnModeRTS
	
	LDA #$10				; poof effect, we're now in the air	
	STA Player_SuitLost
	STA Player_FireDash

	LDA Sound_QLevel2		; flame sound effect
	ORA #SND_LEVELFLAME
	STA Sound_QLevel2

ContinueDash:
	LDY Player_LastDirection
	STY Player_Direction

	LDA Fox_DashDir, Y
	STA <Player_XVelZ
	STA <Player_InAir

	LDA Fox_DashDir + 2, Y
	STA Player_FlipBits

	LDA #$00
	STA <Player_YVelZ

	LDA #$F4
	STA Power_Change

Fox_BurnModeRTS:
	RTS

Player_KillDash:
	
	LDA #$10			; if we reach here, we hit a wall, shake the ground!
	STA Level_Vibration	; Level_Vibration = $10 (little shake effect)

	; Wham! sound effect
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDY #$00
	LDA <Player_FlipBits
	BNE Player_BounceLeft

	INY
Player_BounceLeft:
	LDA Bounce_Direction, Y
	STA <Player_XVelZ

	LDA <Player_X
	ADD Bounce_Direction + 2, Y
	STA <Player_X

	LDA <Player_XHi
	ADC Bounce_Direction + 4, Y
	STA <Player_XHi

Player_KillDash_NoFX:
	LDA #$00			; kills burn mode completely
	STA Player_FireDash

	LDA #$10					
	STA Player_SuitLost

	LDA #$06
	STA Power_Change

	LDA <Player_FlipBits
	EOR #$40
	STA <Player_FlipBits
	RTS

Bounce_Direction
	.byte $20, $E0
	.byte $02, $FE
	.byte $00, $FF

Player_HandleWater:

	LDA Level_Tile_Prop_Head
	JSR Level_CheckIfTileUnderwater

	BCS Player_HandleWater1

	TYA		 
	BNE Player_HandleWater10	

Player_HandleWater1:

	LDA Player_InWater
	BNE Player_HandleWater2
	JMP Player_HandleWater12	

Player_HandleWater2:
	LDA <Player_InAir
	BNE Player_HandleWater3	 

	BCS Player_HandleWater12	 
	BCC Player_HandleWater9	 

Player_HandleWater3:
	BCS Player_HandleWater4	

	LDA <Player_YVelZ
	BMI Player_HandleWater6	

Player_HandleWater4:

	ROR A		
	STA <Temp_Var16	

	LDA Level_Tile_Prop_Floor_Ceiling_Left
	JSR Level_CheckIfTileUnderwater

	BCS Player_HandleWater5

	TYA
	BEQ Player_HandleWater9

Player_HandleWater5:
	LDA <Temp_Var16
	BMI Player_HandleWater10	

Player_HandleWater6:
	LDY <Player_YVelZ
	CPY #-$0C
	BGS Player_HandleWater7	 

	LDY #-$0C

Player_HandleWater7:
	LDA <Counter_1
	AND #$07
	BNE Player_HandleWater8

	INY		 

Player_HandleWater8:
	STY <Player_YVelZ 

	LDA <Pad_Input
	AND #~PAD_A
	STA <Pad_Input	 

	LDA <Pad_Holding
	TAY		 

	AND #~PAD_UP
	STA <Pad_Holding 

	LDA #$01
	STA Top_Of_Water

	TYA		 
	AND #(PAD_A)
	CMP #(PAD_A)
	BNE Player_HandleWater12	 

	; Player wants to exit water!
	LDA #-$34
	STA <Player_YVelZ 

	LDA #$00
	STA <Temp_Var15

Player_HandleWater9:
	LDY #$00	 
	STY Player_SwimCnt 

Player_HandleWater10:
	LDY <Temp_Var15
	CPY Player_InWater
	BEQ Player_HandleWater12	 

	JSR Player_Splash

	LDY <Temp_Var15

Player_HandleWater11:
	TYA
	STA Player_InWater	
	BEQ Player_HandleWater12

	LDY <Player_YVelZ
	BMI Player_HandleWater12
	STA <Player_YVelZ

Player_HandleWater12:
	LDA Player_InWater
	BEQ Player_HandleWaterRTS

	LDA #$00
	STA Player_Flip

	LDA LeftRightInfection
	ORA Player_Yolked
	ORA Player_Oiled
	BEQ Player_HandleWaterRTS

	LDA #$17
	STA Player_SuitLost

	LDA Player_EffectiveSuit
	ADD #$01
	STA Player_QueueSuit

	LDA #$00
	STA LeftRightInfection
	STA Player_Yolked
	STA Player_Oiled

Player_HandleWaterRTS:
	RTS

Pipe_PadDirForEnter:	
	.byte PAD_RIGHT, PAD_LEFT	; What to press to enter a horizontal pipe; pad right and left, respectively
	.byte PAD_DOWN, PAD_UP		; What to press to enter a vertical pipe; pad down and up, respectively

PRG008_BC43:
	.byte $09, $04, $04	; Offset applied to Player_X when: in air or level is sloped, Player is NOT small, Player is small

Player_HandlePipe:
	LDA <Player_YZ
	LDA <Player_InAir
	BNE PRG008_BCAA	 	; If Player is mid air, jump to PRG008_BCAA

	LDA Level_Tile_Prop_Wall_Lower	 ; Get tile near head...
	CMP #TILE_PROP_SOLID_TOP
	BGE PRG008_BC79

	JMP PRG008_BCAA

PRG008_BC79:
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_HPIPE_BOTTOM)
	BEQ PRG008_BC7A

	JMP PRG008_BCAA

PRG008_BC7A:
	LDX #$00

	LDA <Player_X
	AND #$0f	
	CMP #$08	
	BLS PRG008_BC92	 ; If Player is on left half of tile, jump to PRG008_BC92
 
	INX		 ; X = 1

PRG008_BC92:
	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ PRG008_BCAA	 ; If Player is NOT pressing correct direction to enter pipe, jump to PRG008_BCAA

	; Correct direction to enter pipe...

	TYA
	BNE PRG008_BCA4	 ; If pipe type (Y) is not 0, jump to PRG008_BCA4

	LDY #$01	 ; Y = 1 

	LDA Level_HorzScrollLock	
	BEQ PRG008_BCA4	 ; If not currently junctioning, jump to PRG008_BCA4

	DEY		 ; Y = 0 

PRG008_BCA4:
	JSR PipeEntryPrepare	 ; Prepare pipe entry

PRG008_BCA7:
	RTS

PRG008_BCAA:

	LDX #$02	 ; X = 2
	LDA Level_Tile_Prop_Floor_Ceiling_Left	 

	LDY <Player_InAir
	BEQ PRG008_BCC4	 ; If Player is NOT mid air, jump to PRG008_BCC4

	LDY Player_HitCeiling
	BEQ Player_HandlePipeRTS	 ; If Player has not just hit off a ceiling, jump to PRG008_BCA7

	LDY Player_IsDucking
	BNE Player_HandlePipeRTS	 ; If Player is NOT ducking, jump to PRG008_BCC0

PRG008_BCC0:
	INX		 ; X = 3

	LDA Level_Tile_Prop_Floor_Ceiling_Right

PRG008_BCC4:
	STX <Temp_Var3		 ; Store pipe mode -> Temp_Var3
	CMP #TILE_ITEM_COIN
	BGE Player_HandlePipeRTS

	CMP #TILE_PROP_SOLID_ALL
	BCC Player_HandlePipeRTS

	AND #$0F
	STA <Temp_Var1

	LDA #TILE_PROP_VPIPE_RIGHT
	SEC
	SBC <Temp_Var1
	CMP #$02
	BGE Player_HandlePipeRTS

PRG008_BCD6:
	TAY		 ; Tile index result -> 'A'
	STY <Temp_Var1	 ; Store pipe type -> Temp_Var1

	AND #$01	 ; Determine left vs right tile (odd/bit 0 indicates right tile)
	ASL A
	ASL A
	ASL A
	ASL A		 ; Multiply 0/1 by 16
	STA <Temp_Var2	 ; Temp_Var2 = 0 or 16

	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ Player_HandlePipeRTS	 ; If Player is NOT pressing the correct direction to enter pipe, jump to PRG008_BD4B

	LDA Level_PipeMove
	BNE Player_HandlePipeRTS	 ; If Player is already in pipe, jump to PRG008_BD4B

	LDY #$00	 ; Y = 0 (Player is mid-air or level is sloped)

	LDA <Player_InAir
	BNE PRG008_BD1F	 ; If Player is mid air or this is a sloping level, jump to PRG008_BD1F

	INY		 ; Y = 1 (Player is NOT small)
	LDA <Player_Suit
	BNE PRG008_BD1F	 ; If Player is NOT small, jump to PRG008_BD1F

	INY		 ; Y = 2 (Player is small)

PRG008_BD1F:
	LDA <Player_X	
	AND #$0f	
	PHA		 ; Save Player's relative X across tile

	ADD PRG008_BC43,Y ; Add appropriate offset
	AND #$10	 ; Check if on "odd" tile (only true on Player_X 16, 48, 80, etc.) AKA right tile
	BNE PRG008_BD30	 ; If so, jump to PRG008_BD30

	PLA		 ; Restore Player's relative X across tile
	ORA #$F0	 ; Make negative, sort of
	PHA		 ; Save it again

PRG008_BD30:
	PLA		 ; Restore Player's relative X across tile
	ADD <Temp_Var2	 ; 0 or 16, left or right tile
	SUB #3	 
	CMP #10
	BGE Player_HandlePipeRTS	 ; If Player_X >= 10 after subtracting 3 (??), jump to PRG008_BD4B

	LDA <Temp_Var1	 ; Get pipe type
	LSR A		 
	TAY		 
	JSR PipeEntryPrepare	 ; Prepare entry into pipe!
	JSR PipeMove_SetPlayerFrame	 ; Update Player frame!
	JSR Player_Draw29	 ; Draw Player

	; Do not return to caller!!
	PLA		 
	PLA
Player_HandlePipeRTS:
	RTS		 ; Return

Climbing_XVel: .byte $00, $10, $F0, $00
Climbing_YVel: .byte $00, $10, $F0, $00

Player_HandleClimbing:
	LDA Player_IsClimbingObject	
	BEQ Player_HandleClimbingCheck
	STA Player_IsClimbing
	JMP Player_DoClimbing

Player_HandleClimbingCheck:
	LDA Player_InWater
	ORA Player_IsHolding
	ORA Player_FireDash
	ORA Player_Shell
	BEQ Player_HandleClimbing1

Player_NotClimbing:
	LDA #$00
	STA Player_IsClimbing
	RTS

Player_HandleClimbing1:
	LDA Level_Tile_Prop_Head
	AND #$0F
	CMP #TILE_PROP_CLIMBABLE
	BNE Player_NotClimbing

Player_HandleClimbing2:
	LDA Player_IsClimbing
	BNE Player_DoClimbing

	LDA <Player_YVelZ
	BMI Player_NotClimbing

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ Player_NotClimbing

Player_DoClimbing:
	LDA <Pad_Input
	AND #PAD_A
	BEQ Player_DoClimbing1

	LDA #$00
	STA Player_IsClimbing
	STA Player_IsClimbingObject
	JMP DIRECT_TO_JUMP

Player_DoClimbing1:
	LDA #$01
	STA Player_IsClimbing

	LDA <Player_FlipBits
	AND #~SPR_VFLIP
	STA <Player_FlipBits

	LDA #$00
	STA Player_Flip
	STA <Player_XVelZ
	STA <Player_YVelZ

Player_DoClimbing2:
	LDA <Pad_Holding
	AND #$0C
	LSR A
	LSR A
	TAX

	LDA Climbing_YVel, X
	STA <Player_YVelZ
	STA Player_EffYVel

	LDA <Pad_Holding
	AND #$03
	TAX

	LDA Climbing_XVel, X
	STA <Player_XVelZ
	STA Player_EffXVel

	LDA <Player_YVelZ
	BPL Player_DoClimbing2_0

	LDA #$08
	STA <Temp_Var11

	LDA #$04
	LDX <Player_Suit
	BNE Player_DoClimbing1_1

	LDA #$10

Player_DoClimbing1_1:
	STA <Temp_Var10

	LDA Player_IsClimbingObject
	BNE Player_DoClimbing2_0

	JSR Player_GetTileAndSlope
	AND #$0F
	CMP #TILE_PROP_CLIMBABLE
	BEQ Player_DoClimbing2_0

	JSR Player_ApplyXVelocity
	JMP Player_DoClimbing2_1

Player_DoClimbing2_0:

	JSR Player_ApplyXVelocity
	JSR Player_ApplyYVelocity

Player_DoClimbing2_1:
	JSR Player_DoClimbAnim	 ; Animate climbing
	JSR Player_Draw29	 ; Draw Player
	JSR Climbing_Pointer
	PLA
	PLA

Player_DoClimbingRTS:
	RTS

Player_PoisonMode:
	LDA Player_Vehicle
	BNE Cant_Poison_Mode

	LDA Poison_Mode
	BNE Continue_Poison_Mode

	LDA Player_Power
	CMP #$50
	BNE Cant_Poison_Mode

	LDA <Pad_Holding
	AND #PAD_DOWN
	BEQ Cant_Poison_Mode

	LDA <Pad_Input
	AND #PAD_B
	BEQ Cant_Poison_Mode

	LDA #SND_LEVELSHOE
	STA Sound_QLevel1

	INC Poison_Mode

	LDA #$F0
	STA Power_Change

	LDA #$02
	STA Player_StarInv

Cant_Poison_Mode:
	RTS

Continue_Poison_Mode:	
	LDA <Pad_Holding
	AND #PAD_B
	BEQ Stop_Poison_Mode

	LDA Player_Power
	BEQ Stop_Poison_Mode

	LDA #$02
	STA Player_StarInv
	RTS

Stop_Poison_Mode:
	LDA #$08
	STA Power_Change
	STA Player_StarInv

	LDA #$00
	STA Poison_Mode
	RTS

Player_CheckForeground:
	
	LDX #$05

Player_CheckForeground1:
	LDA Level_Tile_Prop_Head, X
	CMP #(TILE_PROP_SOLID_TOP)
	BCS Player_CheckForeground2

	AND #(TILE_PROP_FOREGROUND)
	BEQ Player_CheckForeground2

	LDA #$01
	STA Player_Behind
	RTS

Player_CheckForeground2:
	DEX
	BPL Player_CheckForeground1

	LDA Level_Tile_Prop_Body
	AND #(TILE_PROP_SOLID_TOP)
	BNE Player_CheckForegroundRTS

	LDA #$00
	STA Player_Behind

Player_CheckForegroundRTS:	
	RTS

Check_Timers:
	LDA Kill_Tally_Ticker
	BNE Killy_TallyTick

	STA Kill_Tally
	BEQ Check_SlowWatch

Killy_TallyTick:	
	DEC Kill_Tally_Ticker

Check_SlowWatch:
	LDA Slow_Watch
	BEQ Check_StopWatch

	LDA <Counter_1
	AND #$01
	BNE Check_StopWatch

	DEC Slow_Watch

Check_StopWatch:
	LDA Stop_Watch
	BEQ Check_TimersRTS

	LDA <Counter_1
	AND #$01
	BEQ Check_TimersRTS

	DEC Stop_Watch

Check_TimersRTS:	
	RTS


Player_Splash:
	LDA Player_Vehicle
	BNE Check_TimersRTS

	LDY #$05

Player_FindSplash:
	LDA Objects_State, Y
	BEQ Player_MakeSplash

	INY
	CPY #$08
	BNE Player_FindSplash

	RTS

Player_MakeSplash:
	LDA <Player_X
	STA Objects_XZ, Y

	LDA <Player_XHi
	STA Objects_XHiZ, Y

	LDA Player_BoundTop
	SUB #$08
	AND #$F0
	STA Objects_YZ, Y

	LDA Player_BoundTopHi
	SBC #$00
	STA Objects_YHiZ, Y

	LDA #OBJ_WATERSPLASH
	STA Objects_ID, Y

	LDA #$0F
	STA Objects_Timer, Y

	LDA #OBJSTATE_FRESH
	STA Objects_State, Y

	LDA #$02
	STA Objects_SpritesRequested, Y

	LDA #SPR_PAL2
	STA Objects_SpriteAttributes, Y

	LDA #$00
	STA Objects_Orientation, Y
	STA WaterSplash_IsOil, Y
	RTS		 ; Return

Player_SetHolding: 
	LDA Objects_BeingHeld
	ORA Objects_BeingHeld + 1
	ORA Objects_BeingHeld + 2
	ORA Objects_BeingHeld + 3
	ORA Objects_BeingHeld + 4
	ORA Objects_BeingHeld + 5
	ORA Objects_BeingHeld + 6
	ORA Objects_BeingHeld + 7
	STA Player_IsHolding
	RTS
