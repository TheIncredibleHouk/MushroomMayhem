; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-05 22:51:55.464428532 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
Level_TilesetIdx_ByTileset:
	; Basically Level_TilesetIdx is just Level_Tileset - 1
	.byte $FF	;  0 Map (UNUSED)
	.byte $00	;  1 Plains style
	.byte $01	;  2 Mini Fortress style
	.byte $02	;  3 Hills style
	.byte $03	;  4 High-Up style
	.byte $04	;  5 pipe world plant infestation
	.byte $05	;  6 water world
	.byte $06	;  7 Toad House
	.byte $07	;  8 Vertical pipe maze
	.byte $08	;  9 desert levels
	.byte $09	; 10 Airship
	.byte $0A	; 11 Giant World
	.byte $0B	; 12 Ice level
	.byte $0C	; 13 Sky level
	.byte $0D	; 14 Underground

	; Defines 4 frames of animation to use while Player walks
Player_WalkFramesByPUp:
	.byte PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1, PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1	; 0 - Small
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 1 - Big
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 2 - Fire
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 3 - Leaf
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 4 - Frog
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 5 - Tanooki
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 6 - Hammer

	; Frames used during the "power up" sequence from small -> Big
Player_GrowFrames:
	.byte PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2
	.byte PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY
	.byte PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY

	; Stores frame to be used while traversing a pipe
	; Order is small, small + kuribo, other, other + kuribo
PipeMove_Frame:
	.byte PF_INPIPE_SMALL, PF_INPIPE_SMALLKURIBO, PF_INPIPE_BIG, PF_INPIPE_BIGKURIBO

	; Frame used when Player is "skidding"
Player_SkidFrame:
	.byte PF_SKID_SMALL, PF_SKID_BIG	; First value is for small, the other for everything else

Player_SwimActiveFrames:
	; Everything but small
	.byte PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2, PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2	
	; Small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2

	; Player sprite frames for swimming; first four are all power-up/suits
	; EXCEPT small, and the other four are for small
Player_SwimIdleFrames:
	.byte PF_SWIMIDLE_BIG, PF_SWIMIDLE_BIG+1, PF_SWIMIDLE_BIG-8, PF_SWIMIDLE_BIG+1	; Everything but small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+3, PF_SWIMIDLE_SMALL+3	; Small

	; Player's tail attack frames
Player_TailAttackFrames:
	.byte PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+1, PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+2, PF_TAILATKGROUND_BASE	; On ground
	.byte PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-5, PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-4, PF_TAILATKINAIR_BASE	; In air

	; Frames for when Player is in Kuribo's shoe
Player_KuriboFrame:
	.byte PF_KURIBO_SMALL, PF_KURIBO_BIG	; First value is for small, the other for everything else

	; Player duck frame
Player_DuckFrame:
	; First value is for everything EXCEPT Raccoon power; value on right is for raccoon power
	.byte PF_DUCK_NOTRACCOON,  PF_DUCK_RACCOON

;Player_Shell_Mode_Frames:
;	.byte $35, $3D, $31, $1D
	
	; The three sprite frames for when Player shoots a fireball/hammer
Player_FireOnGround:	.byte PF_THROWONGROUND_BASE, PF_THROWONGROUND_BASE+3, PF_THROWONGROUND_BASE+2
Player_FireInAir:	.byte PF_THROWINAIR_BASE, PF_THROWINAIR_BASE+1, PF_THROWINAIR_BASE+2

	; Frames used while frog hopping
Player_FrogHopFrames:
	.byte PF_FROGHOP_BASE, PF_FROGHOP_BASE+2, PF_FROGHOP_BASE+1, PF_FROGHOP_BASE

	; Frames used when Player is running at high speed!
Player_SpreadEagleFrames:
	.byte PF_RUNBIG_BASE, PF_RUNBIG_BASE+1, PF_RUNBIG_BASE+2, PF_RUNBIG_BASE+1	; Player is not small
	.byte PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1, PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1	; Player is small


	; The raccoon power uses rotations of three frames based on different conditions
Player_TailWagFlyFrames:
	.byte PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE	; Flying
	.byte PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE	; Flying, apex
	.byte PF_JUMPRACCOON, PF_JUMPRACCOON, PF_JUMPRACCOON			; Jump/fall
	.byte PF_TAILWAGFALL+2, PF_TAILWAGFALL+1, PF_TAILWAGFALL		; Flutter wag

Player_HoldingFrames:
	.byte PF_HOLDBIG_BASE, PF_HOLDBIG_BASE+1, PF_HOLDBIG_BASE+2, PF_HOLDBIG_BASE+1	; Player is not small
	.byte PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1, PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1	; Player is small

Player_TwisterSpinFrames:
	.byte PF_SPINSMALLORFROG_BASE+12, PF_SPINSMALLORFROG_BASE, PF_SPINSMALLORFROG_BASE+12, PF_SPINSMALLORFROG_BASE	; small or frog
	.byte PF_SPINSLIDESUITS_BASE+10, PF_SPINSLIDESUITS_BASE, PF_SPINSLIDESUITS_BASE+10, PF_SPINSLIDESUITS_BASE+1	; suits that slide
	.byte PF_SPINOTHER_BASE, PF_SPINOTHER_BASE+2, PF_SPINOTHER_BASE, PF_SPINOTHER_BASE+3	; otherwise

	; Airship "caught anchor" frame or general vine climbing
Player_ClimbFrame:
	.byte PF_CLIMB_SMALL	; Small
	.byte PF_CLIMB_BIG	; Big
	.byte PF_CLIMB_BIG	; Fire
	.byte PF_CLIMB_BIG	; Leaf
	.byte PF_CLIMB_FROG	; Frog
	.byte PF_CLIMB_BIG	; Tanooki
	.byte PF_CLIMB_BIG	; Hammer

	; Airship jump frame used by power up
Airship_JumpFrameByPup:

Player_VibeDisableFrame:
	.byte PF_WALKSMALL_BASE		; Small
	.byte PF_WALKBIG_BASE+2		; Big
	.byte PF_WALKBIG_BASE+2		; Fire
	.byte PF_WALKSPECIAL_BASE+2	; Leaf
	.byte PF_WALKSPECIAL_BASE	; Frog
	.byte PF_WALKBIG_BASE+2	; Tanooki
	.byte PF_WALKBIG_BASE+2		; Hammer

	; Unused data?
	.byte $FE, $02, $05, $FB, $01
	.byte $02, $03, $00

	; When Player hits water, splash!
Player_WaterSplash:
	LDA <Player_SpriteY
	CMP #$b8
	BGE PRG008_A111	 ; If sprite Y >= $B8, jump to PRG008_A111 (RTS)

	LDA Splash_DisTimer
	BNE PRG008_A0F9	 ; If Splash_DisTimer > 0 (Player splashes disabled), jump to PRG008_A0F9

	STA <Temp_Var1	 ; Temp_Var1 = 0

	LDA <Player_Suit
	BEQ PRG008_A0C8	 ; If Player is small, jump to PRG008_A0C8

	LDA Player_IsDucking
	BEQ PRG008_A0CC	 ; If Player is not ducking, jump to PRG008_A0CC

PRG008_A0C8:

	; Player is small or ducking

	LDA #10
	STA <Temp_Var1	 ; Temp_Var1 = 10

PRG008_A0CC:
	LDA #$01
	STA Splash_Counter	 ; Splash_Counter = 1 (begin splash)

	LSR A
	STA Splash_NoScrollY	 ; Splash_NoScrollY = 0 (splash Y is relative to screen scroll)

	LDA Level_AScrlConfig
	BEQ PRG008_A0E7	 ; If no auto scroll effects are occurring, jump to PRG008_A0E7

	; Auto scroll effect active...

	LDA <Player_SpriteY
	CMP #136
	BLT PRG008_A0E7	 ; If Player_SpriteY < 136, jump to PRG008_A0E7

	LDA #147
	STA Splash_NoScrollY	 ; Splash_NoScrollY = 147 (splash Y is not relative to screen scroll, appropriate for fixed water at bottom)

	BNE PRG008_A0F1	 ; Jump (technically always) to PRG008_A0F1

PRG008_A0E7:
	LDA <Player_Y
	ADD <Temp_Var1	; Y offset
	AND #$F0	; align to grid
	;ADD #$08	; +2

PRG008_A0F1:
	STA Splash_Y	 ; 147 or above formula -> Splash_Y 

	LDA <Player_X
	STA Splash_X	 ; Splash_X = Player_X

PRG008_A0F9:
	LDA <Player_YVel
	BMI PRG008_A0FA
	AND #$80
	STA <Temp_Var1
	LDA <Player_YVel
	LSR A
	ORA <Temp_Var1
	LSR A
	ORA <Temp_Var1
	STA <Player_YVel

PRG008_A0FA:
	LDA <Player_XVel
	AND #$80
	STA <Temp_Var1
	LDA <Player_XVel
	LSR A
	ORA <Temp_Var1
	LSR A
	ORA <Temp_Var1
	STA <Player_XVel

	; When Player hits water, a bubble is made

	LDY #$02	 ; Y = 2 (all bubble slots)

PRG008_A109:
	LDA Bubble_Cnt,Y
	BEQ PRG008_A118	 ; If this bubble slot is free, jump to PRG008_A118

PRG008_A10E:
	DEY		 ; Y--
	BPL PRG008_A109	 ; While Y >= 0, loop!

PRG008_A111:
	RTS		 ; Return


	; Y offsets
SplashBubble_YOff:	.byte 16, 22, 19

	; X offsets
SplashBubble_XOff:	.byte  0,  4, 11

PRG008_A118:
	LDA RandomN,Y	 	; Get random number
	ORA #$10
	STA Bubble_Cnt,Y	; Store into bubble counter

	; Set Bubble Y
	LDA <Player_Y
	ADC SplashBubble_YOff,Y
	STA Bubble_Y,Y
	LDA <Player_YHi
	ADC #$00
	STA Bubble_YHi,Y

	; Set Bubble X
	LDA <Player_X
	ADC SplashBubble_XOff,Y
	STA Bubble_X,Y
	LDA <Player_XHi
	ADC #$00
	STA Bubble_XHi,Y

	JMP PRG008_A10E	 ; Jump to PRG008_A10E


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoGameplay
;
; This subroutine is MAJOR; it performs a LOT of tasks which make
; the Player gameplay; too much to discuss here, so go through it!
; About the only thing it doesn't cover is colliding with other
; objects; this is handled elsewhere...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoGameplay:
	LDY Level_Tileset
	DEY
	STY Level_TilesetIdx

	JSR Level_Initialize	 ; Initialize level if needed
	JSR LevelJunction_PartialInit	 

	; NOTE: If a partial initialization occurred (above),
	; it will NOT return here!  It will be back up at PRG030...

	JSR Sprite_RAM_Clear
	JSR Player_Update	 ; WHERE THE PLAYER DOES EVERYTHING!! (Except touch other objects)

	; If Player is...
	LDA <Player_IsDying	; ... dying ....
	ORA Level_PipeMove	; ... moving through a pipe ...
	ORA Player_SuitLost	; ... just lost his suit ...
	ORA Player_StarOff	; ... starman is wearing off ...
	ORA Player_Grow		; ... is growing/shrinking ...
	STA <Player_HaltGame	; ... means he's halting the gameplay for now

	BNE PRG008_A1C1	 	; And if that's the case, jump to PRG008_A1C1
	
	JSR CheckForLevelEnding
	LDA CompleteLevelTimer
	BPL GameIsHalted

	JSR CoinsEarnedBuffer
	JSR Do_Air_Timer
	JSR Do_PowerChange
	JSR Increase_Game_Timer
	JSR Try_Item_Reserve_Release
	JSR Try_Use_Equipped
	LDA DayNightActive
	BEQ NoTransition
	LDA NightTransition
	BEQ NotNight
	JSR DoNightTransition

NotNight:
	LDA DayTransition
	BEQ NoTransition
	JSR DoDayTransition

NoTransition:
	JSR DoPaletteEffect

GameIsHalted:
	JSR Player_Refresh
	INC Level_NoStopCnt	; As long as none of the above is happening, continue the "no stop" counter...

PRG008_A1C1:
	; Decrement several adjacent counters!
	LDX #$07	 ; X = 7

PRG008_A1DE:
	LDA Event_Countdown,X
	BEQ PRG008_A1E6	 ; If counter is = 0, jump to PRG008_A1E6

	DEC Event_Countdown,X	 ; Otherwise, decrement it!

PRG008_A1E6:
	DEX		 ; X--
	BPL PRG008_A1DE	 ; While X >= 0, loop!

	LDA Level_PSwitchCnt
	BEQ PRG008_A20C	 ; If Level_PSwitchCnt = 0 (P-Switch not active), jump to PRG008_A20C
	CMP #$FF
	BEQ PRG008_A20C
	CMP #$01
	BNE PRG008_A203	 ; If Level_PSwitchCnt <> 1, jump to PRG008_A203

	LDY #$0A	 ; Y = $0A (Invincibility song)

	LDA Player_StarInv
	CMP #$20
	BGE PRG008_A1FE	 ; If Player_StarInv >= $20, jump to PRG008_A1FE

	LDY Level_MusicQueueRestore	 ; Y = regular BGM

PRG008_A1FE:
	STY Sound_QMusic2 ; Restore appropriate music
	BNE PRG008_A209	 ; If Level_PSwitchCnt > 0, jump to PRG008_A209

PRG008_A203:
	LDA <Counter_1
	AND #$03	 ; Cap 0 - 3
	BNE PRG008_A20C	 ; If 1 - 3, jump to PRG008_A20C (RTS)

PRG008_A209:
	DEC Level_PSwitchCnt	 ; Level_PSwitchCnt--

PRG008_A20C:
	RTS		 ; Return


	; Just amounts to calling Player_Draw, but takes care of switching to page 29 and back
Player_Draw29:
	JSR PChg_C000_To_29	 ; Change page @ C000 to 29
	JSR Player_Draw	 	; Draw Player
	JMP PChg_C000_To_0	 ; Change page @ C000 to 0 and don't come back!

Player_DrawAndDoActions29:
	JSR PChg_C000_To_29	 ; Change page @ C000 to 29

	LDA #$00	 
	STA Player_InPipe 	; Player_InPipe = 0

	JSR Player_DrawAndDoActions	 ; Draw Player and do actions (going to coin heaven, the airship intro, going through pipes, ...)

	INC Player_InPipe	 ; Player_InPipe = 1

PRG008_A224:

	; If Player did NOT enter a pipe, we jump here...

	; Pull return address (so we do NOT return to the original Player_DrawAndDoActions 
	; call, thus not setting Player_InPipe flag... seems like a stupid way to 
	; conditionalize that, but hey, I didn't program in the 80s...)
	PLA
	PLA

	JMP PChg_C000_To_0	 ; Jump to PChg_C000_To_0 (switch C000 back to page 0 and return)

PChg_C000_To_29:
	; Change page @ C000 to 29
	LDA #29
	STA PAGE_C000
	JMP PRGROM_Change_C000

PChg_C000_To_0:
	; Change page @ C000 to 0
	LDA #$00
	STA PAGE_C000
	JMP PRGROM_Change_C000


MapPowersToSuit:
	.byte $01, $02, $03, $08, $04, $09, $05, $06, $0B, $07, $0C
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_Initialize
; 
; If level has not yet initialized, this does so, otherwise it
; simply exits and does nothing...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_XStarts:
	.byte $18, $70, $D8, $80

Level_Initialize:
	LDA <Player_XStart	
	BEQ PRG008_A242	 ; If Player_XStart = 0 (not yet initialized), jump to PRG008_A242
	RTS		 ; Return


PRG008_A242:
	STA Level_ChangeReset ; Set Level_ChangeReset = 0 (trigger scene-change reset)

	LDA #$28
	STA Player_SprOff ; Player sprite rooted at offset $28


	; Set player power up based on current suit on 
	LDX World_Map_Power
	INX
	STX Player_QueueSuit 
	LDA #$40
	STA Air_Time
	STA Tile_Anim_Enabled
	LDA #$FF
	STA CompleteLevelTimer

	LDA Player_Coins
	STA Previous_Coins
	LDA Player_Coins+1
	STA Previous_Coins+1
	LDA Player_Coins+2
	STA Previous_Coins+2
	LDA Player_Coins+3
	STA Previous_Coins+3
	LDA Cherries
	STA Previous_Cherries
	LDA Magic_Stars
	STA Previous_Stars

	; Set power up's correct palette
	JSR Level_SetPlayerPUpPal

	LDA #SPR_HFLIP
	STA <Player_FlipBits	 ; Player_FlipBits = $40 (face right)

	; Set Player_X based on Level_SelXStart

	LDA <Player_X
	STA <Player_XStart	; Also set Player_XStart

	JSR Level_InitAction_Do	; Do whatever action this level wants at the start, if any

PRG008_A277:

PRG008_A27A:
PRG008_A29E:
	LDA <Vert_Scroll
	STA Level_VertScroll	; Level_VertScroll = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_VertScrollH	; Level_VertScrollH = Vert_Scroll_Hi

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_InitAction_Do
;
; Performs whatever is requested by the level as an initial action
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_InitAction_JumpTable:
	.word LevelInit_DoNothing	; 0 - Do nothing
	.word LevelInit_StartSliding	; 1 - Start level sliding (if able by power-up)
	.word LevelInit_PipeExitTop	; 2 - Start by exiting top of pipe
	.word LevelInit_PipeExitBottom	; 3 - Start by exiting bottom of pipe
	.word LevelInit_PipeExitRight	; 4 - Start by exiting right of pipe
	.word LevelInit_PipeExitLeft	; 5 - Start by exiting left of pipe

Level_InitAction_Do:
	LDA Level_InitAction
	ASL A		
	TAY		; Y = Level_InitAction << 1 (2 byte index)

	; Copy jump address into Temp_Var1/2
	LDA Level_InitAction_JumpTable,Y
	STA <Temp_Var1
	LDA Level_InitAction_JumpTable+1,Y
	STA <Temp_Var2

	LDA #$00
	STA Level_InitAction	; Level_InitAction = 0 (same memory gets used as Player_Slide after this!)

	JMP [Temp_Var1]		; Jump appropriately...


LevelInit_StartSliding:
	; #DAHRKDAIZ Start Sliding code removed.
LevelInit_DoNothing:
	RTS		 ; Return

LevelInit_PipeExitTop:
	LDA #$83	 ; A = $83 (sets Level_PipeMove)
	LDY #$01	 ; Y = 1 (come out pipe from the top, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitBottom:
	LDA #$82	 ; A = $82 (sets Level_PipeMove)
	LDY #$02	 ; Y = 2 (come out pipe from the bottom, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitRight:
	LDA #$80	 ; A = $80 (sets Level_PipeMove)
	LDY #$03	 ; Y = 3 (come out pipe to the right, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitLeft:
	LDA #$81	 ; A = $81 (sets Level_PipeMove)
	LDY #$04	 ; Y = 4 (come out pipe to the left, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_Airship:


LevelInit_Airship_Board:

PRG008_A324:
	; Set as appropriate from entry
	STA Level_PipeMove
	STY Level_PipeExitDir
	JMP PRG008_A38E	 ; Jump to PRG008_A38E


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelJunction_PartialInit
; 
; Performs some re-initialization required after entering a door
; or pipe and handles some airship intro stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelJunction_PartialInit:
	LDA LevelPartialInit
	BEQ PRG008_A388	 ; If LevelPartialInit = 0, jump to PRG008_A388

	LDA #$00
	STA LevelPartialInit	 ; LevelPartialInit = 0
	STA ForcedSwitch
	STA Level_HAutoScroll	 ; Disable auto horizontal scrolling
	STA Level_AScrlConfig	 ; Clear auto scroll configuration (no auto scroll)
;	STA Player_SlideRate	 ; No slide
	STA Level_ChangeReset	 ; Do level scene change reset

	JSR Level_SetPlayerPUpPal  ; Set power up's correct palette
	JSR PRG008_A27A		   ; Partial level initialization (basically continues after setting the power up)

	LDA Level_AirshipCtl
	BEQ PRG008_A379	 ; If Level_AirshipCtl = 0, jump to PRG008_A379

	; While airship opening is occurring...
	LDA #$00	
	STA <Player_XVel		; Player_XVel = 0
	STA Level_InitAction		; Level_InitAction = 0
	JSR LevelInit_Airship_Board	; Board the airship

PRG008_A379:
	LDA Level_InitAction
	CMP #$06
	BNE PRG008_A383	 	; If Level_InitAction <> 6 (Run & Jump for the airship), jump to PRG008_A383

	JSR LevelInit_Airship	 ; Run & Jump for the airship
PRG008_A383:

	JSR PRG008_A38E	 

	; Pulls prior return address, meaning this function
	; will return to the caller's caller!
	PLA
	PLA

PRG008_A388:
	RTS		 ; Return

Event_Countdown_Init:
	; 0 = Not used, 1 = Up, 2 = Down, 3 = Right, 4 = Left
	; Ticks to initialize Event_Countdown
	.byte $00, $3F, $07, $20, $20

PRG008_A38E:
	; Common point for exiting and entering from pipe
	; and some other routines... (if Level_PipeMove = 0,
	; then clearly there's no pipe action going on)

	LDA Level_PipeMove
	BEQ PRG008_A3C9	 ; If Level_PipeMove = 0, jump to PRG008_A3C9 (RTS)

	; Queue pipe sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA <Player_X	
	STA <Pipe_PlayerX	 ; Pipe_PlayerX = Player_X

	LDA <Player_Y
	AND #$F0	
	STA <Pipe_PlayerY
	DEC <Pipe_PlayerY 	; Pipe_PlayerY = Player_Y aligned to nearest 16, minus 1

	LDA Level_7Vertical
	BNE PRG008_A3B6	 	; If level is vertical, jump to PRG008_A3B6
	
	; For non-vertical levels...
	LDA <Vert_Scroll
	STA Level_VertScroll	; Level_VertScroll = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_VertScrollH	; Level_VertScrollH = Vert_Scroll_Hi

PRG008_A3B6:
	LDA Level_PipeExitDir
	BNE PRG008_A3C0	 	; If Level_PipeExitDir <> 0, jump to PRG008_A3C0

	LDA #$02	 
	STA Level_PipeExitDir	 ; If Level_PipeExitDir is not set, assume we're coming out the bottom

PRG008_A3C0:
	AND #$0f	 ; Ensure Level_PipeExitDir is capped (note, though, only 0-3 is valid)
	TAY		 
	LDA Event_Countdown_Init,Y
	STA Event_Countdown	 ; Event_Countdown = Event_Countdown_Init[Y]

PRG008_A3C9:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Update
;
; Responsible for ALL of the magic; does everything
; needed to make a functional Player object!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Update:
	LDA Player_QueueSuit
	BEQ PRG008_A3FA	 ; If we don't have a suit change queued, jump to PRG008_A3FA
	BMI PRG008_A3F2

	CMP #$0f
	BLS PRG008_A3EC	 ; If Player_QueueSuit < $0F (statue enable), jump to PRG008_A3EC


PRG008_A3DC:
	CMP #$40
	BEQ PRG008_A3E7	 ; If Player_QueueSuit = $40 (make a splash), jump to PRG008_A3E7


PRG008_A3E7:
	INC Player_InWater	; Set "in water" flag
	BNE PRG008_A3F2	 	; Jump (technically always) to PRG008_A3F2

PRG008_A3EC:
	; Suit queue
	AND #$0f
	LDY #$00
	STY Player_Power
	STY Power_Change
	CMP #$05
	BEQ PRG008_A3ED

	CMP #$09
	BNE PRG008_A3EF

PRG008_A3ED:
	LDY #$06
	STY Power_Change

PRG008_A3EF:
	STA Effective_Suit
	CMP #$08 
	BCC Not_Special
	SBC #$05
	STA Special_Suit_Flag
	BNE Is_Special

Not_Special:
	LDY #$00
	STY Special_Suit_Flag

Is_Special:
	TAY	
	DEY		 ; Y = Player_QueueSuit - 1
	STY <Player_Suit ; Store into Player_Suit
	DEC Effective_Suit

PRG008_A3F2:
	LDX #$00
	STX Player_QueueSuit	  ; Clear Player_QueueSuit
	STX Exp_Doubler
	STX Player_Shell
	STX Boo_Mode_Timer
	STX Boo_Mode_KillTimer
	LDA Poison_Mode
	ORA Fox_FireBall
	BEQ PRG008_A3F1
	STX Poison_Mode
	STX Fox_FireBall

PRG008_A3F1:

	LDA Frozen_State
	BNE PRG008_A3FA
	JSR Level_SetPlayerPUpPal ; Set power up's correct palette

PRG008_A3FA:
	LDA <Player_IsDying
	ORA Player_HaltTick
	BNE PRG008_A472	 ; If gameplay is halted by Player_HaltTicks OR Player is dying, jump to PRG008_A472

	; Non-halted gameplay normal flow...
	LDA Player_AboveTop
	BNE PRG008_A427	 ; If Player_AboveTop <> 0 (Player is above the top of screen), jump to PRG008_A427

	; "Fall in a pit and die"!
	LDA <Player_SpriteY
	AND #$F0
	CMP #$c0
	BNE PRG008_A427	 ; If Player_SpriteY < $C0 && Player_SpriteY > $CF, jump to PRG008_A427

	LDA Player_Equip
	CMP #ITEM_CATCH
	BNE PRG008_A3FB

	LDA #$00
	STA Player_Equip

	LDA #$80
	STA Player_FlyTime

	LDA #$04
	STA Player_QueueSuit

	LDA #$B0
	STA <Player_YVel
	STA <Player_Y
	BNE PRG008_A427

PRG008_A3FB:
	JSR Player_Die	 ; Begin death sequence

	; This jumps the initial part of the death sequence
	LDA #$c0
	STA Event_Countdown ; Event_Countdown = $C0
	LDA #$02
	STA <Player_IsDying	; Player_IsDying = 2 (already dropped off screen)

	BNE PRG008_A472	 	; Jump (technically always) to PRG008_A472

PRG008_A427:
PRG008_A44D:
PRG008_A45A:
	; Still have time left OR in debug mode...

	LDA <Player_SpriteX
	CMP #$f8
	BLT PRG008_A472	 ; Intended meaning: If Player_SpriteX > -8, jump to PRG008_A472

	; Player_SpriteX has been pushed too far left! Assumed crushed!
	; (Except in Vertical levels or if the level was completed)

	LDA Player_EndLevel
	BNE PRG008_A472	 ; If either a vertical level or the level was completed, jump to PRG008_A472

	; Player was crushed!

	JSR Player_Die	 ; Begin death sequence

	LDA #$01
	STA <Player_IsDying	 ; Player_IsDying = 1 (superfluous, Player_Die sets it to 1)

	JMP PRG008_A44D	 ; Jump to PRG008_A44D

PRG008_A472:
	; The following are always called, dead or alive...

	JSR Debug_Code
	JSR Player_DrawAndDoActions29	; Draw Player and perform reactions to various things (coin heaven, pipes, etc lots more)
	LDA #$04
	STA Air_Change
	JSR Player_ControlJmp	 	; Controllable actions
	LDA Player_InWater
	BEQ PRG008_A473
	LDA Top_Of_Water
	BNE PRG008_A473
	LDA Effective_Suit
	CMP #$04
	BEQ PRG008_A473
	LDA #$FF
	STA Air_Change

PRG008_A473:
	JSR Player_RunMeterUpdate	 	; Update "Power Meter"
	LDA <Horz_Scroll
	STA LastHorzScroll
	LDA <Horz_Scroll_Hi
	STA LastHorzScrollHi
	JSR Player_DoScrolling	 	; Scroll relative to Player against active rules
	JSR SetLastScrollDirection
	JSR Player_TailAttack_HitBlocks	; Do Tail attack against blocks
	JSR Player_DetectSolids		; Handle solid tiles, including slopes if applicable
	JSR Player_DoSpecialTiles	; Handle unique-to-style tiles!
	JSR CheckSpinners
	JSR Player_DoVibration		; Shake the screen when required to do so!
	JSR Player_SetSpecialFrames	; Set special Player frames
	JSR Player_Draw29	 	; ... and if you get through all that, draw the Player!!
	JSR Player_Events

	LDA #$00
	STA Player_XVelAdj	 ; Player_XVelAdj = 0

	RTS		 ; Return

VibrationOffset:
	.byte 0,  2,  3,  1	; For when 0 >= Vert_Scroll >= $7F
	.byte 0, -2, -3, -1	; For when $80 >= Vert_Scrol >= $FF

	; Simple function which updates the "Shake" effect from something heavy
Player_DoVibration:
	LDA Level_Vibration	 
	BEQ PRG008_A4BE		; If level is NOT vibrating, jump to PRG008_A4BE

	DEC Level_Vibration	 ; Level_Vibration--
	AND #$03	 	; Cap 0 - 3

	LDY <Vert_Scroll
	BPL PRG008_A4B1	 ; If Vert_Scroll < $80, jump to PRG008_A4B1

	ORA #$04	 ; Otherwise, use value 4 - 7

PRG008_A4B1:
	TAY		 	; index value -> 'Y'
	LDA VibrationOffset,Y	; Get offset 
	PHA		 	; Save it
	ADD Level_VertScroll	
	STA Level_VertScroll	; Level_VertScroll += offset
	PLA		 	; Restore it

PRG008_A4BE:
	STA Vert_Scroll_Off	 ; Update Vert_Scroll_Off
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_RunMeterUpdate
;
; Handles updating the "Power Meter" as appropriate,
; and plays the annoying "ringing" noise :)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_RunMeterUpdate:
	LDY Player_FlyTime	 
	BEQ PRG008_A4E4	 ; If Player is not flying (or at least high-speed jumping), jump to PRG008_A4E4

	CPY #$ff
	BEQ Sound_FullPowerRing	 ; If Player_FlyTime = $FF (P-Wing active), jump to Sound_FullPowerRing

	LDA <Counter_1
	AND #$01
	BEQ PRG008_A4D5	 ; Every other tick, jump to PRG008_A4D5

	DEY			 
	STY Player_FlyTime ; Player_FlyTime--
	LDA Effective_Suit
	CMP #$03
	BNE PRG008_A4D5

	STY Player_Power

PRG008_A4D5:
	TYA		 ; Y (Player_FlyTime) -> A 
	BNE Sound_FullPowerRing	 ; If Player_FlyTime <> 0, jump to Sound_FullPowerRing

	STY Player_RunMeter ; Otherwise, clear Player_RunMeter

Sound_FullPowerRing:

	; Full power ringing sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPOWER
	STA Sound_QPlayer

	RTS		 ; Return


PRG008_A4E4:
	LDA Player_RunMeter
	CMP #$7f
	BNE PRG008_A4F8	 ; If Player_RunMeter <> $7F (max power), jump to PRG008_A4F8

	JSR Sound_FullPowerRing	 ; Play full power ringing sound

	LDA Player_RunFlag
	BEQ PRG008_A4F8	 ; If Player is not running, jump to PRG008_A4F8

	LDY #$10	 ; Y = $10
	JMP PRG008_A51A	 ; Jump to PRG008_A51A

PRG008_A4F8:
	LDA Player_PMeterCnt
	BNE PRG008_A523	 ; If Player_PMeterCnt <> 0, jump to PRG008_A523

	SEC		 ; Set carry
	ROL Player_RunMeter ; Player_RunMeter is shifted left 1, its old bit 7 in the carry, and '1' introduced at bit 0

	LDA Player_RunFlag
	BNE PRG008_A50C	 ; If Player is running, jump to PRG008_A50C

	ROR Player_RunMeter ; Restore Player_RunMeter
	LSR Player_RunMeter ; Shift it 1 to the right

PRG008_A50C:
	LDY #$18	 ; Y = $18

	LDA Player_RunMeter
	BEQ PRG008_A520	 ; If Player_RunMeter = 0, jump to PRG008_A520

	LDA Player_RunFlag
	BEQ PRG008_A51A	 ; If Player is not running, jump to PRG008_A51A

	LDY #$08	 ; Otherwise, Y = $8
PRG008_A51A:
	STY Player_PMeterCnt	 ; Set Player_PMeterCnt

	JMP PRG008_A523	 ; Jump to PRG008_A523

PRG008_A520:
	STA Player_FlyTime ; Clear Player_FlyTime

PRG008_A523:

	LDA #$00
	STA Player_RunFlag ; Player_RunFlag = 0

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SetPlayerPUpPal
;
; Puts the palette required by the Player's current power-up into
; the graphics buffer.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Palette colors per power up level -- first byte is never used!
PowerUp_Palettes:
	.byte $00, $16, $36, $0F	; 0 - Mario default palette
	.byte $00, $16, $36, $0F	; 1 - #DAHRKDAIZ SUPER MARIO
	.byte $00, $30, $36, $06	; 2 - Fire Flower
	.byte $00, $16, $36, $0F	; 3 - Leaf (Not used, uses 0 or 1 as appropriate)
	.byte $00, $28, $36, $0F	; 4 - Frog Suit
	.byte $00, $19, $36, $0F	; 5 - #DAHRKDAIZ Koopa Suit
	.byte $00, $30, $27, $0F	; 6 - Hammer Suit
	.byte $00, $30, $31, $01	; 7 - #DAHRKDAIZ Ice Mario
	.byte $00, $27, $36, $06	; 8 - #DAHRKDAIZ Fire Fox Mario
	.byte $00, $30, $31, $01	; 9 - Unused
	.byte $00, $25, $36, $0F	; A - #DAHRKDAIZ Boo Mario
	.byte $00, $36, $36, $0F	; B - #DAHRKDAIZ Ninja Mario
	.byte $00, $0B, $2B, $0F	; infected
	.byte $00, $28, $30, $27	; yolked

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Suit pallete code removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; #DAHRKDAIZ if we're i special suit mode, we jump farther into the table.
Level_SetPlayerPUpPal:
	LDA Yolked
	BEQ CheckInfection

	LDA #$0D
	BNE Skipped_Palette

CheckInfection:
	LDA LeftRightInfection
	BEQ Normal_Palette
	LDA #$0C
	BNE Skipped_Palette

Normal_Palette:
	LDA Effective_Suit

Skipped_Palette:
	TAY
	LDX Graphics_BufCnt
	TXA
	ADD #$06
	STA Graphics_BufCnt	 ; Graphics_BufCnt += 6 more bytes coming in...

	; Going to send in a palette update

	; PPU Address $3F11 (make sure to match with Palette_Buffer offsets below!)
	LDA #$3f
	STA Graphics_Buffer,X
	LDA #$11
	STA Graphics_Buffer+1,X

	; Run of 3 bytes
	LDA #$03
	STA Graphics_Buffer+2,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+6,X

	TYA
	ASL A
	ASL A
	TAY	; Y <<= 2 (4 bytes per index)

	LDA PowerUp_Palettes+1,Y
	STA Graphics_Buffer+3,X
	STA Palette_Buffer+$11	 ; Also put into Palette_Buffer

	LDA PowerUp_Palettes+2,Y
	STA Graphics_Buffer+4,X
	STA Palette_Buffer+$12	 ; Also put into Palette_Buffer

	LDA PowerUp_Palettes+3,Y
	STA Graphics_Buffer+5,X
	STA Palette_Buffer+$13	 ; Also put into Palette_Buffer

	RTS		 ; Return


	; This is the main value of X acceleration applied
Player_XAccelMain:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button	With B button
	;      F   N   S   X     F   N   S   X
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Normal
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Big
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Fire
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Leaf
	.byte -1,  2,  2,  0, 	-1,  2,  2,  0	; Frog
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Tanooki
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Hammer


Player_XAccelMain_UW:
	; If on the ground	If swimming above the ground
	.byte -1,  1,  1,  0, 	-1,  0,  0,  0

	.byte -1,  0,  0,  0, 	-1,  0,  1,  0
	.byte -1,  0,  0,  0, 	-1,  0,  0,  0


	; The following values are added to the "Counter_Wiggly"
	; value in an attempt to push the likelihood of a carry
	; which gives just a slight boost to the Player's X
	; velocity acceleration; way of making it sort of a
	; fractional increase while he moves...
Player_XAccelPseudoFrac:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button		With B button
	;       F    N    S    X          F    N    S    X
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Small
	.byte $20, $E0, $00, $00,	$20, $E0, $00, $00	; Big
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Fire
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Leaf
	.byte $00, $00, $00, $00, 	$00, $00, $00, $00	; Frog
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Tanooki
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Hammer

Player_XAccelPseudoFrac_UW:
	; If on the ground		If swimming above the ground
	.byte $30, $00, $00, $00, 	$E0, $30, $80, $00

	.byte $A0, $E0, $C0, $00, 	$A0, $E0, $20, $00
	.byte $D0, $E0, $60, $00, 	$D0, $E0, $C0, $00

	.byte $10, $F0


	; Maximum tick count for walking animation tick counter
	; (i.e. what tick value to reach to go to next anim frame)
Player_WalkAnimTickMax:
	; 0-15 POSSIBLE, but only 0-7 defined (due to game's max X vel of $38)
	; Index is Player_XVel >> 3
	.byte $07, $06, $05, $04, $03, $02, $01, $01, $01	; Lower number = faster animation


	; Root jump velocity
Player_RootJumpVel:	.byte PLAYER_JUMP

	; Based on how fast Player is running, the jump is
	; increased just a little (this is subtracted, thus
	; for the negative Y velocity, it's "more negative")
Player_SpeedJumpInc:	.byte $00, $02, $04, $08

;; FIXME: Anybody want to claim this?
;	.byte $00, $03, $06, $08, $08, $08, $08, $06, $03, $00, $04, $08, $12, $16, $16, $12
;	.byte $08, $04

	; This sets the sprite's H/V flip bits for the somersault
Player_SomersaultFlipBits:
	.byte $00, $00, $00, $00, $C0, $C0, $C0, $C0, $80, $01


	; Bit which must be set in FloatLevel_PlayerWaterStat to override 
	; system and assume that we're underwater no matter what tile detected
FloatLevel_StatCheck:
	.byte $40, $80


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_CheckIfTileUnderwater
;
; This checks if the given tile in Temp_Var1/2 (depending on 'X')
; is "underwater", based on Temp_Var3 (Level_TilesetIdx << 2) and
; the tile's "quadrant", which index "Level_MinTileUWByQuad"
;
; The result can be overridden if the proper bit in 
; FloatLevel_PlayerWaterStat is set, which will force the
; report to say underwater...
;
; CARRY: The "carry flag" will be set and the input tile not
; otherwise tested if the tile is in the "solid floor" region!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_CheckIfTileUnderwater:
	; X = 0 or 1

	LDY #$01
	STY <Temp_Var15	 ; Temp_Var15 = 1 (Indicates underwater)

	; UNDERWATER OVERRIDE (for "floating" levels that have fixed water at the bottom)
	LDA FloatLevel_PlayerWaterStat
	AND FloatLevel_StatCheck,X
	BNE PRG008_A6A8	 ; If bit is set, jump to PRG008_A6A8

	LDA <Temp_Var1,X
	AND #$F0
	CMP #$C0
	BCS PRG008_A6A9	 ; If tile is solid floor, jump to PRG008_A6A9 (RTS)

PRG008_A68D:

	LDY #$00	 ; Y = 0 (Not under water)

	AND #TILE_PROP_WATER
	BEQ PRG008_A6A6	 ; If the starting underwater tile is greater than the detected tile, jump to PRG008_A6A6

	LDA LeftRightInfection
	ORA Yolked
	BEQ PRG008_A6A5
	LDA #$17
	STA Player_SuitLost
	LDA Effective_Suit
	ADD #$01
	STA Player_QueueSuit
	LDA #$00
	STA LeftRightInfection
	STA Yolked
	; Otherwise...

PRG008_A6A5:
	INY		 ; Y = 1 (Underwater)

PRG008_A6A6:
	STY <Temp_Var15	 ; Store Y -> Temp_Var15 (0, 1, or 2)

PRG008_A6A8:
	CLC		 ; Clear carry (tile was not in the solid floor region)

PRG008_A6A9:
	RTS		 ; Return

Player_ControlJmp:
	JMP Player_Control	 ; Jump to Player_Control

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Control
;
; Pretty much all controllable Player actions like ducking,
; sliding, tile detection response, doors, vine climbing, and 
; including basic power-up / suit functionality (except the actual 
; throwing of fireballs / hammers for some reason!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Control:
	JSR VScreenTransitions
	LDA #$00
	STA Top_Of_Water
	LDA <Player_FlipBits
	STA Player_FlipBits_OLD

	LDA <Player_InAir
	STA Player_InAir_OLD

	LDA Player_EndLevel
	BNE PRG008_A6D2	 ; If Player is running off at the end of the level, jump to PRG008_A6D2

	LDA Player_VibeDisable
	BEQ PRG008_A6DA	 	; If Player is not "vibrationally disabled", jump to PRG008_A6DA

	DEC Player_VibeDisable	 ; Otherwise Player_VibeDisable--

PRG008_A6D2:

	; Remove horizontal velocity and cancel controller inputs
	LDA #$00	
	STA <Player_XVel
	STA <Pad_Holding
	STA <Pad_Input	


PRG008_A6DA:

	LDA Player_Slide
	BEQ PRG008_A6E5	 	; If Player is NOT sliding down slope, jump to PRG008_A6E5

	LDA <Pad_Input
	AND #~PAD_B
	STA <Pad_Input		; Otherwise, disable 'B' button

PRG008_A6E5:
	LDA Fox_FireBall		; if in fireball mode, disable, all but select and start
	BEQ Normal_008_1

	LDA <Pad_Input		
	AND #(PAD_START | PAD_SELECT | PAD_B)
	STA <Pad_Input

	LDA <Pad_Holding
	AND #(PAD_START | PAD_SELECT | PAD_B)
	STA <Pad_Holding

Normal_008_1:
PRG008_A6F2:
	LDY <Player_Suit
	BEQ PRG008_A70E	 	; If Player is small, jump to PRG008_A70E

	CPY #PLAYERSUIT_FROG
	BEQ PRG008_A70E	 	; If Player is Frog, jump to PRG008_A70E

	LDA Player_IsHolding
	BNE PRG008_A70E	 	; If Player is holding something, sliding down a slope, or in a Kuribo's shoe, jump to PRG008_A70E 

	LDA <Player_InAir
	BEQ PRG008_A71C	 	; If Player is NOT mid air, jump to PRG008_A71C

	LDA Player_InWater
	BEQ PRG008_A715	 	; If Player is NOT in water, jump to PRG008_A715

PRG008_A70E:
	; Forcefully disable any ducking
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

	BEQ PRG008_A736	 	; Jump (technically always) to PRG008_A736

PRG008_A715:
	LDA Player_IsDucking
	BNE PRG008_A733	 	; If Player is ducking down, jump to PRG008_A733
	BEQ PRG008_A736	 	; Otherwise, jump to PRG008_A736

PRG008_A71C:
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

	;LDA Player_SlideRate 
	;BNE PRG008_A736	 	; If Player has a slide magnitude, jump to PRG008_A736

PRG008_A72B:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	CMP #PAD_DOWN
	BNE PRG008_A736	 	; If Player is not just holding down, jump to PRG008_A736

PRG008_A733:
	STY Player_IsDucking	; Set ducking flag (uses non-zero suit value)

PRG008_A736:
	LDY #20		 	; Y = 20 (ducking or small)

	LDA <Player_Suit 	
	BEQ PRG008_A743	 	; If Player is small, jump to PRG008_A743

	LDA Player_IsDucking
	BNE PRG008_A743	 	; If Player is ducking, jump to PRG008_A743

	LDY #10		 	; Otherwise, Y = 10 (not ducking, not small)

PRG008_A743:
	STY <Temp_Var10		; Temp_Var10 (Y offset) = 20 or 10

	LDA #$08
	STA <Temp_Var11		; Temp_Var11 (X offset) = 8

	LDA Level_Tile_Prop_GndL	 ; Get left ground tilee
	STA <Temp_Var2		 ; -> Temp_Var2

	JSR Player_GetTileAndSlope ; Get tile above Player
	STA Level_Tile_Prop_Head	 ; -> Level_Tile_Head
	STA <Temp_Var1		 ; -> Temp_Var1

PRG008_A77E:
	LDA Player_InAir
	ORA Player_Shell
	BNE PRG008_A7AD_2

	LDA Level_Tile_Prop_Body
	CMP #TILE_PROP_SOLID_ALL
	BCC PRG008_A7AC	 	; If Player is mid air, in water, or moving in a pipe, jump to PRG008_A7AD

PRG008_A7AB:
	LDA <Player_X
	AND #$0F
	CMP #04
	BCC PRG008_A7AC
	CMP #$0C
	BCS PRG008_A7AC

	JSR Player_GetHurt


PRG008_A7AC:
	LDX #$00
	LDA Level_Tile_Prop_Head
	CMP #TILE_ITEM_BRICK
	BNE PRG008_A7AC1

	LDY Player_Shell
	BNE PRG008_A7AD_2

PRG008_A7AC1:
	CMP #TILE_PROP_SOLID_ALL
	BCC PRG008_A7AD

	INX

PRG008_A7AD:
	STX Player_ForcedSlide

PRG008_A7AD_2:
	; This will be used in Level_CheckIfTileUnderwater 
	; as bits 2-3 of an index into Level_MinTileUWByQuad
	LDX #$00	; Checks Temp_Var1 for tile and $40 override bit in UNK_584
	JSR Level_CheckIfTileUnderwater

	; Carry is set by Level_CheckIfTileUnderwater if tile was in the
	; "solid floor" region regardless of being "underwater"
	BCS PRG008_A7BE	 ; If carry set (tile was in solid region), jump to PRG008_A7BE

	; 'Y' is the result of Level_CheckIfTileUnderwater:
	; 0 = Not under water, 1 = Underwater, 2 = Waterfall
	TYA		 
	BNE PRG008_A812	 ; If Y <> 0 (somehow under water), jump to PRG008_A812

PRG008_A7BE:

	; NOT underwater!
	LDA Player_InWater
	BNE PRG008_A7BF
	JMP PRG008_A827	 ; If Player was not previously in water, jump to PRG008_A827

PRG008_A7BF:
	LDA <Player_InAir
	BNE PRG008_A7CB	 ; If Player is mid air, jump to PRG008_A7CB

	; Player is NOT flagged as mid air...

	BCS PRG008_A827	 ; If tile was in the floor solid region, jump to PRG008_A827
	BCC PRG008_A80B	 ; If tile was NOT in the floor solid region, jump to PRG008_A80B

PRG008_A7CB:

	; Player is known as mid air!

	BCS PRG008_A7D1	 ; If tile was in floor solid region, jump to PRG008_A7D1

	LDA <Player_YVel
	BMI PRG008_A7E2	 ; If Player's Y velocity < 0 (moving upward), jump to PRG008_A7E2

PRG008_A7D1:

	; Player's Y velocity >= 0...
	; OR Player just hit a solid tile with the head

	ROR A		 ; The important concept here is to save the previous carry flag
	STA <Temp_Var16	 ; Temp_Var16 (most importantly) contains the previous carry flag in bit 7

	LDX #$01	 ; Checks Temp_Var2 for tile and $80 override bit in UNK_584
	JSR Level_CheckIfTileUnderwater

	BCS PRG008_A7DE	 ; If tile was in the floor solid region, jump to PRG008_A7DE

	TYA
	BEQ PRG008_A80B	 ; If Y = 0 (Not underwater), jump to PRG008_A80B

PRG008_A7DE:
	LDA <Temp_Var16
	BMI PRG008_A812	 ; If we had a floor solid tile in the last check, jump to PRG008_A812

	; Did NOT hit a solid floor tile with head last check

PRG008_A7E2:
	LDY <Player_YVel
	CPY #-$0C
	BGS PRG008_A7EA	 ; If Player_YVel >= -$0C, jump to PRG008_A7EA

	; Prevent Player_YVel from being less than -$0C
	LDY #-$0C

PRG008_A7EA:
	LDA <Counter_1
	AND #$07
	BNE PRG008_A7F1

	INY		 ; 1:8 chance velocity will be dampened just a bit

PRG008_A7F1:
	STY <Player_YVel ; Update Player_YVel

	LDA <Pad_Input
	AND #~PAD_A
	STA <Pad_Input	 ; Strip out 'A' button press

	LDA <Pad_Holding
	TAY		 ; Y = Pad_Holding

	AND #~PAD_UP
	STA <Pad_Holding ; Strip out 'Up'

	LDA #$01
	STA Top_Of_Water

NoAirInc:
	TYA		 ; A = original Pad_Holding
	AND #(PAD_UP | PAD_A)
	CMP #(PAD_UP | PAD_A)
	BNE PRG008_A827	 ; If Player is not pressing UP + A, jump to PRG008_A827

	; Player wants to exit water!
	LDA #-$34
	STA <Player_YVel ; Player_YVel = -$34 (exit velocity from water)

PRG008_A80B:

	; Player NOT marked as "in air" and last checked tile was NOT in the solid region
	; OR second check tile was not underwater

	LDY #$00	 
	STY Player_SwimCnt ; Player_SwimCnt = 0
	BEQ PRG008_A819	   ; Jump (technically always) to PRG008_A819

PRG008_A812:
	LDY <Temp_Var15
	CPY Player_InWater
	BEQ PRG008_A827	   ; If Player_InWater = Temp_Var15 (underwater flag = underwater status), jump to PRG008_A827

PRG008_A819:
	; Player's underwater flag doesn't match the water he's in...

	TYA
	STA Player_InWater	; Merge water flag status
	JSR Player_WaterSplash	 ; Hit water; splash!

PRG008_A827:

	; Player not flagged as "under water"
	; Player not flagged as "mid air" and last checked tile was in solid region

	LDA <Player_FlipBits
	AND #%01111111	 
	STA <Player_FlipBits	 ; Clear vertical flip on sprite

	LDA Level_Tile_Prop_Body	
	CMP #TILE_ITEM_COIN
	BCS PRG008_A86C	 ; If tile is DOOR2's tile, jump to PRG008_A83F

	AND #$0F
	CMP #TILE_PROP_DOOR
	BNE PRG008_A86C	 ; If tile is not DOOR1, jump to PRG008_A86C

PRG008_A83F:

	; DOOR LOGIC
	LDA <Pad_Input
	AND #PAD_UP
	BEQ PRG008_A86C	 ; If Player is not pressing up in front of a door, jump to PRG008_A86C

	LDA <Player_InAir
	BNE PRG008_A86C	 ; If Player is mid air, jump to PRG008_A86C

PRG008_A852:

	LDA <Player_X
	ADD #$08
	STA <Player_X
	LDA <Player_XHi
	ADC #$00
	STA <Player_XHi
	LDA <Player_X
	AND #$F0	 ; Lock to nearest column (place directly in doorway)
	STA <Player_X	 ; Update Player_X
	LDA #$00
	STA <Player_XVel
	JSR Do_Pointer_Effect
	INC Level_JctCtl ; Set appropriate value to Level_JctCtl
	LDA #$00
	STA Level_PipeMove

PRG008_A86C:

	; VINE CLIMBING LOGIC
	LDA Player_InWater
	ORA Player_IsHolding
	ORA Boo_Mode_Timer
	ORA Fox_FireBall
	ORA Player_Shell
	BNE PRG008_A890	 ; If Player is in water, holding something, or in 

	LDA Level_Tile_Prop_Head
	AND #$0F
	CMP #TILE_PROP_CLIMBABLE
	BNE PRG008_A890	 ; If tile is not the vine, jump to PRG008_A890

	LDA Player_IsClimbing
	BNE PRG008_A898Boost	 ; If climbing flag is set, jump to PRG008_A898

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_A890	 ; If Player is not pressing up or down, jump to PRG008_A890

	LDY <Player_YVel
	BMI PRG008_A890

	LDY <Player_InAir
	BNE PRG008_A898	 ; If Player is in the air, jump to PRG008_A898

	AND #%00001000
PRG008_A898Boost:
	BNE PRG008_A898	 ; If Player is pressing up, jump to PRG008_A898

PRG008_A890:
	LDA Level_Tile_Prop_Head
	CMP #TILE_ITEM_COIN
	BCS PRG008_A892

	LDA Level_Tile_Prop_Body
	AND #$0F
	CMP #TILE_PROP_DEPLETE_AIR
	BEQ Deplete_Air0

	LDA Level_Tile_Prop_Head
	AND #$0F
	CMP #TILE_PROP_DEPLETE_AIR
	BNE PRG008_A892

Deplete_Air0:
	LDA #$FF
	STA Air_Change

PRG008_A892:
	LDA #$00
	STA Player_IsClimbing	 ; Player_IsClimbing = 0 (Player is not climbing)

	LDA #$18
	STA <Temp_Var10
	LDA #$08
	STA <Temp_Var11		; Temp_Var11 (X offset) = 8
	JSR Player_GetTileAndSlope

	STA Level_Tile_Prop_Body
	AND #$0F
	CMP #TILE_PROP_TREASURE
	BNE PRG008_A897
	LDA <Pad_Input
	AND #PAD_B
	BEQ PRG008_A897
	JSR OpenTreasure

PRG008_A897:
	JMP PRG008_A8F9	 ; Jump to PRG008_A8F9

PRG008_A898:
	; #DAHRKDAIZ check for jumping off climbables
	LDA <Pad_Input
	AND #PAD_A
	BEQ DO_CLIMBING
	LDA #$00
	STA Player_IsClimbing
	JSR DIRECT_TO_JUMP
	RTS

DO_CLIMBING:
	LDA #$01
	STA Player_IsClimbing	 ; Player_IsClimbing = 1 (Player is climbing)
	; Kill Player velocities
	LDA #$00
	STA <Player_XVel
	STA <Player_YVel

	LDY #$10 	; Y = $10 (will be Y velocity down if Player is pressing down)

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_A8CA	 ; If Player is not pressing up or down, jump to PRG008_A8CA

	; Player is pressing UP or DOWN...

	AND #PAD_UP
	BEQ PRG008_A8C8	 ; If Player is NOT pressing UP, jump to PRG008_A8C8

	; Player is pressing UP...

	LDY #16		; Y = 16

	LDA <Player_Suit
	BEQ PRG008_A8B7	 ; If Player is small, jump to PRG008_A8B7

	LDY #0	 	; Otherwise, Y = 0

PRG008_A8B7:
	STY <Temp_Var10	 ; Temp_Var10 = 16 or 0 (if small) (Y Offset for Player_GetTileAndSlope)

	LDA #$08
	STA <Temp_Var11	 ; Temp_Var11 = 8 (X Offset for Player_GetTileAndSlope)

	JSR Player_GetTileAndSlope	; Get tile

	CMP #TILE_ITEM_COIN
	BGE PRG008_A8CA
	AND #$0F
	CMP #TILE_PROP_CLIMBABLE
	BNE PRG008_A8CA	 ; If tile is NOT another vine, jump to PRG008_A8CA

	LDY #-$10
	STY <Player_InAir ; Flag Player as "in air"

PRG008_A8C8:
	STY <Player_YVel  ; Set Player's Y Velocity

PRG008_A8CA:
	LDY #$10	 ; Y = $10 (rightward X velocity)

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_A8DA	 ; If Player is NOT pressing LEFT or RIGHT, jump to PRG008_A8DA

	AND #PAD_LEFT
	BEQ PRG008_A8D8	 ; If Player is NOT pressing LEFT, jump to PRG008_A8D8

	LDY #-$10	 ; Y = -$10 (leftward X velocity)

PRG008_A8D8:
	STY <Player_XVel ; Set Player's X Velocity

PRG008_A8DA:
	LDA Player_IsClimbing
	BEQ PRG008_A8EC	 ; If Player is NOT climbing, jump to PRG008_A8EC

	; Player is climbing...

	LDA <Player_InAir
	BNE PRG008_A8EC	 ; If Player is in air, jump to PRG008_A8EC

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BNE PRG008_A8EC	 ; If Player is pressing UP or DOWN, jump to PRG008_A8EC

	STA Player_IsClimbing	 ; Set climbing flag

PRG008_A8EC:

	; Apply Player's X and Y velocity for the vine climbing
	JSR Player_ApplyXVelocity
	JSR Player_ApplyYVelocity

	JSR Player_DoClimbAnim	 ; Animate climbing
	JSR Player_Draw29	 ; Draw Player
	RTS		 ; Return

PRG008_A8F9:

	; Player not climbing...

;	LDA Player_SlideRate
;	BEQ PRG008_A906	 ; If Player sliding rate is zero, jump to PRG008_A906
;
;	; Otherwise, apply it
;	LDA <Player_XVel
;	ADD Player_SlideRate
;	STA <Player_XVel

PRG008_A906:
	JSR Player_ApplyXVelocity	 ; Apply Player's X Velocity

PRG008_A916:

	LDY #$02	 ; Y = 2 (moving right)

	LDA <Player_XVel
	BPL PRG008_A925	 ; If Player's X Velocity is rightward, jump to PRG008_A925

	JSR Negate	 ; Negate X Velocity (get absolute value)

	DEY		 ; Y = 1 (moving left)

PRG008_A925:
	BNE PRG008_A928	 ; If Player's X Velocity is not zero (what is intended by this check), jump PRG008_A928

	; Player's velocity is zero
	TAY		 ; And thus, so is Y (not moving left/right)

PRG008_A928:
	STA <Temp_Var3	 ; Temp_Var3 = absolute value of Player's X Velocity

	STY Player_MoveLR	; Set Player_MoveLR appropriately
 
	LDA <Player_InAir
	BEQ PRG008_A940	 ; If Player is not mid air, jump to PRG008_A940

	LDA <Player_YHi
	BPL PRG008_A93D	 ; If Player is on the upper half of the screen, jump to PRG008_A93D

	; Player is mid air, lower half of screen...

	LDA <Player_Y
	BMI PRG008_A93D	 ; If Player is beneath the half point of the lower screen, jump to PRG008_A93D

	LDA <Player_YVel
	BMI PRG008_A940	 ; If Player is moving upward, jump to PRG008_A940

PRG008_A93D:
	JSR Player_ApplyYVelocity	 ; Apply Player's Y velocity

PRG008_A940:
	JSR Player_CommonGroundAnims	 ; Perform common ground animation routines

PRG008_A94C:
	LDA <Player_Suit

	LDY Player_InWater
	BEQ PRG008_A956	 ; If Player is not under water, jump to PRG008_A956

	ADD #$07	 ; Otherwise, add 7 (underwater code pointers)

PRG008_A956:
	ASL A		 ; 2-byte pointer
	TAY		 ; -> Y


	; Get proper movement code address for power-up 
	; (ground movement, swimming, Kuribo's shoe)
	LDA PowerUpMovement_JumpTable,Y
	STA <Temp_Var1
	LDA PowerUpMovement_JumpTable+1,Y
	STA <Temp_Var2


	JMP [Temp_Var1]	 ; Jump into the movement code!

PowerUpMovement_JumpTable:
	; Ground movement code
	.word GndMov_Small	; 0 - Small
	.word GndMov_Big	; 1 - Big
	.word GndMov_FireHammer	; 2 - Fire
	.word GndMov_Leaf	; 3 - Leaf
	.word GndMov_Frog	; 4 - Frog
	.word GndMov_Tanooki	; 5 - Tanooki
	.word GndMov_FireHammer	; 6 - Hammer

	; Underwater movement code
	.word Swim_SmallBigLeaf	; 0 - Small
	.word Swim_SmallBigLeaf	; 1 - Big
	.word Swim_FireHammer	; 2 - Fire
	.word Swim_SmallBigLeaf	; 3 - Leaf
	.word Swim_Frog		; 4 - Frog
	.word Swim_Tanooki	; 5 - Tanooki
	.word Swim_FireHammer	; 6 - Hammer

	; Kuribo's shoe
	.word Move_Kuribo

GndMov_Small:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	LDA Player_SandSink
	LSR A		 
	BCS PRG008_A9A3	 ; If bit 0 of Player_SandSink was set, jump to PRG008_A9A3 (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_A9A3	 ; If Player_AllowAirJump, jump to PRG008_A9A3 (RTS)

	LDA <Player_InAir
	BEQ PRG008_A9A3	 ; If Player is not mid air, jump to PRG008_A9A3 (RTS)

	; Player is mid-air...

	LDA #PF_JUMPFALLSMALL	; Standard jump/fall frame

	LDY Player_FlyTime
	BEQ PRG008_A9A1	 ; If Player_FlyTime = 0, jump to PRG008_A9A1

	LDA #PF_FASTJUMPFALLSMALL	 ; High speed jump frame

PRG008_A9A1:
	STA <Player_Frame ; Set appropriate frame

PRG008_A9A3:
	RTS		 ; Return

Swim_SmallBigLeaf:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	RTS		 ; Return

GndMov_Big:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	RTS		 ; Return

GndMov_FireHammer:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	JSR Player_ShootAnim ; Do Player shooting animation
	RTS		 ; Return

Swim_FireHammer:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	JSR Player_ShootAnim ; Do Player shooting animation
	RTS		 ; Return

GndMov_Leaf:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_AnimTailWag ; Do Player's tail animations
	JSR Player_TailAttackAnim ; Do Player's tail attack animations
	RTS		 ; Return

	RTS		 ; Return?

GndMov_Frog:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	LDA Player_IsHolding
	BNE PRG008_AA23	 ; If Player is holding something, jump to PRG008_AA23

	LDA <Player_InAir
	BEQ PRG008_AA00	 ; If Player is NOT in mid air, jump to PRG008_AA00

	LDA Player_SandSink
	LSR A
	BCS PRG008_AA00	 ; If bit 0 of Player_SandSink is set, jump to PRG008_AA00

	LDA #$00
	STA Player_FrogHopCnt	 ; Player_FrogHopCnt = 0

	LDY #$01	 ; Y = 1
	JMP PRG008_AA1E	 ; Jump to PRG008_AA1E

PRG008_AA00:
	LDA Player_FrogHopCnt
	BNE PRG008_AA1A	 ; If Player_FrogHopCnt <> 0, jump to PRG008_AA1A

	STA <Player_XVel	; Player_XVel = 0
	LDA <Pad_Holding	
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AA1A	 ; If Player is not pressing left/right, jump to PRG008_AA1A

	; Play frog hop sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERFROG
	STA Sound_QPlayer

	LDA #$1f
	STA Player_FrogHopCnt ; Player_FrogHopCnt = $1f

PRG008_AA1A:
	LSR A
	LSR A
	LSR A
	TAY	 ; Y = Player_FrogHopCnt >> 3

PRG008_AA1E:
	LDA Player_FrogHopFrames,Y	; Get frog frame
	STA <Player_Frame		; Store as frame

PRG008_AA23:
	RTS		 ; Return

Frog_SwimSoundMask:
	.byte $03, $07

	; Base frame for the different swimming directions of the frog
Frog_BaseFrame:
	; Down, Up, Left/Right
	.byte PF_FROGSWIM_DOWNBASE, PF_FROGSWIM_UPBASE, PF_FROGSWIM_LRBASE

	; Frame offset to frames above
Frog_FrameOffset:
	.byte $02, $02, $02, $01, $00, $01, $02, $02

	; Base velocity for frog swim right/down, left/up
Frog_Velocity:
	.byte 16, -16

Swim_Frog:
	LDX #$ff	 ; X = $FF

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_AA61	 ; If Player is NOT pressing up/down, jump to PRG008_AA61

	; 
	STA <Player_InAir

	LSR A
	LSR A
	LSR A
	TAX		 ; X = 1 if pressing up, else 0

	LDA Frog_Velocity,X	; Get base frog velocity
	BPL PRG008_AA4D	 ; If value >= 0 (if pressing down), jump to PRG008_AA4D

	LDY Player_AboveTop
	BPL PRG008_AA4D	 ; If Player is not off top of screen, jump to PRG008_AA4D

	LDA #$00	 ; A = 0

PRG008_AA4D:
	LDY <Pad_Holding
	BPL PRG008_AA52	 ; If Player is not pressing 'A', jump to PRG008_AA52

	ASL A		 ; Double vertical speed

PRG008_AA52:
	CMP #(PLAYER_FROG_MAXYVEL+1)
	BLT PRG008_AA5C	 

	LDY <Player_InAir
	BNE PRG008_AA5C	 ; If Player is swimming above ground, jump to PRG008_AA5C

	LDA #PLAYER_FROG_MAXYVEL	 ; Cap swim speed

PRG008_AA5C:
	STA <Player_YVel ; Set Y Velocity
	JMP PRG008_AA6E	 ; Jump to PRG008_AA6E

PRG008_AA61:
	LDY <Player_YVel
	BEQ PRG008_AA6E	 ; If Y Velocity = 0, jump to PRG008_AA6E

	INY		 ; Y++

	LDA <Player_YVel
	BMI PRG008_AA6C	 ; If Player_YVel < 0, jump to PRG008_AA6C

	DEY
	DEY		 ; Y -= 2

PRG008_AA6C:
	STY <Player_YVel ; Update Y Velocity

PRG008_AA6E:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AA84	 ; If Player is not pressing left or right, jump to PRG008_AA84

	; Player is pressing left/right...

	LSR A
	TAY
	LDA Frog_Velocity,Y	; Get base frog velocity

	LDY <Pad_Holding
	BPL PRG008_AA7E	 ; If Player is not pressing 'A', jump to PRG008_AA7E

	ASL A		 ; Double horizontal velocity

PRG008_AA7E:
	STA <Player_XVel ; Update X Velocity

	LDX #$02	 ; X = 2
	BNE PRG008_AA9C	 ; Jump (technically always) to PRG008_AA9C

PRG008_AA84:
	LDY <Player_XVel
	BEQ PRG008_AA94	 ; If Player is not moving horizontally, jump to PRG008_AA94

	INY		 ; Y++

	LDA <Player_XVel
	BMI PRG008_AA8F	 ; If Player_XVel < 0, jump to PRG008_AA8F

	DEY
	DEY		 ; Y -= 2

PRG008_AA8F:
	STY <Player_XVel ; Update X Velocity
	JMP PRG008_AA9C	 ; Jump to PRG008_AA9C

PRG008_AA94:
	LDA <Player_InAir
	BNE PRG008_AA9C	 ; If Player is swimming above ground, jump to PRG008_AA9C

	LDA #$15	 ; A = $15
	BNE PRG008_AAD2	 ; Jump (technically always) to PRG008_AAD2

PRG008_AA9C:
	TXA		 
	BMI PRG008_AAC8	 ; If X < 0, jump to PRG008_AAC8

	LDA <Counter_1
	LSR A
	LSR A

	LDY #$00	 ; Y = 0

	BIT <Pad_Holding
	BMI PRG008_AAAB	 ; If Player is holding 'A', jump to PRG008_AAAB

	LSR A		 ; Otherwise, reduce velocity adjustment
	INY		 ; Y++

PRG008_AAAB:
	AND #$07
	TAY	
	BNE PRG008_AABF	

	LDA <Counter_1
	AND Frog_SwimSoundMask,Y
	BNE PRG008_AABF	 ; If timing is not right for frog swim sound, jump to PRG008_AABF

	; Play swim sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

PRG008_AABF:
	LDA Frog_BaseFrame,X
	ADD Frog_FrameOffset,Y
	BNE PRG008_AAD2

PRG008_AAC8:
	LDY #PF_FROGSWIM_IDLEBASE

	LDA <Counter_1
	AND #$08
	BEQ PRG008_AAD1

	INY

PRG008_AAD1:
	TYA

PRG008_AAD2:
	STA <Player_Frame ; Update Player_Frame
	RTS		 ; Return

GndMov_Tanooki:
	JSR Player_Koopa_Shell  ; Change into/maintain Koopa shell mode
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	RTS		 ; Return

Swim_Tanooki:	
	LDA Player_InWater
	BEQ Dont_Kill_Shell
	LDA #$00
	STA Player_Shell

Dont_Kill_Shell:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	RTS		 ; Return

; #DAHRKDAIZ Commenting out Kuribo code
Move_Kuribo:
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Kuribo shoe related code removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GroundHControl
;
; Routine to control based on Player's left/right pad input (not
; underwater); configures walking/running
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Table of values that have to do with Player_UphillSpeedIdx override
Player_UphillSpeedVals:
	.byte $00, $16, $15, $14, $13, $12, $11, $10, $0F, $0E, $0D

Player_GroundHControl:
	LDA Player_Shell
	ORA Fox_FireBall
	BEQ Grnd_No_Shell
	JSR Player_Shell_HitBlocks
	RTS

Grnd_No_Shell:
	LDY #Pad_Input

	BIT <Pad_Holding
	BVC PRG008_AB83	; If Player is NOT holding 'B', jump to PRG008_AB83

	; Player is holding B...

	LDA <Player_InAir
	BNE PRG008_AB78	 ; If Player is mid air or sliding, jump to PRG008_AB78

	LDA <Temp_Var3
	CMP #PLAYER_TOPRUNSPEED
	BMI PRG008_AB78	 ; If Player's X Velocity magnitude is less than PLAYER_TOPRUNSPEED, jump to PRG008_AB78

	; Player is going fast enough while holding B on the ground; flag running!
	INC Player_RunFlag ; Player_RunFlag = 1

PRG008_AB78:
	; Start with top run speed
	LDY #PLAYER_TOPRUNSPEED ; Y = PLAYER_TOPRUNSPEED

	LDA Player_RunMeter
	CMP #$7f
	BNE PRG008_AB83	 ; If Player has not hit full power, jump to PRG008_AB83

	; Otherwise, top power speed
	LDY #PLAYER_TOPPOWERSPEED	 ; Y = PLAYER_TOPPOWERSPEED

PRG008_AB83:
	STY <Temp_Var14	 ; Store top speed -> Temp_Var14

	LDY Player_Slippery
	BEQ PRG008_AB98	 ; If ground is not slippery at all, jump to PRG008_AB98

	INC Player_WalkAnimTicks ; Player_WalkAnimTicks++

	DEY
	TYA
	ASL A
	ASL A
	ASL A
	ADD #$40
	TAY		 ; Y = ((selected top speed - 1) << 3) + $40 ??
	BNE PRG008_AB9E	 ; And as long as that's not zero, jump to PRG008_AB9E

PRG008_AB98:
	LDA <Player_Suit
	ASL A
	ASL A
	ASL A
	TAY		 ; Y = Player_Suit << 3

PRG008_AB9E:
	BIT <Pad_Holding
	BVC PRG008_ABA6	 ; If Player is NOT pressing 'B', jump to PRG008_ABA6

	; Otherwise...
	INY
	INY
	INY
	INY	; Y += 4 (offset 4 inside Player_XAccel* tables)

PRG008_ABA6:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_ABB8	 ; If Player is pressing LEFT or RIGHT, jump to PRG008_ABB8

	; Player not pressing LEFT/RIGHT...

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01 (RTS)

	LDA <Player_XVel
	BEQ PRG008_AC01	 ; If Player is not moving horizontally, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABD3	 ; If Player is moving leftward, jump to PRG008_ABD3
	BPL PRG008_ABEB	 ; If Player is moving rightward, jump to PRG008_ABEB

PRG008_ABB8:

	; Player is pressing left/right...

	INY
	INY		 ; Y += 2 (offset 2 within Player_XAccel* tables, the "skid" rate)

	AND Player_MoveLR
	BNE PRG008_ABCD	  ; If Player suddenly reversed direction, jump to PRG008_ABCD

	DEY		 ; Y-- (back one offset, the "normal" rate)

	LDA <Temp_Var3	 
	CMP <Temp_Var14	 
	BEQ PRG008_AC01	 ; If Player's current X velocity magnitude is the same as the selected top speed, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABCD	 ; If it's less, then jump to PRG008_AC01

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01

	DEY		 ; Y-- (back one offset, the "friction" stopping rate)

PRG008_ABCD:


	; At this point, 'Y' contains the current power-up in bits 7-3, 
	; bit 2 is set if Player pressed B, bit 1 is set if the above
	; block was jumped, otherwise bit 0 is set if the X velocity is
	; less than the specified maximum, clear if over the max


	LDA <Pad_Holding
	AND #PAD_RIGHT
	BNE PRG008_ABEB	 ; If Player is holding RIGHT, jump to PRG008_ABEB (moving rightward code)

PRG008_ABD3:

	; Player moving leftward

	LDA #$00	 
	SUB Player_XAccelPseudoFrac,Y ; Negate value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get Player_XAccelMain[Y]
	EOR #$ff	 ; Negate it (sort of)
	STA <Temp_Var2	 ; -> Temp_Var2

	LDA <Temp_Var1
	BNE PRG008_ABF5	 ; If Temp_Var1 <> 0, jump to PRG008_ABF5

	INC <Temp_Var2	 ; Otherwise, Temp_Var2++
	JMP PRG008_ABF5	 ; Jump to PRG008_ABF5

PRG008_ABEB:

	; Player moving rightward

	LDA Player_XAccelPseudoFrac,Y ; Get value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get value from Player_XAccelMain[Y]
	STA <Temp_Var2	  ; -> Temp_Var2

PRG008_ABF5: 
	LDA <Temp_Var1
	ADD RandomN	; actual value not used, looking for a semi-random carry

	LDA <Player_XVel
	ADC <Temp_Var2
	STA <Player_XVel	; Player_XVel += Temp_Var2 (and sometimes carry)

PRG008_AC01:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_UnderwaterHControl
;
; Routine to control based on Player's left/right pad input underwater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_UnderwaterHControl:
	LDY #(Player_XAccelMain_UW - Player_XAccelMain)	; Y = index to appropriate under water values

	LDA #%00001000
	STA <Temp_Var14	 ; Temp_Var14 = pretend like Player is definitely hitting UP

	LDA <Player_InAir
	BEQ PRG008_AC14	 ; If Player is not in the air, jump to PRG008_AC14

	LDA #Pad_Input
	STA <Temp_Var14	 ; Temp_Var14 = actual Pad_Input (as compared to what happened above)

	INY
	INY
	INY
	INY		 ; Y += 4 (offset into Player_XAccel* tables)
 
PRG008_AC14:
	LDA <Player_InAir
	PHA		 ; Save Player_InAir

	LDA #$00
	STA <Player_InAir ; Player_InAir= 0

	JSR PRG008_ABA6	 ; Reuses part of normal movement code

	PLA		 
	STA <Player_InAir ; Restore Player_InAir

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_JumpFlyFlutter
;
; Controls the acts of jumping, flying, and fluttering (tail wagging)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG008_AC22:
	.byte $D0, $CE, $CC, $CA, $CA, $CA

Player_JumpFlyFlutter:
	;LDA Player_ForcedSlide
	; Player_JumpFlyFlutter1
	;RTS

Player_JumpFlyFlutter1:
	LDA Wall_Jump_Enabled
	BNE PRG008_AC30
	LDA Player_AllowAirJump
	BEQ PRG008_AC30	 ; If Player_AllowAirJump = 0, jump to PRG008_AC30

	DEC Player_AllowAirJump ; Player_AllowAirJump--

PRG008_AC30:

	LDA <Pad_Input
	AND #PAD_A
	STA <Temp_Var1	 ; Temp_Var1 = $80 if Player is pressing 'A', otherwise 0
	BNE Jump_Over_PRG008_AC9E
	JMP PRG008_AC9E	 ;

Jump_Over_PRG008_AC9E:
	LDA Wall_Jump_Enabled
	BNE PRG008_AC41

	LDA Player_AllowAirJump
	BNE DIRECT_TO_JUMP	 ; If Player_AllowAirJump <> 0, jump to PRG008_AC41

	LDA <Player_InAir
	BEQ DIRECT_TO_JUMP
	JMP PRG008_AC9E	 ; If Player is mid air, jump to PRG008_AC9E

PRG008_AC41:
	; #DAHRKDAIZ modified to push the player "off" the wall when doing a wall jump
	JSR Do_Wall_Jump

DIRECT_TO_JUMP:
	; Play jump sound
	; #DAHRKDAIZ modified to play the "small jump" from SMB1 for small Mario

	LDA <Player_Suit
	BNE STORE_BIG_JUMP
	LDA #SND_SMALLJUMP
	BNE STORE_SMALL_JUMP

STORE_BIG_JUMP:
	LDA Sound_QPlayer

STORE_SMALL_JUMP:
	ORA #SND_PLAYERJUMP	 
	STA Sound_QPlayer

	LDA Player_StarInv
	BEQ PRG008_AC6C	 ; If Player is not invincible by star, jump to PRG008_AC6C

	LDA Player_RunMeter
	CMP #$7f
	BEQ PRG008_AC6C	 ; If Player is at max power, jump to PRG008_AC6C

	LDA Player_IsHolding
	BNE PRG008_AC6C	 ; If Player is holding something, jump to PRG008_AC6C

	LDA Effective_Suit
	BEQ PRG008_AC6C
	CMP #$03
	BEQ PRG008_AC6C
	CMP #$08
	BEQ PRG008_AC6C

	; Otherwise, mark as mid air AND backflipping
	STA <Player_InAir

	LDA #$00
	STA Player_AllowAirJump	 ; Cut off Player_AllowAirJump

PRG008_AC6C:

	; Get absolute value of Player's X velocity
	LDA <Player_XVel
	BPL PRG008_AC73
	JSR Negate

PRG008_AC73:

	LSR A
	LSR A
	LSR A
	LSR A
	TAX	 ; X = Magnitude of Player's X Velocity >> 4 (the "whole" part)

	LDA Player_RootJumpVel	 	; Get initial jump velocity
	SUB Player_SpeedJumpInc,X	; Subtract a tiny bit of boost at certain X Velocity speed levels
	LDY Wall_Jump_Enabled
	BEQ Normal_Jump
	LDA #$D0

	STA Player_Flip

Normal_Jump:
	STA DAIZ_TEMP1
	LDA Player_Equip
	CMP #BADGE_JUMP
	BNE Jump_Normal
	LDA DAIZ_TEMP1
	SEC
	SBC #$06
	STA DAIZ_TEMP1

Jump_Normal:
	LDA DAIZ_TEMP1
	STA <Player_YVel		; -> Y velocity

	LDA #$01
	STA <Player_InAir ; Flag Player as mid air

	LDA #$00	
	STA Player_WagCount	 ; Player_WagCount = 0
	STA Player_AllowAirJump	 ; Player_AllowAirJump = 0

	LDA Player_RunMeter
	CMP #$7f
	BNE PRG008_AC9E		; If Player is not at max power, jump to PRG008_AC9E

	LDA Player_FlyTime
	BNE PRG008_AC9E	 	; If Player still has flight time left, jump to PRG008_AC9E

	LDA #$80
	STA Player_FlyTime	; Otherwise, Player_FlyTime = $80


PRG008_AC9E:
	LDA <Player_InAir
	BNE PRG008_ACB3		; If Player is mid air, jump to PRG008_ACB3

	LDY <Player_Suit		; #DAHRKDAIZ hacked, only Racoon Mario can fly
	CPY #$03	
	BEQ PRG008_AD1A	 	; If power up has flight ability, jump to PRG008_AD1A

	LDA #$00
	STA Player_FlyTime	; Otherwise, Player_FlyTime = 0 :(
	JMP PRG008_AD1A	 ; Jump to PRG008_AD1A

PRG008_ACB3:

	; Player is mid air...

	LDY #$05	 ; Y = 5

	LDA <Player_YVel
	CMP #-$20
	BGS PRG008_ACC8	 ; If Player's Y velocity >= -$20, jump to PRG008_ACC8

	LDA Player_mGoomba
	BNE PRG008_ACCD	 ; If Player has got a microgoomba stuck to him, jump to PRG008_ACCD

	LDA <Pad_Holding
	BPL PRG008_ACC8	 ; If Player is NOT pressing 'A', jump to PRG008_ACC8

	LDY #$01	 ; Y = 1
	BNE PRG008_ACCD	 ; Jump (technically always) to PRG008_ACCD

PRG008_ACC8:
	LDA #$00
	STA Player_mGoomba ; Player_mGoomba = 0

PRG008_ACCD:
	TYA	
	ADD <Player_YVel
	LDX Boo_Mode_Timer
	BNE Skip_YVel
	LDX Fox_FireBall
	BNE Skip_YVel
	STA <Player_YVel ; Player_YVel += Y

Skip_YVel:
	LDA <Player_WagCount
	BEQ PRG008_ACD9	 ; If Player_WagCount = 0, jump to PRG008_ACD9

	DEC <Player_WagCount ; Otherwise, $F0--

PRG008_ACD9:

	LDA Effective_Suit
	CMP #$03
	BNE PRG008_ACEF	 	; If this power up does not have flight, jump to PRG008_ACEF

	LDY <Temp_Var1		; Y = $80 if Player was pressing 'A' when this all began
	BEQ PRG008_ACEF	 	; And if he wasn't, jump to PRG008_ACEF

	LDA #$10	 
	STA <Player_WagCount 	; Otherwise, Player_WagCount = $10

PRG008_ACEF:
	LDA <Player_WagCount
	BEQ PRG008_AD1A	 	; If Player has not wag count left, jump to PRG008_AD1A

	; RACCOON / TANOOKI TAIL WAG LOGIC

	LDA <Player_YVel
	CMP #PLAYER_FLY_YVEL
	BLS PRG008_AD1A	 ; If Player's Y velocity is < PLAYER_FLY_YVEL, jump to PRG008_AD1A

	LDY #PLAYER_FLY_YVEL	 ; Y = PLAYER_FLY_YVEL

	LDA Player_FlyTime
	BEQ PRG008_AD0E	 ; If Player is not flying, jump to PRG008_AD0E

	CMP #$0f
	BGE PRG008_AD18	 ; If Player has a great amount of flight time left, jump to PRG008_AD18

	; Player has a small amount of flight time left

	LDY #$F0
	AND #$08	 
	BNE PRG008_AD18	 ; Every 8 ticks, jump to PRG008_AD18

	LDY #$00	 ; Y = 0 (at apex of flight, Player no longer rises)
	BEQ PRG008_AD18	 ; Jump (technically always) to PRG008_AD18

PRG008_AD0E:
	LDA <Player_YVel
	BMI PRG008_AD1A	 ; If Player's Y velocity < 0 (moving upward), jump to PRG008_AD1A

	CMP #PLAYER_TAILWAG_YVEL
	BLT PRG008_AD1A	 ; If Player's Y velocity < PLAYER_TAILWAG_YVEL, jump to PRG008_AD1A

	LDY #PLAYER_TAILWAG_YVEL ; Y = PLAYER_TAILWAG_YVEL

PRG008_AD18:
	STY <Player_YVel ; Set appropriate Y velocity

PRG008_AD1A:
	LDA Player_UphillSpeedIdx
	BEQ PRG008_AD2E	 ; If Player_UphillSpeedIdx = 0 (not walking uphill), jump to PRG008_AD2E

	LSR A
	TAY		 ; Y = Player_UphillSpeedIdx >> 1

	LDA <Player_YVel
	BPL PRG008_AD2E	 ; If Player's Y vel >= 0, jump to PRG008_AD2E (RTS)

	CMP PRG008_AC22,Y
	BLS PRG008_AD2E	; If Player's uphill speed < Y velocity, jump to PRG008_AD2E

	LDA #$20
	STA <Player_YVel ; Player_YVel = $20

PRG008_AD2E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimV
;
; Controls the acts of swimming (the up/down part only), not
; including the Frog Suit style (which is totally different)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SwimV:
	
	LDA Frozen_State
	BNE PRG008_AD4C
	LDA <Pad_Input		 
	BPL PRG008_AD4C	 ; If Player is NOT pressing 'A', jump to PRG008_AD4C

	; Player swimming sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	LDY <Player_InAir
	BNE PRG008_AD45	 ; If Player is swimming above ground, jump to PRG008_AD4A

	LDA #PLAYER_SWIMSTART_YVEL
	STA <Player_InAir ; "mid air" underwater
	BNE PRG008_AD4A	 ; Jump (technically always) to PRG008_AD4A

PRG008_AD45:

	; Swimming speed the rest of the time

	LDA <Player_YVel
	SUB #PLAYER_SWIM_YVEL	 ; A = Player_YVel - PLAYER_SWIM_YVEL

PRG008_AD4A:
	STA <Player_YVel ; Set Player_YVel appropriately

PRG008_AD4C:
	LDA <Player_InAir
	BEQ PRG008_AD7E	 ; If Player is on the ground, jump to PRG008_AD7E

	LDA <Player_YVel
	BMI PRG008_AD5A	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD5A

	LDA <Counter_1
	AND #$02
	BNE PRG008_AD5C	 ; Every 4 ticks, jump to PRG008_AD5C

PRG008_AD5A:

	; Player's sink rate...

	INC <Player_YVel ; Player_YVel++

PRG008_AD5C:
	LDY #PLAYER_SWIM_YVEL	 ; Y = PLAYER_SWIM_YVEL

	LDA <Player_YVel
	BPL PRG008_AD75	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD75

	LDY Player_AboveTop
	BPL PRG008_AD73	 ; If Player is not above top of screen, jump to PRG008_AD73

	LDY Player_SpriteY
	CPY #-8	 
	BGE PRG008_AD73	 ; If Player sprite is a bit high up, jump to PRG008_AD73

	ADD #$10
	STA <Player_YVel ; Player_YVel += $10

PRG008_AD73:
	LDY #PLAYER_SWIMSTART_YVEL	 ; Y = PLAYER_SWIMSTART_YVEL

PRG008_AD75:
	ADD #PLAYER_SWIM_YVEL
	CMP #PLAYER_MAXSPEED
	BLT PRG008_AD7E	 ; If result is less than Player's max speed, jump to PRG008_AD7E

	STY <Player_YVel ; Otherwise, update it

PRG008_AD7E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimAnim
;
; Animates Player for swimming
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SwimAnim:
	LDA <Player_InAir
	BEQ PRG008_ADBC	 ; If Player is NOT swimming above ground, jump to PRG008_ADBC (RTS)

	LDA <Pad_Input
	BPL PRG008_AD9A	 ; If Player is NOT pressing 'A', jump to PRG008_AD9A

	LDA Player_SwimCnt
	BNE PRG008_AD97	 ; If Player_SwimCnt <> 0, jump to PRG008_AD97

PRG008_AD8C:
	LDA #$00
	STA Player_SwimCnt	 ; Player_SwimCnt = 0
	STA Counter_ByPlayerSpd	 ; Counter_ByPlayerSpd = 0
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

PRG008_AD97:
	INC Player_SwimCnt	 ; Player_WalkAnimTicks++

PRG008_AD9A:
	LDA Player_SwimCnt
	BNE PRG008_ADBD	 ; If Player_SwimCnt <> 0, jump to PRG008_ADBD

	LDA <Player_XVel
	BNE PRG008_ADAD	 ; If Player is moving left or right, jump to PRG008_ADAD

	; Player NOT moving left/right

	LDA <Counter_1
	AND #$30
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	STA <Player_WalkFrame	 ; Choose a "walk" (swim) relative frame based on game counter

PRG008_ADAD:
	LDY <Player_WalkFrame

	LDA <Player_Suit
	BNE PRG008_ADB7	 ; If Player is not small, jump to PRG008_ADB7

	INY
	INY
	INY
	INY	; Otherwise, use Player_WalkFrame + 4

PRG008_ADB7:
	LDA Player_SwimIdleFrames,Y	 ; Get appropriate swim frame
	STA <Player_Frame	 ; Set it!

PRG008_ADBC:
	RTS		 ; Return


PRG008_ADBD:
	LDA Counter_ByPlayerSpd
	CMP #$06
	BLT PRG008_ADCB	 ; If Counter_ByPlayerSpd < 6, jump to PRG008_ADCB

	DEC Player_SwimCnt	; Player_SwimCnt--
	BNE PRG008_AD8C	 	; If Player_SwimCnt > 0, jump to PRG008_AD8C

	LDA #$05	 ; A = 5

PRG008_ADCB:
	LDY <Player_Suit ; Y = Player_Suit
	BNE PRG008_ADD2	 ; If Player is not small, jump to PRG008_ADD2

	ADD #$06	 ; For small, A = 11

PRG008_ADD2:
	TAY		 ; Y = 5 or 11

	; Set Player swimming frame
	LDA Player_SwimActiveFrames,Y
	STA <Player_Frame

	RTS		 ; Return

PowerUp_Ability:
	;     Small, Big, Fire, Leaf, Frog, Tanooki, Hammer
	.byte $00,   $00, $00,  $01,  $02,  $00,     $00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_CommonGroundAnims
;
; Performs "common" animations for walking around on the ground
; (walking/standing, ducking, sliding) and, for some reason, also
; contains the debug mode power-up cycle logic (SELECT to cycle
; through all available power-ups and toggle Kuribo's shoe)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_CommonGroundAnims:

	; Get absolute value of Player_XVel
	LDA <Player_XVel
	BPL PRG008_ADE0
	JSR Negate

PRG008_ADE0:

	LSR A
	LSR A
	LSR A
	TAY		 ; Y = Absolute value of Player's X Velocity shifted right by 3 (1 bit left of "whole" part)

	INC Player_WalkAnimTicks
	LDA Player_WalkAnimTicks
	CMP Player_WalkAnimTickMax,Y
	BMI PRG008_AE03	 ; If we haven't reached the rollover point in the walking animation ticks, jump to PRG008_AE03

	LDA #$00
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

	INC <Player_WalkFrame	 ; Next Player frame
	INC Counter_ByPlayerSpd	 ; Increment Player-speed-based counter

	; Cap Player_WalkFrame at 0-3 (why not just AND it?)
	LDA <Player_WalkFrame
	CMP #$04
	BMI PRG008_AE03

	LDA #$00
	STA <Player_WalkFrame

PRG008_AE03:

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_AE11	 ; If Player is pressing left or right, jump to PRG008_AE11

	; Player NOT pressing left/right

	LDA <Player_XVel
	BNE PRG008_AE11	 ; If Player_XVel <> 0, jump to PRG008_AE11

	LDA #$02
	STA <Player_WalkFrame	 ; Otherwise, force Player_WalkFrame to 2 (standing still)

PRG008_AE11:
	LDA Player_TailAttack
	BNE PRG008_AE26	 ; If Player is performing tail attack, jump to PRG008_AE26

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AE26	 ; If Player is NOT pressing left or right, jump to PRG008_AE26

	; Player is pressing left/right

	LDY #$00	; No flip

	AND #%00000010
	BNE PRG008_AE24	 ; If Player is pressing left, jump to PRG008_AE24

	LDY #SPR_HFLIP	; Horizontal flip

PRG008_AE24:
	STY <Player_FlipBits	; Set appropriate flip

PRG008_AE26:


PRG008_AE50:


PRG008_AE58:
	LDA <Player_Suit
	ASL A
	ASL A
	ORA <Player_WalkFrame	 ; Take the walk frame and push the current power-up to bit 2
	TAY		 ; -> Y
	LDA Player_WalkFramesByPUp,Y	 ; Get appropriate sprite frame
	STA <Player_Frame		 ; -> Player_Frame

	LDA Player_InWater
	BNE PRG008_AE90	 ; If Player is in water, jump to PRG008_AE90

	; Player not in water...

	LDA <Player_XVel
	ADD #$01
	CMP #$03
	BLT PRG008_AE90	 ; If (Player_XVel + 1) < 3, jump to PRG008_AE90

	LDA Player_MoveLR
	AND <Pad_Holding
	BEQ PRG008_AE90	 ; If Player is pressing the opposite direction from his movement, jump to PRG008_AE90

	LDY <Player_Suit
	BEQ PRG008_AE7F	 ; If Player is small, jump to PRG008_AE7F

	LDY #$01	 ; Otherwise, Y = 1

PRG008_AE7F:
	LDA <Player_InAir
	BNE PRG008_AE90	 ; If Player is mid air, jump to PRG008_AE90

	; Play "skid" sound
	LDA Sound_QLevel2
	ORA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA Player_SkidFrame,Y
	STA <Player_Frame ; Set skid frame

PRG008_AE90:
	LDA Player_IsDucking
	BEQ PRG008_AEA2	 ; If Player is not ducking

	LDY <Player_Suit
	LDA PowerUp_Ability,Y	; Get "ability" bits for suit
	AND #$01	 	; Bit 0 specifies that the power up can do raccoon style flying and fluttering
	TAY		 
	LDA Player_DuckFrame,Y	; Get appropriate duck frame
	STA <Player_Frame	; Set frame!

PRG008_AEA2:
	LDA Player_Slide
	BEQ PRG008_AEC0	 ; If Player is not sliding, jump to PRG008_AEC0

	; Player is sliding...

	LDA <Player_InAir
	BNE PRG008_AEB1	 ; If Player is mid air, jump to PRG008_AEB1

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP)
	BEQ PRG008_AEB6	 ; If Player is not holding LEFT, RIGHT, or UP, jump to PRG008_AEB6

PRG008_AEB1:

	; Otherwise, cancel the sliding
	; Aside: Did you know pressing UP would stop you from sliding in Mario 3?  I didn't :P

	LDA #$00
	STA Player_Slide ; Player_Slide = 0 (stop sliding)

PRG008_AEB6:
	LDA #PF_SLIDE_BIG	 ; Frame for anything besides small
	LDY <Player_Suit
	BNE PRG008_AEBE	 ; If Player is not small, jump to PRG008_AEBE

	LDA #PF_SLIDE_SMALL	 ; Frame for small

PRG008_AEBE:
	STA <Player_Frame ; Set appropriate Player frame

PRG008_AEC0:
	RTS		 ; Return

TwisterSpin_FlipBits:	.byte $00, $40

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SetSpecialFrames
;
; Set one of the "special" frames, i.e. "spread eagle" running,
; somersaulting, holding, pipe facing, kicking, twirling, and
; even the forced-to-standing frame of "vibrationally disabled"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SetSpecialFrames:

	; Get absolute value of Player_XVel
	LDA <Player_XVel
	BPL PRG008_AECA
	JSR Negate
PRG008_AECA:

	CMP #$37
	BLT PRG008_AEF0	 ; If magnitude of Player's horizontal velocity is < $37, jump to PRG008_AEF0

	LDA Player_FlyTime
	BNE PRG008_AEF0	 ; If Player already has flight time, jump to PRG008_AEF0

	LDA Player_IsDucking
	ORA Player_IsClimbing
	ORA Player_Slide
	BNE PRG008_AEF0	 ; If Player is ducking, in a Kuribo's shoe, climbing a vine, or sliding, jump to PRG008_AEF0!!

	LDY <Player_WalkFrame	; Y = Player_WalkFrame (0 - 3)

	LDA <Player_Suit
	BNE PRG008_AEEB	 ; If Player is NOT small, jump to PRG008_AEEB

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG008_AEEB:
	LDA Player_SpreadEagleFrames,Y	 ; Get cooresponding spread-eagle frame
	STA <Player_Frame		 ; Store that!

PRG008_AEF0:
	LDA Player_Flip
	BEQ PRG008_AF0F	 ; If Player is NOT somersaulting, jump to PRG008_AF0F

	LDA <Counter_1
	LSR A		; A = Counter_1 >> 1
	PHA		 ; Save it

	AND #$07	 ; Cap 0 - 7
	TAY		 ; -> 'Y'

	LDA Player_SomersaultFlipBits,Y	 ; Get proper somersault flip bits

	LDY <Player_XVel
	BPL PRG008_AF05	 ; If Player_XVel >= 0, jump to PRG008_AF05

	EOR #SPR_HFLIP	 ; Otherwise, horizontally flip!

PRG008_AF05:
	STA <Player_FlipBits		 ; Update Player flip bits
	PLA		 ; Restore Counter_1 >> 1

	AND #$03	 ; Cap 0 - 3
	ADD #PF_SOMERSAULT_BASE	 ; Add base somersault frame
	STA <Player_Frame ; Update Player_Frame!

PRG008_AF0F:
	LDA Player_IsHolding
	BEQ PRG008_AF2F	 ; If Player is NOT holding something, jump to PRG008_AF2F

	LDY <Player_WalkFrame	 ; Y = PRG008_AF2F

	LDA Player_InAir_OLD
	BEQ PRG008_AF22	 ; If Player was NOT in air, jump to PRG008_AF22

	LDY #$00	; Otherwise, Y = 0

	LDA <Player_Suit
	BNE PRG008_AF22	
	INY		 ; ... unless small, in which case, Y = 1

PRG008_AF22:
	LDA <Player_Suit
	BNE PRG008_AF2A	 ; If Player is NOT small, jump to PRG008_AF2A

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG008_AF2A:
	LDA Player_HoldingFrames,Y ; Get appropriate "holding" frame
	STA <Player_Frame	 ; Update Player frame!

PRG008_AF2F:
	LDA Player_PipeFace
	BNE PRG008_AF45	 ; If Player is facing forward, jump to PRG008_AF45

	LDA Player_IsHolding
	BEQ PRG008_AF52	 ; If Player is NOT holding something, jump to PRG008_AF52

	LDA <Player_FlipBits
	CMP Player_FlipBits_OLD
	BEQ PRG008_AF52	 ; If Player's flip bits haven't changed, jump to PRG008_AF52

	LDA #$07
	STA Player_PipeFace ; Otherwise, Player_PipeFace = 7 (Player briefly faces forward while turning around holding something)

PRG008_AF45:
	DEC Player_PipeFace	 ; Player_PipeFace--

	LDA #PF_INPIPE_BIG	; Face-forward frame when Player is NOT small

	LDY <Player_Suit
	BNE PRG008_AF50	 ; If Player is NOT small, jump to PRG008_AF50

	LDA #PF_INPIPE_SMALL	 ; Face-forward frame when Player is small

PRG008_AF50:
	STA <Player_Frame ; Update Player frame !

PRG008_AF52:
	LDA Player_Kick
	BEQ PRG008_AF69	 ; If Player is NOT kicking something, jump to PRG008_AF69

	LDA #$00
	STA Player_TailAttack	 ; Player_TailAttack = 0 (stop tail attack effect if active!)

	LDY #PF_KICK_SMALL	 ; Kick frame when small

	LDA <Player_Suit
	BEQ PRG008_AF64	 ; If Player is small, jump to PRG008_AF64

	LDY #PF_KICK_BIG	 ; Kick frame when NOT small

PRG008_AF64:
	STY <Player_Frame ; Update Player frame!

	DEC Player_Kick	 ; PRG008_AF64--

PRG008_AF69:
	LDA Player_TwisterSpin
	BEQ PRG008_AFA1	 ; If Player is NOT twirling, jump to PRG008_AFA1

	DEC Player_TwisterSpin	 ; Player_TwisterSpin--

	LDY #$00	; Y = 0 (base index for small or frog)

	LDA <Player_Suit
	BEQ PRG008_AF87	 ; If Player is small, jump to PRG008_AF87

	CMP #$04
	BEQ PRG008_AF85	 ; If Player is Frog, jump to PRG008_AF85

	LDY #$04	 ; Y = 4 (base index all suits that can slide on slopes)

	TAX		 ; Power up -> 'X'

	LDA Player_Shell
	BNE PRG008_AF85

	LDA PowerUp_Ability,X
	AND #$01	 
	BEQ PRG008_AF87	 ; If able to slide on slopes, jump to PRG008_AF87

PRG008_AF85:
	LDY #$08	 ; Y = 8 (base value otherwise)

PRG008_AF87:
	STY <Temp_Var1	 ; Temp_Var1 = 0, 4, or 8

	LDA <Counter_1
	AND #$0c	 ; Cap value 0 - 11
	LSR A		 
	LSR A		 ; >> 2 (0 - 3)
	PHA		 ; Save it

	LSR A		 ; Shift down one more time
	TAY		 ; -> 'Y'
	LDA TwisterSpin_FlipBits,Y ; Get appropriate flip bits
	STA <Player_FlipBits	  ; ... and set them!

	PLA		 ; Restore (0 - 2)

	ADD <Temp_Var1	 ; Add base index
	TAY		 ; -> 'Y'

	LDA Player_TwisterSpinFrames,Y	 ; Get appropriate spin frame
	STA <Player_Frame		 ; Update Player frame!

PRG008_AFA1:
	LDA Player_VibeDisable
	BEQ PRG008_AFAD	 ; If Player is not "vibrationally disabled", jump to PRG008_AFAD

	LDY <Player_Suit
	LDA Player_VibeDisableFrame,Y	 ; Get appropriate "vibrationally disabled" frame (typ. standing)
	STA <Player_Frame	; Update Player frame!

PRG008_AFAD:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Koopa_Shell
;
; Change into or maintain Tanooki statue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Koopa_Shell:
	LDA <Player_InAir
	BNE RTSShell
	LDA Effective_Suit
	CMP #$05
	BNE Kill_Shell
	LDA <Player_XVel
	BEQ NoShellRTS				; If XVel is not 0 and holding down, we're in shell mode
	LDA <Pad_Holding
	AND #(PAD_DOWN)
	BNE NoShellRTS

Kill_Shell:
	LDA #$00

NoShellRTS:
	STA Player_Shell

RTSShell:
	RTS

	; Player's climb "animation", which is really just flipping the sprite
Player_DoClimbAnim:
	LDA Player_IsClimbing
	BEQ PRG008_B035	 ; If Player is NOT climbing, jump to PRG008_B035 (RTS)

	LDY <Player_Suit
	LDA Player_ClimbFrame,Y	 ; Get appropriate climbing frame
	STA <Player_Frame	 ; Store into Player_Frame

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN | PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_B035	 ; If Player is NOT pressing UP or DOWN, jump to PRG008_B035

	; Every 8 ticks, flip Player horizontally
	LDA <Counter_1
	AND #$08
	ASL A	
	ASL A	
	ASL A	
	STA <Player_FlipBits

PRG008_B035:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_AnimTailWag
;
; Animates the Player's tail wag for flying and fluttering
; Also plays the "wag" sound as appropriate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_AnimTailWag:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B09F	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B09F (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_B09F	 ; If Player_AllowAirJump, jump to PRG008_B09F (RTS)

	LDA <Player_InAir
	BEQ PRG008_B09F	 ; If Player is NOT mid air, jump to PRG008_B09F (RTS)

	LDA Player_IsDucking
	BNE PRG008_B082	 ; If Player is ducking, jump to PRG008_B082

	LDA Special_Suit_Flag		; Doesn't apply to  fire fox
	BNE PRG008_B062
	LDA <Pad_Input
	BPL PRG008_B062	 ; If Player is NOT pressing A, jump to PRG008_B062


	; The following replaces what would be a queued jump sound with the "wag" sound
	LDA Sound_QPlayer
	CMP #SND_PLAYERJUMP
	BEQ PRG008_B05D	 ; If jump sound is NOT queued, jump to PRG008_B05D

	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B05D:
	LDA #10
	STA Player_TailCount	 ; Player_TailCount = $10

PRG008_B062:
	LDA Player_TailCount
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = Player_TailCount >> 2

	LDA #$00	; A = 0 (flying!)

	LDY Player_FlyTime
	BNE PRG008_B072	 ; If flying, jump to PRG008_B072

	LDA #$06	 ; A = 6 (fluttering/falling)

PRG008_B072:
	LDY <Player_YVel
	BMI PRG008_B079	 ; If Player Y velocity < 0, jump to PRG008_B079

	ADD #$03	 ; Otherwise, add 3 (apex, when just running out of power, flying steady)

PRG008_B079:
	ADD <Temp_Var1	 ; Add specific frame offset
	TAY		 ; A -> Y
	LDA Player_TailWagFlyFrames,Y	 ; Get correct frame
	STA <Player_Frame ; And set it!

PRG008_B082:
	LDA Player_FlyTime
	ORA Player_WagCount
	BEQ PRG008_B09F	 ; If flying or fluttering, jump to PRG008_B09F (RTS)

	LDY #-1		 ; Y = -1
	LDA <Player_XVel
	BPL PRG008_B095	 ; If Player_XVel >= 0, jump to PRG008_B095

	LDY #1		 ; Y = 1
	JSR Negate	 ; Negate Player_XVel (get absolute value)

PRG008_B095:

	; Y = -1 and Player_XVel >= 0
	;    OR
	; Y = 1 and Player_XVel < 0
	;    (but magnitude is in 'A' either way)

	CMP #PLAYER_TOPWALKSPEED	
	BLS PRG008_B09F	 ; If X Velocity magnitude is < PLAYER_TOPWALKSPEED, jump to PRG008_B09F (RTS)

	; Otherwise add 'Y', which gives a slow acceleration up to that speed when in air as raccoon
	TYA
	ADD <Player_XVel
	STA <Player_XVel

PRG008_B09F:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SoarJumpFallFrame
;
; Sets Player's frame appropriate for "soaring" (high speed jump),
; standard jumping, or falling...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SoarJumpFallFrame:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B0C5	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B0C5

	LDA Player_AllowAirJump
	BNE PRG008_B0C5	 ; If Player_AllowAirJump, jump to PRG008_B0C5 (RTS)

	LDA <Player_InAir
	BEQ PRG008_B0C5	 ; If Player is mid air, jump to PRG008_B0C5 (RTS)

	LDA Player_IsDucking
	BNE PRG008_B0C5	 ; If Player is ducking, jump to PRG008_B0C5 (RTS)

	LDA #PF_FASTJUMPBIG	 ; High speed "soar" jump frame

	LDY Player_FlyTime
	BNE PRG008_B0C3	 ; If Player has jumped at high speed, jump to PRG008_B0C3

	LDA #PF_JUMPBIG	 ; Normal "fist pump" jump frame

	LDY <Player_YVel
	BMI PRG008_B0C3	 ; If Player is moving upward, jump to PRG008_B0C3

	LDA #PF_FALLBIG	 ; Standard "fall" frame

PRG008_B0C3:
	STA <Player_Frame ; Set appropriate frame

PRG008_B0C5:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttackAnim
;
; Animate tail attack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttackAnim:
	LDA <Pad_Holding
	AND #PAD_DOWN
	BNE PRG008_B109	 ; If Player is holding down, jump to PRG008_B109

	BIT <Pad_Input
	BVC PRG008_B0E2	 ; If Player is NOT pressing 'B', jump to PRG008_B0E2

	LDA Player_TailAttack
	BNE PRG008_B0E2	 ; If Player is performing tail attack, jump to PRG008_B0E2

	LDA #$12
	STA Player_TailAttack	 ; Player_TailAttack = $12
	LDA <Player_FlipBits
	ROL A
	ROL A
	ROL A
	AND #$01
	STA Player_Direction

	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B0E2:
	LDA Player_TailAttack
	BEQ PRG008_B109	 ; If Player is not performing tail attack, jump to PRG008_B109

	LSR A
	LSR A
	TAY		 ; Y = Player_TailAttack >> 2

	LDA <Player_InAir
	BEQ PRG008_B0F3	 ; If Player is NOT in mid air, jump to PRG008_B0F3

	INY
	INY
	INY
	INY
	INY		 ; Y += 5 (use mid air tail attack frames)

PRG008_B0F3:
	LDA Player_TailAttackFrames,Y	 ; Get appropriate tail attack frame
	STA <Player_Frame		 ; Store it


	; Flips player at particular times

	LDA Player_TailAttack
	CMP #$0b
	BEQ PRG008_B103

	CMP #$03
	BNE PRG008_B109

PRG008_B103:
	LDA <Player_FlipBits
	EOR #SPR_HFLIP
	STA <Player_FlipBits

PRG008_B109:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ShootAnim
;
; Animate shooting a fireball / hammer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ShootAnim:
	LDA Player_FireCount
	BEQ PRG008_B11E	 ; If Player has not just shot something, jump to PRG008_B11E

	LSR A
	LSR A		; A = Player_FireCount >> 2

	LDY <Player_InAir
	BEQ PRG008_B118	 ; If Player is mid air, jump to PRG008_B118

	ADD #(Player_FireInAir - Player_FireOnGround)	 ; Otherwise, offset to "on ground" frames

PRG008_B118:
	TAY		 ; A -> Y
	LDA Player_FireOnGround,Y ; Get appropriate frame
	STA <Player_Frame	 ; Set it!

PRG008_B11E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoScrolling
;
; Scrolls screen horizontally and vertically (including Raster
; Effects) as appropriate for Player's position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoScrolling:
	LDA Level_JctCtl
	BEQ PRG008_B127

PRG008_B126:
	RTS

PRG008_B127:
	LDA LevelVertJct
	BEQ PRG008_B12F	 ; If we're NOT in a Big Question Block area, jump to PRG008_B12F

	JMP PRG008_B1CE	 ; Otherwise, jump to PRG008_B1CE

PRG008_B12F:
	LDY Level_AScrlConfig
	BEQ PRG008_B150	 ; If no raster effects, jump to PRG008_B150
	BMI PRG008_B150	 ; If ASCONFIG_HDISABLE is set, jump to PRG008_B150

	; Sets horizontal scroll to auto scroll alternate values

	LDA Level_AScrlPosH
	PHA		 ; Save Level_AScrlPosH

	SUB <Horz_Scroll
	STA Level_ScrollDiffH	 ; Difference between horizontal scroll and Level_AScrlPosH

	PLA		 ; Restore Level_AScrlPosH
	STA <Horz_Scroll ; Set as new horizontal scroll

	LDA Level_AScrlPosHHi
	STA <Horz_Scroll_Hi	 ; Set proper "high" position for raster

	LDA Level_AScrlSclLastDir
	STA <Scroll_LastDir	 ; Set "Scroll_LastDir" as appropriate for raster

	JMP PRG008_B208		; Jump to PRG008_B208

PRG008_B150:

	; No raster effects or horizontal auto scroll not desired

	LDA <Player_X
	SUB <Horz_Scroll
	BPL PRG008_B195	 ; If Player_X >= Horz_Scroll, jump to PRG008_B195

	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$80
	ADD <Horz_Scroll
	STA <Temp_Var2	 ; Temp_Var2 = $80 + Horz_Scroll
	BCC PRG008_B166	 ; If no carry, jump to PRG008_B166

	INC <Temp_Var1	 ; Apply carry

PRG008_B166:
	LDA <Player_XHi
	CMP <Temp_Var1
	BLS PRG008_B1CE	 ; If Player_XHi < Temp_Var1 (Horizontal scroll as appropriate when adding $80), jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BEQ PRG008_B1CE	 ; If Player_X = Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE
	BMI PRG008_B1CE	 ; If Player_X < Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE

	STA Level_ScrollDiffH	 ; Result stored into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	 ; Horz_Scroll += Level_ScrollDiffH
	BCC PRG008_B181	 	; If no carry, jump to PRG008_B181
	INC <Horz_Scroll_Hi	 ; Otherwise, apply carry

PRG008_B181:

	LDA <Horz_Scroll_Hi
	CMP <Level_Width
	BLS PRG008_B1CE	 	; If Horz_Scroll_Hi < Level_Width, jump to PRG008_B1CE

	; Otherwise...
	LDA #$00
	STA <Horz_Scroll	 ; Horz_Scroll = 0
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	JMP PRG008_B1CE	 	; Jump to PRG008_B1CE

PRG008_B195:
	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$70
	ADD <Horz_Scroll
	STA <Temp_Var2		; Temp_Var2 = $70 + Horz_Scroll
	BCC PRG008_B1A4	 	; If no carry, jump to PRG008_B1A4
	INC <Temp_Var1		 ; Otherwise, apply carry

PRG008_B1A4:
	LDA <Temp_Var1
	CMP <Player_XHi
	BLS PRG008_B1CE	 	; If Temp_Var1 < Player_XHi, jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BPL PRG008_B1CE	 	; If Player_X >= Temp_Var2, jump to PRG008_B1CE

	STA Level_ScrollDiffH	; Store difference into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	; Horz_Scroll += Level_ScrollDiffH
	BCS PRG008_B1BD	 	; If carry set, jump to PRG008_B1BD
	DEC <Horz_Scroll_Hi	; Otherwise, remove carry

PRG008_B1BD:

	LDA <Horz_Scroll_Hi
	BPL PRG008_B1CE	 	; If Horz_Scroll_Hi >= 0, jump to PRG008_B1CE

	; Clear a bunch
	LDA #$00	 
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA Level_ScrollDiffH

PRG008_B1CE:
	LDA <Player_SpriteX

	LDY <Player_XVel
	BMI PRG008_B1DD	 ; If Player X velocity < 0 (moving leftward), jump to PRG008_B1DD

	; Player moving rightward...

	CMP #232
	BLT PRG008_B208	 ; If Player_SpriteX < 232, jump to PRG008_B1DD

	LDA #232	; Cap max at 232
	JMP PRG008_B1E3	 ; Jump to PRG008_B1E3

PRG008_B1DD:
	CMP #17
	BGE PRG008_B208	 ; If Player_SpriteX >= 17, jump to PRG008_B208
	LDA #16	 	; Cap min at 16

PRG008_B1E3:
	STA <Player_SpriteX ; Update Player_SpriteX

	LDY #$00	 ; Y = 0 (offset of Player_XHi)

	SUB <Player_X
	BPL PRG008_B1EE	 ; If Player_SpriteX >= Player_X, jump to PRG008_B1EE

	LDY #$ff	 ; Y = $FF (offset of Player_XHi, sign extended high part of negative)

PRG008_B1EE:
	ADD <Player_X	 
	STA <Player_X	 ; Player_X += difference between this and Player_SpriteX
	BCC PRG008_B1F6	 ; If no carry, jump to PRG008_B1F6

	INY		 ; Otherwise, apply carry

PRG008_B1F6:
	TYA		 ; A = Y ("high" part offset)
	ADD <Player_XHi	 ; Apply high adjustment
	STA <Player_XHi	 ; And store it!

	LDA <Player_XVel
	PHP		 ; Save processor status

	AND #%00001111	 ; Just take lower 4 bits (the "fractional" part)

	PLP		 ; Restore processor status

	BPL PRG008_B206	 ; If Player_XVel >= 0, jump to PRG008_B206

	ORA #$F0	 ; Otherwise, provide negative sign extention for fractional part

PRG008_B206:
	STA <Player_XVel ; Revise Player_XVel with only signed fractional part!

PRG008_B208:
	LDA Level_FreeVertScroll
	BEQ PRG008_B214	 ; If Level_FreeVertScroll = 0 (not freely scrolling), jump to PRG008_B214

	AND #$01
	BNE PRG008_B258	 ; If Level_FreeVertScroll = 1 (freely scrolling), jump to PRG008_B258

	; Otherwise, arbitrarily locked (whatever Vert_Scroll is)...
	JMP PRG008_B2A0	 ; Jump to PRG008_B2A0

PRG008_B214:

	; Not freely vertical scrolling (which persists as "NEVER" if 
	; Auto Scroll is active, but otherwise MAY be overridden)

	LDA Level_AScrlConfig
	BEQ PRG008_B246	 ; If auto scroll effect active, jump to PRG008_B246

	; Calculates Player Y based on auto scroll position
AutoScroll_CalcPlayerY:
	LDA Level_AScrlPosV
	PHA		 ; Save "Level_AScrlPosV"

	SUB <Vert_Scroll
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = difference of current scroll position from Level_AScrlPosV

	PLA		 	; Restore "Level_AScrlPosV"
	STA <Vert_Scroll 	; Becomes the new Vert_Scroll
	STA Level_VertScroll	; Becomes the new Level_VertScroll

	LDA <Player_InAir
	BEQ PRG008_B245	 ; If Player is not mid-air, jump to PRG008_B245 (RTS)

	LDA Player_IsClimbing
	ORA AScrlURDiag_WrapState_Copy
	BNE PRG008_B245	 ; If Player is climbing or diagonal autoscroller is wrapping, jump to PRG008_B245

	LDA Level_ScrollDiffV
	BPL PRG008_B23C	 ; If Level_ScrollDiffV >= 0, jump to PRG008_B23C

	DEC <Player_YHi	; Player_YHi--

PRG008_B23C:
	ADD <Player_Y
	STA <Player_Y	 ; Player_Y = Level_ScrollDiffV + Player_Y

	BCC PRG008_B245	 ; If no carry, jump to PRG008_B245

	INC <Player_YHi	 ; Otherwise, carry into Player_YHi

PRG008_B245:
	RTS		 ; Return


PRG008_B246:

	; VERTICAL SCROLL LOCK LOGIC

	; Checking whether vertical scrolling should be allowed in levels that explicitly disable it.
	; When set to not allow it by default, so long as no raster effects are going on (see above),
	; then we may allow it if the Player is flying (or high speed jumping) or climbing a vine.

	; Once the scroll point has reached Vert_Scroll = $EF (lowest scroll point) it stays there
	; unless one of the above specified overrides occur.  And here we go...

	LDA <Vert_Scroll
	CMP #$ef
	BNE PRG008_B258	 ; If Vert_Scroll <> $EF (lowest scroll point), jump to PRG008_B258 (allow free while Vert_Scroll < $EF)

	LDA Player_FlyTime
	ORA Player_IsClimbing
	PHP		 ; Save processor status

	LDA #$ef	 ; A = $EF (locked vertical scroll value)

	PLP		 ; Restore processor status

	; Optional free vertical scroll override...

	BEQ PRG008_B2A2	 ; If Player is not flying or climbing, jump to PRG008_B2A2

PRG008_B258:

	; Free vertical scrolling allowed

	LDA <Player_Y
	SUB Level_VertScroll
	STA <Temp_Var1		; Temp_Var1 = Player_Y - Level_VertScroll (difference between Player_Y and vertical scroll)

	LDA <Player_YHi
	SBC Level_VertScrollH
	BMI PRG008_B272	 ; If (Player_YHi - Level_VertScrollH) < 0, jump to PRG008_B272

	LDA <Temp_Var1
	SUB #$30
	BCS PRG008_B284	 ; If there was no borrow, jump to PRG008_B284

	; Minimum vertical scroll delta is -3
	CMP #-3
	BGE PRG008_B274	 ; If difference is -3 or above, jump to PRG008_B274

PRG008_B272:
	LDA #-3	 	; Otherwise, enforce -3 minimum

PRG008_B274:
	STA Level_ScrollDiffV ; Store as vertical difference

	ADD <Vert_Scroll   ; Add Vert_Scroll 
	BCS PRG008_B281	   ; If carry occurred, jump to PRG008_B281

	LDA #$00
	STA Level_ScrollDiffV	; Level_ScrollDiffV = 0

PRG008_B281:
	JMP PRG008_B29E	 ; Jump to PRG008_B29E

PRG008_B284:
	LDA <Temp_Var1
	SUB #$58
	BCC PRG008_B2A0	 ; If borrow occurred, jump to PRG008_B2A0

	STA Level_ScrollDiffV	; Store as vertical difference

	ADD <Vert_Scroll
	BCS PRG008_B297	 ; If carry occurred, jump to PRG008_B297

	CMP #$ef
	BLT PRG008_B29E	 ; If calculated value is less than $EF, we're not at the bottom yet, and so jump to PRG008_B29E

PRG008_B297:
	LDA #$00
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$ef	 ; Bottom scroll position is $EF

PRG008_B29E:
	STA <Vert_Scroll	 ; Update Vert_Scroll

PRG008_B2A0:
	LDA <Vert_Scroll	

PRG008_B2A2:

	; Entry point if free vertical scrolling is disabled and Player did not override it

	STA Level_VertScroll	 ; Set Level_VertScroll

	LDA #$00
	STA Level_VertScrollH	 ; Level_VertScroll = 0

	RTS		 ; Return


	; Offsets used for tile detection in non-sloped levels
	; +16 if moving downward
	; +8 if on the right half of the tile
TileAttrAndQuad_OffsFlat:
	;     Yoff Xoff

	; Not small or ducking moving downward - Left half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $0E	; In-front lower
	.byte $0E, $0E	; In-front upper

	; Not small or ducking moving downward - Right half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $01	; In-front lower
	.byte $0E, $01	; In-front upper

	; Not small or ducking moving upward - Left half
	.byte $06, $08	; Ground left
	.byte $06, $08	; Ground right
	.byte $1B, $0E	; In-front lower
	.byte $0E, $0E	; In-front upper

	; Not small or ducking moving upward - Right half
	.byte $06, $08	; Ground left
	.byte $06, $08	; Ground right
	.byte $1B, $01	; In-front lower
	.byte $0E, $01	; In-front upper


TileAttrAndQuad_OffsFlat_Sm:
	; Small or ducking moving downward - Left half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $0D	; In-front lower
	.byte $14, $0D	; In-front upper

	; Small or ducking moving downward - Right half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $02	; In-front lower
	.byte $14, $02	; In-front upper

	; Small or ducking moving upward - Left half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $1B, $0D	; In-front lower
	.byte $14, $0D	; In-front upper

	; Small or ducking moving upward - Right half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $1B, $02	; In-front lower
	.byte $14, $02	; In-front upper


PlayerY_HeightOff:	.byte $12, $05	; Left value is Player_Y offset for small/ducking, right for otherwise
Wall_Clip:	
	.byte $03, $02

PRG008_B3B0:	.byte $04, $0D

	; If $01, this is treated as a "not floor" tile, which means to watch out
	; for the Player to hit his head rather than track the sloped floor...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileAndSlope
;
; Gets tile and attribute of tile for either non-vertical or
; vertical levels based on Player's position
;
; Temp_Var10 is a Y offset (e.g. 0 for Player's feet, 31 for Player's head)
; Temp_Var11 is an X offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileAndSlope:

	LDA #$00
	STA Temp_VarNP0 ; Temp_VarNP0 = 0

	LDA Player_PartDetEn
	BEQ PRG008_B3F7	 ; If Player_PartDetEn is not set, jump to PRG008_B3F7

	; Bottom two tile rows forced detection enabled when Player Y >= 160...

	LDA Player_AboveTop
	BNE PRG008_B3F7	 ; If Player is above top of screen, jump to PRG008_B3F7

	LDA <Player_Y
	ADD <Temp_Var10		; Temp_Var10 is the Y offset 
	SUB Level_VertScroll	; Make relative to Vertical Scroll

	CMP #160
	BLT PRG008_B3F7	 ; If result < 160, jump to PRG008_B3F7

	; Player is low enough to the visual floor... detect the bottom two rows of tiles!

	SBC #16		; - 16
	AND #$F0	; Align to tile grid
	STA <Temp_Var14	; -> Temp_Var14

	LDA #$01
	STA <Temp_Var13	 ; Temp_Var13 = 1 (implied high byte / carry)

	STA Temp_VarNP0 ; Temp_VarNP0 = 1

	BNE PRG008_B406	 ; Jump (technically always) to PRG008_B406

PRG008_B3F7:
	LDA <Player_YHi
	BPL PRG008_B3F8

	LDA #$00
	STA <Temp_Var13
	STA <Temp_Var14
	BEQ PRG008_B406

PRG008_B3F8:
	STA <Temp_Var13	 ; Temp_Var13 = Player_YHi

	LDA <Temp_Var10	 ; Temp_Var10 is the Y offset 
	ADD <Player_Y	 
	STA <Temp_Var14	 ; Temp_Var14 = Temp_Var10 + Player_Y

	BCC PRG008_B406	 ; If no carry, jump to PRG008_B406

	INC <Temp_Var13	 ; Apply carry to Temp_Var13

PRG008_B406:
	LDA <Temp_Var13
	BEQ PRG008_B419	 ; If Temp_Var13 (high byte / carry) = 0, jump to PRG008_B419

	; When carry exists..

	CMP #$01
	BNE PRG008_B414	 ; If Temp_Var13 <> 1, jump to PRG008_B414

	LDA <Temp_Var14
	CMP #$b0	
	BLT PRG008_B419	 ; If Temp_Var14 < $B0, jump to PRG008_B419

PRG008_B414:
	LDA #$A8
	STA <Temp_Var14


PRG008_B419:
	LDA <Player_XHi
	STA <Temp_Var15	 ; Temp_Var15 = Player_XHi

	LDA <Temp_Var11
	BPL PRG008_B423	 ; If Temp_Var11 >= 0, jump to PRG008_B423

	DEC <Temp_Var15	 ; Temp_Var15--

PRG008_B423:
	LDA <Player_X
	ADD <Temp_Var11
	STA <Temp_Var16	 ; Temp_Var16 = Player_X + Temp_Var11
	BCC PRG008_B42E	 ; If no carry, jump to PRG008_B42E

	INC <Temp_Var15	 ; Temp_Var15++ (apply carry to Temp_Var15)

PRG008_B42E:

	; So in total we've calculated:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	; X/Y were not modified, so as inputs:
	; X = 0 (going down) or 1 (going up)
	; Y = Player_YVel

	STY <Temp_Var10	 ; Temp_Var10 = Player_YVel
	STX <Temp_Var11	 ; Temp_Var11 = 0 or 1

	JSR Player_GetTileAndSlope_Normal	 ; Set Level_Tile and Player_Slopes

	LDX <Temp_Var11	 	; Temp_Var11 = 0 (going down) or 1 (going up)
	LDY Level_PipeMove	; Y = Level_PipeMove (movement command in $8x form)
	BNE PRG008_B43F	 	; If Level_PipeMove <> 0, jump to PRG008_B43F

	PHA
	JSR CheckSpriteOnFG
	ORA Player_Behind_En
	STA Player_Behind_En
	PLA

PRG008_B43F:
	LDY <Temp_Var10	 ; Y = Player_YVel
	RTS		 ; Return

TileSolidOffset:
	.byte $00, $0E
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DetectSolids
;
; Handles Player's collision against solid tiles (wall and ground,
; handles slopes and sliding on them too!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DetectSolids:
	LDA Boo_Mode_Timer
	BNE No_Detection
	LDA #$00
	STA Player_HitCeiling ; Clear Player_HitCeiling
	STA Wall_Jump_Enabled

	LDA Level_PipeMove
	BEQ PRG008_B47E	 ; If not going through a pipe, jump to PRG008_B47E

No_Detection:
	RTS		 ; Return

PRG008_B47E:
	LDY #(TileAttrAndQuad_OffsFlat_Sm - TileAttrAndQuad_OffsFlat) + 6	; 6 = 3 * 2 (the offset we start on below) and work backwards from

	LDA <Player_Suit
	BEQ PRG008_B4B2	 ; If Player is small, jump to PRG008_B4B2

	LDA Player_IsDucking
	BNE PRG008_B4B2	 ; If Player is ducking, jump to PRG008_B4B2

	LDY #6		; 6 = 3 * 2 (the offset we start on below) and work backwards from

PRG008_B4B2:
	LDX #$03	 ; X = 3 (the reason for +6 above)

	LDA <Player_YVel 
	BPL PRG008_B4BD	 ; If Player_YVel >= 0 (moving downward), jump to PRG008_B4BD

	; Otherwise, add 16 to index
	TYA
	ADD #16
	TAY

PRG008_B4BD:
	LDA <Player_X
	AND #$0f
	CMP #$08
	BLS PRG008_B4CA	 ; If Player is on the left half of the tile, jump to PRG008_B4CA

	; If on the right half, add 8 to index
	TYA	
	ADD #$08
	TAY	

PRG008_B4CA:
	TYA		 ; Offset -> 'A'
	PHA		 ; Save offset
	TXA
	PHA

	; Get X/Y offset for use in detection routine
	LDA TileAttrAndQuad_OffsFlat,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA TileAttrAndQuad_OffsFlat+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope	 ; Get tile
	
	JSR Level_DoCommonSpecialTiles
	STA Level_Tile_Prop_GndL,X	 ; Store it
	JSR HandleIceBreak
	JSR Player_WallHandle

	PLA
	TAX
	PLA		 
	TAY		 ; Restore 'Y' index
	DEY
	DEY		 ; Y -= 2 (next pair of offsets)

	DEX		 ; X--

	BMI PRG008_B4F3	 ; If X < 0, jump to PRG008_B4F3
	JMP PRG008_B4CA	 ; Otherwise, loop!

PRG008_B4F3:

	LDA <Player_YVel
	BPL PRG008_B55B	 ; If Player Y velocity >= 0 (moving downward), jump to PRG008_B55B

	LDA <Player_InAir
	BEQ PRG008_B55B	 ; If Player is NOT mid air, jump to PRG008_B55B

	LDA Level_Tile_Prop_GndL
	CMP #TILE_PROP_SOLID_ALL
	BCS PRG008_B558	 ; If not touching a solid tile, jump to PRG008_B55A

	LDA Level_Tile_Prop_GndR
	CMP #TILE_PROP_SOLID_ALL
	BCC PRG008_B55B

PRG008_B558:
	LDA #$01
	STA Player_HitCeiling	 ; Flag Player as having just hit head off ceiling
	LDA #$FF
	STA <Player_YVel ; Update Player_YVel
	LDA Player_Y
	AND #$F0
	LDX Player_Suit
	BEQ PRG008_B559
	LDX Player_IsDucking
	BNE PRG008_B559
	ORA #$08
	STA Player_Y
	RTS		 ; Return

PRG008_B559:
	AND #$F0
	ORA #$0F
	STA <Player_Y
	;LDA <Player_YHi
	;ADC #$00
	;STA <Player_YHi
	RTS


PRG008_B55B:
	LDA <Player_YVel
	BMI PRG008_B57F
	LDA Level_Tile_Prop_GndR	 ; Get right tile
	AND #TILE_PROP_SOLID_TOP
	BNE PRG008_B580	 	 ; If the tile is >= the attr value, jump to PRG008_B57E

	LDA Level_Tile_Prop_GndL	 ; Get left tile
	AND #TILE_PROP_SOLID_TOP	
	BNE PRG008_B580	 	 ; If the tile is >= the attr value, jump to PRG008_B57E

PRG008_B57E:
	LDA <Player_InAir
	BNE PRG008_B57F
	LDA #$01
	STA <Player_YVel 
	STA <Player_InAir

PRG008_B57F:
	RTS

PRG008_B580:
	LDA <Player_Y
	SEC
	AND #$0F
	CMP #$06
	BGE PRG008_B581
	LDA <Player_Y
	AND #$F0
	STA <Player_Y
	LDA #$00	 
	STA <Player_InAir ; Player NOT mid air
	STA <Player_YVel  ; Halt Player vertically
	LDA #$01
	STA Kill_Tally	  ; Reset Kill_Tally

PRG008_B581:
	RTS		 ; Return

	; Handle all common special tiles (ice blocks, P-Switches, bump blocks, etc.)
	; Does not include things like instant-kill lava tiles...
Level_DoCommonSpecialTiles:
	STA TempA
	STY TempY

	CMP #TILE_ITEM_COIN
	BCC PRG008_B582
	JMP PRG008_B586

PRG008_B582:
	AND #$F0
	CMP #TILE_PROP_SOLID_BOTTOM
	BNE PRG008_B582_2
	LDA TempA
	JMP PRG008_B586

PRG008_B582_2:
	CMP #TILE_PROP_SOLID_TOP
	BCS PRG008_B585
	LDA TempA
	AND #$0F
	CMP #TILE_PROP_COIN
	BNE PRG008_B583

	LDA Level_ChgTileEvent
	BNE PRG008_B583

	LDY <Temp_Var12		 
	LDA <Level_Tile	; prevent double collecting
	EOR #$01
	STA [Map_Tile_AddrL],Y	; prevent double collecting
	JSR Level_QueueChangeBlock

	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	INC Coins_Earned

	LDA #$00
	LDY TempY
	RTS

PRG008_B583:
	CMP #TILE_PROP_CHERRY
	BNE PRG008_B584

	LDA Cherries
	CMP #99
	BCS PRG008_B584

	LDA Level_ChgTileEvent
	BNE PRG008_B583

	LDY <Temp_Var12		 
	LDA <Level_Tile	; prevent double collecting
	EOR #$01
	STA [Map_Tile_AddrL],Y	; prevent double collecting
	JSR Level_QueueChangeBlock

	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1

	INC Cherries
	LDA #$00
	LDY TempY

PRG008_B584:
	CMP #TILE_PROP_TRAP
	BNE NoTrapSet
	LDA #$01
	BNE SetTrapVal

NoTrapSet:
	LDA #$00

SetTrapVal:
	STA TrapSet

PRG008_B585_3:

	CPX #$02
	BCS PRG008_B585_4
	LDA <Level_Tile
	AND #$3F
	BNE PRG008_B585_4
	LDA <Player_YVel
	BMI PRG008_B585_4
	LDA #$D0
	STA <Player_YVel
	STA <Player_InAir
	LDA #$00
	STA TempA

PRG008_B585_4:
	LDA TempA
	RTS

PRG008_B585:
	LDA TempA
	AND #$0F
	CPX  #$02
	BCS PRG008_B585_2
	CMP #TILE_PROP_PSWITCH
	BCC PRG008_B585_3
	PHA

	LDY <Temp_Var12		 
	LDA <Level_Tile
	EOR #$01
	STA [Map_Tile_AddrL],Y	
	JSR Level_QueueChangeBlock
	LDA #$10
	STA Level_Vibration	; Level_Vibration = $10 (little shake effect)

	; Wham! sound effect
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	PLA
	CMP #TILE_PROP_PSWITCH
	BNE PRG008_B585_2_2
	LDA #$80	 
	STA Level_PSwitchCnt	 ; Level_PSwitchCnt = $80 (duration of switch)

	; Play P-Switch song
	LDA #MUS2B_PSWITCH
	STA Sound_QMusic2

PRG008_B585_2:
	LDA TempA
	RTS

PRG008_B585_2_2:
	LDA #$01
	STA EventSwitch
	LDA #$00
	STA EventVar
	RTS

PRG008_B586:
	CPX #$02
	BCC NoFireFoxBusts
	LDY Fox_FireBall
	BNE DoSpinnerBusts

NoFireFoxBusts:
	LDY <Player_YVel
	BPL PRG008_B588
	CPX  #$01
	BCS PRG008_B588
	JSR Level_DoBumpBlocks	 ; Handle any bumpable blocks (e.g. ? blocks, note blocks, etc.)
	JSR PRG008_B558

PRG008_B588:
	LDA TempA
	RTS

DoSpinnerBusts:
	CMP #TILE_ITEM_COIN
	BCC SpinnerBustRts
	JSR Level_DoBumpBlocks
	LDX TempX

NoSpinnerKeepGoing:
	LDA #$00

SpinnerBustRts
	RTS

Level_DoBumpBlocks:
	STX TempX
	AND #$0F
	STA DAIZ_TEMP4
	TAY 
	BEQ DoBumps
	CMP #$0C
	BCS DoBumps
	LDA Objects_State + 5
	BEQ DoBumps
	RTS

DoBumps:
	LDA #$00
	STA ObjectBump
	LDA #$10
	STA Splash_DisTimer
	TYA
	JSR LATP_HandleSpecialBounceTiles	; Do what this special tile ought to do!
	TYA		 ; Power up result (if any) is in 'Y'!
	BMI PRG008_B78C

PRG008_B723:
	; Play bump sound

	TYA
	ORA #$20
	STA Player_Bounce
	LDY #$01

PRG008_B723_2:
	LDA #$C0
	STA TempA
	INY

PRG008_B724:
	STY Player_BounceDir
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	LDA <Level_Tile
	AND #$C0
	STA <Temp_Var12

	
PRG008_B75B:
	LDY #$06	; Y = 6

	LDA Objects_State,Y
	BEQ PRG008_B766	 ; If this object is dead/empty, jump to PRG008_B766
	INY		 ; Y++

PRG008_B766:
	; Align Y lo to tile grid
	LDA <Temp_Var14
	AND #$F0
	STA <Temp_Var14
	STA Objects_Y,Y	 ; Store into object slot

	LDA <Temp_Var13
	STA Objects_YHi,Y ; Store Y Hi into object slot

	LDA <Temp_Var15	
	STA Objects_XHi,Y ; Store X Hi into object slot

	LDA <Temp_Var16
	AND #$F0
	STA Objects_X,Y	 ; Store X Lo into object slot

	
	JSR BlockBump_Init	; Init the block bump effect!

	STX TempX
	LDA DAIZ_TEMP4
	SUB #$0D
	BMI PRG008_B78B
	CMP #$02
	BCS PRG008_B78B
	TAX
	LDA <Level_Tile
	STA Level_BlkFinish
	LDA NoPUpTypes, X
	STA Player_Bounce
	LDX TempX
	CPX #$01
	BNE PRG008_B78B
	LDA #$00
	RTS
	
PRG008_B78B:
	LDA TempA
	RTS		 ; Return

PRG008_B78C:
	LDA <Level_Tile
	AND #$C0
	ORA #$01
	JSR Level_QueueChangeBlock
	LDA #$00
	RTS

NoPUpTypes:
	.byte $31, $41, $2B
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LATP_HandleSpecialBounceTiles
;
; Ever wondered where the code was that makes ? blocks emerge 
; powerups, music note blocks bounce you around, and bricks bust?
; Well, here it is!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LATP_HandleSpecialBounceTiles:
	STA <Temp_Var1	 ; Backup power-up request -> Temp_Var1 
	LDA Player_Bounce
	BNE PRG008_B7B7	 ; If Player is already in a bounce, jump to PRG008_B7B7

	LDY #$06	 ; Y = 6 (object slot index)
	LDA Objects_State,Y	; Check this object's state
	ORA Level_BlkBump	; And block bump 1...
	BEQ PRG008_B7A7	 	; If item is "dead/empty" and block bump 1 isn't in use, jump to PRG008_B7A7

	LDA Objects_State+1,Y ; Check next object's state
	ORA Level_BlkBump+1  ; And block bump 2...
	BNE PRG008_B7B7	 	; If item is NOT "dead/empty" or block bump 2 is in use, jump to PRG008_B7B7

PRG008_B7A7:
	LDY #$05	 ; Y = 5 (object slot index)

	LDA Objects_Timer,Y
	BEQ PRG008_B7BA	 ; If timer expired, jump to PRG008_B7BA

	LDA <Temp_Var16	 ; Player detect X low
	AND #$F0	 ; Aligned to tile grid
	CMP Objects_X,Y	 
	BNE PRG008_B7BA	 ; If this object's X does not match the aligned detect X, jump to PRG008_B7BA

PRG008_B7B7:
	LDY #$00	 ; Y = 0 (no space for bounce object found)

 
	RTS		 ; Return


PRG008_B7BA:

	; Align X Detect low to tile grid
	LDA <Temp_Var16
	AND #$F0
	STA <Temp_Var16

	LDA <Temp_Var1	 ; Get power-up value
	ASL A		 ; Make into 2-byte index
	TAY		 ; -> 'Y'

	; Load jump address as per block tile type...
	LDA LATP_JumpTable,Y
	STA <Temp_Var1	
	LDA LATP_JumpTable+1,Y
	STA <Temp_Var2	
	JMP [Temp_Var1]	 ; Handle special block!

LATP_JumpTable:
	.word LATP_Coin	; 1 = Mushroom/Flower
	.word LATP_Flower		; 4 = Coin
	.word LATP_Leaf		; 2 = Mushroom/Leaf
	.word LATP_IceFlower; 5 = Coin/Star
	.word LATP_Frog     ;
	.word LATP_FoxLeaf	; A = Fox Leaf
	.word LATP_Koopa	;
	.word LATP_Pumpkin	; 8 = 10 coin
	.word LATP_Sledge   ;
	.word LATP_NinjaShroom		; 9 = 1-up
	.word LATP_Star		; 3 = Star-
	.word LATP_Vine		; 7 = Vine
	.word LATP_PSwitch	; B = P-Switch
	.word LATP_Brick	; 6 = Standard brick behavior
	.word LATP_Spinner
	.word LATP_Key
	
LATP_None:
	LDY #$01		; Y = 1 (spawn .. nothing?) (index into PRG001 Bouncer_PUp)
	RTS		 ; Return

LATP_Flower:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)
	LDY #$02	 ; Y = 5 (spawn a mushroom) (index into PRG001 Bouncer_PUp)
	JSR Do_PUp_Proper
	RTS		 ; Return

; #DAHRKDAIZE ICE_FLOWER
LATP_IceFlower:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$08	 ; Y = 2 (spawn an ice flower) (index into PRG001 Bouncer_PUp)
	JSR Do_PUp_Proper
	RTS		 ; Return

;;;;;;;;;;;;
LATP_Pumpkin:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)
	LDY #$09	 ; Y = 2 (spawn an ice flower) (index into PRG001 Bouncer_PUp)
	JSR Do_PUp_Proper
	RTS		 ; Return

LATP_Leaf:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$03	 ; Y = 3 (spawn a leaf) (index into PRG001 Bouncer_PUp)
	JSR Do_PUp_Proper
	RTS		 ; Return

LATP_Star:
	LDA #$80
	STA PUp_StarManFlash	 ; PUp_StarManFlash = $80 (activate star man flash)

	LDY #$04	 ; Y = 4 (spawn a starman) (index into PRG001 Bouncer_PUp)

	RTS		 ; Return

LATP_Coin:
	JSR LATP_CoinCommon	 ; Do common "power up" coin routine

	LDY #$01	 ; Y = 1 (spawn a coin) (index into PRG001 Bouncer_PUp, i.e. nothing)

	LDA <Temp_Var16
	ORA <Temp_Var15	; Regenerate 10 coin block ID
	CMP B10Coin_ID
	BNE PRG008_B82F	; If this is a DIFFERENT coin block than the last one we started, jump to PRG008_B82F (RTS)

PRG008_B82F:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Code removed for Starman continuation block
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LATP_Spinner:
	
	LDA Fox_FireBall
	BNE LATP_Brick
	LDA Level_ChgTileEvent
	BNE NoSpinner
	STX TempX
	LDX #$09

FindFreeSpinner:
	LDA SpinnerBlockTimers, X
	BEQ DoSpinner
	DEX
	BPL FindFreeSpinner
	LDX TempX

NoSpinner:
	RTS

DoSpinner:
	LDA <Level_Tile
	STA SpinnerBlocksReplace, X
	EOR #$01
	STA <Level_Tile
	LDA #$FF
	STA SpinnerBlockTimers, X
	LDA <Temp_Var14
	STA SpinnerBlocksY,X	 ; Store into object slot

	LDA <Temp_Var13
	STA SpinnerBlocksYHi,X ; Store Y Hi into object slot

	LDA <Temp_Var15	
	STA SpinnerBlocksXHi,X ; Store X Hi into object slot

	LDA <Temp_Var16
	STA SpinnerBlocksX,X ; Store X Hi into object slot
	LDX TempX
	LDY #$01
	RTS

LATP_Brick:
	LDA <Level_Tile
	PHA
	JSR LATP_GetCoinAboveBlock	; Get coin above block, if any
	PLA
	STA <Level_Tile

	CPX #$04
	BEQ PRG008_B84E	 ; If on tile check index 4 (tail attack's tile), jump to PRG008_B84E (bust brick!)

	LDA <Player_Suit
	BNE PRG008_B84E	 ; If Player is not small, jump to PRG008_B84E (bust brick!)

	LDY #$01	 ; Y = 1 (spawn a coin) (index into PRG001 Bouncer_PUp, i.e. nothing)

	RTS		 ; Return

LATP_BustIce:
PRG008_B84E:
	; Crumbling sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; If a brick is busting in slot 1, move it to slot 2

	LDA #$02
	STA BrickBust_En	 ; Set brick bust enable

	; Y
	LDA <Temp_Var14
	AND #$F0
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr	 ; Store upper brick segment Y

	ADD #$08
	STA BrickBust_YLwr	 ; Store lower brick segment Y

 	; X
	LDA <Temp_Var16
	AND #$F0
	SUB <Horz_Scroll
	STA BrickBust_X	 ; Store X base coordinate

	LDA #$00	 
	STA BrickBust_XDist	 ; Reset X fan out distance
	STA BrickBust_HEn	 ; Reset horizontal enablers

	LDA #-6	 
	STA BrickBust_YVel	 ; Y velocity = -6

	LDY #$80
	STY <Temp_Var12		 ; Temp_Var12 = CHNGTILE_DELETETOBG

	LDY #$80	 	; Y = $80
	RTS		 ; Return

LATP_Vine:
	LDY #$00	 ; Y = 0 (??)

	; Vine raise sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

	LDY #$06	 ; Y = 6 (vine) (index into PRG001 Bouncer_PUp)
	RTS		 ; Return

LATP_NinjaShroom:
	
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$07	 ; Y = 7 (1-up) (index into PRG001 Bouncer_PUp)
	JSR Do_PUp_Proper
	RTS		 ; Return

LATP_Key:

	LDA #OBJSTATE_INIT
	STA Objects_State + 5
	LDA #OBJ_KEY
	STA Level_ObjectID + 5
	LDA <Temp_Var14
	AND #$F0
	SUB #$11
	STA Objects_Y + 5
	LDA <Temp_Var13
	SBC #$00
	STA Objects_YHi + 5

	LDA <Temp_Var16
	AND #$F0
	STA Objects_X + 5
	LDA <Temp_Var15
	STA Objects_XHi + 5

	LDY #$00
KeyRTS:
	RTS		 ; Return

LATP_FoxLeaf:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$0A	 ; Y = 3 (spawn a leaf) (index into PRG001 Bouncer_PUp)
	JSR Do_PUp_Proper
	RTS		 ; Return

LATP_Frog:
	LDY #$04
	JSR Do_PUp_Proper
	CPY #$04
	BNE Frog_RTS
	LDA #$01
	STA PUp_StarManFlash

Frog_RTS:
	RTS		 ; Return


LATP_Koopa:
	LDY #$04
	JSR Do_PUp_Proper
	CPY #$04
	BNE Koopa_RTS
	LDA #$02
	STA PUp_StarManFlash

Koopa_RTS:
	RTS


LATP_Sledge:
	LDY #$04
	JSR Do_PUp_Proper
	CPY #$04
	BNE Sledge_RTS
	LDA #$03
	STA PUp_StarManFlash

Sledge_RTS:
	RTS

LATP_PSwitch:
	LDY #$05	 ; Y = 5

PRG008_B8BE:
	LDA SpecialObj_ID,Y
	BEQ PRG008_B8C9	 ; If this is a free spawn event slot, jump to PRG008_B8C9
	DEY		 ; Y--
	BPL PRG008_B8BE	 ; While Y >= 0, loop!
	JMP PRG008_B8D3	 ; Jump to PRG008_B8D3

PRG008_B8C9:
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y	 ; Special object "poof"
	LDA #$20	 
	STA SpecialObj_Data,Y	 ; Used as "counter" while poof is in effect

PRG008_B8D3: 
	LDA <Temp_Var14	 ; Get Y Low
	AND #$F0	 ; Align to tile grid
	SUB #16		 ; Above hit tile
	PHP		 ; Save processor status

	CPY #$00
	BLS PRG008_B8E2	 ; If index < 0, then we don't have a special object, and skip setting Y Lo

	STA SpecialObj_YLo,Y	 ; Otherwise, store Y Lo

PRG008_B8E2:
	STA Level_BlockChgYLo	 ; Store block change Y low coord
	PLP		 ; Restore processor status

	LDA <Temp_Var13	 ; Get Y high
	SBC #$00	 ; Apply carry as necessary from previous subtraction

	CPY #$00	 
	BLS PRG008_B8F1	 ; If index < 0, then we don't have a special object, and skip setting Y Hi
	STA SpecialObj_YHi,Y	 ; Otherwise, store Y Hi

PRG008_B8F1:
	STA Level_BlockChgYHi	 ; Store block change Y high coord

	LDA <Temp_Var16	 ; Get X Low

	CPY #$00
	BLS PRG008_B8FD	 ; If index < 0, then we don't have a special object, and skip setting X Lo
	STA SpecialObj_XLo,Y	 ; Otherwise, store X Lo

PRG008_B8FD:
	STA Level_BlockChgXLo	 ; Store block change X low coord

	LDA <Temp_Var15		 ; Get X Hi
	STA Level_BlockChgXHi	 ; Store block change X high coord

	LDA PSwitchActivateTile	 
	STA Level_ChgTileEvent	 ; Queue P-Switch appear!

	LDY #$01	 ; Y = 1 (index into PRG001 Bouncer_PUp, i.e. nothing)
	RTS		 ; Return

LATP_CoinCommon:
	INC Coins_Earned ; One more coin earned
	INC Coins_ThisLevel	 ; One more coin earned this level

	; Y Lo - into Temp_Var1
	LDA <Temp_Var14	
	STA <Temp_Var1	

	; X Lo - center it up, shove into Temp_Var2
	LDA <Temp_Var16
	AND #$F0
	ORA #$04
	STA <Temp_Var2

	JMP Produce_Coin	 ; Jump to Produce_Coin (common "power up" coin entry)

	; Special routine which gets a coin above a ? block, if one is present!
LATP_GetCoinAboveBlock:
	LDA <Temp_Var14
	PHA		 ; Save Temp_Var14 (Y Lo)
	SUB #16	
	STA <Temp_Var14	 ; Temp_Var14 -= 16 (get tile above)

	STX <Temp_Var5	 ; Backup X into Temp_Var5
	JSR Player_GetTileAndSlope_Normal	 ; Get a tile here
	LDX <Temp_Var5	 ; Restore X into Temp_Var5

	TAY
	LDA TileProperties, Y
	CMP #TILE_ITEM_COIN
	BCS PRG008_B948
	AND #$0F
	CMP #TILE_PROP_COIN
	BNE PRG008_B948	 ; If tile above is not a coin, jump to PRG008_B948

	; Tile above was a coin...
	; The following will collect the coin along with the ? block hit!
	LDY <Temp_Var12		 ; ... and copied into Temp_Var12
	LDA [Map_Tile_AddrL],Y
	EOR #$01
	STA [Map_Tile_AddrL],Y
	
	JSR Level_QueueChangeBlock	; Delete to background

	PLA		 
	STA <Temp_Var14		 ; Restore Temp_Var14
	JMP LATP_CoinCommon	 ; Jump to common coin routine

PRG008_B948:
	PLA		 
	STA <Temp_Var14	 ; Restore Temp_Var14
	RTS		 ; Return


Player_TailAttack_Offsets: ; (Y and X)
	.byte 28, -6	; Player not horizontally flipped
	.byte 28, 21	; Player horizontally flipped

Player_ShellAttack_Offsets:
	.byte 28, 0	; Player not horizontally flipped
	.byte 28, 15; Player horizontally flipped

Player_Shell_FlipFlip:
	.byte $02, $00, $00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttack_HitBlocks
;
; Short routine that handles the tail attack hitting blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttack_HitBlocks:
     LDA Player_TailAttack
     CMP #$09
     BNE PRG008_B979        ; If Player_TailAttack <> 9, jump to PRG008_B979

Player_Shell_HitBlocks:
    LDY #$00         ; Y = 0 (Player not flipped)

	LDA <Player_FlipBits
	BNE PRG008_B95F	 ; If Player is horizontally flipped, jump to PRG008_B95F

	LDY #$02	 ; Y = 2 (Player flipped)

PRG008_B95F:
	LDA Player_Shell		; in shell mode, we flip the flip bits so we break bricks
	BEQ Normal_Tail_Flip			; while moving forward
	LDA Player_Shell_FlipFlip, Y
	TAY
	LDA Player_ShellAttack_Offsets,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA Player_ShellAttack_Offsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)
	JMP Do_Tile_Attack

Normal_Tail_Flip:
	LDA Player_TailAttack_Offsets,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA Player_TailAttack_Offsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

Do_Tile_Attack:
	JSR Player_GetTileAndSlope	 ; Get tile near tail
	
	CMP #TILE_ITEM_COIN
	BCC PRG008_B979
	LDX #$04	 
	STA Level_Tile_Prop_GndL,X	 ; Store into tail's special slot
	JSR Level_DoBumpBlocks	 ; Handle blocks that can be "bumped"

PRG008_B979:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_BumpOffBlocks
;
; Handle a kicked shelled object bouncing off blocks.  Modifies
; Level_Tile_Whack as part of the logic (i.e. like the Player
; tail-attacked whatever block got hit) 
; A = input detected tile by kicked shelled object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_BumpOffBlocks:
	CMP #TILE_ITEM_COIN
	BCC PRG008_B994
	STA TempA
 
	LDA Player_Bounce 
	BNE PRG008_B994	 ; If Player is bouncing, jump to PRG008_B9D3 
 
	TXA
	PHA
	LDA TempA
	LDX #$04
	JSR Level_DoBumpBlocks	 ; Have kicked object hit bumpable blocks
	PLA
	TAX

	LDA Player_Bounce 
	BEQ PRG008_B994	 ; If block is NOT a bouncing type, jump to PRG008_B994  

	; Set bounce direction and flag that it was an object that bounced
	LDA #$01 
	STA Player_BounceDir 
	STA Player_BounceObj 

PRG008_B994:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoSpecialTiles
;
; Handles special tiles unique to level styles:
; Pipe logic, conveyors, spikes, muncher/jelectro, white block, 
; quicksand, toad house treasure chests... 
; Good place to put custom-by-Tileset tiles!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRG008_BC43:
	.byte $08, $04, $04	; Offset applied to Player_X when: in air or level is sloped, Player is NOT small, Player is small

Pipe_PadDirForEnter:	
	.byte PAD_RIGHT, PAD_LEFT	; What to press to enter a horizontal pipe; pad right and left, respectively
	.byte PAD_DOWN, PAD_UP		; What to press to enter a vertical pipe; pad down and up, respectively

Player_DoSpecialTiles:
	
	LDA Player_Shell
	ORA Player_TailAttack
	ORA Player_Flip	 
	BNE PRG008_BCA7	 ; If Player is a Tanooki Statue, tail attacking, or invincibility flipping, jump to PRG008_BCA7
	; Copy in the mask of allowable pipe tiles -> Temp_Var16
	
	LDA #$00
	STA Player_Slippery	 ; Player_Slippery = 0 (default ground not slippery)
	LDA <Player_InAir
	BNE PRG008_BCAA	 	; If Player is mid air, jump to PRG008_BCAA

	LDA Level_Tile_Prop_InFL	 ; Get tile near head...
	CMP #TILE_PROP_SOLID_TOP
	BGE PRG008_BC79
	JMP PRG008_BCAA

PRG008_BC79:
	AND #$0F
	CMP #TILE_PROP_HPIPE_BOTTOM
	BEQ PRG008_BC7A
	JMP PRG008_BCAA

PRG008_BC7A:
	LDX #$00
	LDA <Player_X
	AND #$0f	
	CMP #$08	
	BLS PRG008_BC92	 ; If Player is on left half of tile, jump to PRG008_BC92
 
	INX		 ; X = 1

PRG008_BC92:
	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ PRG008_BCAA	 ; If Player is NOT pressing correct direction to enter pipe, jump to PRG008_BCAA

	; Correct direction to enter pipe...

	TYA
	BNE PRG008_BCA4	 ; If pipe type (Y) is not 0, jump to PRG008_BCA4

	LDY #$01	 ; Y = 1 

	LDA LevelVertJct	
	BEQ PRG008_BCA4	 ; If not currently junctioning, jump to PRG008_BCA4

	DEY		 ; Y = 0 

PRG008_BCA4:
	JSR PipeEntryPrepare	 ; Prepare pipe entry

PRG008_BCA7:
	JMP PRG008_BD4B	 ; Jump to PRG008_BD4B

PRG008_BCAA:
	LDX #$02	 ; X = 2
	LDA Level_Tile_Prop_GndL	 

	LDY <Player_InAir
	BEQ PRG008_BCC4	 ; If Player is NOT mid air, jump to PRG008_BCC4

	LDY Player_HitCeiling
	BEQ PRG008_BCA7	 ; If Player has not just hit off a ceiling, jump to PRG008_BCA7

	LDY Player_IsDucking
	BEQ PRG008_BCC0	 ; If Player is NOT ducking, jump to PRG008_BCC0

	JMP PRG008_BD4B	 ; Otherwise, jump to PRG008_BD4B

PRG008_BCC0:
	INX		 ; X = 3

	LDA Level_Tile_Prop_GndR

PRG008_BCC4:
	STX <Temp_Var3		 ; Store pipe mode -> Temp_Var3
	CMP #TILE_ITEM_COIN
	BGE PRG008_BD4B
	AND #$0F
	STA <Temp_Var1
	LDA #TILE_PROP_VPIPE_RIGHT
	SEC
	SBC <Temp_Var1
	CMP #$02
	BGE PRG008_BD4B

PRG008_BCD6:
	TAY		 ; Tile index result -> 'A'
	STY <Temp_Var1	 ; Store pipe type -> Temp_Var1

	AND #$01	 ; Determine left vs right tile (odd/bit 0 indicates right tile)
	ASL A
	ASL A
	ASL A
	ASL A		 ; Multiply 0/1 by 16
	STA <Temp_Var2	 ; Temp_Var2 = 0 or 16

	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ PRG008_BD4B	 ; If Player is NOT pressing the correct direction to enter pipe, jump to PRG008_BD4B

	LDA Level_PipeMove
	BNE PRG008_BD4B	 ; If Player is already in pipe, jump to PRG008_BD4B

	LDY #$00	 ; Y = 0 (Player is mid-air or level is sloped)

	LDA <Player_InAir
	BNE PRG008_BD1F	 ; If Player is mid air or this is a sloping level, jump to PRG008_BD1F

	INY		 ; Y = 1 (Player is NOT small)
	LDA <Player_Suit
	BNE PRG008_BD1F	 ; If Player is NOT small, jump to PRG008_BD1F

	INY		 ; Y = 2 (Player is small)

PRG008_BD1F:
	LDA <Player_X	
	AND #$0f	
	PHA		 ; Save Player's relative X across tile

	ADD PRG008_BC43,Y ; Add appropriate offset
	AND #$10	 ; Check if on "odd" tile (only true on Player_X 16, 48, 80, etc.) AKA right tile
	BNE PRG008_BD30	 ; If so, jump to PRG008_BD30

	PLA		 ; Restore Player's relative X across tile
	ORA #$F0	 ; Make negative, sort of
	PHA		 ; Save it again

PRG008_BD30:
	PLA		 ; Restore Player's relative X across tile
	ADD <Temp_Var2	 ; 0 or 16, left or right tile
	SUB #3	 
	CMP #10
	BGE PRG008_BD4B	 ; If Player_X >= 10 after subtracting 3 (??), jump to PRG008_BD4B

	LDA <Temp_Var1	 ; Get pipe type
	LSR A		 
	TAY		 
	JSR PipeEntryPrepare	 ; Prepare entry into pipe!
	JSR PipeMove_SetPlayerFrame	 ; Update Player frame!
	JSR Player_Draw29	 ; Draw Player

	; Do not return to caller!!
	PLA		 
	PLA

	RTS		 ; Return

PRG008_BD4B:
	LDX #$05	 ; X = 1 (check one tile by foot, then check the other!)	

PRG008_BD59:
	STX <Temp_Var2
	LDA Level_Tile_Prop_Head,X
	STA <Temp_Var3
	AND #$C0
	CMP #TILE_PROP_SOLID_BOTTOM
	BEQ PRG008_BE2E
	LDA <Temp_Var3
	CMP #TILE_ITEM_COIN
	BGE PRG008_BE2E
	AND #$0F
	STA <Temp_Var1
	LDA #TILE_PROP_MOVE_DOWN
	SEC
	SBC <Temp_Var1
	CMP #$04
	BGE PRG008_BD73
	TAY

PushFull:
	JSR ApplyTileMove
	JMP PRG008_BE2E		; Jump to PRG008_BD73

PRG008_BD73:
	LDA <Temp_Var1
	CMP #TILE_ITEM_COIN
	BCS PRG008_BDB1
	AND #$0F
	CMP #TILE_PROP_HARMFUL
	BNE PRG008_BDB1	
 
PRG008_BDA4:
	LDA <Temp_Var3
	CMP #TILE_PROP_SOLID_TOP
	BCC PRG008_BDAF

PRG008_BDAE:
	JMP Player_GetHurt	 ; Get hurt!

PRG008_BDAF:
	AND #TILE_PROP_WATER
	BEQ PRG008_BDAE
	;LDA Player_InWater
	;BEQ PRG008_BDB1
	LDA Effective_Suit
	CMP #$08
	BNE PRG008_BDAE

PRG008_BDB1:
	; SLIPPERY, ICY GROUND LOGIC
	LDA Wall_Jump_Enabled
	BNE PRG008_BDB2
	LDA <Player_InAir
	BNE PRG008_BE2E	 ; If Player is in air, jump to PRG008_BE31

PRG008_BDB2:
	LDA <Temp_Var3
	CMP #TILE_PROP_SOLID_TOP
	BCC PRG008_BE2E
	AND #$0F
	CMP #TILE_PROP_SLICK
	BNE PRG008_BE2E

	LDA #$02	 
	STA Player_Slippery	 ; Player_Slippery = 2 (ground is REALLY slippery!)

PRG008_BE2E:
	LDX <Temp_Var2
	DEX		 ; X--
	BPL PRG008_BD59	 ; While X >= 0, loop!

PRG008_BE2F:
	RTS		 ; Return

TileGround:	 .byte $00, $00, $10, $F0
TileWaterX:	 .byte $00, $00, $20, $E0
TileWaterY:	 .byte $01, $FE, $00, $00
TileWall:	 .byte $08, $F8, $00, $00
TileAirX:	 .byte $00, $00, $28, $C8
TileAirY:	 .byte $38, $B8, $00, $00

ApplyTileMove:
	CPX #$03
	BEQ ApplyTileMove1
	CPX #$02
	BNE ApplyTileMove2

ApplyTileMove1:
	LDA <Player_InAir
	ORA Player_InWater
	BNE ApplyTileMove1_1
	LDA TileGround, Y
	STA Player_CarryXVel 

ApplyTileMove1_1:
	RTS

ApplyTileMove2:
	CPX #$01
	BNE ApplyTileMove3
	LDA Player_InWater
	BEQ ApplyTileMove3
	LDA Effective_Suit
	CMP #$04
	BEQ ApplyTileMove2_1

	LDA TileWaterX, Y
	BEQ ApplyTileMove2_0
	STA Player_XVel

ApplyTileMove2_0:
	LDA Player_IsHolding
	BNE ApplyTileMove2_1
	LDA Player_YVel
	ADD TileWaterY, Y
	STA Player_YVel
	

ApplyTileMove2_1:
	LDA #$01
	STA Player_InAir
	RTS

ApplyTileMove3:
	CPX #$05
	BEQ ApplyTileMove4
	CPX #$04
	BNE ApplyTileMove5

ApplyTileMove4:
	LDA Wall_Jump_Enabled
	BEQ ApplyTileMove5
	LDA TileWall, Y
	STA Player_CarryYVel
	LDA #$00
	STA Player_YVel

ApplyTileMove5:
	CPX #$01
	BEQ ApplyTileMove5_1
	CPX #$00
	BNE ApplyTileMove6
	LDA Player_InWater
	BNE ApplyTileMove6

ApplyTileMove5_1:
	LDA TileAirX, Y
	BEQ ApplyTileMove5_2
	STA <Player_XVel

ApplyTileMove5_2:
	LDA TileAirY, Y
	BEQ ApplyTileMove6
	STA <Player_YVel
	STA <Player_InAir

ApplyTileMove6:
	RTS

PipeMove_SetPlayerFrame:
	LDY <Player_Suit
	BEQ PRG008_BF0A	 ; If small, jump to PRG008_BF0A

	LDY #$02	 ; Otherwise, Y = 2

PRG008_BF0A:
PRG008_BF10:
	LDA PipeMove_Frame,Y ; Get appropriate pipe traversal frame
	STA <Player_Frame	  ; Store as Player frame
	RTS		 ; Return


	; X and Y offsets to "correct" Player masking sprite when entering pipe
PipeEnter_XYOffs:
	.byte 16,   0	; right
	.byte  0,   0	; left
	.byte  0,  32	; up
	.byte  0, -16	; down	<-- not applied if Player is small


	; Does common stuff to prepare to enter a pipe!
PipeEntryPrepare:
	STX Level_PipeMove	 ; Set appropriate pipe movement

	; Play pipe sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA Level_ExitToMap	; A = 1 (pipe will exit level)
	BNE PRG008_BF49		; If pipes in this level do NOT exit to map, jump to PRG008_BF47

PRG008_BF47:
	LDA #$03	 ; A = 3 (regular pipe mechanics)

PRG008_BF49:

	; Construct pipe movement
	ASL A
	ASL A
	ORA Level_PipeMove
	STA Level_PipeMove

	; Set timer while in pipe
	LDA #$3c
	STA Event_Countdown

	; X <<= 1 (pipe movement, shifted left 1)
	TXA
	ASL A
	TAX

	LDA <Player_X
	ADD PipeEnter_XYOffs,X	 ; Add appropriate X offset
	CPX #$04	 
	BGS PRG008_BF65	 	; If pipe movement is up/down, jump to PRG008_BF65

	AND #$F0	 ; Otherwise, align Player_X to grid

PRG008_BF65:
	STA <Pipe_PlayerX	; Update Player_X

	LDA <Player_Y
	CPX #$06	
	BNE PRG008_BF71	 ; If not a downward pipe, jump to PRG008_BF71

	LDY <Player_Suit
	BEQ PRG008_BF75	 ; If Player is small, jump to PRG008_BF75

PRG008_BF71:
	ADD PipeEnter_XYOffs+1,X ; Add appropriate Y offset

PRG008_BF75:
	AND #$F0	 ; Align Player_Y to grid

	CPX #$04	 
	BLS PRG008_BF7E	 ; If left/right pipe, jump to PRG008_BF7E

	SUB #$01	 ; Move Player up one pixel 

PRG008_BF7E:
	STA <Pipe_PlayerY ; Set Pipe_PlayerY

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_QueueChangeBlock
;
; Changes a block, used for tiles which appear/disappear
;
; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
; Temp_Var15 / Temp_Var16 -- X Hi and Lo
;
; Register 'A' as input sets Level_ChgTileEvent
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_QueueChangeBlock:
	STA Level_ChgTileEvent	 ; Store type of block change!

	; Store change Y Hi and Lo
	LDA <Temp_Var13
	STA Level_BlockChgYHi
	LDA <Temp_Var14
	AND #$F0		; Align to nearest grid coordinate
	STA Level_BlockChgYLo

	; Store change X Hi and Lo
	LDA <Temp_Var15
	STA Level_BlockChgXHi
	LDA <Temp_Var16	
	AND #$F0	 	; Align to nearest grid coordinate
	STA Level_BlockChgXLo

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyXVelocity
;
; Applies Player's X velocity and makes sure he's not moving
; faster than the cap value (PLAYER_MAXSPEED)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ForceDirection:
	.byte $10, $F0

Player_ApplyXVelocity:
	LDA Player_ForcedSlide
	BEQ Player_ApplyXVelocity1

	LDY Player_PrevXDirection
	LDA ForceDirection, Y
	STA <Player_CarryXVel

	LDA #$00
	STA <Player_XVel

Player_ApplyXVelocity1:
	LDX #$00	; X = 0
	LDY #PLAYER_MAXSPEED	; Y = PLAYER_MAXSPEED

	LDA <Player_XVel
	BPL PRG008_BFAC	 ; If Player_XVel >= 0, jump to Player_ApplyXVelocity 

	LDY #-PLAYER_MAXSPEED	 ; Y = -PLAYER_MAXSPEED

	; Negate Player_XVel (get absolute value)
	NEG

PRG008_BFAC:
	STA <Temp_Var16		; Store absolute value Player_XVel -> Temp_Var166
	CMP #PLAYER_MAXSPEED
	BLS Player_ApplyVelocity ; If we haven't hit the PLAYER_MAXSPEED yet, apply it!
	STY <Player_XVel	 ; Otherwise, cap at max speed!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyVelocity
;
; Applies Player's velocity for X or Y (depending on register 'X')
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyVelocity:
	; X may specify offset to YVel, or else be zero
	LDA <Player_XVel,X	; Get velocity

	CPX #$00
	BNE No_Weather_Vel

	LDY Player_InWater
	BNE No_Weather_Vel

	; X Velocity only
	LDY Level_PipeMove
	BNE No_Weather_Vel

	LDY Player_OnPlatform
	BNE No_Weather_Vel

	LDY Wind
	BEQ No_Weather_Vel

	ADD Wind

No_Weather_Vel:
	ADD <Player_CarryXVel, X

PRG008_BFBF:
	PHA		 ; Save result

	ASL A
	ASL A
	ASL A
	ASL A		 ; Get "fractional" part of velocity
	STA <Temp_Var12	 ; Store into Temp_Var12

	LDY #$00	 ; Y = 0

	PLA		 ; Restore prior result

	LSR A
	LSR A
	LSR A
	LSR A		 ; Get "whole" part of velocity

	; "Whole" part is like a 4-bit signed integer
	; $0 - $7 is therefore rightward
	; $8 - $F is therefore leftward
	CMP #$08
	BLT PRG008_BFD3	 ; If whole part is less than 8, jump to PRG008_BFD3

	DEY		 ; Y = $FF (sign extended negative)

	; Turn "whole part" into a full 8-bit signed
	ORA #$F0

PRG008_BFD3:
	STA <Temp_Var11	 ; Store velocity into Temp_Var11 (low part)
	STY <Temp_Var13	 ; Temp_Var13 = 0 or $FF (High part)

	; Accumulating fractional component
	LDA Player_XVelFrac,X
	ADD <Temp_Var12	
	STA Player_XVelFrac,X

	; Apply velocity to X if there's carry
	LDA <Player_X,X
	STA Previous_X
	ADC <Temp_Var11
	STA <Player_X,X
	
	
	; Apply velocity to XHi if there's carry
	LDA <Player_XHi,X
	ADC <Temp_Var13	
	STA <Player_XHi,X
	CPX #$00
	BNE No_Odo_Increase
	LDY #$00
	LDA Previous_X
	SEC
	SBC Player_X
	BEQ No_Odo_Increase
	BPL Dont_Flip
	INY
	EOR #$FF
	CLC
	ADC #$01
Dont_Flip:
	CLC
	ADC Odometer_Increase
	STA Odometer_Increase
	LDA Player_ForcedSlide
	BNE No_Odo_Increase
	STY Player_PrevXDirection

No_Odo_Increase:
	LDA #$00
	STA <Player_CarryXVel, X
	
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyYVelocity
;
; Applies Player's Y velocity and makes sure he's not falling 
; faster than the cap value (FALLRATE_MAX)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyYVelocity:
	LDA <Player_YVel
	BMI PRG008_BFF9	 ; If Player_YVel < 0, jump to PRG008_BFF9

	CMP #FALLRATE_MAX
	BLS PRG008_BFF9	 ; If Player_YVelo < FALLRATE_MAX, jump to PRG008_BFF9

	; Cap Y velocity at FALLRATE_MAX
	LDA #FALLRATE_MAX
	STA <Player_YVel ; Player_YVel = FALLRATE_MAX

PRG008_BFF9:
	LDX #(Player_YVel - Player_XVel) ; Do the Y velocity
	JSR Player_ApplyVelocity	 ; Apply it!

	RTS		 ; Return

; Rest of ROM bank was empty
	
	; #DAHRKDAIZ - custom code created to decrease air meter while swimming
	; if frog suit or top of water, increase air.
Do_Air_Timer:				; Added code to increase/decrease the air time based on water
	LDA Air_Change
	BNE CheckAirChange
	RTS

AirTicker: .byte $07, $0A
CheckAirChange:
	LDA Air_Time
	BPL Change_Air

Air_Kill:
	JMP Player_Die

Change_Air:
	ADD Air_Change
	BMI Air_Kill
	CMP #$40
	BCC NotMaxAir
	LDA #$40
	STA Air_Time
	RTS

NotMaxAir:
	STA TempA
	INC Air_Time_Frac
	LDA Air_Time_Frac
	LDY #$00
	LDX Player_Equip
	CPX #BADGE_AIR
	BNE NotMaxAir1
	INY

NotMaxAir1:
	CMP AirTicker, Y
	BCC NoChange

	LDA #$00
	STA Air_Time_Frac
	LDA TempA
	STA Air_Time
	CMP #$10
	BGE NoChange
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

NoChange:
	RTS

Power_TickChange:
	.byte $07, $0A

Do_PowerChange:				; Added code to increase/decrease the air time based on water
	INC Power_Tick
	LDX #$00
	LDA Player_Equip
	CMP #BADGE_PMETER
	BNE Do_PowerChange01
	INX

Do_PowerChange01:
	LDA Power_Tick
	CMP Power_TickChange, X
	BNE Do_PowerChange0
	LDA #$00
	STA Power_Tick
	LDA Power_Change
	BNE Do_PowerChange1

Do_PowerChange0:
	RTS

Do_PowerChange1:

	LDA Player_Power
	ADD Power_Change
	BPL Do_PowerChange2

	LDA #$00
	BEQ Do_PowerChange3

Do_PowerChange2:
	CMP #$50
	BCC Do_PowerChange3
	LDA #$00
	STA Power_Change
	LDA #$50

Do_PowerChange3:
	STA Player_Power
	RTS

Do_PUp_Proper:
	LDA Player_Equip
	CMP #BADGE_NOSHOORMS
	BEQ PUp_RTS
	LDA <Player_Suit
	BNE PUp_RTS
	LDY #$05
PUp_RTS:
	RTS

Shell_Bounce:
	LDA Level_Tile_Prop_GndL, X
	CMP #TILE_ITEM_BRICK
	BEQ Shell_Bounce0

	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer
	LDA Player_FlipBits			; flip direction the player is facing
	EOR #$40				
	STA Player_FlipBits				
	LDA <Player_XVel
	EOR #$FF
	ADC #$01
	STA <Player_XVel
	JSR Player_ApplyXVelocity
	BPL Shell_Bounce1
	LDA <Player_X
	AND #$F0
	STA <Player_X

Shell_Bounce0:
	RTS

Shell_Bounce1:
	LDA <Player_X
	ADD #$08
	AND #$F0
	STA <Player_X
	LDA <Player_XHi
	ADC #$00
	STA <Player_XHi

Shell_BounceRTS:
	RTS

VScreenTransitions:
	LDA Level_FreeVertScroll
	CMP #$03
	BEQ CheckPlayer_Y
	RTS

CheckPlayer_Y:
	JSR CheckPlayer_YLow
	JSR CheckPlayer_YHi
	RTS
		
CheckPlayer_YHi:
	LDA <Player_XHi
	CMP <Level_Width
	BEQ NotYHi
	LDA <Player_YHi
	BPL NotYHi
	LDA <Player_Y
	LDX Player_IsClimbing
	BEQ NormalYHiCheck
	SUB #$10
	
NormalYHiCheck:
	CMP #$F4
	BCS NotYHi

	LDX <Player_XHi
	INX
	STX <Player_XHi
	LDX #$A1
	LDA <Player_Suit
	BNE NotSmallMario
	LDX #$98

NotSmallMario:
	STX <Player_Y
	LDA #$01
	STA <Player_YHi
	INC Level_JctCtl
	INC Level_KeepObjects
	PLA
	PLA

	LDX #$07
	LDA #$00
ClearSprite:
	LDY Objects_State, X
	CPY #OBJSTATE_HELD
	BEQ NextSprite
	LDY Level_ObjectID, X
	CPY Global_Object
	BEQ NextSprite
	STA Objects_State, X
	LDY Objects_SpawnIdx,X	
	LDA Level_ObjectsSpawned,Y
	AND #$7f
	STA Level_ObjectsSpawned,Y

NextSprite:
	DEX
	BPL ClearSprite

NotYHi:
	RTS

CheckPlayer_YLow:
	LDA <Player_XHi
	BEQ NotYLo
	LDA <Player_YHi
	CMP #$01
	BNE NotYLo
	LDA <Player_Y
	CMP #$A8
	BCC NotYLo

	LDX <Player_XHi
	DEX
	STX <Player_XHi
	LDA #$00
	STA <Player_Y
	STA <Player_YHi
	INC Level_JctCtl
	PLA
	PLA

NotYLo:
	RTS

CheckSpinners:
	LDX #$09

CheckCurrentSpinners
	LDA SpinnerBlockTimers, X
	BEQ NextSpinner

	DEC SpinnerBlockTimers, X
	BNE NextSpinner

	LDA Level_ChgTileEvent
	BNE SkipSpinner

	LDA SpinnerBlocksX, X
	STA Temp_Var16

	LDA SpinnerBlocksXHi, X
	STA <Temp_Var15
	 
	LDA SpinnerBlocksY, X
	STA <Temp_Var14

	LDA SpinnerBlocksYHi, X
	STA <Temp_Var13

	LDA SpinnerBlocksReplace, X
	JSR Level_QueueChangeBlock

NextSpinner:
	DEX
	BNE CheckCurrentSpinners
	RTS

SkipSpinner:
	INC SpinnerBlockTimers, X
	JMP NextSpinner

CheckForLevelEnding:
	LDA CompleteLevelTimer
	BPL DoCountDown
	CMP #$80
	BEQ StartCountDown
	RTS

StartCountDown:
	LDA <Player_InAir
	BNE NoCountDown
	JSR DestroyAllEnemies
	LDA #$00
	STA <Player_XVel
	LDA #MUS1_BOSSVICTORY
	STA Sound_QMusic1
	DEC CompleteLevelTimer
	RTS

DoCountDown:
	LDA #$FF
	STA Player_HaltTick
	LDA <Counter_1
	AND #$01
	BNE NoCountDown
	DEC CompleteLevelTimer
	BMI EndLevel

NoCountDown:
	RTS

EndLevel:
	LDA #$00
	STA Map_ReturnStatus
	LDA #$01
	STA Level_ExitToMap
	RTS

CoinsEarnedBuffer:
	LDA Coins_Earned_Buffer
	BEQ CoinsEarnedBufferRTS
	LDA <Counter_1
	AND #$01
	BNE CoinsEarnedBufferRTS
	DEC Coins_Earned_Buffer
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	INC Coins_Earned

CoinsEarnedBufferRTS:
	RTS

DoPaletteEffect:
	LDA PaletteEffect
	JSR DynJump

	.word NoEffect
	.word RainbowWithMovement
	.word NoEffect

NoEffect:
	RTS

RainbowEffectColors:
	.byte $31, $33, $35, $37, $38, $39, $3A, $3B, $3C, $31, $33, $35, $37, $38, $39
	.byte $21, $23, $25, $27, $28, $29, $2A, $2B, $2C, $21, $23, $25, $27, $28, $29
	.byte $01, $03, $05, $07, $08, $09, $0A, $0B, $0C, $01, $03, $05, $07, $08, $09

RainbowWithMovement:
	LDA <Counter_1
	AND #$07
	BNE NoEffectChange
	INC EffectCounter
	LDA EffectCounter
	CMP #$09
	BNE DontClearCounter
	LDA #$00
	STA EffectCounter

DontClearCounter:
	LDX EffectCounter
	LDA RainbowEffectColors, X
	STA Palette_Buffer + 06
	LDA RainbowEffectColors + 15, X
	STA Palette_Buffer + 7
	LDA RainbowEffectColors + 30, X
	STA Palette_Buffer + 5

	LDA RainbowEffectColors + 3, X
	STA Palette_Buffer + 10
	LDA RainbowEffectColors + 18, X
	STA Palette_Buffer + 11
	LDA RainbowEffectColors + 33, X
	STA Palette_Buffer + 9

	LDA RainbowEffectColors + 6, X
	STA Palette_Buffer + 14
	LDA RainbowEffectColors + 21, X
	STA Palette_Buffer + 15
	LDA RainbowEffectColors + 36, X
	STA Palette_Buffer + 13

NoEffectChange:
	RTS

Player_Events:
	LDA EventSwitch
	BEQ Player_EventsRTS

	LDA PAGE_C000
	PHA
	LDA #$0E
	STA PAGE_C000
	JSR PRGROM_Change_C000 
	JSR HandleLevelEvent
	PLA 
	STA PAGE_C000
	JSR PRGROM_Change_C000 

Player_EventsRTS:
	RTS

Player_Refresh:
	RTS

Debug_Code:
	LDA <Pad_Holding
	AND #PAD_B
	BEQ Debug_CodeRTS

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ Debug_CodeRTS

	LDA Effective_Suit
	CMP #$08
	BEQ Debug_Code0

	CMP #$0B
	BCC Debug_Code1

	LDA #$FF
	BMI Debug_Code1

Debug_Code0:
	LDA #$09

Debug_Code1:
	ADD #$02
	STA Player_QueueSuit

Debug_CodeRTS:
	RTS


OpenTreasure:
	JSR LATP_CoinCommon
	LDA #$09
	ADD Coins_Earned_Buffer
	STA Coins_Earned_Buffer
	LDA <Level_Tile
	EOR #$01
	JSR Level_QueueChangeBlock

OpenTreasure1:
	RTS

Player_WallHandle:
	CPX #$02
	BCS Player_WallHandle1
	JMP PRG008_B53B

Player_WallHandle1:
	LDA Level_Tile_Prop_GndL, X
	AND #TILE_PROP_SOLID_ALL
	CMP #TILE_PROP_SOLID_ALL
	BNE OpenTreasure1	 ; If not touching a solid tile, jump to PRG008_B53B

	LDA Player_Shell
	BEQ PRG008_B53A_2
	JSR Shell_Bounce
	JMP PRG008_B53B

PRG008_B53A_2:
	JSR Can_Wall_Jump
	
	LDA Player_ForcedSlide
	BNE PRG008_B53B

	LDA <Player_X
	STA TempA
	ADD #$08
	AND #$F0
	STA <Player_X

	LDA <Player_XHi
	STA TempY
	ADC #$00
	STA <Player_XHi

	LDX #$00
	LDA <Player_Suit
	BEQ PRG008_B530

	INX

PRG008_B530:
	LDA TempA
	AND #$0F
	CMP #$08
	BCS PRG008_B531

	LDA <Player_XVel
	ADD Player_CarryXVel, X
	ADD Wind
	BMI PRG008_B53C

	LDA <Player_XVel
	BPL PRG008_B530_1

	LDA <Pad_Holding
	AND #PAD_LEFT
	BNE PRG008_B530_2

PRG008_B530_1:
	LDA #$00
	STA <Player_XVel

PRG008_B530_2:
	LDA <Player_X
	ADD Wall_Clip, X
	STA <Player_X

	LDA <Player_XHi
	ADC #$00
	STA <Player_XHi
	RTS

PRG008_B531:
	LDA <Player_XVel
	ADD Player_CarryXVel, X
	ADD Wind
	BEQ PRG008_B531_2
	BPL PRG008_B53C

PRG008_B531_2:
	LDA <Player_XVel
	BMI PRG008_B531_3

	LDA <Pad_Holding
	AND #PAD_RIGHT
	BNE PRG008_B531_4

PRG008_B531_3:
	LDA #$00
	STA <Player_XVel

PRG008_B531_4:

	LDA <Player_X
	SUB Wall_Clip, X
	STA <Player_X

	LDA <Player_XHi
	SBC #$00
	STA <Player_XHi

PRG008_B53B:
	RTS

PRG008_B53C:
	LDA TempA
	STA <Player_X
	LDA TempY
	STA <Player_XHi
	RTS

HandleIceBreak:
	LDY Player_InWater
	BEQ HandleIceBreak2

	LDY <Player_YVel
	BPL HandleIceBreak2

	CPX #$00
	BNE HandleIceBreak2

	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_SLICK)
	BNE HandleIceBreak2

	LDA Level_ChgTileEvent
	BNE HandleIceBreak2

	JSR LATP_BustIce
	LDA #$59
	STA BrickBust_Tile
	LDA #SPR_PAL1
	STA BrickBust_Pal
	LDA Level_Tile
	EOR #$01
	JSR Level_QueueChangeBlock

HandleIceBreak2:
	RTS

SetLastScrollDirection:
	LDA <Horz_Scroll
	CMP LastHorzScroll
	BEQ SetLastScrollDirection2
	SUB LastHorzScroll
	LDA <Horz_Scroll_Hi
	SBC LastHorzScrollHi
	BPL SetLastScrollDirection1

	LDA #$01
	STA <Scroll_LastDir
	RTS

SetLastScrollDirection1:
	LDA #$00
	STA <Scroll_LastDir

SetLastScrollDirection2:
EquipNoUse:
	RTS


Try_Use_Equipped:
	LDA Player_Equip
	BEQ SetLastScrollDirection2
	CMP #BADGE_COIN
	BCS SetLastScrollDirection2

	LDA <Pad_Holding
	AND #PAD_DOWN
	BEQ SetLastScrollDirection2

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ SetLastScrollDirection2

	LDA Player_Equip
	JSR DynJump

	.word EquipNoUse
	.word StopWatch
	.word StopWatch
	.word SlowWatch
	.word SlowWatch
	.word PowBlock
	.word PowBlock
	.word PowBlock
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word EquipNoUse
	.word StarManItem
	.word StarManItem

StopWatch:
	DEC Player_Equip
	LDA #$FF
	STA Stop_Watch
	RTS

SlowWatch:
	LDA #$FF
	STA Slow_Watch
	LDA Player_Equip
	CMP #ITEM_SLOW2
	BNE SlowWatch1
	DEC Player_Equip
	RTS

SlowWatch1:
	LDA #$00
	STA Player_Equip
	RTS
	
PowBlock:
	LDA #$10
	STA Level_Vibration
	LDX #$04

PowBlock0:
	LDA Objects_State, X
	CMP #OBJSTATE_NORMAL
	BNE PowBlock1
	LDY Level_ObjectID,X	 ; Get object's ID -> Y
	LDA Object_AttrFlags,Y	 ; Get this object's attribute flags
	AND #OAT_HITNOTKILL	 
	BNE PowBlock1
	JSR Object_PoofDie

PowBlock1:
	DEX
	BPL PowBlock0


	STA Slow_Watch
	LDA Player_Equip
	CMP #ITEM_POW1
	BEQ PowBlock2
	DEC Player_Equip
	RTS

PowBlock2:
	LDA #$00
	STA Player_Equip
	RTS

StarManItem:
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	LDA Sound_QMusic2
	ORA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2
	; Player_StarInv = $E0
	LDA #$e0
	STA Player_StarInv
	LDA Player_Equip
	CMP #ITEM_STAR2
	BNE StarManItem1
	DEC Player_Equip
	RTS

StarManItem1:
	LDA #$00
	STA Player_Equip
	RTS
