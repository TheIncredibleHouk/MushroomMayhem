; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-12-14 17:45:42.706614297 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup02 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $02 (i.e. objects starting at ID $48) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup02_InitJumpTable:
	.word ObjInit_Ninji	; Object $48 - OBJ_NINJI
	.word ObjInit_DoNothing	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjInit_MagicStar1	; Object $4A - OBJ_MAGICSTAR
	.word ObjInit_MagicStar2	; Object $4B - OBJ_MAGICSTAR
	.word ObjInit_MagicStar3	; Object $4C - OBJ_MAGICSTAR
	.word ObjInit_DoNothing	; Object $4D
	.word ObjInit_DoNothing		; Object $4E
	.word ObjInit_DoNothing		; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjInit_Explosion	; Object $50 - OBJ_EXPLOSION
	.word ObjInit_RotoDiscDualCCW	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjInit_Spintula	; Object $52 - OBJ_SPINTULA
	.word ObjInit_PipePodobo	; Object $53 - OBJ_PIPEPODOBO
	.word ObjInit_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjInit_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjInit_PiranhaSidewaysL	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjInit_PiranhaSidewaysR	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjInit_Pyrantula		; Object $58 - OBJ_PYRANTULA
	.word ObjInit_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjInit_RotoDiscDualCW	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjInit_RotoDiscDualCCW	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjInit_IceBlock		; Object $5C - OBJ_ICEBLOCK
	.word ObjInit_DoNothing		; Object $5D - OBJ_STONEBLOCK
	.word ObjInit_RotoDiscDualCW	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjInit_RotoDiscDualCW	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjInit_RotoDiscDualCW	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjInit_PhantomBlooper	; Object $61 - OBJ_SKULLBLOOPER
	.word ObjInit_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjInit_FloatMine	; Object $63 - OBJ_FLOATMINE
	.word ObjInit_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjInit_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjInit_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjInit_ShyGuy		; Object $67 - OBJ_SNOWGUY
	.word ObjInit_Twirling		; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjInit_Twirling		; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjInit_ShyGuy	; Object $6A - OBJ_VEGGIEGUY
	.word ObjInit_ShyGuy	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup02_NormalJumpTable:
	.word ObjNorm_Ninji	; Object $48 - OBJ_NINJI
	.word ObjNorm_DoNothing	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjNorm_MagicStar	; Object $4A - OBJ_MAGICSTAR
	.word ObjNorm_MagicStar		; Object $4B - OBJ_MAGICSTAR
	.word ObjNorm_MagicStar		; Object $4C - OBJ_MAGICSTAR
	.word ObjNorm_DoNothing	; Object $4D
	.word RhythmPlatforms		; Object $4E
	.word DPad_ControlTiles	; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjNorm_Explosion		; Object $50 - OBJ_EXPLOSION
	.word ObjNorm_RotoDiscDual	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjNorm_Spintula	; Object $52 - OBJ_SPINTULA
	.word ObjNorm_PipePodobo	; Object $53 - OBJ_PIPEPODOBO
	.word ObjNorm_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjNorm_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjNorm_PiranhaSideways	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjNorm_PiranhaSideways	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjNorm_Pyrantula		; Object $58 - OBJ_PYRANTULA
	.word ObjNorm_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjNorm_RotoDisc		; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjNorm_RotoDisc		; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjNorm_IceBlock		; Object $5C - OBJ_ICEBLOCK
	.word ObjNorm_IceBlock		; Object $5D - OBJ_STONEBLOCK
	.word ObjNorm_RotoDiscDualOpp	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjNorm_RotoDiscDualOpp2	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjNorm_RotoDiscDual	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjNorm_PhantomBlooper		; Object $61 - OBJ_SKULLBLOOPER
	.word ObjNorm_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjNorm_FloatMine	; Object $63 - OBJ_FLOATMINE
	.word ObjNorm_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjNorm_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjNorm_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjNorm_SnowGuy	; Object $67 - OBJ_SNOWGUY
	.word ObjNorm_TwirlingShell	; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjNorm_TwirlingShell	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjNorm_VeggieGuy		; Object $6A - OBJ_VEGGIEGUY
	.word ObjNorm_ShyGuy	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) Collision routine jump table (if calling Object_InteractWithPlayer;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup02_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $48 - OBJ_NINJI
	.word ObjHit_DoNothing	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word Magic_StarCollect	; Object $4A - OBJ_MAGICSTAR
	.word Magic_StarCollect	; Object $4A - OBJ_MAGICSTAR
	.word Magic_StarCollect	; Object $4A - OBJ_MAGICSTAR
	.word ObjHit_DoNothing	; Object $4D
	.word ObjHit_DoNothing	; Object $4E
	.word ObjHit_DoNothing	; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjHit_DoNothing	; Object $50 - OBJ_EXPLOSION
	.word ObjHit_DoNothing	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjHit_DoNothing	; Object $52 - OBJ_SPINTULA
	.word ObjHit_DoNothing	; Object $53 - OBJ_PIPEPODOBO
	.word ObjHit_DoNothing	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word Object_Hold	; Object $55 - OBJ_BOBOMB
	.word ObjHit_DoNothing	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjHit_DoNothing	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjHit_DoNothing	; Object $58 - OBJ_PYRANTULA
	.word ObjHit_DoNothing	; Object $59 - OBJ_FIRESNAKE
	.word ObjHit_DoNothing	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjHit_DoNothing	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word Object_Hold	; Object $5C - OBJ_ICEBLOCK
	.word ObjHit_DoNothing	; Object $5D - OBJ_STONEBLOCK
	.word ObjHit_DoNothing	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjHit_DoNothing	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjHit_DoNothing	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjHit_DoNothing	; Object $61 - OBJ_SKULLBLOOPER
	.word ObjHit_DoNothing	; Object $62 - OBJ_BLOOPER
	.word FloatMine_Expload	; Object $63 - OBJ_FLOATMINE
	.word ObjHit_DoNothing	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjHit_DoNothing	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjHit_DoNothing	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjHit_DoNothing	; Object $67 - OBJ_SNOWGUY
	.word OCSPECIAL_KILLCHANGETO | OBJ_BUZZYBEATLE	; Object $68 - OBJ_TWIRLINGBUZZY
	.word OCSPECIAL_KILLCHANGETO | OBJ_SPINY	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjHit_DoNothing	; Object $6A - OBJ_VEGGIEGUY
	.word ObjHit_DoNothing	; Object $6B - OBJ_SHYGUY

	
	; Object group $02 (i.e. objects starting at ID $48) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup02_Attributes:
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $48 - OBJ_NINJI
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4A - OBJ_MAGICSTAR
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4B - OBJ_MAGICSTAR
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4C - OBJ_MAGICSTAR
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $4D
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $4E
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $50 - OBJ_EXPLOSION
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $52 - OBJ_SPINTULA
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $53 - OBJ_PIPEPODOBO
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $55 - OBJ_BOBOMB
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $58 - OBJ_PYRANTULA
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $59 - OBJ_FIRESNAKE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA1_PAL2 | OA1_WIDTH16 | OA1_WIDTH16	; Object $5C - OBJ_ICEBLOCK
	.byte OA1_PAL1 | OA1_WIDTH16 | OA1_WIDTH16	; Object $5D - OBJ_STONEBLOCK
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $61 - OBJ_SKULLBLOOPER
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $62 - OBJ_BLOOPER
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $63 - OBJ_FLOATMINE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $67 - OBJ_SNOWGUY
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6A - OBJ_VEGGIEGUY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6B - OBJ_SHYGUY

	; Object group $02 (i.e. objects starting at ID $48) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup02_Attributes2:
	.byte $00 	; Object $48 - OBJ_NINJI
	.byte $00	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte $00  	; Object $4A - OBJ_MAGICSTAR
	.byte $00  	; Object $4B - OBJ_MAGICSTAR
	.byte $00  	; Object $4C - OBJ_MAGICSTAR
	.byte $00	; Object $4D
	.byte $00	; Object $4E
	.byte $00  	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte $00	; Object $50 - OBJ_EXPLOSION
	.byte $00  	; Object $51 - OBJ_ROTODISCDUAL
	.byte $00  	; Object $52 - OBJ_SPINTULA
	.byte $00  	; Object $53 - OBJ_PIPEPODOBO
	.byte $00  	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte $00 	; Object $55 - OBJ_BOBOMB
	.byte $00	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte $00	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte $00	; Object $58 - OBJ_PYRANTULA
	.byte $00  	; Object $59 - OBJ_FIRESNAKE
	.byte $00  	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte $00  	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte $00	; Object $5C - OBJ_ICEBLOCK
	.byte $00  	; Object $5D - OBJ_STONEBLOCK
	.byte $00  	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte $00  	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte $00  	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte $00  	; Object $61 - OBJ_SKULLBLOOPER
	.byte $00  	; Object $62 - OBJ_BLOOPER
	.byte $00  	; Object $63 - OBJ_FLOATMINE
	.byte $00  	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte $00	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte $00	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte $00  	; Object $67 - OBJ_SNOWGUY
	.byte $00	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte $00	; Object $69 - OBJ_TWIRLINGSPINY
	.byte $00  	; Object $6A - OBJ_VEGGIEGUY
	.byte $00  	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup02_Attributes3:
	.byte OA3_HALT_NORMALONLY  	; Object $48 - OBJ_NINJI
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4A - OBJ_MAGICSTAR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4B - OBJ_MAGICSTAR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4C - OBJ_MAGICSTAR
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE 	; Object $4D
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $4E
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA3_HALT_NORMALONLY 	; Object $50 - OBJ_EXPLOSION
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA3_HALT_NORMALONLY	; Object $52 - OBJ_SPINTULA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $53 - OBJ_PIPEPODOBO
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA3_HALT_NORMALONLY 	; Object $55 - OBJ_BOBOMB
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA3_HALT_NORMALONLY 	; Object $58 - OBJ_PYRANTULA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $59 - OBJ_FIRESNAKE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA3_HALT_NORMALONLY	; Object $5C - OBJ_ICEBLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5D - OBJ_STONEBLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE 	; Object $61 - OBJ_SKULLBLOOPER
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $62 - OBJ_BLOOPER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE 	; Object $63 - OBJ_FLOATMINE
	.byte OA3_HALT_NORMALONLY 	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA3_HALT_NORMALONLY	; Object $67 - OBJ_SNOWGUY
	.byte OA3_HALT_NORMALONLY 	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA3_HALT_NORMALONLY 	; Object $6A - OBJ_VEGGIEGUY
	.byte OA3_HALT_NORMALONLY 	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup02_PatTableSel:
	.byte OPTS_SETPT5 | $0F	; Object $48 - OBJ_NINJI
	.byte OPTS_NOCHANGE	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OPTS_NOCHANGE	; Object $4A - OBJ_MAGICSTAR
	.byte OPTS_NOCHANGE	; Object $4B - OBJ_MAGICSTAR
	.byte OPTS_NOCHANGE	; Object $4C - OBJ_MAGICSTAR
	.byte OPTS_NOCHANGE	; Object $4D
	.byte OPTS_NOCHANGE	; Object $4E
	.byte OPTS_SETPT5 | $0E	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OPTS_NOCHANGE	; Object $50 - OBJ_EXPLOSION
	.byte OPTS_SETPT5 | $12	; Object $51 - OBJ_ROTODISCDUAL
	.byte OPTS_SETPT5 | $0A	; Object $52 - OBJ_SPINTULA
	.byte OPTS_NOCHANGE	; Object $53 - OBJ_PIPEPODOBO
	.byte OPTS_SETPT5 | $0E	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OPTS_SETPT5 | $0A	; Object $55 - OBJ_BOBOMB
	.byte OPTS_SETPT5 | $5A	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OPTS_SETPT5 | $5A	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OPTS_SETPT5 | $0A	; Object $58 - OBJ_PYRANTULA
	.byte OPTS_SETPT5 | $0A	; Object $59 - OBJ_FIRESNAKE
	.byte OPTS_SETPT5 | $12	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OPTS_SETPT5 | $12	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OPTS_NOCHANGE	; Object $5C - OBJ_ICEBLOCK
	.byte OPTS_NOCHANGE	; Object $5D - OBJ_STONEBLOCK
	.byte OPTS_SETPT5 | $12	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OPTS_SETPT5 | $12	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OPTS_SETPT5 | $12	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OPTS_SETPT5 | $1A	; Object $61 - OBJ_SKULLBLOOPER
	.byte OPTS_SETPT5 | $1A	; Object $62 - OBJ_BLOOPER
	.byte OPTS_SETPT5 | $1A	; Object $63 - OBJ_FLOATMINE
	.byte OPTS_SETPT6 | $4F	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OPTS_NOCHANGE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OPTS_NOCHANGE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OPTS_SETPT5 | $0F	; Object $67 - OBJ_SNOWGUY
	.byte OPTS_SETPT5 | $0B	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OPTS_SETPT5 | $0B	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OPTS_SETPT5 | $0F	; Object $6A - OBJ_VEGGIEGUY
	.byte OPTS_SETPT5 | $0F	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) "Kill Action"
	; Determines what action is taken when object is in "Killed" state (6)
	; See Object_DoKillAction for the jump table
	; NOTE: Any action type other than zero always sets the frame to 2 (unless object is not general purpose, i.e. index >= 5)

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup02_KillAction:
	.byte KILLACT_JUSTDRAW16X16	; Object $48 - OBJ_NINJI
	.byte KILLACT_STANDARD	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte KILLACT_STANDARD	; Object $4A - OBJ_MAGICSTAR
	.byte KILLACT_STANDARD	; Object $4B - OBJ_MAGICSTAR
	.byte KILLACT_STANDARD	; Object $4C - OBJ_MAGICSTAR
	.byte KILLACT_STANDARD	; Object $4D
	.byte KILLACT_STANDARD	; Object $4E
	.byte KILLACT_NORMALANDKILLED	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte KILLACT_JUSTDRAW16X16	; Object $50 - OBJ_EXPLOSION
	.byte KILLACT_STANDARD	; Object $51 - OBJ_ROTODISCDUAL
	.byte KILLACT_JUSTDRAWMIRROR	; Object $52 - OBJ_SPINTULA
	.byte KILLACT_POOFDEATH	; Object $53 - OBJ_PIPEPODOBO
	.byte KILLACT_STANDARD	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte KILLACT_NORMALANDKILLED	; Object $55 - OBJ_BOBOMB
	.byte KILLACT_POOFDEATH	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte KILLACT_POOFDEATH	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte KILLACT_JUSTDRAWMIRROR	; Object $58 - OBJ_PYRANTULA
	.byte KILLACT_POOFDEATH	; Object $59 - OBJ_FIRESNAKE
	.byte KILLACT_STANDARD	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte KILLACT_STANDARD	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte KILLACT_NORMALSTATE	; Object $5C - OBJ_ICEBLOCK
	.byte KILLACT_NORMALSTATE	; Object $5D - OBJ_STONEBLOCK
	.byte KILLACT_STANDARD	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte KILLACT_STANDARD	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte KILLACT_STANDARD	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte KILLACT_JUSTDRAWMIRROR	; Object $61 - OBJ_SKULLBLOOPER
	.byte KILLACT_JUSTDRAWMIRROR	; Object $62 - OBJ_BLOOPER
	.byte KILLACT_NORMALSTATE	; Object $63 - OBJ_FLOATMINE
	.byte KILLACT_JUSTDRAW16X16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte KILLACT_STANDARD	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte KILLACT_STANDARD	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte KILLACT_JUSTDRAW16X16	; Object $67 - OBJ_SNOWGUY
	.byte KILLACT_JUSTDRAWMIRROR	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte KILLACT_JUSTDRAWMIRROR	; Object $69 - OBJ_TWIRLINGSPINY
	.byte KILLACT_JUSTDRAW16X16	; Object $6A - OBJ_VEGGIEGUY
	.byte KILLACT_NORMALANDKILLED	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) pattern index starts
	; These are used for all states except "normal"

OG2_POff .func (\1 - ObjectGroup02_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup02_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG2_POff(ObjP48), OG2_POff(ObjP49), OG2_POff(ObjP4A), OG2_POff(ObjP4B)
	.byte OG2_POff(ObjP4C), OG2_POff(ObjP4D), OG2_POff(ObjP4E), OG2_POff(ObjP4F)
	.byte OG2_POff(ObjP50), OG2_POff(ObjP51), OG2_POff(ObjP52), OG2_POff(ObjP53)
	.byte OG2_POff(ObjP54), OG2_POff(ObjP55), OG2_POff(ObjP56), OG2_POff(ObjP57)
	.byte OG2_POff(ObjP58), OG2_POff(ObjP59), OG2_POff(ObjP5A), OG2_POff(ObjP5B)
	.byte OG2_POff(ObjP5C), OG2_POff(ObjP5D), OG2_POff(ObjP5E), OG2_POff(ObjP5F)
	.byte OG2_POff(ObjP60), OG2_POff(ObjP61), OG2_POff(ObjP62), OG2_POff(ObjP63)
	.byte OG2_POff(ObjP64), OG2_POff(ObjP65), OG2_POff(ObjP66), OG2_POff(ObjP67)
	.byte OG2_POff(ObjP68), OG2_POff(ObjP69), OG2_POff(ObjP6A), OG2_POff(ObjP6B)


	; Object group $02 (i.e. objects starting at ID $48) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup02_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup02_PatternSets:
	; (End restricted alignment space)

ObjP49:
ObjP4D:
ObjP4E:
ObjP4F:
ObjP65:
ObjP66:
	.byte $91, $93, $9D, $9F, $9D, $9F

ObjP53:
	.byte $8D, $8D, $8F, $8F, $95, $95
ObjP5C:
	.byte $61, $61

ObjP5D:
	.byte $97, $99, $97, $99, $61, $63   ;#DAHRKDAIZ ICEBLOCK_SPRITE
ObjP68:
	.byte $95, $97, $91, $93, $A1, $A1
ObjP69:
	.byte $81, $83, $85, $87, $89, $89
ObjP54:
	.byte $91, $93, $91, $93

ObjP50:
ObjP55:
	.byte $A7, $A9, $AB, $AD, $97, $99, $97, $99

ObjP4A:
ObjP4B:
ObjP4C:
	.byte $7F, $7F
ObjP48:
	.byte $A1, $A3, $A5, $A7, $A5, $A7
	 
ObjP56:
ObjP57:
	.byte $81, $83, $87, $89

ObjP52:
ObjP58:
	.byte $A1, $A1, $A3, $A3, $A5, $A5

ObjP59:
	.byte $81, $83, $85, $87, $85, $87
ObjP51:
ObjP5A:
ObjP5B:
	.byte $A1, $A1, $A3, $A3, $A5 ,$A5
ObjP5E:
ObjP5F:
ObjP60:
	.byte $99, $9B, $9D, $9F

ObjP61:
	.byte $B5, $B5, $B7, $B7, $B5, $B5

ObjP62:

	.byte $B1, $B1, $B3, $B3, $B1, $B1
ObjP63:
	.byte $81, $83, $A1, $A3
ObjP64:
	.byte $E7, $E9, $E7, $EF, $E7, $EF

ObjP67:
	.byte $85, $87
	.byte $81, $83
	.byte $85, $B7
	.byte $81, $B5
	.byte $BB, $BB
	.byte $B1, $B1
	.byte $91, $93


ObjP6A:
	.byte $85, $87
	.byte $81, $83
	.byte $85, $B7
	.byte $81, $B5
	.byte $BB, $BB
	.byte $B1, $B1

ObjP6B:
	.byte $85, $87
	.byte $81, $83
	.byte $85, $B7
	.byte $81, $B5
	.byte $B1, $B1

ObjInit_IceBlock:
	RTS

IceBlock_Kicked = Objects_Data1
IceBlock_PrevHold = Objects_Data2

ObjNorm_IceBlock:
	LDA <Player_HaltGameZ
	BNE IceBlock_Draw

	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BEQ IceBlock_Burst

	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox

	LDA Objects_BeingHeld, X
	STA IceBlock_PrevHold, X
	
	JSR Object_InteractWithPlayer

	LDA IceBlock_PrevHold, X
	BEQ IceBlock_DetectTiles

	CMP Objects_BeingHeld, X
	BEQ IceBlock_DetectTiles

	LDA #$01
	STA IceBlock_Kicked, X

IceBlock_DetectTiles:
	JSR Object_DetectTiles
	JSR Object_CheckForeground

	LDA <Objects_XVelZ, X
	ORA <Objects_YVelZ, X
	ORA Objects_BeingHeld, X
	BEQ IceBlock_NoBurst

	JSR Object_KillOthers
	BCC IceBlock_NoBurst

	; if hit another object an held, it bursts
	LDA Objects_BeingHeld, X
	BEQ IceBlock_Burst

	JMP IceBlock_Burst

IceBlock_NoBurst:
	LDA Objects_BeingHeld, X
	BNE IceBlock_Draw

	LDA IceBlock_Kicked, X
	BNE IceBlock_TestBreak

	JSR Object_DampenVelocity
	JMP IceBlock_TileInteract

IceBlock_TestBreak:
	LDA <Objects_TilesDetectZ, X
	AND #(HIT_LEFTWALL | HIT_RIGHTWALL | HIT_CEILING)
	BEQ IceBlock_TileInteract
	
IceBlock_Burst:
	LDA <Objects_YZ, X
	STA Debris_Y

	LDA <Objects_XZ, X
	STA Debris_X

	JSR Common_MakeIce
	JSR Object_TestTopBumpBlocks
	JSR Object_TestSideBumpBlocks

	JMP Object_SetDeadEmpty

IceBlock_TileInteract:
	JSR Object_InteractWithTiles

IceBlock_Draw:
	JSR Object_DrawMirrored
	LDA Sprite_RAM+$06, Y
	ORA #SPR_VFLIP
	STA Sprite_RAM+$06, Y
	RTS


ObjInit_Spintula:
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	
	LDA Object_VertTileValue, X
	STA Spintula_DetectTile, X

	EOR #$01
	STA Spintula_DetectTile2, X
	RTS		 ; Return

Spintula_DetectTile = Objects_Data3
Spintula_DetectTile2 = Objects_Data4
Spintula_Action = Objects_Data5
Spintula_Frame = Objects_Data6
Spintula_Pause = Objects_Data7

ObjNorm_Spintula:
	LDA <Player_HaltGameZ
	BEQ ObjNorm_Spintula1
	
	JMP Object_DrawMirrored	

ObjNorm_Spintula1:
	JSR Object_DeleteOffScreen
	LDA Spintula_Pause, X
	BNE ObjNorm_Spintula2

	JSR Object_ApplyYVel_NoGravity

ObjNorm_Spintula2:
	LDA #$00
	STA Spintula_Pause, X
	
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_DetectTiles

	LDA Spintula_Action, X
	JSR DynJump
	
	.word Spintula_Wait
	.word Spintula_SpinDown
	.word Spintula_Wait2
	.word Spintula_SpinUp

Spintula_Wait:
	LDA Objects_Timer,X
	BNE Spintula_WaitRTS
	
	JSR Object_XDistanceFromPlayer
	CMP #$28
	
	BCS Spintula_WaitRTS
	INC Spintula_Action, X
	
	LDA #$20
	STA <Objects_YVelZ, X
	STA Spintula_Pause, X

Spintula_WaitRTS:
	JMP Object_DrawMirrored

Spintula_SpinDown:
	LDA <Objects_YHiZ, X
	BEQ Spintula_GoDown

	LDA <Objects_YZ, X
	CMP #$A0
	BCS Spintula_SpinDownStop

Spintula_GoDown:
	LDA Object_VertTileValue, X
	CMP Spintula_DetectTile, X
	BEQ Spintula_DrawWeb

	CMP Spintula_DetectTile2, X
	BNE Spintula_SpinDownStop

Spintula_DrawWeb:
	LDA <Objects_YZ, X
	AND #$0F
	BNE Spintual_DownDraw

	LDA Block_NeedsUpdate
	BEQ Spintual_DoDrawWeb
	
	INC Spintula_Pause, X
	BNE Spintula_SpinDownRTS

Spintual_DoDrawWeb:
	LDA Object_BodyTileValue, X
	ORA #$01
	JSR Object_ChangeBlock
	
Spintual_DownDraw:
	INC Spintula_Frame, X
	LDA Spintula_Frame, X
	LSR A
	AND #$01
	STA Objects_Frame, X
	
Spintula_SpinDownRTS:
	JMP Object_DrawMirrored

Spintula_SpinDownStop:
	INC Spintula_Action, X

	LDA #$20
	STA Objects_Timer,X

	LDA #$00
	STA <Objects_YVelZ, X
	JMP Object_DrawMirrored

Spintula_Wait2:
	LDA Objects_Timer, X
	BNE Spintula_Wait2Draw

	INC Spintula_Action, X
	LDA #$F0
	STA <Objects_YVelZ, X

Spintula_Wait2Draw:
	JMP Object_DrawMirrored

Spintula_SpinUp:

	LDA Object_VertTileValue, X
	CMP Spintula_DetectTile, X
	BEQ Spintula_DeleteWeb

	CMP Spintula_DetectTile2, X
	BNE Spintula_SpinUpStop

Spintula_DeleteWeb:
	LDA <Objects_YZ, X
	AND #$0F
	BNE Spintual_UpDraw

	LDA Block_NeedsUpdate
	BEQ Spintula_DoDeleteWeb

	INC Spintula_Pause, X
	BNE Spintula_SpinUpRTS

Spintula_DoDeleteWeb:
	LDA Object_BodyTileValue, X
	AND #$FE

	JSR Object_ChangeBlock
	
Spintual_UpDraw:
	INC Spintula_Frame, X
	LDA Spintula_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X
	
Spintula_SpinUpRTS:
	JMP Object_DrawMirrored

Spintula_SpinUpStop:
	LDA #$00
	STA Spintula_Action, X

	LDA #$20
	STA Objects_Timer,X

	LDA #$00
	STA <Objects_YVelZ, X
	JMP Object_DrawMirrored

PipePodobo_YVel:
	.byte $20, $E0

PipePodobo_Orientation:
	.byte SPR_VFLIP, $00

PipePodobo_StartY = Objects_Data3
PipePodobo_StartYHi = Objects_Data4
PipePodobo_Frame = Objects_Data5

ObjInit_PipePodobo:
	LDA Objects_Property, X
	AND #$01
	BEQ ObjInit_PipePodobo1

	LDA #$0A
	STA PatTable_BankSel+4

ObjInit_PipePodobo1:
	LDA Objects_Property, X
	AND #$02
	LSR A
	TAY

	LDA PipePodobo_YVel, Y
	STA Objects_YVelZ, X

	LDA PipePodobo_Orientation, Y
	STA Objects_Orientation,X

	LDA #SPR_BEHINDBG
	ORA Objects_SpriteAttributes, X
	STA Objects_SpriteAttributes, X

	; Store original Y/Hi into Var5/Var4
	LDA <Objects_YZ,X
	STA PipePodobo_StartY,X

	LDA <Objects_YHiZ,X
	STA PipePodobo_StartYHi,X

	LDA <Objects_XZ, X
	ADD #$08
	STA <Objects_XZ, X

	LDA #$01
	STA Objects_NoIce, X
	RTS

ResetPipePodobo:
	LDA #$20
	STA Objects_Timer, X

	LDA PipePodobo_StartY, X
	STA <Objects_YZ, X

	LDA PipePodobo_StartYHi, X
	STA <Objects_YHiZ, X
	RTS		 ; Return

ObjNorm_PipePodobo:
	LDA <Player_HaltGameZ
	BEQ ObjNorm_PipePodobo1

	JMP Object_DrawMirrored

ObjNorm_PipePodobo1:
	LDA Objects_Timer, X
	BEQ ObjNorm_PipePodobo2

	RTS

ObjNorm_PipePodobo2:
	JSR Object_ApplyYVel_NoGravity
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat	 ; Handle Player collision with Podoboo

	LDA <Objects_YZ, X
	AND #$0F
	BNE PipePodobo_Animate

	JSR Object_DetectTiles
	LDA Object_BodyTileProp, X
	CMP #TILE_PROP_SOLID_ALL
	BCC PipePodobo_Animate

	JSR ResetPipePodobo

PipePodobo_Animate:
	; Frame loop 0-2
	INC PipePodobo_Frame, X
	LDA PipePodobo_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$03
	CMP #$03
	BCC PipePodobo_StoreFrame

	LDA #$00
	STA PipePodobo_Frame, X

PipePodobo_StoreFrame:
	STA Objects_Frame, X
	
PipePodobo_Draw:
	JMP Object_DrawMirrored	 ; Draw Podoboo and don't come back!


SnowGuy_Frame = Objects_Data1
SnowGuy_Holding = Objects_Data2
SnowGuy_DiggingSnow = Objects_Data3
SnowGuy_ForceDrawSnow =  Objects_Data4

ObjInit_SnowGuy:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer

	LDA Objects_Property, X
	STA SnowGuy_Holding, X
	RTS		 ; Return

ObjNorm_SnowGuy:
	LDA <Player_HaltGameZ
	BEQ SnowGuy_Norm
	
	JMP SnowGuy_Draw

SnowGuy_Norm:
	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_FacePlayerOnLanding
	JSR SnowGuy_FindSnow
	JSR SnowGuy_GrabSnow
	JSR SnowGuy_ThrowSnow
	JSR Object_AttackOrDefeat

SnowGuy_Animate:
	INC SnowGuy_Frame, X
	LDY #$00

	LDA SnowGuy_DiggingSnow, X
	BNE SnowGuy_Draw
	
	LDA SnowGuy_Holding, X
	BEQ SnowGuy_NoArms

	INY

SnowGuy_NoArms:
	TYA
	ASL A
	STA <Temp_Var1

	LDA SnowGuy_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA <Temp_Var16
	ORA <Temp_Var1
	STA Objects_Frame, X

SnowGuy_Draw:
	LDA <Objects_YVelZ, X
	BPL SnowGuy_GroundAnim

	LDA #$05
	STA Objects_Frame, X
	JSR Object_DrawMirrored
	JMP SnowGuy_DrawSnow

SnowGuy_GroundAnim:
	LDA Objects_Frame, X
	SUB #$04
	CMP #$02
	BCS SnowGuy_DrawNorm

	JSR Object_DrawMirrored
	JMP SnowGuy_DrawSnow

SnowGuy_DrawNorm:
	JSR Object_Draw

SnowGuy_DrawSnow:
	LDA SnowGuy_ForceDrawSnow, X
	BEQ SnowGuy_SnowNotForced 

	LDA #$00
	STA SnowGuy_ForceDrawSnow, X
	BEQ SnowGuy_SnowSprites

SnowGuy_SnowNotForced:
	LDA SnowGuy_Holding, X
	BEQ SnowGuy_DrawDone

SnowGuy_SnowSprites:
	LDA #$0E
	ADD <Temp_Var16
	STA <Temp_Var16

	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #SPRITE_0_HINVISIBLE
	BNE SnowGuy_DrawRight


	LDA #$8D
	STA Sprite_RAMTile + 8, Y

	LDA Objects_SpriteX, X
	STA Sprite_RAMX + 8, Y

	LDA Sprite_RAMY, Y
	SUB <Temp_Var16
	STA Sprite_RAMY + 8, Y

	LDA Sprite_RAMAttr, Y
	AND #SPR_BEHINDBG
	ORA #SPR_PAL2
	STA Sprite_RAMAttr + 8, Y

SnowGuy_DrawRight:
	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #SPRITE_1_INVISIBLE
	BNE SnowGuy_DrawDone

	LDA #$8F
	STA Sprite_RAMTile + 12, Y

	LDA Objects_SpriteX, X
	ADD #$08
	STA Sprite_RAMX + 12, Y

	LDA Sprite_RAMY, Y
	SUB <Temp_Var16
	STA Sprite_RAMY + 12, Y

	LDA Sprite_RAMAttr, Y
	AND #SPR_BEHINDBG
	ORA #SPR_PAL2
	STA Sprite_RAMAttr + 12, Y

SnowGuy_DrawDone:
	RTS

SnowGuy_FindSnow:
	LDA SnowGuy_Holding, X
	BNE SnowGuy_FindSnowDone

	LDA SnowGuy_DiggingSnow, X
	BNE SnowGuy_FindSnowDone

	LDA <Objects_XZ, X
	AND #$0F
	BNE SnowGuy_FindSnowDone

	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ SnowGuy_FindSnowDone

	LDA Object_VertTileProp, X
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_ENEMYSOLID)
	BNE SnowGuy_FindSnowDone

	LDA #$40
	STA SnowGuy_DiggingSnow, X
	
SnowGuy_FindSnowDone:
	RTS

SnowGuy_GrabSnow:
	LDA SnowGuy_DiggingSnow, X
	BEQ SnowGuy_GrabSnowDone
	
	LDA #$00
	STA <Objects_XVelZ, X
	DEC SnowGuy_DiggingSnow, X
	BNE SnowGuy_KeepDigging
	
	LDA #$01
	STA SnowGuy_Holding, X
	
	LDA #$E0
	STA <Objects_YVelZ, X
	RTS
	
SnowGuy_KeepDigging:
	LDA SnowGuy_DiggingSnow, X
	CMP #$20
	BCS ShyGuy_DigAnimate
	
	LDA #$06
	STA Objects_Frame, X
	RTS
	
ShyGuy_DigAnimate:
	LSR A
	LSR A
	LSR A
	AND #$01
	ADD #$04
	STA Objects_Frame, X
	
SnowGuy_GrabSnowDone:
	RTS

SnowGuy_ThrowSnow:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ SnowGuy_ThrowSnowDone

	LDA <Objects_YVelZ, X
	BNE SnowGuy_ThrowSnowDone

	LDA SnowGuy_Holding, X
	BEQ SnowGuy_ThrowSnowDone

	JSR Object_XDistanceFromPlayer
	LDA <XDiff
	CMP #$50
	BCS SnowGuy_ThrowSnowDone

	JSR Object_FindEmptyY
	BCC SnowGuy_ThrowSnowDone
	
	LDA <Objects_XZ, X
	STA Objects_XZ, Y

	LDA <Objects_XHiZ, X
	STA Objects_XHiZ, Y

	LDA <Objects_YZ, X
	SUB #$10
	STA Objects_YZ, Y

	LDA <Objects_YHiZ, X
	SBC #$00
	STA Objects_YHiZ, Y

	LDA #$E8
	STA Objects_YVelZ, Y

	LDA #OBJ_SNOWBALL
	STA Objects_ID, Y

	LDA #SPR_PAL2
	STA Objects_SpriteAttributes, Y
	
	LDA #$E8
	STA Objects_XVelZ, Y

	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	BEQ SnowGuy_ClearHolding

	LDA Objects_XVelZ, Y
	EOR #$FF
	ADD #$01
	STA Objects_XVelZ, Y

SnowGuy_ClearHolding:
	LDA #$00
	STA SnowGuy_Holding, X

	INC SnowGuy_ForceDrawSnow, X

SnowGuy_ThrowSnowDone:
	RTS
	

VeggieGuy_Frame = Objects_Data1
VeggieGuy_Holding = Objects_Data2
VeggieGuy_PullingVeggie = Objects_Data3

ObjInit_VeggieGuy:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer
	RTS		 ; Return

ObjNorm_VeggieGuy:
	LDA <Player_HaltGameZ
	BEQ VeggieGuy_Norm
	
	JMP VeggieGuy_Draw

VeggieGuy_Norm:
	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_FacePlayerOnLanding
	JSR VeggieGuy_FindVeggie
	JSR VeggieGuy_GrabVeggie
	JSR VeggieGuy_ThrowVeggie
	JSR Object_AttackOrDefeat

VeggieGuy_Animate:
	INC VeggieGuy_Frame, X

VeggieGuy_Draw:
	LDY #$00

	LDA VeggieGuy_PullingVeggie, X
	BNE VeggieGuy_DoDraw
	
	LDA VeggieGuy_Holding, X
	BEQ VeggieGuy_NoArms

	INY

VeggieGuy_NoArms:
	TYA
	ASL A
	STA <Temp_Var1

	LDA VeggieGuy_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA <Temp_Var16
	ORA <Temp_Var1
	STA Objects_Frame, X

VeggieGuy_DoDraw:
	LDA <Objects_YVelZ, X
	BPL VeggieGuy_GroundAnim

	LDA #$05
	STA Objects_Frame, X
	JSR Object_DrawMirrored
	JMP VeggieGuy_DrawVeggie

VeggieGuy_GroundAnim:
	LDA Objects_Frame, X
	SUB #$04
	CMP #$02
	BCS VeggieGuy_DrawNorm

	JSR Object_DrawMirrored
	JMP VeggieGuy_DrawVeggie

VeggieGuy_DrawNorm:
	JSR Object_Draw

VeggieGuy_DrawVeggie:

	LDA VeggieGuy_Holding, X
	BEQ VeggieGuy_DrawDone

VeggieGuy_VeggieSprites:
	LDA #$0E
	ADD <Temp_Var16
	STA <Temp_Var16

	LDA Objects_SpritesVerticallyOffScreen, X
	AND #SPRITE_0_VINVISIBLE
	BNE VeggieGuy_DrawDone

	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #SPRITE_0_HINVISIBLE
	BNE VeggieGuy_DrawRight

	LDA #$B3
	STA Sprite_RAMTile + 8, Y

	LDA Objects_SpriteX, X
	STA Sprite_RAMX + 8, Y

	LDA Objects_SpriteY, X
	SUB <Temp_Var16
	STA Sprite_RAMY + 8, Y

	LDA #SPR_PAL2
	STA Sprite_RAMAttr + 8, Y

VeggieGuy_DrawRight:
	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #SPRITE_1_INVISIBLE
	BNE VeggieGuy_DrawDone

	LDA #$B3
	STA Sprite_RAMTile + 12, Y

	LDA Objects_SpriteX, X
	ADD #$08
	STA Sprite_RAMX + 12, Y

	LDA Objects_SpriteY, X
	SUB <Temp_Var16
	STA Sprite_RAMY + 12, Y

	LDA #(SPR_PAL2 | SPR_HFLIP)
	STA Sprite_RAMAttr + 12, Y

VeggieGuy_DrawDone:
	RTS

VeggieGuy_FindVeggie:
	LDA VeggieGuy_Holding, X
	BNE VeggieGuy_FindVeggieDone

	LDA VeggieGuy_PullingVeggie, X
	BNE VeggieGuy_FindVeggieDone

	LDA <Objects_XZ, X
	AND #$0F
	BNE VeggieGuy_FindVeggieDone

	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ VeggieGuy_FindVeggieDone

	LDA Object_BodyTileProp, X
	CMP #TILE_PROP_SOLID_TOP
	BCS VeggieGuy_FindVeggieDone

	AND #$0F
	CMP #TILE_PROP_ENEMY
	BNE VeggieGuy_FindVeggieDone

	LDA #$20
	STA VeggieGuy_PullingVeggie, X
	
VeggieGuy_FindVeggieDone:
	RTS

VeggieGuy_GrabVeggie:
	LDA VeggieGuy_PullingVeggie, X
	BEQ VeggieGuy_GrabVeggieDone
	
	LDA #$00
	STA <Objects_XVelZ, X
	
	DEC VeggieGuy_PullingVeggie, X
	BNE VeggieGuy_KeepPulling

	LDA Block_NeedsUpdate
	BEQ VeggieGuy_Pluck

	INC VeggieGuy_PullingVeggie, X
	RTS

VeggieGuy_Pluck:
	
	LDA #$01
	STA VeggieGuy_Holding, X
	
	LDA #$E0
	STA <Objects_YVelZ, X

	LDA <Objects_XZ, X
	ADD #$08
	STA Block_DetectX

	LDA <Objects_XHiZ, X
	STA Block_DetectXHi

	LDA <Objects_YZ, X
	ADD #$08
	STA Block_DetectY

	LDA <Objects_YHiZ, X
	STA Block_DetectYHi

	LDA Object_BodyTileValue, X
	AND #$C0
	ORA #$01
	JSR Object_ChangeBlock
	RTS
	
VeggieGuy_KeepPulling:
	LDA #$04
	STA Objects_Frame, X
	RTS

VeggieGuy_GrabVeggieDone:
	RTS

VeggieGuy_ThrowVeggie:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ VeggieGuy_ThrowVeggieDone

	LDA <Objects_YVelZ, X
	BNE VeggieGuy_ThrowVeggieDone

	LDA VeggieGuy_Holding, X
	BEQ VeggieGuy_ThrowVeggieDone

	JSR Object_XDistanceFromPlayer
	LDA <XDiff
	CMP #$30
	BCS VeggieGuy_ThrowVeggieDone

	JSR Object_YDistanceFromPlayer

	LDA <YDiff
	CMP #$20
	BCS VeggieGuy_ThrowVeggieDone

	JSR Object_PrepProjectile
	BCC VeggieGuy_ThrowVeggieDone
	
	
	LDA #SOBJ_VEGGIE
	STA SpecialObj_ID,Y

	LDA <Objects_XZ, X
	STA SpecialObj_X, Y

	LDA <Objects_XHiZ, X
	STA SpecialObj_XHi, Y

	LDA <Objects_YZ, X
	SUB #$10
	STA SpecialObj_Y, Y

	LDA <Objects_YHiZ, X
	SBC #$00
	STA SpecialObj_YHi, Y

	LDA #$E8
	STA SpecialObj_YVel, Y

	LDA #$E0
	STA SpecialObj_XVel, Y

	LDA <Objects_XVelZ, X
	BMI VeggieGuy_ClearHolding
	
	LDA #$20
	STA SpecialObj_XVel, Y

VeggieGuy_ClearHolding:
	LDA #$00
	STA VeggieGuy_Holding, X

VeggieGuy_ThrowVeggieDone:
	RTS

ShyGuy_Frame = Objects_Data1
ShyGuy_Holding = Objects_Data2

ObjInit_ShyGuy:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer
	RTS		 ; Return

ObjNorm_ShyGuy:
	LDA <Player_HaltGameZ
	BEQ ShyGuy_Norm
	
	JMP ShyGuy_Draw

ShyGuy_Norm:
	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE ShGuy_Alive

	LDA ShyGuy_Holding, X
	BEQ ShyGuy_DeadRTS

	JSR ShyGuy_ThrowBlockForced
	LDA #$00
	STA Objects_XVelZ, Y

ShyGuy_DeadRTS:
	JMP Object_Draw

ShGuy_Alive:
	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_FacePlayerOnLanding
	JSR ShyGuy_FindBlock
	JSR ShyGuy_GrabBlock
	JSR ShyGuy_ThrowBlock
	JSR Object_AttackOrDefeat

ShyGuy_Animate:
	INC ShyGuy_Frame, X
	LDY #$00

	LDA ShyGuy_Holding, X
	BEQ ShyGuy_NoArms

	INY

ShyGuy_NoArms:
	TYA
	ASL A
	STA <Temp_Var1

	LDA ShyGuy_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA <Temp_Var16
	ORA <Temp_Var1
	STA Objects_Frame, X

ShyGuy_Draw:
	LDA <Objects_YVelZ, X
	BPL ShyGuy_GroundAnim

	LDA #$04
	STA Objects_Frame, X
	JMP Object_DrawMirrored

ShyGuy_GroundAnim:
	JSR Object_Draw
	LDA ShyGuy_Holding, X
	BEQ ShyGuy_DrawDone

	
	LDA #$0E
	ADD <Temp_Var16
	STA <Temp_Var16

	LDA Objects_SpritesVerticallyOffScreen, X
	AND #SPRITE_0_VINVISIBLE
	BNE ShyGuy_DrawDone

	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #SPRITE_0_HINVISIBLE
	BNE ShyGuy_DrawRight


	LDA #$67
	STA Sprite_RAMTile + 8, Y

	LDA Objects_SpriteX, X
	STA Sprite_RAMX + 8, Y

	LDA Objects_SpriteY, X
	SUB <Temp_Var16
	STA Sprite_RAMY + 8, Y

	LDA #SPR_PAL3
	STA Sprite_RAMAttr + 8, Y

ShyGuy_DrawRight:
	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #SPRITE_1_INVISIBLE
	BNE ShyGuy_DrawDone

	LDA #$67
	STA Sprite_RAMTile + 12, Y

	LDA Objects_SpriteX, X
	ADD #$08
	STA Sprite_RAMX + 12, Y

	LDA Objects_SpriteY, X
	SUB <Temp_Var16
	STA Sprite_RAMY + 12, Y

	LDA #(SPR_PAL3 | SPR_HFLIP)
	STA Sprite_RAMAttr + 12, Y

ShyGuy_DrawDone:
	RTS

ShyGuy_ScanAbove:
	.byte $48, $38, $28, $18, $08

ShyGuy_FindBlock:
	LDA ShyGuy_Holding, X
	BNE ShyGuy_FindBlockDone

	LDA <Objects_XZ, X
	AND #$0F
	BNE ShyGuy_FindBlockDone

	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ ShyGuy_FindBlockDone

	LDY #$04
	LDA <Objects_XZ, X
	ADD #$08
	STA Tile_DetectionX

	LDA <Objects_XHiZ, X
	STA Tile_DetectionXHi

ShyGuy_FindLoop:
	STY TempY
	LDA <Objects_YZ, X
	SUB ShyGuy_ScanAbove, Y
	STA Tile_DetectionY

	LDA <Objects_YHiZ, X
	SBC #$00
	STA Tile_DetectionYHi

	JSR Object_DetectTile

	LDA Tile_LastProp
	CMP #TILE_PROP_ITEM
	BCS ShyGuy_JumpForBlock

	LDY TempY
	DEY
	BPL ShyGuy_FindLoop

ShyGuy_FindBlockDone:
	RTS

ShyGuy_JumpForBlock:
	LDA #$B8
	STA <Objects_YVelZ, X

	LDA #$00
	STA <Objects_XVelZ, X
	RTS

ShyGuy_GrabBlock:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_CEILING
	BEQ ShyGuy_GrabBlockDone 

	LDA Object_VertTileProp, X
	CMP #TILE_PROP_ITEM
	BCC ShyGuy_GrabBlockDone

	LDY Block_NeedsUpdate
	BNE ShyGuy_GrabBlockDone

	AND #$0F
	ADD #$01
	STA ShyGuy_Holding, X

	LDA <Objects_XZ, X
	ADD #$08
	STA Tile_DetectionX

	LDA <Objects_XHiZ, X
	ADC #$00
	STA Tile_DetectionXHi

	LDA <Objects_YZ, X
	SUB #$08
	STA Tile_DetectionY

	LDA <Objects_YHiZ, X
	SBC #$00
	STA Tile_DetectionYHi

	LDA Tile_LastValue
	AND #$C0
	ORA #$01

	JSR Object_ChangeBlock

ShyGuy_GrabBlockDone:
	RTS

ShyGuy_ThrowBlock:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ ShyGuy_ThrowBlockDone

	LDA ShyGuy_Holding, X
	BEQ ShyGuy_ThrowBlockDone

	JSR Object_XDistanceFromPlayer
	LDA <XDiff
	CMP #$40
	BCS ShyGuy_ThrowBlockDone

ShyGuy_ThrowBlockForced:
	JSR Object_FindEmptyY
	BCC ShyGuy_ThrowBlockDone

	LDA #OBJ_BRICK
	STA Objects_ID, Y

	LDA #SPR_PAL3
	STA Objects_SpriteAttributes, Y

	LDA ShyGuy_Holding, X
	STA Brick_PowerUp, Y

	LDA <Objects_XZ, X
	STA Objects_XZ, Y

	LDA <Objects_XHiZ, X
	STA Objects_XHiZ, Y

	LDA <Objects_YZ, X
	SUB #$10
	STA Objects_YZ, Y

	LDA <Objects_YHiZ, X
	SBC #$00
	STA Objects_YHiZ, Y

	LDA #$D8
	STA Objects_YVelZ, Y

	LDA #$E0
	STA Objects_XVelZ, Y

	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	BEQ ShyGuy_ClearHolding

	LDA Objects_XVelZ, Y
	EOR #$FF
	ADD #$01
	STA Objects_XVelZ, Y

ShyGuy_ClearHolding:
	LDA #$00
	STA ShyGuy_Holding, X

ShyGuy_ThrowBlockDone:
	RTS

BrickBust_MicroGoomba:
	LDA #$04	 ; A = 4 (the Microgoomba that falls out of a Piledriver)

PRG003_A4DD:
	STA <Temp_Var16	 ; Input value -> Temp_Var16

	; Crumbling brick sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDA #$00
	STA TempA
	LDA Objects_ID,X
	CMP #OBJ_ICEBLOCK
	BNE PRG003_A4E9
	LDA #$01
	STA TempA

PRG003_A4E9:
	LDA Objects_State + 5
	BNE PRG003_A4E92

	LDA Objects_Data2, X
	BEQ PRG003_A4E92

	STA Objects_ID + 5
	LDA Objects_Data3, X
	STA PUp_StarManFlash
	LDA #OBJSTATE_INIT
	STA Objects_State + 5
	LDA #$C0
	STA <Objects_YVelZ + 5
	STA PowerUp_NoRaise
	LDY #$10
	LDA <Objects_XVelZ, X
	BPL PRG003_A4E91
	LDY #$F0

PRG003_A4E91:
	TYA
	STA <Objects_XVelZ + 5
	LDA <Objects_XZ, X
	STA <Objects_XZ + 5
	LDA <Objects_YZ, X
	STA <Objects_YZ  + 5
	LDA <Objects_XHiZ, X
	STA <Objects_XHiZ + 5
	LDA <Objects_YHiZ, X
	STA <Objects_YHiZ  + 5

PRG003_A4E92:
	JSR Object_SetDeadEmpty	; Destroy the Ice Block

	; Break apart into the four brick bust pieces
PRG003_A4EA:
	JSR BustBlock_Segment 	; Generate Ice block segment

	LDA TempA
	STA SpecialObj_Stompable,Y

PRG003_A4EB:
	DEC <Temp_Var16		; Temp_Var16--
	BPL PRG003_A4EA		; While Temp_Var16 >= 0, loop!

	RTS		 ; Return

Piledriver_YOff:	.byte $01, $00, $02, $04, $05, $02

	; "Bust block" is an ice block that smashed into wall or a Microgoomba brick getting busted
	; First four are the brick bits, the last is the microgoomba
BustBlock_YOffByInput:	.byte -$04, -$04, $04, $04, $00
BustBlock_YHiOffByInput:	.byte  $FF,  $FF, $00, $00, $00
BustBlock_YVelByInput:	.byte $C0, $C0, $D0, $D0, $D0
BustBlock_XVelByInput:	.byte $F8, $08, $F8, $08, $00 

	; Generates a segment of the busted brick (or microgoomba in the case of the Piledriver)
BustBlock_Segment:
	LDY #$07	 ; Y = 7 (wider expanse of special object slots)

	JSR SpecialObject_FindEmptyAbortY	 ; Find an empty special object slot or don't come back here...

	; Temp_Var1 = Ice Block's Y
	LDA <Objects_YZ,X
	STA <Temp_Var1

	; Temp_Var3 = Ice Block's Y Hi
	LDA <Objects_YHiZ,X
	STA <Temp_Var3

	; Temp_Var2 = Ice Block's X
	LDA <Objects_XZ,X
	STA <Temp_Var2

	; X = Temp_Var16 (input value for Ice Block)
	LDX <Temp_Var16

	; Add Y offset by input
	LDA <Temp_Var1
	ADD BustBlock_YOffByInput,X
	STA SpecialObj_Y,Y
	LDA <Temp_Var3
	ADC BustBlock_YHiOffByInput,X
	STA SpecialObj_YHi,Y

	; X Lo = Temp_Var2
	LDA <Temp_Var2
	STA SpecialObj_X,Y

	; Set Ice Block Y Velocity by input
	LDA BustBlock_YVelByInput,X
	STA SpecialObj_YVel,Y

	; Set Ice Block X Velocity by input
	LDA BustBlock_XVelByInput,X
	STA SpecialObj_XVel,Y

	LDA #SOBJ_BRICKDEBRIS	 ; Busting brick, input value 4 only
 
	CPX #$04	 ; X = 4
	BNE PRG003_A54E	 ; If input value <> 4, jump to PRG003_A54E

	LDA #SOBJ_MICROGOOMBA	 ; Otherwise, micro Goomba

PRG003_A54E:
	STA SpecialObj_ID,Y	 ; Set appropriate ID

	LDA #$ff
	STA SpecialObj_Data1,Y

	LDX <CurrentObjectIndexZ		 ; X = object slot index

PRG003_A567:
	RTS		 ; Return

Twirler_InitXVel:	.byte $08, -$08
Twirl_DropXVel: .byte $18, $E8

ObjInit_Twirling:
	JSR Object_XDistanceFromPlayer

	; Set twirler X velocity towards Player
	LDA Twirler_InitXVel,Y
	STA <Objects_XVelZ,X

	; Set vertically flipped
	LDA #SPR_VFLIP
	STA Objects_Orientation,X

	DEC <Objects_YZ,X	 ; Start one pixel higher

	LDY <Objects_YZ,X
	INY	
	BNE PRG003_A580
	DEC <Objects_YHiZ,X	 ; Apply carry
PRG003_A580:

	RTS		 ; Return

; FIXME: Anybody want to claim this?
; $A581
	.byte $F8, $08

ObjNorm_TwirlingShell:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR TwirlShell_Draw	 	; Draw the twirling shell enemy

	LDA <Player_HaltGameZ
	BNE PRG003_A5EF	 ; If gameplay halted, jump to PRG003_A5EF

	JSR Object_InteractWithPlayer

	LDA Objects_ID,X
	CMP #OBJ_BUZZYBEATLE
	BNE PRG003_A59A	 ; If object has not become a Buzzle Beatle, jump to PRG003_A59A

	;JMP Object_SetShellState ; Set shell state and don't come back!

PRG003_A59A:
	LDY #$00	 ; Y = 0

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A5A3	 ; 8 ticks on, 8 ticks off; jump to PRG003_A5A3

	INY		 ; Y = 1

PRG003_A5A3:
	TYA
	STA Objects_Frame,X	 ; Toggle frame 0/1

	JSR Object_ApplyXVel	 ; Apply X velocity

	; Maintain Y Velocity = -$01 (sticks to ceiling)
	LDA #-$01
	STA <Objects_YVelZ,X

	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_TilesDetectZ,X
	AND #$08
	BNE PRG003_A5CA	 ; If still detecting ceiling, jump to PRG003_A5CA

	; No more ceiling!

	INC Objects_Data3,X	 ; Var7++

	LDA Objects_Data3,X
	CMP #$02
	BGE PRG003_A5DB	 	; If Var7 >= 2, jump to PRG003_A5DB

	JSR Object_Reverse	; Turn around
	JSR Object_ApplyXVel	; Apply X velocity
	JMP PRG003_A5CF		; Jump to PRG003_A5CF

PRG003_A5CA:
	; Var7 = 0
	LDA #$00
	STA Objects_Data3,X

PRG003_A5CF:
	JSR Object_XDistanceFromPlayer	

	LDA <Temp_Var16
	ADD #$30
	CMP #$60
	BGE PRG003_A5EF	 ; If Player is not close enough, jump to PRG003_A5EF

PRG003_A5DB:

	; Go into "kicked" state!
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	LDA ObjGroupRel_Idx
	ASL A		; 2 byte index for ObjectGroup02_CollideJumpTable
	TAY		; Y = offset into ObjectGroup_CollideJumpTable

	LDA ObjectGroup02_CollideJumpTable,Y
	STA Objects_ID,X	 ; Change into the appropriate target object

	JSR Object_XDistanceFromPlayer
	LDA Twirl_DropXVel, Y
	STA <Objects_XVelZ,X

PRG003_A5EF:
	LDA <Objects_TilesDetectZ,X
	AND #$03
	BEQ PRG003_A5F8	 ; If object has not hit a wall, jump to PRG003_A5F8

	JSR Object_Reverse	 ; Otherwise, turn around...

PRG003_A5F8:
	RTS		 ; Return

	; Unused data I think?  Possibly was for the twirling shell

TwirlShell_Draw:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

	LDA Objects_Frame,X
	CMP #$02
	BLT PRG003_A613	 ; If frame < 2, jump to PRG003_A613

	; Clear horizontal flip on frame 2+
	LDA Objects_Orientation,X
	AND #~SPR_HFLIP
	STA Objects_Orientation,X

PRG003_A613:
	JMP Object_Draw ; Draw shelled enemy and don't come back!

ObjInit_DonutLift: 
	RTS		 ; Return

ObjNorm_DonutLift:
	JSR Object_SetPaletteFromAttr	 ; Set palette

	LDY #$5a	 ; Y = $5A (Patterns for donut lift, vertical only)

	LDA Level_7Vertical
	BNE PRG003_A62A	 ; If this level is vertical, jump to PRG003_A62A

	LDA Level_TilesetIdx
	CMP #$01
	BNE PRG003_A62D	 ; If tileset is not Mini-Fortress style, jump to PRG003_A62D

	LDY #$12	 ; Y = $12 (Patterns for donut lift, Mini-Fortress only)

PRG003_A62A:

	; Mini-Fortress or vertical orientation only...

	STY PatTable_BankSel+4

PRG003_A62D:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE PRG003_A64E	 ; If object falls off-screen at all, jump to PRG003_A64E (destroys it)

	JSR Object_Draw	; Draw donut lift

	LDA <Player_HaltGameZ
	BNE PRG003_A651	 ; If gameplay is halted, jump to PRG003_A651 (RTS)

	LDA Objects_Data3,X
	BNE PRG003_A66A	 ; If Var7 is non-zero, jump to PRG003_A66A

	JSR Object_HitTest	 ; Do Player to object collision test

	LDA Objects_PlayerHitStat,X
	BNE PRG003_A652	 ; If Player is not touching object, jump to PRG003_A652

	LDA Block_UpdateValue
	BNE PRG003_A651	 ; If a tile change event is active, jump to PRG003_A651

	JSR DonutLift_ChangeBlock	; Do block change

PRG003_A64E:
	JSR Object_SetDeadEmpty	 ; Mark as dead/empty

PRG003_A651:
	RTS		 ; Return

PRG003_A652:
	DEC Objects_Data2,X	 ; Var5--
	BNE PRG003_A65A	 	; If Var5 > 0, jump to PRG003_A65A

	INC Objects_Data3,X	 ; Var7++

	RTS		 ; Return

PRG003_A65A:
	LDA <Counter_1
	AND #$07
	STA Objects_Timer4,X	 ; Timer4 = 0 to 7

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_A669	 ; If Player has not touched donut lift, jump to PRG003_A669 (RTS)

	JSR PRG003_A67C

PRG003_A669:
	RTS		 ; Return

PRG003_A66A:
	JSR Object_ApplyYVel_NoGravity	 ; Apply Y limit

	LDA <Objects_YVelZ,X
	CMP #$40
	BGS PRG003_A677	 ; If donut lift is moving downward faster than $40, jump to PRG003_A677

	; Gravity
	INC <Objects_YVelZ,X
	INC <Objects_YVelZ,X

PRG003_A677:
	JSR Object_HitTest	 ; Do Player to object collision detection
	BCC PRG003_A691	 ; If no collision, jump to PRG003_A691 (RTS)

PRG003_A67C:
	LDA <Player_YVel
	BMI PRG003_A691	 ; If Player is moving upward, jump to PRG003_A691 (RTS)

	; Otherwise, lock Player at 31 pixels above donut lift
	LDA <Objects_YZ,X
	SUB #31
	STA <Player_Y

	LDA <Objects_YHiZ,X
	SBC #$00
	STA <Player_YHi

	; Player is not in air
	LDA #$00
	STA <Player_InAir

PRG003_A691:
	RTS		 ; Return

DonutLift_ChangeBlock:
	; Queue tile change event
	LDA #$80
	STA Block_UpdateValue
	INC Block_UpdateValue

	; Block change to occur at Y+1
	LDA <Objects_YZ,X
	ADD #$01
	STA Block_ChangeY
	LDA <Objects_YHiZ,X
	ADC #$00
	STA Block_ChangeYHi

	LDA <Objects_XHiZ,X
	STA Block_ChangeXHi
	LDA <Objects_XZ,X
	STA Block_ChangeX

	RTS		 ; Return

ObjInit_BobOmb:
	JSR Object_MoveTowardsPlayer
	RTS		 ; Return

BobOmb_Frame = Objects_Data3
BobOmb_Activated = Objects_Data4
BobOmb_Unstable = Objects_Data5
BobOmb_Action = Objects_Data1
BobOmb_BehindTimer = Objects_Data2

ObjNorm_BobOmb:
	LDA <Player_HaltGameZ
	BEQ BobOmb_DoAction

	JMP Object_Draw

BobOmb_DoAction:
	
	LDA Objects_State, X
	CMP #OBJSTATE_KILLED

	BEQ BobOmb_Death

	LDA BobOmb_Action, X
	JSR DynJump

	.word BobOmb_Norm
	.word BobOmb_Left
	.word BobOmb_Right
	.word BobOmb_Raise
	.word BobOmb_Drop

BobOmb_Death:
	LDA Objects_PlayerProjHit, X
	CMP #HIT_FIREBALL
	BNE BobOmb_Death1

	LDA #$01
	STA Explosion_Timer, X

BobOmb_Death1:
	JMP BobOmb_Draw

BobOmb_Raise:
	LDA Objects_Timer, X
	BEQ BobOmb_PopOut

	CMP #$20
	BCC BobOmb_RaiseDone

	LDA #$F0
	STA <Objects_YVelZ, X
	JSR Object_ApplyYVel_NoGravity
	JMP BobOmb_Draw

BobOmb_PopOut:
	JSR Object_CalcBoundBox
	JSR Object_MoveDirectionFacing
	
	LDA #$D0
	STA <Objects_YVelZ, X

	LDA #$00
	STA BobOmb_Action, X

	LDA #$08
	STA BobOmb_BehindTimer, X

BobOmb_RaiseDone:
	JMP BobOmb_Draw

BobOmb_Drop:
	LDA Objects_Timer, X
	BEQ BobOmb_DropDown

	CMP #$20
	BCC BobOmb_DropDone

	LDA #$10
	STA <Objects_YVelZ, X
	JSR Object_ApplyYVel_NoGravity
	JMP BobOmb_Draw

BobOmb_DropDown:
	JSR Object_CalcBoundBox
	
	LDA #$01
	STA <Objects_YVelZ, X

	LDA #$00
	STA BobOmb_Action, X

	LDA #$08
	STA BobOmb_BehindTimer, X

BobOmb_DropDone:
	JMP BobOmb_Draw

BobOmb_Left:
	LDA Objects_Timer, X
	CMP #$10
	BEQ BobOmb_Out

	LDA #$F8
	STA <Objects_XVelZ, X
	JSR Object_ApplyXVel
	JMP BobOmb_Animate

BobOmb_Right:
	LDA Objects_Timer, X
	BEQ BobOmb_Out

	LDA #$08
	STA <Objects_XVelZ, X
	JSR Object_ApplyXVel

	JMP BobOmb_Animate

BobOmb_Out:
	LDA #$00
	STA BobOmb_Action, X
	LDA #$08
	STA BobOmb_BehindTimer, X
	JMP BobOmb_Animate

BobOmb_Norm:

	JSR Object_DeleteOffScreen	 
	JSR Object_Move
	JSR Object_CalcBoundBox

	LDA <Objects_XVelZ, X
	BNE BobOmb_Norm1

	JSR Object_FacePlayerOnLanding

BobOmb_Norm1:

	LDA Explosion_Timer, X
	ORA BobOmb_Unstable, X
	BEQ BobOmb_Attack

	JSR Object_DetectTiles
	
	LDA BobOmb_Unstable, X
	BNE BobOmb_UnstableCheck

	JSR Object_DampenVelocity
	JSR Object_InteractWithTiles
	JSR Object_InteractWithPlayer
	
	LDA #$02
	STA Objects_Frame, X
	JMP Object_Draw

BobOmb_UnstableCheck:
	JSR Object_InteractWithTiles
	JSR Object_InteractWithPlayer
	JSR Object_RespondToTailAttack

	LDA Objects_BeingHeld, X
	BNE BobOmb_ShakeDraw

	LDA Objects_PreviousTilesDetect,X
	BNE BobOmb_ShakeDraw

	LDA <Objects_TilesDetectZ,X
	BEQ BobOmb_ShakeDraw

	LDA #$01
	STA Explosion_Timer, X
	BNE BobOmb_ShakeDraw

BobOmb_Attack:
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_AttackOrDefeat
	
	LDA Objects_Stomped, X
	BEQ BobOmb_Animate

	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE BobOmb_Animate

	LDA #OBJSTATE_NORMAL
	STA Objects_State, X

	LDA Objects_Property, X
	BNE BobOmb_Unstabilize

	LDA #$A0
	STA Explosion_Timer, X
	BNE BobOmb_Animate

BobOmb_Unstabilize:
	LDA #$02
	STA Objects_Frame,X
	INC BobOmb_Unstable, X
	BNE BobOmb_Draw

BobOmb_Animate:
	INC BobOmb_Frame, X
	LDA BobOmb_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

BobOmb_Draw:
	LDA Objects_SpriteAttributes, X
	AND #~SPR_BEHINDBG
	STA Objects_SpriteAttributes, X

	LDA BobOmb_Action, X
	ORA BobOmb_BehindTimer, X
	BEQ BobOmb_NotBehind

	LDA Objects_SpriteAttributes, X
	ORA #SPR_BEHINDBG
	STA Objects_SpriteAttributes, X

	LDA BobOmb_BehindTimer, X
	BEQ BobOmb_NotBehind

	DEC BobOmb_BehindTimer, X

BobOmb_NotBehind:
	JMP Object_Draw

BobOmb_ShakeDraw:
	INC BobOmb_Frame, X
	JSR Object_Draw

	LDA BobOmb_Frame, X
	AND #$02
	BEQ BobOmb_ShakeDraw1

	LDA Object_SpriteRAMOffset, X
	TAX
	DEC Sprite_RAMY, X
	DEC Sprite_RAMY + 4, X

BobOmb_ShakeDraw1:
	RTS

	; X and Y offsets for the exploding Bob-omb stars
BombStars_XOff:	.byte -$04, $04, $08, $04, -$04, -$08, $00, $08, $08, $00, -$08, -$08
BombStars_YOff:	.byte -$08, -$08, $00, $08, $08, $00, $08, $04, -$04, -$08, -$04, $04

Explosion_Offset = Objects_Data1

ObjInit_Explosion:
	LDA #$18
	STA Objects_Timer,X

	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #$10
	STA RotatingColor_Cnt
	RTS		 ; Return

ObjNorm_Explosion:
	
	LDA <Player_HaltGameZ
	BNE DrawEx	 ; If gameplay is halted, jump to PRG003_A82E

	INC Explosion_Offset,X	 ; Otherwise, Var4++

DrawEx:
	LDA Objects_Timer,X
	BNE PRG003_A836	 ; If timer has not expired, jump to PRG003_A836

	JMP Object_SetDeadEmpty	 ; Otherwise, mark Bob-omb as Dead/Empty and don't come back!

PRG003_A836:
	AND #$03
	BNE Explosion_NoKill

	JSR Object_CalcBoundBox
	JSR Object_KillOthers

Explosion_NoKill:
	JSR Object_CalcSpriteXY_NoHi

	; Temp_Var16 = 5
	LDA #$05
	STA <Temp_Var16

PRG003_A83D:
	; Temp_Var1 = Bob-omb's sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1	

	; Temp_Var2 = Bob-omb's sprite X + 4
	LDA <Objects_SpriteX,X
	ADD #$04
	STA <Temp_Var2

	LDA Objects_Data1,X
	LSR A		 ; Var4 / 2
	PHA		 ; Save value

	; Temp_Var3 = 0 to 3, depending on Var4 / 2
	AND #$03
	STA <Temp_Var3

	LDX <Temp_Var16	 ; X = Temp_Var16

	PLA		 ; Restore Var4 / 2

	AND #$04	 ; Mask 0-3
	BEQ PRG003_A85C	 ; If result is zero, jump to PRG003_A85C

	; Otherwise, X += 6
	TXA
	ADD #$06
	TAX

PRG003_A85C:
	LDA <Temp_Var1
	ADD BombStars_YOff,X
	STA <Temp_Var1

	LDA <Temp_Var2
	ADD BombStars_XOff,X
	STA <Temp_Var2

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG003_A85C	 ; While Temp_Var3 >= 0, loop!

	LDX <CurrentObjectIndexZ		 ; X = object slot index

	JSR Sprite_NoCarryIfVisible
	BCS PRG003_A89D	 ; If this star is not visible, jump to PRG003_A89D

	LDA <Temp_Var16
	ASL A
	ASL A		; A = Temp_Var16 * 4 (one sprite per star)
	ADC Object_SpriteRAMOffset,X	 ; Add the base Sprite_RAM offset
	TAY		 ; -> 'Y'

	; Star Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Star X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; Star pattern
	LDA #$17
	STA Sprite_RAM+$01,Y

	LDA <Counter_1
	LSR A	
	LSR A	
	ADD <CurrentObjectIndexZ
	AND #$03	 ; Palette select 0 to 3
	STA Sprite_RAM+$02,Y	 ; Set attributes

	JSR PRG003_BD1E	 ; Uses part of the "Tail" hurt code, checks if Player has been hit by explosion

PRG003_A89D:
	DEC <Temp_Var16	 ; Temp_Var16--
	BPL PRG003_A83D	 ; While Temp_Var16 >= 0, loop!

	JSR Object_KillOthers

Explosion_BumpBlocks:
	LDA Objects_Timer,X
	AND #$07
	TAY

	LDA <Objects_XZ, X
	ADD ExplodeXOffsets + 8, Y
	STA Tile_DetectionX

	LDA <Objects_XHiZ, X
	ADC ExplodeXOffsets, Y
	STA Tile_DetectionXHi

	LDA <Objects_YZ, X
	ADD ExplodeYOffsets + 8, Y
	STA Tile_DetectionY

	LDA <Objects_YHiZ, X
	ADC ExplodeYOffsets, Y
	STA Tile_DetectionYHi

	JSR Object_DetectTile

	LDA Tile_LastProp
	CMP #(TILE_PROP_SOLID_TOP | TILE_PROP_STONE)
	BEQ Explosion_Bust

	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_STONE)
	BEQ Explosion_Bust 

	CMP #(TILE_PROP_SOLID_TOP | TILE_PROP_ENEMYSOLID)
	BEQ Explosion_Bust

	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_ENEMYSOLID)
	BEQ Explosion_Bust

	CMP #(TILE_PROP_ITEM)
	BCS Explosion_Bump
	RTS

Explosion_Bust:
	LDA #TILE_ITEM_BRICK
	STA Tile_LastProp

Explosion_Bump:
	JSR Object_DirectBumpBlocks
	RTS

ExplodeXOffsets:
	.byte $FF, $00, $00, $FF, $00, $FF, $00, $00
	.byte $F8, $08, $18, $F8, $18, $F8, $08, $18

ExplodeYOffsets
	.byte $FF, $FF, $FF, $00, $00, $00, $00, $00
	.byte $F8, $F8, $F8, $08, $08, $18, $18, $18

	; Calculates an upper left X/Y offset
BobOmb_CalcULOffXY:
	; Temp_Var3 = Bob-omb's Sprite X - 24
	LDA <Objects_SpriteX,X	 
	SUB #24
	STA <Temp_Var3

	; Temp_Var7 = Bob-omb's Sprite Y - 24
	LDA <Objects_SpriteY,X
	SUB #24
	STA <Temp_Var7

	; Temp_Var4 and Temp_Var8 = $40
	LDA #$40
	STA <Temp_Var4
	STA <Temp_Var8

	RTS		 ; Return
MagicStarOffset:
	.byte $00, $10, $20

ObjNorm_MagicStar:

	JSR Object_DeleteOffScreen	
	JSR Object_CalcBoundBox
	JSR Magic_Star_Action
	JSR Object_InteractWithPlayer

	JSR Object_DetectTiles
	JSR Object_CheckForeground
	JMP Object_DrawMirrored

Magic_StarCollect:
	LDA Sound_QLevel1
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap
	INC Magic_Stars

	JSR GetLevelBit

	STA <Temp_Var1
	STY <Temp_Var2

	LDA Magic_StarIndicator, X
	TAY

	LDA <Temp_Var2
	ADD MagicStarOffset, Y
	TAY

	LDA <Temp_Var1
	ORA Magic_Stars_Collected1, Y
	STA Magic_Stars_Collected1, Y

	JMP Object_SetDeadEmpty

Magic_Star_Action:
	LDA Objects_Property, X
	JSR DynJump

	.word ObjNorm_DoNothing
	.word MagicStar_NoFloat
	.word MagicStar_CheckEnemies
	.word MagicStar_CheckPSwitch
	.word MagicStar_CheckItemBlock
	.word MagicStar_CheckClearedBlock
	.word MagicStar_SpinnersActive

MagicStar_CheckEnemies:
	LDY #$04

CheckEnemies:
	CPY <CurrentObjectIndexZ
	BEQ NoCheck

	LDA Objects_State, Y
	CMP #OBJSTATE_KILLED
	BCS NoCheck

	CMP #OBJSTATE_DEADEMPTY
	BNE Check_Done

NoCheck:
	DEY
	BPL CheckEnemies

	LDA #$01
	STA Objects_Property, X

Check_Done:
	PLA
	PLA
	RTS

MagicStar_CheckPSwitch:
	LDA Level_PSwitchCnt
	BNE MagicStar_CheckPSwitch1
	PLA
	PLA
	RTS

MagicStar_CheckPSwitch1:
	JMP Object_InteractWithTiles

MagicStar_NoFloat:
	LDA <Player_HaltGameZ
	BNE MagicStar_NoMove

	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles

MagicStar_NoMove:
	JMP Object_InteractWithTiles

MagicStar_CheckItemBlock:
	JSR Object_DetectTileCenter

	LDA Tile_LastValue
	AND #$3F
	BNE MagicStar_CheckItemBlock1

	LDA #$01
	STA Objects_Property, X

	LDA #$D0
	STA Objects_YVelZ, X

	LDA Objects_YZ, X
	SUB #$10
	STA Objects_YZ, X

	LDA Objects_YHiZ, X
	SBC #$00
	STA Objects_YHiZ, X
	RTS

MagicStar_CheckItemBlock1:
	PLA
	PLA
	RTS

MagicStar_CheckClearedBlock:
	JSR Object_DetectTileCenter
	
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCS MagicStar_CheckItemBlock1

	LDA #$01
	STA Objects_Property, X
	RTS

MagicStar_SpinnersActive:
	LDY #$02
	LDX #$07

NextSpinnerCheck:
	LDA SpinnerBlocksActive, X
	BEQ NextSpinnerCheck1

	DEY
	BPL NextSpinnerCheck1

	LDX <CurrentObjectIndexZ

	LDA #$01
	STA Objects_Property, X

	LDA #SND_LEVELUNK
	STA Sound_QLevel1
	RTS

NextSpinnerCheck1:
	DEX
	BPL NextSpinnerCheck
	PLA
	PLA
	RTS



Magic_StarIndicator = Objects_Data4
ObjInit_MagicStar1:
	LDA #$00
	STA Magic_StarIndicator, X
	JMP ObjInit_MagicStar

ObjInit_MagicStar2:
	LDA #$01
	STA Magic_StarIndicator, X
	JMP ObjInit_MagicStar

ObjInit_MagicStar3:
	LDA #$02
	STA Magic_StarIndicator, X

ObjInit_MagicStar:

	JSR GetLevelBit
	STA <Temp_Var1
	STY <Temp_Var2
	
	LDA Magic_StarIndicator, X
	TAY

	LDA <Temp_Var2
	ADD MagicStarOffset, Y
	TAY

	LDA <Temp_Var1
	AND Magic_Stars_Collected1, Y
	BEQ Dont_Kill_Star

Kill_Star:
	JSR Object_Delete

Dont_Kill_Star:
	RTS		 ; Return

MagicStar_Radar:
	LDA Player_Equip
	SUB #ITEM_RADARNE
	BMI MagicStar_RadarRTS

	CMP #$09
	BCS MagicStar_RadarRTS
	LDA #$00
	STA <Temp_Var1
	JSR Object_XDistanceFromPlayer

	CMP #$00
	BEQ MagicStar_Radar1

	LDA EWBitMap, Y
	STA <Temp_Var1
	
MagicStar_Radar1:
	JSR Object_YDistanceFromPlayer
	CMP #$00
	BEQ MagicStar_Radar2

	LDA NSBitMap, Y
	ORA <Temp_Var1
	STA <Temp_Var1

MagicStar_Radar2:
	LDY <Temp_Var1
	LDA RadarMap, Y
	STA Player_Equip
	RTS

MagicStar_RadarRTS:
	RTS
EWBitMap:
	.byte $02, $01

NSBitMap:
	.byte $04, $08

RadarMap:
	.byte ITEM_RADAR, ITEM_RADARE, ITEM_RADARW, ITEM_RADAR
	.byte ITEM_RADARN, ITEM_RADARNE, ITEM_RADARNW, ITEM_RADAR
	.byte ITEM_RADARS, ITEM_RADARSE, ITEM_RADARSW
	

Star_Vel:
	.byte -$20, -$17, $00, $17, $20, $17, $00, -$17
Star_VelEnd

Explode_Stars:
	LDY #(Star_VelEnd - Star_Vel - 1)

PRG003_AEF1:
	; Explosion star
	LDA #SOBJ_EXPLOSIONSTAR
	STA SpecialObj_ID,Y

	; Star X +4
	LDA <Objects_XZ,X
	ADD #$04
	STA SpecialObj_X,Y

	; Star Y +16
	LDA <Objects_YZ,X
	ADD #16
	STA SpecialObj_Y,Y
	LDA <Objects_YHiZ,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data1,X

	; Set Y velocity
	LDA Star_Vel,Y
	STA SpecialObj_YVel,Y

	; X is rotated around by offset
	TYA
	ADD #$02
	AND #$07
	TAX

	; Set X velocity
	LDA Star_Vel,X
	STA SpecialObj_XVel,Y

	; SpecialObj_Timer = $3F
	LDA #$3F
	STA SpecialObj_Timer,Y

	LDX <CurrentObjectIndexZ		 ; X = object slot index

	DEY		 ; Y--
	BPL PRG003_AEF1	; While Y >= 0, loop!

	RTS		 ; Return

ObjInit_PiranhaSidewaysR:
	; Right-way piranha +16 X (basically start outside of pipe instead of inside)
	LDA #16
	ADD <Objects_XZ,X
	STA <Objects_XZ,X

ObjInit_PiranhaSidewaysL:

	; Start X + 1 over
	LDA <Objects_XZ,X
	ADD #$01
	STA Objects_Data2,X

	; Start Y + 7 over
	LDA <Objects_YZ,X
	ADD #$07
	STA <Objects_YZ,X

	RTS		 ; Return


ObjNorm_PiranhaSideways:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR SidePiranha_Draw	 ; Draw piranha
	JSR Object_AttackOrDefeat	 ; Player to piranha collision

	LDA <Player_HaltGameZ
	BNE PRG003_AF9C	 ; If gameplay halted, jump to PRG003_AF9C

	; Var3 is the animation timer; toggles frame 0 and 1 every 8 ticks
	INC Objects_Data3,X	; Var3++
	LDA Objects_Data3,X
	LDY #$00	 ; Y = 0
	AND #$08	 
	BEQ PRG003_AF60	 ; 8 ticks on, 8 ticks off; jump to PRG003_AF60
	INY		 ; Y = 1
PRG003_AF60:
	TYA		 
	STA Objects_Frame,X	 ; Update frame

	; Perform the state action of Var4 (0-3)
	LDA Objects_Data1,X
	AND #$03
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word SidePiranha_HideInPipe	; Piranha hides in pipe until timer expires
	.word SidePiranha_Emerge	; Piranha emerges from pipe
	.word SidePiranha_Chomp		; Piranha sits there and chomps for a bit
	.word SidePiranha_Receed	; Piranha goes back into pipe

SidePiranha_Emerge:
	LDA Objects_Data2,X
	SUB #25
	CMP <Objects_XZ,X
	BGE PRG003_AF95	 ; If (Var5 - 25) >= Piranha's X, jump to PRG003_AF95

	LDA #-$10	; Leftward moving piranha
	BNE PRG003_AF8B	 ; Jump (technically always) to PRG003_AF8B

SidePiranha_Receed:
	LDA <Objects_XZ,X
	ADD #$01
	CMP Objects_Data2,X
	BGE PRG003_AF95	 ; If piranha's X >= Var5, jump to PRG003_AF95

	LDA #$10	; Rightward moving piranha

PRG003_AF8B:
	STA <Objects_XVelZ,X	 ; Update X velocity

	JMP Object_ApplyXVel	 ; Apply X velocity and don't come back!

SidePiranha_Chomp:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

PRG003_AF95:
	INC Objects_Data1,X	 ; Var4++ (next internal state)

	; Reset timer to $38
	LDA #$38
	STA Objects_Timer,X

PRG003_AF9C:
	RTS		 ; Return

SidePiranha_HideInPipe:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

	BEQ PRG003_AF95	 ; Otherwise, jump to PRG003_AF95

PRG003_AFA4:
	RTS		 ; Return

SidePiranha_EndSprXOff:
	.byte 16, 0

SidePiranha_Draw:
	LDA #$20	 ; A = $20 (leftward piranha attributes)

	LDY Objects_ID,X
	CPY #OBJ_PIRANHASIDEWAYSLEFT
	BEQ PRG003_AFB2	 ; If this is a leftward piranha, jump to PRG003_AFB2

	LDA #$60	 ; A = $60 (rightward piranha attributes)

PRG003_AFB2:
	STA Objects_Orientation,X	 ; Set piranha attributes

	LDA <Objects_XZ,X
	PHA		 ; Save piranha's X

	LDA Objects_Orientation,X
	AND #SPR_HFLIP
	BEQ PRG003_AFC9	 ; If piranha is not horizontally flipped, jump to PRG003_AFC9

	ASL Objects_SpritesHorizontallyOffScreen,X

	; Piranha's X += 8 (Piranha is 24 pixels wide, of which there's no routine for exactly)
	LDA <Objects_XZ,X
	ADD #$08
	STA <Objects_XZ,X

PRG003_AFC9:
	JSR Object_Draw ; Draw most of piranha

	PLA		 ; Restore 'X'
	STA <Objects_XZ,X	 ; -> 'X'

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0

	LDA Objects_Orientation,X
	AND #SPR_HFLIP
	BEQ PRG003_AFDC	 ; If piranha is NOT horizontally flipped, jump to PRG003_AFDC

	INY		 ; Y = 1

PRG003_AFDC:
	LDA <Objects_SpriteX,X	 ; Get piranha's sprite X
	ADD SidePiranha_EndSprXOff,Y
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X for piranha's remaining bit

	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset

	; Set sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y

	; Temp_Var1 = vertical visibility
	LDA Objects_SpritesVerticallyOffScreen,X
	STA <Temp_Var1

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1
	BCS PRG003_AFFA	 ; If piranha's last bit isn't vertically visible, jump to PRG003_AFFA

	STA Sprite_RAM+$10,Y	 ; Otherwise, set the Y

PRG003_AFFA:
	LDA Sprite_RAM+$02,Y	; Get attribute value from earlier piranha segment
	AND #~$03		; Clear palette select
	ORA #SPR_PAL2		; Set palette select 2
	STA Sprite_RAM+$12,Y	; -> Sprite's attribute

	; Use pattern $85
	LDA #$85
	STA Sprite_RAM+$11,Y

	RTS		 ; Return

ObjInit_WaterCurrent:
	RTS		 ; Return

CurrentUpward_YAccel:	.byte -$03, -$03, -$02, -$01, $00, $00, $00, $00, $00
CurrentDownward_YAccel:	.byte  $03,  $02,  $01,  $00, $00, $00, $00, $00, $00

ObjNorm_WaterCurrent:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	ORA <Player_HaltGameZ
	BNE PRG003_B197	 ; If object falls off-screen or gameplay is halted, jump to PRG003_B197

	JSR Object_XDistanceFromPlayer

	LDA <Temp_Var16
	ADD #$08
	CMP #$20
	BGE PRG003_B18C	 ; If Player is not close enough, jump to PRG003_B18C

	JSR Object_YDistanceFromPlayer

	LDA Objects_ID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B157	 ; If this is a downward current, jump to PRG003_B157

	; For upward current...

	; Negate Temp_Var16
	LDA <Temp_Var16	
	JSR Negate	
	STA <Temp_Var16	
	DEY		 ; Y-- (change direction)

PRG003_B157:
	CPY #$00
	BNE PRG003_B18C	 ; If Player is on wrong side of current object, jump to PRG003_B18C

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = index relative of Player's Y offset

	LDA Objects_ID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BNE PRG003_B177	 ; If this is not a downard current, jump to PRG003_B177

	; Downward current...

	LDA <Player_YVel
	CMP #$3b
	BGS PRG003_B18C	 ; If Player's Y velocity >= $3B, jump to PRG003_B18C

	ADD CurrentDownward_YAccel,Y	 ; Push Player downward

	JMP PRG003_B186	 ; Jump to PRG003_B186

PRG003_B177:
	LDA Player_HitCeiling
	BNE PRG003_B18C	 ; If Player just hit off ceiling, jump to PRG003_B18C

	LDA <Player_YVel
	CMP #-$3C
	BMI PRG003_B18C	 ; If Player's Y velocity is already moving faster than -$3C, jump to PRG003_B18C

	ADD CurrentUpward_YAccel,Y	 ; Push Player upward

PRG003_B186:
	STA <Player_YVel	; Update Player's Y velocity

	; Flag Player as mid-air
	LDA #$01
	STA <Player_InAir

PRG003_B18C:
	INC Objects_Data2,X	 ; Var5++

	LDA Objects_Data2,X
	AND #$0f
	BNE PRG003_B197	 ; 1:16 ticks proceed, otherwise jump to PRG003_B197

	JSR Current_GenerateBubble	; Generate a bubble

PRG003_B197:
	RTS		 ; Return

Current_GenerateBubble:
	LDY #$01
	JSR SpecialObject_FindEmptyAbortY	; Find a free special object in one of the first two slots or don't come back!

	; SpecialObj_Timer = $28
	LDA #$28
	STA SpecialObj_Timer,Y

	; A bubble
	LDA #SOBJ_BUBBLE
	STA SpecialObj_ID,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data1,Y

	STY <Temp_Var1	 ; Special object index -> Temp_Var1

	; Apply a bit of randomness to the bubble's X
	TYA
	ADC RandomN,Y
	AND #$17
	ADD <Objects_XZ,X
	LDY <Temp_Var1		 ; Y = special object index
	STA SpecialObj_X,Y	 ; Store slightly random adjusted X -> Bubble X

	LDA Objects_ID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B1D7	 ; If this is a downard current, jump to PRG003_B1D7

	; Bubble appears at Y - 8
	LDA <Objects_YZ,X
	SBC #$08
	STA SpecialObj_Y,Y
	LDA <Objects_YHiZ,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = -$80
	LDA #-$80
	STA SpecialObj_YVel,Y

	RTS		 ; Return

PRG003_B1D7:
	; Bubble appears at Y + 3
	LDA <Objects_YZ,X
	ADC #$03
	STA SpecialObj_Y,Y
	LDA <Objects_YHiZ,X	; Bug? They don't apply the carry (ADC) here!
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = $7F
	LDA #$7f
	STA SpecialObj_YVel,Y
	RTS		 ; Return


FloatMine_Triggered = Objects_Data1
FloatMine_BobMode = Objects_Data2
FloatMine_BobDirection = Objects_Data3

ObjInit_FloatMine:
	LDA <Objects_XZ, X
	SUB #$04
	STA <Objects_XZ, X

	LDA #$01
	STA Objects_NoIce, X

	LDA Objects_Property, X
	STA FloatMine_Triggered, X

ObjInit_FloatMine0:
	RTS

ObjNorm_FloatMine:
	LDA <Player_HaltGameZ
	BEQ FloatMine_Norm

	JMP FloatMine_Draw

FloatMine_Norm:
	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE FloatMine_NotDead
	JSR FloatMine_Expload

FloatMine_NotDead:
	JSR Object_DeleteOffScreen

	JSR FloatMine_CalcBoundBox
	
	LDA FloatMine_Triggered, X
	BEQ FloatMine_NoMoveYet

	LDA Objects_InWater, X
	BEQ FloatMine_Bob

	INC Reverse_Gravity
	JMP FloatMine_Move

FloatMine_Bob:
	LDA <Objects_YVelZ, X
	BPL FloatMine_Move

	LDA #$00
	STA <Objects_YVelZ, X

FloatMine_Move:
	JSR Object_Move

FloatMine_NoMoveYet:
	JSR Object_InteractWithPlayer
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

	LDA <Objects_TilesDetectZ, X
	BEQ FloatMine_NoExplodeYet

	JSR FloatMine_Expload

FloatMine_NoExplodeYet:
	LDA FloatMine_Triggered, X
	BNE FloatMine_Draw

	JSR Object_XDistanceFromPlayer
	LDA <XDiff
	CMP #$30
	BCS FloatMine_Draw

	JSR Object_YDistanceFromPlayer
	LDA <YDiff
	CMP #$30
	BCS FloatMine_Draw

	INC FloatMine_Triggered, X

FloatMine_Draw:
	LDA Objects_SpriteAttributes, X
	ORA #SPR_BEHINDBG
	STA Objects_SpriteAttributes, X
	JSR Object_Draw16x32

	LDY Object_SpriteRAMOffset,X
	
	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #SPRITE_2_INVISIBLE
	BNE FloatMine_DrawDone

	LDA Objects_SpritesVerticallyOffScreen,X
	AND #SPRITE_0_VINVISIBLE
	BNE FloatMineDraw1

	LDA Objects_SpriteX, X
	ADD #$10
	STA Sprite_RAMX + 16,Y

	LDA Objects_SpriteY, X
	STA Sprite_RAMY + 16,Y

	LDA Sprite_RAMAttr,Y
	STA Sprite_RAMAttr + 16,Y

	LDA #$85
	STA Sprite_RAMTile + 16, Y


FloatMineDraw1:
	LDA Objects_SpritesVerticallyOffScreen,X
	AND #SPRITE_1_INVISIBLE
	BNE FloatMine_DrawDone

	LDA Objects_SpriteX, X
	ADD #$10
	STA Sprite_RAMX + 20,Y

	LDA Objects_SpriteY, X
	ADD #$10
	STA Sprite_RAMY + 20,Y

	LDA Sprite_RAMAttr,Y
	STA Sprite_RAMAttr + 20,Y

	LDA #$A5
	STA Sprite_RAMTile + 20, Y

FloatMine_DrawDone:
	RTS

FloatMine_CalcBoundBox:
	LDA <Objects_XZ,X
	ADD #$04	
	STA Objects_BoundLeft, X

	LDA <Objects_XHiZ, X
	ADC #$00
	STA Objects_BoundLeftHi, X

	LDA <Objects_XZ, X
	ADD #$14
	STA Objects_BoundRight, X
	
	LDA <Objects_XHiZ, X
	ADC #$00
	STA Objects_BoundRightHi, X

	LDA <Objects_YZ,X
	ADD #$04
	STA Objects_BoundTop, X

	LDA <Objects_YHiZ, X
	ADC #$00
	STA Objects_BoundTopHi, X

	LDA <Objects_YZ,X
	ADD #$14
	STA Objects_BoundBottom, X

	LDA <Objects_YHiZ, X
	ADC #$00
	STA Objects_BoundBottomHi, X
	RTS

FloatMine_Expload:
	INC Explosion_Timer, X
	RTS

ObjInit_Ninji:
	LDA #$20
	STA Objects_Timer, X
	RTS

Ninji_Frame = Objects_Data1
Ninji_Action = Objects_Data2
Ninji_HoldStar = Objects_Data3

ObjNorm_Ninji:
	LDA <Player_HaltGameZ
	BEQ Ninji_Norm

	JMP Ninji_Draw

Ninji_Norm:
	JSR Object_DeleteOffScreen 
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_AttackOrDefeat
	
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ Ninji_Grounded

	JSR Object_FacePlayer

Ninji_Grounded:
	JSR Ninji_DoAction

Ninji_Animate:
	LDA Ninji_Action, X
	BNE Ninji_Draw

	INC Ninji_Frame, X
	LDA Ninji_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

Ninji_Draw:
	JSR Object_Draw

	LDA Ninji_HoldStar, X
	BEQ Ninji_DrawStar2

	LDA Objects_SpritesVerticallyOffScreen,X
	AND #SPRITE_0_VINVISIBLE
	BNE Ninji_DrawStar2

	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #SPRITE_0_HINVISIBLE
	BNE Ninji_DrawStar1

	LDA Objects_SpriteX, X
	STA Sprite_RAMX + 8, Y

	LDA Objects_SpriteY, X
	SUB #$0C
	STA Sprite_RAMY  + 8, Y

	LDA #$B9
	STA Sprite_RAMTile + 8, Y

	LDA #SPR_PAL3
	STA Sprite_RAMAttr + 8, Y

Ninji_DrawStar1:
	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #SPRITE_1_INVISIBLE
	BNE Ninji_DrawStar2
	
	LDA Objects_SpriteX, X
	ADD #$08
	STA Sprite_RAMX + 12, Y

	LDA Objects_SpriteY, X
	SUB #$0C
	STA Sprite_RAMY  + 12, Y

	LDA #$B9
	STA Sprite_RAMTile + 12, Y

	LDA #(SPR_PAL3 | SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAMAttr + 12, Y

Ninji_DrawStar2:
	RTS

Ninji_DoAction:
	LDA Ninji_Action, X
	JSR DynJump

	.word Ninji_Idle
	.word Ninji_Jump
	.word Ninji_Hover
	.word Ninji_ThrowStar
	.word Ninji_Fall

Ninji_Jumps: .byte $B0, $BC, $C8, $D4

Ninji_Idle:
	LDA Objects_Timer, X
	BNE Ninji_IdleDone

	INC Ninji_Action, X
	
	LDA RandomN, X
	AND #$03
	TAY

	LDA Ninji_Jumps, Y
	STA <Objects_YVelZ, X

	LDA #$01
	STA Objects_Frame, X
	STA Ninji_HoldStar, X

Ninji_IdleDone:
	RTS

Ninji_Jump:
	LDA <Objects_YVelZ, X
	BMI Ninji_JumpDone

	INC Ninji_Action, X

	LDA #$08
	STA Objects_Timer, X

Ninji_JumpDone:
	RTS

Ninji_Hover:
	LDA #$00
	STA <Objects_YVelZ, X

	LDA Objects_Timer, X
	BNE Ninji_HoverDone

	INC Ninji_Action, X

Ninji_HoverDone:
	RTS

Ninji_ThrowStar:
	LDA #$00
	STA Objects_Frame, X
	STA <Objects_YVelZ, X
	STA Ninji_HoldStar, X

	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE Ninji_ThrowDone

	JSR Object_PrepProjectile	

	LDA #SOBJ_NINJASTAR
	STA SpecialObj_ID,Y

	LDA <Objects_XZ, X
	STA SpecialObj_X, Y

	LDA <Objects_XHiZ, X
	STA SpecialObj_XHi, Y

	LDA <Objects_YZ, X
	SUB #$0C
	STA SpecialObj_Y, Y

	LDA <Objects_YHiZ, X
	SBC #$00
	STA SpecialObj_YHi, Y

	JSR Object_AimProjectile

	LDA SpecialObj_XVel, Y
	JSR Double_Value
	STA SpecialObj_XVel, Y

	LDA SpecialObj_YVel, Y
	JSR Double_Value
	STA SpecialObj_YVel, Y

Ninji_ThrowDone:
	INC Ninji_Action, X
	LDA #$00
	STA Objects_Frame, X
	RTS		 ; Return

Ninji_Fall:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ Ninji_FallDone

	LDA #$60
	STA Objects_Timer, X
	
	LDA #$00
	STA Ninji_Action, X
	STA Objects_Frame, X

Ninji_FallDone:
	RTS

NinjiIdleTimes:
	.byte $30, $40, $38, $48

CheepCheepHopper_InitXVel:	.byte $0C, -$0C

ObjInit_CheepCheepHopper:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer
	RTS		 ; Return


ObjNorm_CheepCheepHopper:
	JSR Object_DeleteOffScreen	; Delete object if it falls too far off-screen
	JSR Object_SetHFlipByXVel 	; Set horizontal flip by travel direction
	JSR Object_Draw 	; Draw Cheep Chep

	LDA <Player_HaltGameZ
	BNE PRG003_B47A	 ; If gameplay is halted, jump to PRG003_B47A

	JSR Object_Move	 	; Do standard movements
	JSR Object_AttackOrDefeat	 ; Player to Cheep Cheep collision

	LDA Objects_InWater,X
	BEQ PRG003_B471	 	; If Cheep Cheep is NOT in water, jump to PRG003_B471

	JSR Object_XDistanceFromPlayer	

	LDY #-$30	 ; Y = -$30

	LDA <Temp_Var16
	ADD #$40
	CMP #$80
	BGE PRG003_B46F	 ; If Cheep Cheep is not close enough to Player, jump to PRG003_B46F

	LDY #-$60	 ; Otherwise, Y = -$60
PRG003_B46F:
	STY <Objects_YVelZ,X	 ; Update Y velocity

PRG003_B471:

	; Toggle frame 0/1
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

PRG003_B47A:
	RTS		 ; Return

Tornado_InitXVel:	.byte $08, -$08

ObjInit_Tornado:
	JSR Object_XDistanceFromPlayer

	; Set initial X velocity towards Player
	LDA Tornado_InitXVel,Y
	STA <Objects_XVelZ,X

	; Var4 = $A5
	LDA #$a5
	STA Objects_Data1,X

	RTS		 ; Return

Tornado_ParticleOffsets:
	.byte $18, $18, $17, $17, $16, $15, $14, $13, $11, $0F, $0D, $0B, $09, $07, $05, $02
	.byte $12, $12, $11, $11, $10, $0F, $0F, $0E, $0C, $0B, $09, $08, $06, $05, $03, $01
	.byte $0E, $0E, $0D, $0D, $0C, $0C, $0B, $0B, $09, $08, $07, $06, $05, $04, $02, $01
	.byte $0A, $0A, $09, $09, $09, $08, $08, $07, $07, $06, $05, $04, $03, $02, $02, $00
	.byte $07, $07, $06, $06, $06, $06, $05, $05, $04, $04, $03, $03, $02, $02, $01, $00
	.byte $03, $03, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01, $00, $00, $00
	.byte $02, $02, $01, $01, $01, $01, $01, $01, $01, $01, $01, $00, $00, $00, $00, $00
	.byte $01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

Tornado_ScatterY:
	.byte $00, $0C, $18, $24, $30, $3C, $48, $54

	; Causes wider to narrow spreading based on position of tornado particle
Tornado_SpreadFreq:
	.byte $38, $30, $28, $20, $18, $10, $08, $00

Tornado_ParticleDivCnt:
	.byte $01, $02

PRG003_B51C:
	.byte $01, $02, $01, $FF, $20, $E0

Tornado_MaskOffset:
	.byte $09, $09, $09, $08, $07, $06, $07, $08

ObjNorm_Tornado:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGameZ
	BNE PRG003_B534	 ; If gameplay is halted, jump to PRG003_B534

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG003_B534:
	LDY Objects_Data1,X	 ; Y = Var4
	BNE PRG003_B53B	 ; If Var4 <> 0, jump to PRG003_B53B

	JMP Object_Delete	 ; Delete object and don't come back!

PRG003_B53B:
	LDA <Counter_1
	AND #$01
	BNE PRG003_B543	 ; Every other tick, jump to PRG003_B543

	DEC Objects_Data1,X	 ; Var4--

PRG003_B543:
	CPY #$40
	BGE PRG003_B551	 ; If Var4 >= $40, jump to PRG003_B551

	; They possibly intended this to divide Counter_1, but because of
	; the previous AND instruction, this will shift it to nothing...
	LSR A
	LSR A
	LSR A
	LSR A

	ADD #$03
	JMP PRG003_B55D	 ; Jump to PRG003_B55D

PRG003_B551:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, by counter / 16

	LDA Tornado_MaskOffset,Y

PRG003_B55D:
	STA Objects_Data2,X	 ; -> Var5

	STA <Temp_Var15		 ; -> Temp_Var15

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA Tornado_ParticleDivCnt,Y
	STA <Temp_Var13		 ; -> Temp_Var13

	JSR Object_CalcSpriteXY_NoHi	 ; Calculate sprites

	; Draw 7 scatter particles to represent the tornado
	LDX #$07	 ; X = 7
PRG003_B578:
	STX <Temp_Var16	 ; -> Temp_Var16

	JSR Tornado_ScatterParticle	 ; Scatters tornado particle
	JSR Tornado_DrawParticle	 ; Draw the tornado particle

	DEX		 ; X--
	BPL PRG003_B578	 ; While X >= 0, loop
 
	LDX <CurrentObjectIndexZ		 ; X = object slot index

	LDA Player_IsDying
	ORA Player_OffScreen
	BNE PRG003_B5C2	 ; If Player is dead or off-screen, jump to PRG003_B5C2 (RTS)

	LDA Objects_Data3,X
	BEQ PRG003_B5C3	 ; If Var3 = 0, jump to PRG003_B5C3

	LDA <Counter_1
	AND #$1f
	ORA #$20
	STA Player_TwisterSpin	 ; Set Player as twirling from Tornado

	LDY #$00	 ; Y = 0

	LDA <Player_Y
	CMP #48
	BLT PRG003_B5A4	 ; If Player Y < 48, jump to PRG003_B5A4

	INY		 ; Y = 1

PRG003_B5A4:

	; Var6 keeps a copy of how it has accelerate the Player
	LDA Objects_Data6,X
	CMP Tornado_PlayerYLimit,Y
	BEQ PRG003_B5B3	 ; If Var6 = Player Y limit, jump to PRG003_B5B3

	ADD Tornado_PlayerYAccel,Y	 ; Accelerate!
	STA Objects_Data6,X	 ; Update Var6

PRG003_B5B3:
	STA <Player_YVel	 ; Set same to Player's Y velocity

	; Halt Player's horizontal movement
	LDA #$00
	STA <Player_XVel

	JSR Object_XDistanceFromPlayer	

	; Set a little plug-along value to the Player
	LDA Tornado_PlayerXVelAdj,Y
	STA Player_CarryXVel

PRG003_B5C2:
	RTS		 ; Return


PRG003_B5C3:
	JSR Object_XDistanceFromPlayer	

	; Palette select 0/1 depending on which side the particle is on
	TYA
	STA Objects_Orientation,X

	BEQ PRG003_B5D3	 ; If on the zero side, jump to PRG003_B5D3

	; Otherwise, negate Temp_Var16
	LDA <Temp_Var16
	JSR Negate
	STA <Temp_Var16

PRG003_B5D3:

	LDA <Temp_Var16
	CMP #$10
	BGE PRG003_B5EF	 ; If Temp_Var16 >= $10, jump to PRG003_B5EF

	LDA <Player_Y
	CMP #112
	BLT PRG003_B5EF	 ; If Player Y < 112, jump to PRG003_B5EF

	INC Objects_Data3,X	 ; Var3++

	; Push Player upward
	DEC <Player_Y
	DEC <Player_Y

	STA <Player_InAir ; Flag Player as mid-air

	; Upward Player!
	LDA #-$20
	STA <Player_YVel

	; Var6 = last set Player Y velocity
	STA Objects_Data6,X

PRG003_B5EF:
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = 0-7, based on upper 3 bits of Temp_Var16
	STY <Temp_Var1	 ; -> Temp_Var1

	LDA Tornado_PlayerXVelAdj2,Y

	LDY Objects_Orientation,X
	BNE PRG003_B604	 ; If on the 1 side, jump to PRG003_B604

	JSR Negate	 ; Otherwise, negate value from Tornado_PlayerXVelAdj2

PRG003_B604:
	STA Player_CarryXVel	 ; -> Player_XVelAdj

	LDA <Temp_Var16	
	CMP #$10
	BGE PRG003_B61C	 ; If Temp_Var16 >= $10, jump to PRG003_B61C

	LDA <Player_Y
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY		 ; Y = upper 4 bits of Player's position (i.e. the tile grid row)

	; Accelerate Player based on his vertical position
	LDA <Player_YVel
	ADD Tornado_PlayerYVelAccelByRow,Y
	STA <Player_YVel

PRG003_B61C:
	RTS		 ; Return

Tornado_PlayerYLimit:	.byte $40, -$40
Tornado_PlayerYAccel:	.byte $04, -$04
Tornado_PlayerXVelAdj:	.byte -$08, $08

Tornado_PlayerXVelAdj2:
	.byte $18, $10, $0A, $06, $00, $00, $00, $00

Tornado_PlayerYVelAccelByRow:
	.byte $10, $04, -$08, -$08, -$08, -$08, -$08, -$08, -$02, -$02, -$02, -$02, $10, $10, $10, $10

Tornado_ScatterParticle:
	TXA		  
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var14	 ; Temp_Var14 = 'X' << 4

	; Temp_Var15 += Tornado_SpreadFreq[X]
	LDA <Temp_Var15
	ADD Tornado_SpreadFreq,X
	STA <Temp_Var15

	LDA <Temp_Var15
	AND #%00001111
	TAY		 ; Y = lower 4 bits of Temp_Var15

	LDA <Temp_Var15
	AND #%00010000
	BEQ PRG003_B659	 ; If Temp_Var15 bit 4 is NOT set, jump to PRG003_B659

	; Sort of negates 'Y'
	TYA
	EOR #$ff
	TAY

PRG003_B659:
	LDA #$00

	CPY #$10
	BEQ PRG003_B668	 ; If 'Y' = $10, jump to PRG003_B668

	TYA

	AND #%00001111
	ORA <Temp_Var14	 ; OR in Temp_Var14

	TAY

	LDA Tornado_ParticleOffsets,Y	 ; A = Tornado_ParticleOffsets[Y]

PRG003_B668:
	STA <Temp_Var10		 ; -> Temp_Var10 (particle offset X)

	LDA <Temp_Var15
	AND #%00001111
	TAY		 ; Y = lower 4 bits of Temp_Var15 

	LDA <Temp_Var15
	AND #%00010000
	BNE PRG003_B679	 ; If Temp_Var15 bit 4 is set, jump to PRG003_B679

	; Sort of negates 'Y'
	TYA
	EOR #$ff
	TAY

PRG003_B679:
	LDA #$00

	CPY #$10
	BEQ PRG003_B693	 ; If 'Y' = $10, jump to PRG003_B693

	TYA

	AND #%00001111
	ORA <Temp_Var14	 ; OR in Temp_Var14

	TAY

	LDA Tornado_ParticleOffsets,Y

	LSR A
	LSR A

	LDY <Temp_Var13	 ; Y = Temp_Var13

	DEY		 ; Y--

	BEQ PRG003_B693	 ; If Y = 0, jump to PRG003_B693

	LSR A

	DEY		 ; Y--
	BEQ PRG003_B693	 ; If Y = 0, jump to PRG003_B693 (... next line)

PRG003_B693:
	STA <Temp_Var9	; -> Temp_Var9 (particle offset Y)

	LDA <Temp_Var15
	AND #%00110000
	BEQ PRG003_B6B1	 ; If neither bit 4 or 5 is set, jump to PRG003_B6B1

	CMP #%00010000
	BEQ PRG003_B6A6	 ; If bit 4 is not set, jump to PRG003_B6A6

	CMP #%00110000
	BEQ PRG003_B6B2	 ; If bit 4 and 5 are not set, jump to PRG003_B6B2

	JSR PRG003_B6B2	 ; Negate Temp_Var10

PRG003_B6A6:
	LDY #$01	 ; Y = 1

PRG003_B6A8:
	; Negate Temp_Var9/10
	LDA Temp_Var9,Y
	JSR Negate
	STA Temp_Var9,Y

PRG003_B6B1:
	RTS		 ; Return

PRG003_B6B2:
	LDY #$00	 ; Y = 0
	BEQ PRG003_B6A8	 ; Jump (technically always) to PRG003_B6A8

PRG003_B6B6:
	.byte $00, $02, $04, $06, $08, $06, $04, $02, $00, $02, $04, $06, $08, $06, $04, $50

Tornado_Masks:
	.byte $0F, $03, $01, $00, $00, $00, $00, $00

Tornado_DrawParticle:
	LDY <CurrentObjectIndexZ 	; Y = object's slot index

	LDA Objects_Data2,Y
	BEQ PRG003_B6B1	 ; If Var5 = 0, jump to PRG003_B6B1 (RTS)

	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	TXA	; object slot index -> 'A'
	AND Tornado_Masks,Y
	STA <Temp_Var1	 ; -> Temp_Var1

	LDA <Counter_1
	AND Tornado_Masks,Y
	CMP <Temp_Var1
	BNE PRG003_B6B1	 ; If masked counter value = Temp_Var1, jump to PRG003_B6B1 (RTS)

	CPX #$06
	BLT PRG003_B6F3	 ; If object slot < 6, jump to PRG003_B6F3

	JSR Object_GetUnusedSprite

	LDX <CurrentObjectIndexZ		 ; X = object slot index
	BGS PRG003_B6FD	 ; Jump (technically always) to PRG003_B6FD

PRG003_B6F3:
	TXA

	ASL A
	ASL A	; A *= 4 (next sprite over)

	LDX <CurrentObjectIndexZ	 ; X = object slot index
	ADD Object_SpriteRAMOffset,X	 ; Base Sprite_RAM offset

	TAY		 ; Sprite_RAM offset -> 'Y'

PRG003_B6FD:
	STY <Temp_Var14	 ; -> Temp_Var14

	LDA <Counter_1
	AND #$0f		; 0-15 counter value
	ADD Objects_SpriteY,X	; Add 0-15 to SpriteY

	; Temp_Var1 (Sprite Y) = Temp_Var16 + Tornado_ScatterY[X] + Temp_Var9
	LDX <Temp_Var16	
	ADD Tornado_ScatterY,X
	ADD <Temp_Var9
	STA <Temp_Var1

	BCS PRG003_B753	 	; If carry set, jump to PRG003_B753 (went too low, so skip it)

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$07	 ; A = 0-7
	ADD <Temp_Var16	 ; 'A' += Temp_Var16
	TAX		 ; -> 'X'

	; Temp_Var2 (Sprite X) = Tornado's Sprite X + Temp_Var10
	LDA PRG003_B6B6,X ; A = PRG003_B6B6[X]
	CLC		 ; Clear carry
	LDX <CurrentObjectIndexZ		 ; X = object slot index
	ADC Objects_SpriteX,X
	ADD <Temp_Var10
	STA <Temp_Var2

	JSR Sprite_NoCarryIfVisible	
	BCS PRG003_B753	 ; If this particle is not visible, jump to PRG003_B753

	LDY <Temp_Var14		 ; Y = Temp_Var14

	; Set particle sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Set particle sprite X
	LDA <Temp_Var2	
	STA Sprite_RAM+$03,Y

	; Pattern $17
	LDA #$17
	STA Sprite_RAM+$01,Y

	LDX #$03	 ; X = 3

	LDA <Temp_Var15
	AND #$3F
	CMP #$20
	BLT PRG003_B74F	 ; If lower 5 bits of Temp_Var15 < $20, jump to PRG003_B74F

	LDX #$01	 ; Otherwise, X = 1

PRG003_B74F:

	; Set particle sprite attributes
	TXA
	STA Sprite_RAM+$02,Y

PRG003_B753:
	LDX <Temp_Var16	 ; X = Temp_Var16

Blooper_YDetectOverride:
	.byte $04, $08

Blooper_XDetectOverride:
	.byte $01, $02

Blooper_XVelPropel:
	.byte $E4, $1C

ObjInit_Blooper:
	RTS		 ; Return


ObjNorm_Blooper:
	LDA <Player_HaltGameZ
	BEQ Blooper_Norm

	JMP Object_DrawMirrored

Blooper_Norm:
	JSR Object_DeleteOffScreen

	LDA <Objects_YVelZ, X
	BMI Blooper_NoStop

	LDA #$00
	STA <Objects_XVelZ, X

Blooper_NoStop:
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles

	LDA Object_VertTileProp, X
	CMP #TILE_PROP_WATER
	BCS Blooper_InWater

	LDA <Objects_YVelZ, X
	AND #$80
	ROL A
	ROL A
	AND #$01
	TAY

	LDA <Objects_TilesDetectZ, X
	ORA Blooper_YDetectOverride, Y
	STA <Objects_TilesDetectZ, X

Blooper_InWater:
	LDA Object_HorzTileProp, X
	CMP #TILE_PROP_WATER
	BCS Blooper_InWater2

	LDA <Objects_XVelZ, X
	AND #$80
	ROL A
	ROL A
	AND #$01
	TAY

	LDA <Objects_TilesDetectZ, X
	ORA Blooper_XDetectOverride, Y
	STA <Objects_TilesDetectZ, X

Blooper_InWater2:
	INC Object_CeilingStops

	JSR Object_InteractWithTiles
	JSR Object_AttackOrDefeat

	JSR Object_YDistanceFromPlayer
	LDA <YDiffAboveBelow
	BNE Blooper_SlowFall

	LDA Objects_Timer, X
	BNE Blooper_SlowFall

	LDA #$DC
	STA <Objects_YVelZ, X

	JSR Object_XDistanceFromPlayer
	LDY <XDiffLeftRight
	LDA Blooper_XVelPropel, Y
	STA <Objects_XVelZ, X
	
	LDA #$40
	STA Objects_Timer, X
	BNE Blooper_Animate

Blooper_SlowFall:
	LDA <Objects_YVelZ, X
	BMI Blooper_Animate

	CMP #$24
	BCC Blooper_Animate

	LDA #$24
	STA <Objects_YVelZ, X

Blooper_Animate:
	AND #$80
	ROL A
	ROL A
	AND #$01
	EOR #$01
	STA Objects_Frame, X

Blooper_Draw:
	JMP Object_DrawMirrored


PhantomBlooper_YDetectOverride:
	.byte $04, $08

PhantomBlooper_XDetectOverride:
	.byte $01, $02

PhantomBlooper_XVelPropel:
	.byte $EC, $14

ObjInit_PhantomBlooper:
	RTS		 ; Return

ObjNorm_PhantomBlooper:
	LDA <Player_HaltGameZ
	BEQ PhantomBlooper_Norm

	JMP Object_DrawMirrored

PhantomBlooper_Norm:
	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles

	LDA #$01
	STA Objects_InWater, X

	LDA #$00
	STA <Objects_TilesDetectZ, X

	LDA Object_VertTileProp, X
	CMP #TILE_PROP_WATER
	BCS PhantomBlooper_InWater

	LDA <Objects_YVelZ, X
	AND #$80
	ROL A
	ROL A
	AND #$01
	TAY

	LDA <Objects_TilesDetectZ, X
	ORA PhantomBlooper_YDetectOverride, Y
	STA <Objects_TilesDetectZ, X

PhantomBlooper_InWater:
	LDA Object_HorzTileProp, X
	CMP #TILE_PROP_WATER
	BCS PhantomBlooper_InWater2

	LDA <Objects_XVelZ, X
	AND #$80
	ROL A
	ROL A
	AND #$01
	TAY

	LDA <Objects_TilesDetectZ, X
	ORA PhantomBlooper_XDetectOverride, Y
	STA <Objects_TilesDetectZ, X

PhantomBlooper_InWater2:
	
	INC Object_CeilingStops
	INC Object_WallStops
	JSR Object_InteractWithTiles
	JSR Object_AttackOrDefeat

	JSR Object_YDistanceFromPlayer
	LDA <YDiffAboveBelow
	BNE PhantomBlooper_SlowFall

	LDA Objects_Timer, X
	BNE PhantomBlooper_SlowFall

	LDA #$DC
	STA <Objects_YVelZ, X

	JSR Object_XDistanceFromPlayer
	LDY <XDiffLeftRight
	LDA PhantomBlooper_XVelPropel, Y
	STA <Objects_XVelZ, X
	
	LDA #$40
	STA Objects_Timer, X
	BNE PhantomBlooper_Animate

PhantomBlooper_SlowFall:
	LDA <Objects_YVelZ, X
	BMI PhantomBlooper_Animate

	CMP #$24
	BCC PhantomBlooper_Animate

	LDA #$24
	STA <Objects_YVelZ, X

PhantomBlooper_Animate:
	AND #$80
	ROL A
	ROL A
	AND #$01
	EOR #$01
	STA Objects_Frame, X

PhantomBlooper_Draw:
	LDA Objects_SpriteAttributes, X
	ORA #SPR_BEHINDBG
	STA Objects_SpriteAttributes, X
	JMP Object_DrawMirrored
;
;	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
;
;	LDA <Player_HaltGameZ
;	BEQ PRG003_B77B	 ; If gameplay is not halted, jump to PRG003_B77B
;
;	LDA Objects_SpriteAttributes, X
;	ORA #SPR_BEHINDBG
;	STA Objects_SpriteAttributes, X
;
;	JMP	 ; Otherwise, draw Blooper and don't come back!
;
;PRG003_B77B:
;	JSR Object_AttackOrDefeat	 ; Do Player to Blooper hit detection!
;
;	LDA Objects_Data2,X
;	AND #$01
;	TAY		 ; Y = 0 or 1
;
;	LDA <Objects_YVelZ,X
;	ADD Blooper_YVelAccel,Y
;	STA <Objects_YVelZ,X
;
;	CMP Blooper_YVelLimit,Y
;	BNE PRG003_B7B6	 ; If Blooper is not at his velocity limit, jump to PRG003_B7B6
;
;	INC Objects_Data2,X	 ; Otherwise, Var5++
;
;PRG003_B7B6:
;	LDA <Objects_YVelZ,X
;
;	LDY Objects_Orientation,X
;	BEQ PRG003_B7C0	 ; If Blooper is not flipped, jump to PRG003_B7C0
;
;	JSR Negate	 ; Otherwise, negate Y velocity
;
;PRG003_B7C0:
;	LDY <Objects_YVelZ,X
;	BMI PRG003_B7DD	 ; If Bloope is moving upward, jump to PRG003_B7DD
;
;	TXA
;	LSR A
;	BCC PRG003_B7D2	 ; If Blooper is an "even" slot, jump to PRG003_B7D2
;
;	LDY #$00	 ; Y = 0
;
;	LDA <Player_FlipBits
;	BNE PRG003_B7CF	 ; If Blooper is flipped, jump to PRG003_B7CF
;
;	INY		 ; Y = 1
;
;PRG003_B7CF:
;	JMP PRG003_B7D5	 ; Jump to PRG003_B7D5
;
;PRG003_B7D2:
;	JSR Object_XDistanceFromPlayer
;
;PRG003_B7D5
;	; Blooper faces Player
;	LDA Blooper_FlipTowardsPlayer,Y
;	STA Objects_Orientation,X
;
;	LDA #$00	 ; A = 0
;
;PRG003_B7DD:
;	STA <Objects_XVelZ,X	 ; Update X Velocity
;
;	JSR Object_DetectTiles	 ; Detect against world
;	LDA Objects_ID, X
;	CMP #OBJ_SKULLBLOOPER
;	BNE PRG003_B7DE
;
;	LDA #$00
;	STA <Objects_TilesDetectZ, X
;
;	LDA Objects_LastProp, X
;	CMP #TILE_PROP_SOLID_ALL		= $C0 ;
;
;	BEQ PRG003_B7DE
;
;	LDA #$01
;	STA Objects_InWater, X
;
;PRG003_B7DE:
;	LDA <Objects_TilesDetectZ,X
;	AND #$03
;	BNE PRG003_B7EB	 ; If Blooper hit a wall, jump to PRG003_B7EB
;
;	JSR Object_ApplyXVel	 ; Otherwise, apply X Velocity
;
;PRG003_B7EB:
;	LDA <Objects_YVelZ,X
;	PHA		 ; Save Y velocity
;
;	CMP #$08
;	BLS PRG003_B814	 ; If Y velocity < $08, jump to PRG003_B814
;
;	LDA <Player_Y	
;	PHA		 ; Save Player's Y
;
;	SBC #23
;	STA <Player_Y	 ; Subtract 23 from Player's Y
;
;	LDA <Player_YHi
;	PHA		 ; Save Player Y Hi
;	SBC #$00	 ; Apply carry
;	STA <Player_YHi	
;
;	JSR Object_YDistanceFromPlayer
;
;	; Restore Player Y/Hi
;	PLA
;	STA <Player_YHi
;	PLA
;	STA <Player_Y
;
;	DEY		 ; Y--
;	BEQ PRG003_B810	 ; If Y = 0, jump to PRG003_B810
;
;	PLA		 ; Restore Y velocity
;
;	LDA #$08
;	PHA		 ; Save 8 instead
;
;PRG003_B810:
;	; Set velocity to $08
;	LDA #$08
;	STA <Objects_YVelZ,X
;
;PRG003_B814:
;	LDA <Objects_TilesDetectZ,X
;	AND #$0c
;	BNE PRG003_B826	 ; If Blooper hit floor or ceiling, jump to PRG003_B826
;
;	LDA <Objects_YVelZ,X
;	BPL PRG003_B823	 ; If Blooper is not moving upward, jump to PRG003_B823
;
;	LDA Objects_InWater,X
;	BEQ PRG003_B826	 ; If Blooper is not in water, jump to PRG003_B826
;
;PRG003_B823:
;	JSR Object_ApplyYVel_NoGravity	 ; Apply Y Velocity
;
;PRG003_B826:
;	PLA		 ; Restore Y Velocity
;	STA <Objects_YVelZ,X	 ; Update Y Veocity
;
;	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
;
;	LDA #$01	; A = 1
;
;	LDY <Objects_YVelZ,X
;	BPL PRG003_B833	 ; If Blooper is not moving upward, jump to PRG003_B833
;
;	LSR A		; A = 0
;
;PRG003_B833:
;	STA Objects_Frame,X	 ; Set frame based on movement
;
;PRG003_B85F:
;	LDA Objects_SpriteAttributes, X
;	ORA #SPR_BEHINDBG
;	STA Objects_SpriteAttributes, X
;	JMP Object_DrawMirrored	 ; Draw Blooper and don't come back!
;
;BlooperKid_YVel:	.byte $F8, $08, $08, $F8
;BlooperKid_XVel:	.byte $08, $08, $F8, $F8
;BlooperKid_Data:	.byte $00, $00, $01, $01
;BlooperKid_UNKD:	.byte $00, $01, $01, $00


Object_SetHFlipByXVel:
	; Clear horizontal flip
	LDA Objects_Orientation,X	 
	AND #~SPR_HFLIP

	LDY <Objects_XVelZ,X
	BEQ PRG003_B8C6		; If not moving horizontally, jump to PRG003_B8C6
	BMI PRG003_B8C3		; If moving leftward, jump to PRG003_B8C3

	; Moving to the right
	ORA #SPR_HFLIP	 ; Set horizontal flip

PRG003_B8C3:
	STA Objects_Orientation,X	 ; Update flip bits

PRG003_B8C6:
	RTS		 ; Return

	; Temp_Var2 is an X input
	; I don't really understand this function, but it determines horizontal
	; visibility by Sprite X somehow. Carry set if not visible.
Sprite_NoCarryIfVisible:
	LDA Objects_SpritesVerticallyOffScreen,X	 
	BNE PRG003_B8E7	 ; If any of the sprites are vertically off-screen, jump to PRG003_B8E7

	LDA <Objects_SpriteY,X
	CMP #208
	BGE PRG003_B8E7	 ; If sprite Y >= 208, jump to PRG003_B8E7

	LDY #$40	 ; Y = $40

	LDA <Objects_SpriteX,X
	BMI PRG003_B8DA	 ; If sprite X >= $80, jump to PRG003_B8DA

	LDY #$C0	 ; Y = $C0

PRG003_B8DA:
	CPY <Temp_Var2	 ; Compare $40 or $C0 to input X value

	EOR Objects_SpritesHorizontallyOffScreen,X

	BMI PRG003_B8E5	 ; If there are inappropriate horizontally off-screen sprites (??) jump to PRG003_B8E5

	BLT PRG003_B8E7	 ; If input X value < 'Y', jump to PRG003_B8E7 (carry clear, but will set carry)
	BGE PRG003_B8E9	 ; If input X value >= 'Y', jump to PRG003_B8E9 (carry set, but will be clear)

PRG003_B8E5:
	BLT PRG003_B8E9	 ; If input X value < 'Y', jump to PRG003_B8E9 (carry clear)

PRG003_B8E7:
	SEC		 ; Set carry
	RTS		 ; Return

PRG003_B8E9:
	CLC		 ; Clear carry
	RTS		 ; Return

FireSnake_Frame = Objects_Data1
FireSnake_CanJump = Objects_Data3
FireSnake_BufferOffset = Objects_Data4

FireSnakeFlips:
	.byte $00, SPR_HFLIP

FireSnake_Jumps:
	.byte $E0, $E0, $D8, $C8, $BA, $B2, $A8, $A0, $98, $90, $8A, $8A, $8A, $8A, $8A, $8A

FireSnake_BufferOffsets:
	.byte 00, 16

ObjInit_FireSnake:
	JSR Object_InitBuffer
	LDA FireSnake_BufferOffsets, Y
	STA FireSnake_BufferOffset, X
	TAY

	LDA #$0F
	STA <Temp_Var1
	
FireSnake_InitLoop:
	LDA <Objects_XZ, X
	STA Object_BufferX, Y

	LDA <Objects_YZ, X
	STA Object_BufferY, Y

	INY
	DEC <Temp_Var1
	BPL FireSnake_InitLoop

	LDA #$01
	STA Objects_NoIce, X
	RTS

ObjNorm_FireSnake:
	LDA <Player_HaltGameZ
	BEQ FireSnake_Norm	 ; If gameplay is NOT halted, jump to PRG003_BD95

	JMP FireSnake_Draw

FireSnake_Norm:
	JSR Object_Move
	JSR FireSnake_MoveTail
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_DetectTiles

	LDA Objects_Timer3, X
	BEQ FireSnake_InteractTiles

	LDA <Objects_YVelZ, X
	BMI FireSnake_InteractTiles

	LDA Object_VertTileProp, X
	CMP #TILE_PROP_SOLID_TOP
	BNE FireSnake_InteractTiles

	LDA <Objects_TilesDetectZ, X
	AND #~HITTEST_BOTTOM
	STA <Objects_TilesDetectZ, X

FireSnake_InteractTiles:
	JSR Object_InteractWithTiles

	LDA FireSnake_CanJump, X
	BEQ FireSnake_TryCanJump

	LDA Objects_Timer, X
	BNE FireSnake_Animate

	JSR Object_YDistanceFromPlayer
	LDA <YDiffAboveBelow
	BEQ FireSnake_DetermineJump

	LDA #$20
	STA Objects_Timer3, X

	LDY #$00
	BEQ FireSnake_DoJump

FireSnake_DetermineJump:
	LDA <YDiff
	LSR A
	LSR A
	LSR A
	LSR A
	TAY
	INY

FireSnake_DoJump:
	LDA FireSnake_Jumps, Y
	STA <Objects_YVelZ, X

	CPY #$00
	BNE FireSnake_TowardsPlayer

	LDA #$20
	STA Objects_Timer3, X

FireSnake_TowardsPlayer:

	JSR Object_MoveTowardsPlayerFast
	LDA #$00
	STA FireSnake_CanJump, X

	
	JMP FireSnake_Animate

FireSnake_TryCanJump:
	LDA <Objects_TilesDetectZ, X
	AND #HITTEST_BOTTOM
	BEQ FireSnake_Animate

	INC FireSnake_CanJump, X
	LDA #$20
	STA Objects_Timer, X

	LDA #$00
	STA <Objects_XVelZ, X


FireSnake_Animate:
	INC FireSnake_Frame, X
	LDA FireSnake_Frame, X
	LSR A
	AND #$01
	STA Objects_Frame, X

	LDA FireSnake_Frame, X
	LSR A
	LSR A
	AND #$01
	TAY
	LDA Objects_Orientation, X
	AND #~SPR_HFLIP

	ORA FireSnakeFlips, Y
	STA Objects_Orientation, X
	JMP FireSnake_Draw

FireSnake_MoveTail:
	LDA #$0E
	STA <Temp_Var1

	LDA FireSnake_BufferOffset, X
	ADD #$0E
	TAY


MoveTail_Loop:
	LDA Object_BufferX, Y
	STA Object_BufferX + 1, Y

	LDA Object_BufferY, Y
	STA Object_BufferY + 1, Y
	DEY
	DEC <Temp_Var1
	BPL MoveTail_Loop

	INY
	LDA <Objects_XZ, X
	STA Object_BufferX, Y

	LDA <Objects_YZ, X
	STA Object_BufferY, Y
	RTS

FireSnake_Draw:
	JSR Object_Draw

FireSnake_RAMOffset = Temp_Var15
FireSnake_TailPartX = Temp_Var2
FireSnake_TailPartY = Temp_Var1
FireSnake_TailOffset = Temp_Var16

FireSnake_DrawTail:
	LDY Object_SpriteRAMOffset, X
	STY <FireSnake_RAMOffset

	LDA FireSnake_BufferOffset, X
	STA <FireSnake_TailOffset
	TAX
	LDA Object_BufferX + 3, X
	SUB <Horz_Scroll
	ADD #$04
	STA <FireSnake_TailPartX
	

	LDA Object_BufferY + 3, X
	SUB <Vert_Scroll
	STA <FireSnake_TailPartY

	JSR Object_ParticleVisibleTest
	BCS FSDT1

	LDY <FireSnake_RAMOffset
	LDA <FireSnake_TailPartX
	STA Sprite_RAMX + 8, Y
	LDA <FireSnake_TailPartY
	STA Sprite_RAMY + 8, Y

	LDA Game_Counter
	AND #$03
	BNE FSDT1

	LDA Sprite_RAMX + 8, Y
	SUB Sprite_RAMX, Y
	STA <FireSnake_TailPartX

	LDA Sprite_RAMY + 8, Y
	SUB Sprite_RAMY, Y
	STA <FireSnake_TailPartY
	JSR FireSnake_TailHitTest

FSDT1:
	LDX <FireSnake_TailOffset

	LDA Object_BufferX + 7, X
	SUB <Horz_Scroll
	ADD #$04
	STA <FireSnake_TailPartX
	

	LDA Object_BufferY + 7, X
	SUB <Vert_Scroll
	STA <FireSnake_TailPartY

	JSR Object_ParticleVisibleTest
	BCS FSDT2

	LDY <FireSnake_RAMOffset
	LDA <FireSnake_TailPartX
	STA Sprite_RAMX + 12, Y
	LDA <FireSnake_TailPartY
	STA Sprite_RAMY + 12, Y

	LDA Game_Counter
	AND #$03
	CMP #$01
	BNE FSDT2

	LDA Sprite_RAMX + 12, Y
	SUB Sprite_RAMX, Y
	STA <FireSnake_TailPartX

	LDA Sprite_RAMY + 12, Y
	SUB Sprite_RAMY, Y
	STA <FireSnake_TailPartY
	JSR FireSnake_TailHitTest

FSDT2:
	LDX <FireSnake_TailOffset
	LDA Object_BufferX + 11, X
	SUB <Horz_Scroll
	ADD #$04
	STA <FireSnake_TailPartX
	

	LDA Object_BufferY + 11, X
	SUB <Vert_Scroll
	STA <FireSnake_TailPartY

	JSR Object_ParticleVisibleTest
	BCS FSDT3

	LDY <FireSnake_RAMOffset
	LDA <FireSnake_TailPartX
	STA Sprite_RAMX + 16, Y
	LDA <FireSnake_TailPartY
	STA Sprite_RAMY + 16, Y

	LDA Game_Counter
	AND #$03
	CMP #$02
	BNE FSDT3

	LDA Sprite_RAMX + 16, Y
	SUB Sprite_RAMX, Y
	STA <FireSnake_TailPartX

	LDA Sprite_RAMY + 16, Y
	SUB Sprite_RAMY, Y
	STA <FireSnake_TailPartY
	JSR FireSnake_TailHitTest

FSDT3:
	LDA Object_BufferX + 15, X
	SUB <Horz_Scroll
	ADD #$04
	STA <FireSnake_TailPartX
	

	LDA Object_BufferY + 15, X
	SUB <Vert_Scroll
	STA <FireSnake_TailPartY

	JSR Object_ParticleVisibleTest
	BCS FSDT4

	LDY <FireSnake_RAMOffset
	LDA <FireSnake_TailPartX
	STA Sprite_RAMX + 20, Y
	LDA <FireSnake_TailPartY
	STA Sprite_RAMY + 20, Y

	LDA Game_Counter
	AND #$03
	CMP #$03
	BNE FSDT4

	LDA Sprite_RAMX + 20, Y
	SUB Sprite_RAMX, Y
	STA <FireSnake_TailPartX

	LDA Sprite_RAMY + 20, Y
	SUB Sprite_RAMY, Y
	STA <FireSnake_TailPartY
	JSR FireSnake_TailHitTest

FSDT4:
	LDY <FireSnake_RAMOffset

	LDA #$89
	STA Sprite_RAMTile + 8, Y
	STA Sprite_RAMTile + 12, Y

	LDA #$8B
	STA Sprite_RAMTile + 16, Y
	STA Sprite_RAMTile + 20, Y

	LDX <CurrentObjectIndexZ
	LDA Objects_Frame, X
	AND #$01
	TAX

	LDA FireSnake_TailFlips, X
	STA Sprite_RAMAttr + 8, Y
	STA Sprite_RAMAttr + 16, Y

	TXA
	EOR #$01
	TAX

	LDA FireSnake_TailFlips, X
	STA Sprite_RAMAttr + 12, Y
	STA Sprite_RAMAttr + 20, Y
	RTS

FireSnake_TailHitTest:
	LDA <FireSnake_TailPartX
	STA <Temp_Var10

	LDA <FireSnake_TailPartY
	STA <Temp_Var11

	LDX <CurrentObjectIndexZ
	LDA Objects_BoundLeft, X
	STA <CalcParam1

	LDA Objects_BoundLeftHi, X
	STA <CalcParam1 + 1

	LDA #$00
	STA <CalcParam2 + 1

	LDA <Temp_Var10
	BPL TailHit_Add

	EOR #$FF
	ADD #$01
	STA <CalcParam2
	JSR Subtract2ByteValue
	JMP TailHit_Bound

TailHit_Add:
	STA CalcParam2
	JSR Add2ByteValue

TailHit_Bound:
	LDA <CalcResult
	STA SpecialObj_BoundLeft
	ADD #$08
	STA SpecialObj_BoundRight

	LDA <CalcResult + 1
	STA SpecialObj_BoundLeftHi
	ADC #$00
	STA SpecialObj_BoundRightHi

	LDA Objects_BoundTop, X
	STA <CalcParam1

	LDA Objects_BoundTopHi, X
	STA <CalcParam1 + 1

	LDA #$00
	STA <CalcParam2 + 1

	LDA <Temp_Var11
	BPL TailHit_Add2

	EOR #$FF
	ADD #$01
	STA CalcParam2
	JSR Subtract2ByteValue
	JMP TailHit_Bound2

TailHit_Add2:
	STA CalcParam2
	JSR Add2ByteValue

TailHit_Bound2:
	LDA <CalcResult
	STA SpecialObj_BoundTop
	ADD #$10
	STA SpecialObj_BoundBottom

	LDA <CalcResult + 1
	STA SpecialObj_BoundTopHi
	ADC #$00
	STA SpecialObj_BoundBottomHi
	JSR SpecialObj_DetectPlayer
	BCC TailHit_None

	JSR Player_GetHurt

TailHit_None:
	RTS

FireSnake_TailFlips:
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP

RotoDisc_VelAccels:
	.byte $01, $FF, $01, $FF, $01, $FF, $01, $FF, $02, $FE, $02, $FE

PRG003_B9BB:
	.byte $00, $03, $01

RotoDisc_VelLimits:
	.byte $10, $F0, $10, $F0, $10, $F0, $10, $F0

PRG003_B9C6:
	.byte $28, $D8, $28, $D8


ObjInit_Pyrantula:
	JSR InitPatrol_Chase
	LDA #$40
	STA Objects_Timer, X
	RTS		

Pyrantula_Frame = Objects_Data1
Pyrantula_FireTimer = Objects_Data2

ObjNorm_Pyrantula:
	LDA <Player_HaltGameZ
	BEQ Pyrantula_Normal
	JMP Pyrantula_Draw	 ; If gameplay is not halted, jump to PRG003_B9D4

Pyrantula_Normal:
	LDA Pyrantula_FireTimer, X
	BNE Pyrantula_Shoot

	LDA Objects_Timer, X
	BNE Pyrantula_Move

	LDA #$20
	STA Pyrantula_FireTimer, X

Pyrantula_Move:
	JSR Object_ChasePlayer
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	
	LDA  Object_VertTileProp, X
	CMP #TILE_PROP_CLIMBABLE
	BEQ Pyrantula_VGo

	LDA #$00
	STA <Objects_YVelZ, X
	STA Objects_YVelFrac,X	

Pyrantula_VGo:
	LDA  Object_HorzTileProp, X
	CMP #TILE_PROP_CLIMBABLE
	BEQ Pyrantula_Animate

	JSR Object_WallStop
	JMP Pyrantula_Animate

Pyrantula_Shoot:
	CMP #$10
	BNE Pyrantula_ShootDraw

	LDA #$06
	STA <Proj_XOff 

	LDA #$0C
	STA <Proj_YOff

	JSR Object_ShootFireBallStraight
	JSR Object_AimProjectile

	LDA SpecialObj_XVel, Y
	JSR Double_Value
	STA SpecialObj_XVel, Y

	LDA SpecialObj_YVel, Y
	JSR Double_Value
	STA SpecialObj_YVel, Y

Pyrantula_ShootDraw:
	DEC Pyrantula_FireTimer, X
	BEQ Pyrantual_Reset

	LDA #$02
	STA Objects_Frame, X
	BNE Pyrantula_Draw

Pyrantual_Reset:
	LDA #$40
	STA Objects_Timer, X
	BNE Pyrantula_Draw

Pyrantula_Animate:
	INC Pyrantula_Frame, X

	LDA Pyrantula_Frame, X
	LSR A
	LSR A
	AND #$01

	STA Objects_Frame, X

Pyrantula_Draw:
	JMP Object_DrawMirrored	 ; Jump (indirectly) to PRG003_BB17 (draws enemy) and don't come back!

RotoDiscSpin:

	RTS		 ; Return

FireChomp_SpitFire:

	; Calculates flying Boom Boom's path so he flies towards Player
BoomBoom_CalcFlightPath:

ObjInit_RotoDiscDualCW:

ObjInit_RotoDiscDualCCW:
	RTS		 ; Return


ObjNorm_RotoDiscDualOpp:
	RTS		 ; Return

ObjNorm_RotoDiscDualOpp2:
	RTS		 ; Return

ObjNorm_RotoDiscDual:
	
	RTS		 ; Return

ObjNorm_RotoDisc:
	RTS
; Rest of ROM bank was empt


PRG003_BD1E:
	LDY #$00	 ; Y = 0

	LDA <Player_Suit
	BEQ PRG003_BD2A	 ; If Player is small, jump to PRG003_BD2A

	LDA Player_IsDucking
	BNE PRG003_BD2A	 ; If Player is ducking, jump to PRG003_BD2A

	INY		 ; Y = 1

PRG003_BD2A:
	LDA <Temp_Var1
	CMP #$c3
	BGE PRG003_BD60	 ; If Temp_Var1 >= $C3, jump to PRG003_BD60 (RTS)

	ADD #$08
	SUB <Player_SpriteY
	SUB Tail_PlayerYOff,Y
	CMP Tail_PlayerYLimit,Y
	BGE PRG003_BD60	 ; If Player is not in good Y range, jump to PRG003_BD60 (RTS)

	LDA <Temp_Var2
	ADD #$04
	SUB <Player_SpriteX
	SBC #$00
	CMP #$10
	BGE PRG003_BD60	 ; If Player is not in good X range, jump to PRG003_BD60 (RTS)

	LDA Player_StarInv
	BNE PRG003_BD60	 ; If Player is invincible by Starman, jump to PRG003_BD60 (RTS)

Player_HurtIfNotDieOffBehind:
	ORA Player_IsDying  	; If Player is dying...
	ORA Player_OffScreen	; ... off-screen ...
	BNE PRG003_BD60	 	; ... jump to PRG003_BD60 (RTS)

	JSR Player_GetHurt	; Otherwise, hurt Player!

PRG003_BD60:
	RTS		 ; Return

	
Tail_PlayerYOff:	.byte $12, $04	; Offset to Player Sprite Y for small/ducking, or not
Tail_PlayerYLimit:	.byte $0E, $18	; Limit value