; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-12-14 17:45:42.706614297 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup02 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $02 (i.e. objects starting at ID $48) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup02_InitJumpTable:
	.word ObjInit_Ninji	; Object $48 - OBJ_NINJI
	.word ObjInit_DoNothing	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjInit_MagicStar1	; Object $4A - OBJ_MAGICSTAR
	.word ObjInit_MagicStar2	; Object $4B - OBJ_MAGICSTAR
	.word ObjInit_MagicStar3	; Object $4C - OBJ_MAGICSTAR
	.word ObjInit_DoNothing	; Object $4D
	.word ObjInit_DoNothing		; Object $4E
	.word ObjInit_DoNothing		; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjInit_BobOmbExplode	; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjInit_RotoDiscDualCCW	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjInit_Spintula	; Object $52 - OBJ_SPINTULA
	.word ObjInit_PodobooCeiling	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjInit_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjInit_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjInit_PiranhaSidewaysL	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjInit_PiranhaSidewaysR	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjInit_Pyrantula		; Object $58 - OBJ_PYRANTULA
	.word ObjInit_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjInit_RotoDiscDualCW	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjInit_RotoDiscDualCCW	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjInit_IceBlock		; Object $5C - OBJ_ICEBLOCK
	.word ObjInit_DoNothing		; Object $5D - OBJ_STONEBLOCK
	.word ObjInit_RotoDiscDualCW	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjInit_RotoDiscDualCW	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjInit_RotoDiscDualCW	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjInit_BlooperWithKids	; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjInit_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjInit_FloatMine	; Object $63 - OBJ_FLOATMINE
	.word ObjInit_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjInit_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjInit_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjInit_ShyGuy		; Object $67 - OBJ_SNOWGUY
	.word ObjInit_Twirling		; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjInit_Twirling		; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjInit_ShyGuy	; Object $6A - OBJ_VEGGIEGUY
	.word ObjInit_ShyGuy	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup02_NormalJumpTable:
	.word ObjNorm_Ninji	; Object $48 - OBJ_NINJI
	.word ObjNorm_DoNothing	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjNorm_MagicStar	; Object $4A - OBJ_MAGICSTAR
	.word ObjNorm_MagicStar		; Object $4B - OBJ_MAGICSTAR
	.word ObjNorm_MagicStar		; Object $4C - OBJ_MAGICSTAR
	.word ObjNorm_Explosion	; Object $4D
	.word ObjNorm_DoNothing		; Object $4E
	.word ObjNorm_ChainChompFree	; Object $4F - OBJ_CHAINCHOMPFREE
	.word BobOmb_DoExplosion		; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjNorm_RotoDiscDual	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjNorm_Spintula	; Object $52 - OBJ_SPINTULA
	.word ObjNorm_PodobooCeiling	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjNorm_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjNorm_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjNorm_PiranhaSideways	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjNorm_PiranhaSideways	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjNorm_Pyrantula		; Object $58 - OBJ_PYRANTULA
	.word ObjNorm_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjNorm_RotoDisc		; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjNorm_RotoDisc		; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjNorm_IceBlock		; Object $5C - OBJ_ICEBLOCK
	.word ObjNorm_IceBlock		; Object $5D - OBJ_STONEBLOCK
	.word ObjNorm_RotoDiscDualOpp	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjNorm_RotoDiscDualOpp2	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjNorm_RotoDiscDual	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjNorm_Blooper		; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjNorm_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjNorm_FloatMine	; Object $63 - OBJ_FLOATMINE
	.word ObjNorm_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjNorm_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjNorm_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjNorm_SnowGuy	; Object $67 - OBJ_SNOWGUY
	.word ObjNorm_TwirlingShell	; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjNorm_TwirlingShell	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjNorm_VeggieGuy		; Object $6A - OBJ_VEGGIEGUY
	.word ObjNorm_ShyGuy	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup02_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $48 - OBJ_NINJI
	.word ObjHit_DoNothing	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjHit_DoNothing	; Object $4A - OBJ_MAGICSTAR
	.word ObjHit_DoNothing	; Object $4A - OBJ_MAGICSTAR
	.word ObjHit_DoNothing	; Object $4A - OBJ_MAGICSTAR
	.word ObjHit_DoNothing	; Object $4D
	.word ObjHit_DoNothing	; Object $4E
	.word ObjHit_DoNothing	; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjHit_DoNothing	; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjHit_DoNothing	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjHit_DoNothing	; Object $52 - OBJ_SPINTULA
	.word ObjHit_DoNothing	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjHit_DoNothing	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjHit_DoNothing	; Object $55 - OBJ_BOBOMB
	.word ObjHit_DoNothing	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjHit_DoNothing	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjHit_DoNothing	; Object $58 - OBJ_PYRANTULA
	.word ObjHit_DoNothing	; Object $59 - OBJ_FIRESNAKE
	.word ObjHit_DoNothing	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjHit_DoNothing	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjHit_DoNothing	; Object $5C - OBJ_ICEBLOCK
	.word ObjHit_DoNothing	; Object $5D - OBJ_STONEBLOCK
	.word ObjHit_DoNothing	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjHit_DoNothing	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjHit_DoNothing	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjHit_DoNothing	; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjHit_DoNothing	; Object $62 - OBJ_BLOOPER
	.word MineDoExplode	; Object $63 - OBJ_FLOATMINE
	.word ObjHit_DoNothing	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjHit_DoNothing	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjHit_DoNothing	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjHit_DoNothing	; Object $67 - OBJ_SNOWGUY
	.word OCSPECIAL_KILLCHANGETO | OBJ_BUZZYBEATLE	; Object $68 - OBJ_TWIRLINGBUZZY
	.word OCSPECIAL_KILLCHANGETO | OBJ_SPINY	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjHit_DoNothing	; Object $6A - OBJ_VEGGIEGUY
	.word ObjHit_DoNothing	; Object $6B - OBJ_SHYGUY

	
	; Object group $02 (i.e. objects starting at ID $48) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup02_Attributes:
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $48 - OBJ_NINJI
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4A - OBJ_MAGICSTAR
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4B - OBJ_MAGICSTAR
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4C - OBJ_MAGICSTAR
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $4D
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $4E
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $52 - OBJ_SPINTULA
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $55 - OBJ_BOBOMB
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $58 - OBJ_PYRANTULA
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $59 - OBJ_FIRESNAKE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA1_PAL2 | OA1_WIDTH16 | OA1_WIDTH16	; Object $5C - OBJ_ICEBLOCK
	.byte OA1_PAL1 | OA1_WIDTH16 | OA1_WIDTH16	; Object $5D - OBJ_STONEBLOCK
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $62 - OBJ_BLOOPER
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $63 - OBJ_FLOATMINE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $67 - OBJ_SNOWGUY
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6A - OBJ_VEGGIEGUY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6B - OBJ_SHYGUY

	; Object group $02 (i.e. objects starting at ID $48) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup02_Attributes2:
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $48 - OBJ_NINJI
	.byte OA2_TDOGRP0	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4A - OBJ_MAGICSTAR
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4B - OBJ_MAGICSTAR
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4C - OBJ_MAGICSTAR
	.byte OA2_TDOGRP0	; Object $4D
	.byte OA2_TDOGRP0	; Object $4E
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA2_TDOGRP1	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $52 - OBJ_SPINTULA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte  OA2_TDOGRP1	; Object $55 - OBJ_BOBOMB
	.byte OA2_TDOGRP0	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA2_TDOGRP0	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1		; Object $58 - OBJ_PYRANTULA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $59 - OBJ_FIRESNAKE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA2_TDOGRP1	; Object $5C - OBJ_ICEBLOCK
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5D - OBJ_STONEBLOCK
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $62 - OBJ_BLOOPER
	.byte OA2_NOSHELLORSQUASH | OA3_TAILATKIMMUNE | OA2_TDOGRP1	; Object $63 - OBJ_FLOATMINE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA2_TDOGRP0	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA2_TDOGRP0	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $67 - OBJ_SNOWGUY
	.byte OA2_TDOGRP1	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA2_TDOGRP1	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $6A - OBJ_VEGGIEGUY
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup02_Attributes3:
	.byte OA3_HALT_NORMALONLY  	; Object $48 - OBJ_NINJI
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4A - OBJ_MAGICSTAR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4B - OBJ_MAGICSTAR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4C - OBJ_MAGICSTAR
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE 	; Object $4D
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $4E
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA3_HALT_NORMALONLY 	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA3_HALT_NORMALONLY	; Object $52 - OBJ_SPINTULA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA3_HALT_NORMALONLY 	; Object $55 - OBJ_BOBOMB
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA3_HALT_NORMALONLY 	; Object $58 - OBJ_PYRANTULA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $59 - OBJ_FIRESNAKE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5C - OBJ_ICEBLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5D - OBJ_STONEBLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $62 - OBJ_BLOOPER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE 	; Object $63 - OBJ_FLOATMINE
	.byte OA3_HALT_NORMALONLY 	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA3_HALT_NORMALONLY	; Object $67 - OBJ_SNOWGUY
	.byte OA3_HALT_NORMALONLY 	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA3_HALT_NORMALONLY 	; Object $6A - OBJ_VEGGIEGUY
	.byte OA3_HALT_NORMALONLY 	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup02_PatTableSel:
	.byte OPTS_SETPT5 | $0F	; Object $48 - OBJ_NINJI
	.byte OPTS_NOCHANGE	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OPTS_NOCHANGE	; Object $4A - OBJ_MAGICSTAR
	.byte OPTS_NOCHANGE	; Object $4B - OBJ_MAGICSTAR
	.byte OPTS_NOCHANGE	; Object $4C - OBJ_MAGICSTAR
	.byte OPTS_NOCHANGE	; Object $4D
	.byte OPTS_NOCHANGE	; Object $4E
	.byte OPTS_SETPT5 | $0E	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OPTS_NOCHANGE	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OPTS_SETPT5 | $12	; Object $51 - OBJ_ROTODISCDUAL
	.byte OPTS_SETPT5 | $10	; Object $52 - OBJ_SPINTULA
	.byte OPTS_NOCHANGE	; Object $53 - OBJ_PODOBOOCEILING
	.byte OPTS_SETPT5 | $0E	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OPTS_SETPT5 | $0A	; Object $55 - OBJ_BOBOMB
	.byte OPTS_SETPT5 | $5A	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OPTS_SETPT5 | $5A	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OPTS_SETPT5 | $10	; Object $58 - OBJ_PYRANTULA
	.byte OPTS_SETPT5 | $0A	; Object $59 - OBJ_FIRESNAKE
	.byte OPTS_SETPT5 | $12	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OPTS_SETPT5 | $12	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OPTS_NOCHANGE	; Object $5C - OBJ_ICEBLOCK
	.byte OPTS_NOCHANGE	; Object $5D - OBJ_STONEBLOCK
	.byte OPTS_SETPT5 | $12	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OPTS_SETPT5 | $12	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OPTS_SETPT5 | $12	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OPTS_SETPT5 | $1A	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OPTS_SETPT5 | $1A	; Object $62 - OBJ_BLOOPER
	.byte OPTS_SETPT5 | $1A	; Object $63 - OBJ_FLOATMINE
	.byte OPTS_SETPT6 | $4F	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OPTS_NOCHANGE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OPTS_NOCHANGE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OPTS_SETPT5 | $0F	; Object $67 - OBJ_SNOWGUY
	.byte OPTS_SETPT5 | $0B	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OPTS_SETPT5 | $0B	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OPTS_SETPT5 | $0F	; Object $6A - OBJ_VEGGIEGUY
	.byte OPTS_SETPT5 | $0F	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) "Kill Action"
	; Determines what action is taken when object is in "Killed" state (6)
	; See Object_DoKillAction for the jump table
	; NOTE: Any action type other than zero always sets the frame to 2 (unless object is not general purpose, i.e. index >= 5)

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup02_KillAction:
	.byte KILLACT_JUSTDRAW16X16	; Object $48 - OBJ_NINJI
	.byte KILLACT_STANDARD	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte KILLACT_STANDARD	; Object $4A - OBJ_MAGICSTAR
	.byte KILLACT_STANDARD	; Object $4B - OBJ_MAGICSTAR
	.byte KILLACT_STANDARD	; Object $4C - OBJ_MAGICSTAR
	.byte KILLACT_STANDARD	; Object $4D
	.byte KILLACT_STANDARD	; Object $4E
	.byte KILLACT_NORMALANDKILLED	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte KILLACT_JUSTDRAW16X16	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte KILLACT_STANDARD	; Object $51 - OBJ_ROTODISCDUAL
	.byte KILLACT_JUSTDRAWMIRROR	; Object $52 - OBJ_SPINTULA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $53 - OBJ_PODOBOOCEILING
	.byte KILLACT_STANDARD	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte KILLACT_JUSTDRAW16X16	; Object $55 - OBJ_BOBOMB
	.byte KILLACT_POOFDEATH	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte KILLACT_POOFDEATH	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte KILLACT_JUSTDRAWMIRROR	; Object $58 - OBJ_PYRANTULA
	.byte KILLACT_NORMALSTATE	; Object $59 - OBJ_FIRESNAKE
	.byte KILLACT_STANDARD	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte KILLACT_STANDARD	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte KILLACT_NORMALSTATE	; Object $5C - OBJ_ICEBLOCK
	.byte KILLACT_NORMALSTATE	; Object $5D - OBJ_STONEBLOCK
	.byte KILLACT_STANDARD	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte KILLACT_STANDARD	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte KILLACT_STANDARD	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte KILLACT_NORMALSTATE	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte KILLACT_JUSTDRAWMIRROR	; Object $62 - OBJ_BLOOPER
	.byte KILLACT_NORMALANDKILLED	; Object $63 - OBJ_FLOATMINE
	.byte KILLACT_JUSTDRAW16X16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte KILLACT_STANDARD	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte KILLACT_STANDARD	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte KILLACT_JUSTDRAW16X16	; Object $67 - OBJ_SNOWGUY
	.byte KILLACT_JUSTDRAWMIRROR	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte KILLACT_JUSTDRAWMIRROR	; Object $69 - OBJ_TWIRLINGSPINY
	.byte KILLACT_JUSTDRAW16X16	; Object $6A - OBJ_VEGGIEGUY
	.byte KILLACT_JUSTDRAW16X16	; Object $6B - OBJ_SHYGUY


	; Object group $02 (i.e. objects starting at ID $48) pattern index starts
	; These are used for all states except "normal"

OG2_POff .func (\1 - ObjectGroup02_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup02_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG2_POff(ObjP48), OG2_POff(ObjP49), OG2_POff(ObjP4A), OG2_POff(ObjP4B)
	.byte OG2_POff(ObjP4C), OG2_POff(ObjP4D), OG2_POff(ObjP4E), OG2_POff(ObjP4F)
	.byte OG2_POff(ObjP50), OG2_POff(ObjP51), OG2_POff(ObjP52), OG2_POff(ObjP53)
	.byte OG2_POff(ObjP54), OG2_POff(ObjP55), OG2_POff(ObjP56), OG2_POff(ObjP57)
	.byte OG2_POff(ObjP58), OG2_POff(ObjP59), OG2_POff(ObjP5A), OG2_POff(ObjP5B)
	.byte OG2_POff(ObjP5C), OG2_POff(ObjP5D), OG2_POff(ObjP5E), OG2_POff(ObjP5F)
	.byte OG2_POff(ObjP60), OG2_POff(ObjP61), OG2_POff(ObjP62), OG2_POff(ObjP63)
	.byte OG2_POff(ObjP64), OG2_POff(ObjP65), OG2_POff(ObjP66), OG2_POff(ObjP67)
	.byte OG2_POff(ObjP68), OG2_POff(ObjP69), OG2_POff(ObjP6A), OG2_POff(ObjP6B)


	; Object group $02 (i.e. objects starting at ID $48) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup02_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup02_PatternSets:
	; (End restricted alignment space)

ObjP49:
ObjP4D:
ObjP4E:
ObjP4F:
ObjP65:
ObjP66:
	.byte $91, $93, $9D, $9F, $9D, $9F

ObjP53:
	.byte $8D, $8D
ObjP5C:
	.byte $8F, $8F, $8F, $8F, $61, $61

ObjP5D:
	.byte $97, $99, $97, $99, $61, $63   ;#DAHRKDAIZ ICEBLOCK_SPRITE
ObjP68:
	.byte $95, $97, $91, $93, $A1, $A1
ObjP69:
	.byte $81, $83, $85, $87, $89, $89
ObjP54:
	.byte $91, $93, $91, $93

ObjP50:
ObjP55:
	.byte $A7, $A9, $AB, $AD, $97, $99, $97, $99

ObjP4A:
ObjP4B:
ObjP4C:
	.byte $7F, $7F
ObjP48:
	.byte $A1, $A3, $A5, $A7, $A5, $A7
	 
ObjP56:
ObjP57:
	.byte $81, $83, $87, $89

ObjP52:
ObjP58:
	.byte $A1, $A1, $A3, $A3, $A5, $A5
ObjP59:
	.byte $81, $83, $85, $87, $85, $87
ObjP51:
ObjP5A:
ObjP5B:
ObjP5E:
ObjP5F:
ObjP60:
	.byte $99, $9B, $9D, $9F
ObjP61:
ObjP62:

	.byte $B1, $B1, $B3, $B3, $B1, $B1
ObjP63:
	.byte $81, $83, $A1, $A3
ObjP64:
	.byte $E7, $E9, $E7, $EF, $E7, $EF

ObjP67:
ObjP6A:
ObjP6B:
	.byte $81, $83, $85, $87, $85, $87, $B1, $B1, $81, $B5, $85, $B7, $BB, $BB, $91, $93

ObjInit_IceBlock:
	LDA #$ff
	STA Objects_Timer3,X

	LDA #OBJSTATE_KICKED	         ; #DAHRKDAIZ makes sure the ice block doesn't disappear immediately
	STA Objects_State,X
	LDA #$01
	STA Objects_SprAttr,X
	LDA #$02
	STA Objects_Frame, X
	LDA <Objects_Y,X
	RTS

ObjNorm_IceBlock:

	; This may seem confusing, but an Ice Block is in held state when grabbed,
	; shelled state when kicked, and just comes here to get busted...

	LDA #$03	 ; A = 3
	JMP PRG003_A4DD	 ; Jump to PRG003_A4DD

ObjInit_Spintula:
	
	RTS		 ; Return

ObjNorm_Spintula:
	LDA <Player_HaltGame
	BEQ ObjNorm_Spintula1
	JMP Object_ShakeAndDrawMirrored	

ObjNorm_Spintula1:
	JSR Object_DeleteOffScreen
	JSR Player_HitEnemy
	JSR Object_ApplyYVel_NoLimit
	JSR Object_WorldDetect4

	LDA Objects_Var1, X
	JSR DynJump
	
	.word Spintula_Wait
	.word Spintula_SpinDown
	.word Spintula_SpinUp

Spintula_Wait:
	LDA Objects_Timer,X
	BNE Spintula_WaitRTS
	JSR Level_ObjCalcXDiffs
	LDA <Temp_Var16
	BPL Spintula_Wait1
	JSR Negate

Spintula_Wait1:
	CMP #$30
	BCS Spintula_WaitRTS
	INC Objects_Var1, X

Spintula_WaitRTS:
	JMP Object_ShakeAndDrawMirrored

Spintula_SpinDown:
	LDA <Objects_DetStat,X
	AND #$04
	BNE Spintula_SpinDownStop
	LDA Objects_LastProp, X
	AND #$C0
	BNE Spintula_SpinDownStop
	LDA Objects_YHi, X
	BEQ Spintula_SpinDown1
	LDA Objects_Y, X
	CMP #$A0
	BCS Spintula_SpinDownStop

Spintula_SpinDown1:
	LDA #$20
	STA <Objects_YVel, X
	LDA <Counter_1
	LSR A
	AND #$01
	STA Objects_Frame, X
	LDA Objects_Y, X
	AND #$0F
	BNE Spintula_SpinDownRTS
	LDA Objects_LastProp, X
	AND #$0F
	CMP #TILE_PROP_CLIMBABLE
	BEQ Spintula_SpinDownRTS
	LDA Level_ChgTileEvent
	BNE Spintula_StopDownVel

	JSR SetObjectTileCoord
	LDA Objects_LastTile, X
	EOR #$01
	STA Level_ChgTileEvent

Spintula_SpinDownRTS:
	JMP Object_ShakeAndDrawMirrored

Spintula_SpinDownStop:
	INC Objects_Var1, X

	LDA #$20
	STA Objects_Timer,X
	LDA Objects_Y, X
	AND #$F0
	SUB #$02
	STA Objects_Y, X
	LDA Objects_YHi, X
	SBC #$00
	STA Objects_YHi, X

Spintula_StopDownVel:
	LDA #$00
	STA <Objects_YVel, X
	JMP Object_ShakeAndDrawMirrored

Spintula_SpinUp:
	LDA Objects_Timer, X
	BNE Spintula_SpinUpRTS

	LDA <Objects_DetStat,X
	AND #$08
	BNE Spintula_SpinUpStop
	LDA Objects_LastProp, X
	AND #$C0
	BNE Spintula_SpinUpStop
	LDA Objects_YHi, X
	BMI Spintula_SpinUpStop

	LDA #$F0
	STA <Objects_YVel, X
	LDA <Counter_1
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X
	LDA Objects_Y, X
	AND #$0F
	BNE Spintula_SpinUpRTS
	LDA Level_ChgTileEvent
	BNE Spintula_StopUpVel

	LDA Objects_LastProp, X
	CMP #TILE_PROP_CLIMBABLE
	BNE Spintula_SpinUpRTS

	JSR SetObjectTileCoord
	LDA Objects_LastTile, X
	EOR #$01
	STA Level_ChgTileEvent

Spintula_SpinUpRTS:
	JMP Object_ShakeAndDrawMirrored

Spintula_SpinUpStop:
	LDA #$10
	STA Objects_Timer,X
	LDA #$00
	STA Objects_Var1, X
	LDA Objects_Y, X
	ADD #$08
	AND #$F0
	STA Objects_Y, X
	LDA Objects_YHi, X
	ADC #$00
	STA Objects_YHi, X

Spintula_StopUpVel:
	LDA #$00
	STA <Objects_YVel, X
	JMP Object_ShakeAndDrawMirrored

CPodobo_YVel:
	.byte $20, $E0

ObjInit_PodobooCeiling:
	LDA Objects_Property, X
	AND #$01
	BEQ ObjInit_PodobooCeiling1

	LDA #$0A
	STA PatTable_BankSel+4

ObjInit_PodobooCeiling1:
	LDA Objects_Property, X
	AND #$02
	LSR A
	TAY
	LDA CPodobo_YVel, Y
	STA Objects_YVel, X

	; Store original Y/Hi into Var5/Var4
	LDA <Objects_Y,X
	STA <Objects_Var5,X
	LDA <Objects_YHi,X
	STA <Objects_Var4,X
	LDA <Objects_X, X
	ADD #$08
	STA <Objects_X, X
	LDA <Objects_XHi, X
	ADC #$00
	STA <Objects_XHi, X

ResetPipePodobo:
	LDA #$20
	STA Objects_Timer, X
	LDA <Objects_Var5, X
	STA <Objects_Y, X
	LDA <Objects_Var4, X
	STA <Objects_YHi, X
	RTS		 ; Return

ObjNorm_PodobooCeiling:
	LDA <Player_HaltGame
	BNE PRG003_A3D5	 ; If gameplay halted, jump to PRG003_A3D5

	JSR Object_ApplyYVel_NoLimit
	JSR Player_HitEnemy	 ; Handle Player collision with Podoboo

	; Flip vertically based on velocity
	LDA <Objects_YVel,X
	EOR #SPR_VFLIP
	AND #SPR_VFLIP
	ORA #$20
	STA Objects_FlipBits,X

	LDA <Counter_1
	AND #$03
	BNE PRG003_A3AA	 ; Proceed 1:4 ticks, otherwise jump to PRG003_A3AA

	; Frame loop 0-2
	INC Objects_Frame,X
	LDY Objects_Frame,X
	CPY #$03
	BNE PRG003_A3AA

	STA Objects_Frame,X	; Zero the frame

PRG003_A3AA:
	LDA <Objects_Y, X
	AND #$0F
	BNE PRG003_A3D2

	JSR Object_WorldDetect4

	LDA Object_TileProp
	AND #TILE_PROP_SOLID_ALL
	BEQ PRG003_A3D2

	JMP ResetPipePodobo

PRG003_A3D2:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

PRG003_A3D5:
	JMP Object_ShakeAndDrawMirrored	 ; Draw Podoboo and don't come back!

BrickBustPowerUp: .byte OBJ_COIN, OBJ_POWERUP_FIREFLOWER, OBJ_POWERUP_SUPERLEAF, OBJ_POWERUP_ICEFLOWER, OBJ_POWERUP_STARMAN, OBJ_POWERUP_FOXLEAF, OBJ_POWERUP_STARMAN, OBJ_POWERUP_PUMPKIN, OBJ_POWERUP_STARMAN, OBJ_POWERUP_NINJASHROOM, OBJ_POWERUP_STARMAN, OBJ_GROWINGVINE, $00, $00, $00, OBJ_KEY
Brick_StarManFlash: .byte $00, $00, $00, $00, $01, $00, $02, $00, $03, $00, $00, $00, $00, $00, $00, $00
ShyGuyDirection: .byte $08, $F8
ShyGuyFlip: .byte SPR_HFLIP, $00

ObjInit_VeggieGuy:
	JSR Level_ObjCalcXDiffs
	LDA ShyGuyDirection, Y
	STA <Objects_XVel,X
	LDA ShyGuyFlip, Y
	STA Objects_FlipBits, X
	LDA Objects_Property, X
	BEQ ObjInit_VeggieGuy1

	LDA #$03
	STA Objects_Var1, X
	LDA #$00
	STA Objects_Property, X

ObjInit_VeggieGuy1:
	RTS		 ; Return

ObjInit_ShyGuy:
	JSR Level_ObjCalcXDiffs
	LDA ShyGuyDirection, Y
	STA <Objects_XVel,X
	LDA ShyGuyFlip, Y
	STA Objects_FlipBits, X
	LDA Objects_Property, X
	BEQ ObjInit_ShyGuy1

	STA Objects_Var2, X
	LDA #$00
	STA Objects_Property, X
	LDA #$02
	STA Objects_Var1, X

ObjInit_ShyGuy1:
	RTS		 ; Return

ObjNorm_SnowGuy:
	LDA <Player_HaltGame
	BNE SnowGuyDraw

	JSR Object_DeleteOffScreen
	JSR Player_HitEnemy
	JSR Object_InteractWithWorld
	JSR Object_HandleBumpUnderneath
	LDA Objects_DetStat,X 
	AND #$04
	BEQ ObjNorm_SnowGuy1
	LDA Objects_PrevDetStat,X 
	AND #$04
	BNE ObjNorm_SnowGuy1

	JSR ObjInit_VeggieGuy

ObjNorm_SnowGuy1:
	LDA Objects_Var1,X
	JSR DynJump

	.word SnowGuyMarch
	.word SnowGuyPull
	.word SnowGuyLift
	.word SnowGuyWait
	.word SnowGuyCarry

SnowGuyMarch:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

	LDA Objects_Var2, X
	BNE SnowGuyDraw

	LDA <Objects_X,X
	AND #$0F
	BEQ SnowGuyFindGrass

SnowGuyDraw:
	LDA Objects_Frame,X
	CMP #$03
	BEQ SnowGuyDrawMirrored
	CMP #$06
	BEQ SnowGuyDrawMirrored
	JSR Object_ShakeAndDraw
	JSR SnowGuyDrawSnowCarried

SnowGuyDraw1:
	RTS

SnowGuyDrawMirrored:
	JSR Object_ShakeAndDrawMirrored
	JSR SnowGuyDrawSnowCarried
	RTS

SnowGuyDrawSnowCarried:
	LDA Objects_Var2, X
	BEQ SnowGuyDrawSnowCarried1
	
	LDY Object_SprRAM, X
	LDA #$95
	STA Sprite_RAM + 9, Y
	LDA #$97
	STA Sprite_RAM + 13, Y
	
	LDA Sprite_RAM + 2
	AND #SPR_BEHINDBG
	ORA #SPR_PAL2
	STA Sprite_RAM + 10, Y
	STA Sprite_RAM + 14, Y
	
	 
	LDA Sprite_RAM + 3, Y
	STA Sprite_RAM + 11, Y
	LDA Sprite_RAM + 7, Y
	STA Sprite_RAM + 15, Y
	
	LDA Sprite_RAM , Y
	SUB #$10
	BCC SnowGuyDrawSnowCarried1
	STA TempA
	LDA Objects_Frame, X
	AND #$01
	ADD TempA
	STA Sprite_RAM + 8, Y
	STA Sprite_RAM + 12, Y

SnowGuyDrawSnowCarried1:
	RTS

SnowGuyFindGrass:
	LDA Objects_LastProp, X
	AND #$0F
	CMP #TILE_PROP_ENEMY
	BNE SnowGuyFindGrass1 
	INC Objects_Var1, X
	LDA #$20
	STA Objects_Timer, X
	LDA #$00
	STA Objects_XVel, X
	LDA #$06
	STA Objects_Frame, X

SnowGuyFindGrass1:
	JMP SnowGuyDraw

SnowGuyPull:
	LDA #$03
	STA Objects_Frame, X
	LDA Objects_Timer, X
	BNE SnowGuyPull1
	
	LDA #$18
	STA Objects_Timer, X
	INC Objects_Var1, X
	BNE SnowGuyPull2

SnowGuyPull1:
	LDA Objects_Timer, X
	AND #$08
	BNE SnowGuyPull2

	LDA #$06
	STA Objects_Frame, X

SnowGuyPull2:
	JMP SnowGuyDraw

SnowGuyLift:
	LDA #$07
	STA Objects_Frame, X
	LDA Objects_Timer, X
	BNE SnowGuyLift1

	LDA #$18
	STA Objects_Timer, X

	LDA #$E0
	STA Objects_YVel, X
	INC Objects_Var2, X
	INC Objects_Var1, X
	LDA #$03
	STA Objects_Frame, X

SnowGuyLift1:
	JMP SnowGuyDraw

SnowGuyWait:
	LDA Objects_DetStat, X
	AND #HIT_DET_GRND
	BEQ SnowGuyWait1
	INC Objects_Var1, X

SnowGuyWait1:
	JMP SnowGuyDraw

SnowGuyCarry:
	LDA #$10
	JSR Level_ObjCalcXBlockDiffs
	CMP #$04
	BCS SnowGuyCarrySnow2
	JSR Level_ObjCalcYBlockDiffs
	CMP #$02
	BCS SnowGuyCarrySnow2
	JSR FindEmptyEnemySlot
	CPX #$FF
	BEQ SnowGuyCarrySnow2

FoundEmptyForSnow:

	LDA #OBJ_SNOWBALL
	STA Level_ObjectID,X

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDY <SlotIndexBackup
	LDA Objects_X,Y
	STA <Objects_X,X

	; Set X Hi
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	; Set Y/Hi
	LDA Objects_Y,Y
	SUB #16
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	SBC #$00
	STA <Objects_YHi,X


	LDA #$00
	STA Objects_Var5, X
	LDA #SPR_HFLIP
	STA Objects_FlipBits, X
	LDA Objects_XVel, Y
	LDY #$20	 ; Y = $30
	ROL A
	BCC ThrowSnow	 ; If Buster's turned around, jump to PRG002_A5F2
	LDY #-$20	 ; Otherwise, Y = -$30
	LDA #$00
	STA Objects_FlipBits, X

ThrowSnow:
	STY <Objects_XVel,X

	LDA #SPR_PAL2
	STA Objects_SprAttr, X

	; Set Y velocity
	LDA #-$20
	STA <Objects_YVel,X
	LDX <SlotIndexBackup
	LDA #$00
	STA Objects_Var1, X
	STA Objects_Var2, X

SnowGuyCarrySnow2:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	ADD #$04
	STA Objects_Frame, X

SnowGuyCarrySnow3:
	JMP SnowGuyDraw

ObjNorm_VeggieGuy:
	LDA <Player_HaltGame
	BNE VeggieGuyDraw

	JSR Object_DeleteOffScreen
	JSR Player_HitEnemy
	JSR Object_InteractWithWorld
	JSR Object_HandleBumpUnderneath
	LDA Objects_DetStat,X 
	AND #$04
	BEQ ObjNorm_VeggieGuy1
	LDA Objects_PrevDetStat,X 
	AND #$04
	BNE ObjNorm_VeggieGuy1

	JSR ObjInit_VeggieGuy

ObjNorm_VeggieGuy1:
	LDA Objects_Var1,X
	JSR DynJump

	.word VeggieGuyMarch
	.word VeggieGuyPull
	.word VeggieGuyWait
	.word VeggieGuyCarry

VeggieGuyMarch:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

	LDA Objects_Var2, X
	BNE VeggieGuyDraw

	LDA <Objects_X,X
	AND #$0F
	BEQ VeggieGuyFindGrass

VeggieGuyDraw:
	LDA Objects_Frame,X
	CMP #$03
	BEQ VeggieGuyDrawMirrored
	CMP #$06
	BEQ VeggieGuyDrawMirrored
	JSR Object_ShakeAndDraw
	JSR VeggieGuyDrawVeggieCarried

VeggieGuyDraw1:
	RTS

VeggieGuyDrawMirrored:
	JSR Object_ShakeAndDrawMirrored
	JSR VeggieGuyDrawVeggieCarried
	RTS

VeggieGuyDrawVeggieCarried:
	LDA Objects_Var2, X
	BEQ VeggieGuyDrawVeggieCarried1
	
	LDY Object_SprRAM, X
	LDA #$B3
	STA Sprite_RAM + 9, Y
	STA Sprite_RAM + 13, Y
	
	LDA #SPR_PAL2
	STA Sprite_RAM + 10, Y
	ORA #SPR_HFLIP
	STA Sprite_RAM + 14, Y
	
	 
	LDA Sprite_RAM + 3, Y
	STA Sprite_RAM + 11, Y
	LDA Sprite_RAM + 7, Y
	STA Sprite_RAM + 15, Y
	
	LDA Sprite_RAM , Y
	SUB #$10
	BCC VeggieGuyDrawVeggieCarried1
	STA TempA
	LDA Objects_Frame, X
	AND #$01
	ADD TempA
	STA Sprite_RAM + 8, Y
	STA Sprite_RAM + 12, Y

VeggieGuyDrawVeggieCarried1:
	RTS

VeggieGuyFindGrass:
	LDA Objects_LastProp, X
	AND #$0F
	CMP #TILE_PROP_ENEMY
	BNE VeggieGuyFindGrass1 
	INC Objects_Var1, X
	LDA #$18
	STA Objects_Timer, X
	LDA #$00
	STA Objects_XVel, X
	LDA #$06
	STA Objects_Frame, X

VeggieGuyFindGrass1:
	JMP VeggieGuyDraw

VeggieGuyPull:
	LDA Objects_Timer, X
	BNE VeggieGuyFindGrass1
	LDA Level_ChgTileEvent
	BNE VeggieGuyPull1
	INC Objects_Var2, X

	LDA Objects_LastTile, X
	AND #$C0
	ORA #$01
	STA Level_ChgTileEvent
	LDA <Objects_Y, X
	STA Objects_LastTileY
	LDA <Objects_YHi, X
	STA Objects_LastTileYHi

	JSR SetObjectTileCoord
	LDA #$E0
	STA Objects_YVel, X
	INC Objects_Var1, X
	LDA #$03
	STA Objects_Frame, X

VeggieGuyPull1:
	JMP VeggieGuyDraw

VeggieGuyWait:
	LDA Objects_DetStat, X
	AND #HIT_DET_GRND
	BEQ VeggieGuyWait1
	INC Objects_Var1, X

VeggieGuyWait1:
	JMP VeggieGuyDraw

VeggieGuyCarry:
	LDA #$10
	JSR Level_ObjCalcXBlockDiffs
	CMP #$04
	BCS VeggieGuyCarryVeggi2
	JSR Level_ObjCalcYBlockDiffs
	CMP #$02
	BCS VeggieGuyCarryVeggi2
	JSR SpecialObj_FindEmptyAbort
	LDA #SOBJ_VEGGIE
	STA SpecialObj_ID,Y

	LDA Objects_X,X
	STA SpecialObj_XLo,Y

	LDA Objects_Y, X
	SUB #$10
	STA SpecialObj_YLo,Y
	LDA Objects_YHi, X
	SBC #$00
	STA SpecialObj_YHi,Y
	LDA #$20	 ; Y = $30
	STA TempA

	LDA Objects_XVel, X
	ROL A
	BCC ThrowVeggie	 ; If Buster's turned around, jump to PRG002_A5F2
	LDA #-$20	 ; Otherwise, Y = -$30
	STA TempA

ThrowVeggie:
	LDA TempA
	STA SpecialObj_XVel,Y

	; Set Y velocity
	LDA #-$18
	STA SpecialObj_YVel,Y

	LDA #$00
	STA Objects_Var1, X
	STA Objects_Var2, X

VeggieGuyCarryVeggi2:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	ADD #$04
	STA Objects_Frame, X

VeggieGuyCarryVeggi3:
	JMP VeggieGuyDraw

ObjNorm_ShyGuy:
	LDA <Player_HaltGame
	BNE ShyGuyDraw

	JSR Object_DeleteOffScreen
	JSR Player_HitEnemy
	JSR Object_InteractWithWorld
	JSR Object_HandleBumpUnderneath
	LDA Objects_DetStat,X 
	AND #$04
	BEQ ObjNorm_ShyGuy1
	LDA Objects_PrevDetStat,X 
	AND #$04
	BNE ObjNorm_ShyGuy1

	JSR ObjInit_ShyGuy

ObjNorm_ShyGuy1:
	LDA Objects_Var1,X
	JSR DynJump

	.word ShyGuyMarch
	.word ShyGuyGetBrick
	.word ShyGuyCarryBrick
	.word ShyGuyWait

ShyGuyMarch:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

	LDA <Objects_X,X
	AND #$0F
	BEQ ShyGuyFindBrickAbove


ShyGuyDraw:
	LDA Objects_Frame,X
	CMP #$03
	BEQ ShyGuyDrawMirrored
	JSR Object_ShakeAndDraw
	JSR ShyGuyDrawBrickCarried

ShyGuyDraw1:
	RTS

ShyGuyDrawMirrored:
	JSR Object_ShakeAndDrawMirrored
	JSR ShyGuyDrawBrickCarried
	RTS

ShyGuyDrawBrickCarried:
	LDA Objects_Var2, X
	BEQ ShyGuyDrawBrickCarried1
	
	LDY Object_SprRAM, X
	LDA #$67
	STA Sprite_RAM + 9, Y
	STA Sprite_RAM + 13, Y
	
	LDA #SPR_PAL3
	STA Sprite_RAM + 10, Y
	ORA #SPR_HFLIP
	STA Sprite_RAM + 14, Y
	
	 
	LDA Sprite_RAM + 3, Y
	STA Sprite_RAM + 11, Y
	LDA Sprite_RAM + 7, Y
	STA Sprite_RAM + 15, Y
	
	LDA Sprite_RAM , Y
	SUB #$10
	BCC ShyGuyDrawBrickCarried1
	STA TempA
	LDA Objects_Frame, X
	AND #$01
	ADD TempA
	STA Sprite_RAM + 8, Y
	STA Sprite_RAM + 12, Y

ShyGuyDrawBrickCarried1:
	RTS

ShyGuyFindBrickAbove:
	LDA <Objects_Y,X
	STA <Temp_Var14
	LDA <Objects_YHi, X
	STA <Temp_Var15
	LDA #$03
	STA <Temp_Var16

ShyGuyLookForBrick:
	LDA <Objects_Y, X
	SUB #$10
	STA <Objects_Y, X
	LDA <Objects_YHi, X
	SBC #$00
	STA <Objects_YHi, X
	LDY #$00
	JSR Object_DetectTile
	CMP #TILE_ITEM_COIN
	BCS ShyGuyBrickFound
	DEC <Temp_Var16
	BPL ShyGuyLookForBrick
	JSR ShyGuyRestore
	JMP ShyGuyDraw

ShyGuyBrickFound:
	LDA #$03
	STA Objects_Frame, X
	LDA #$BC
	STA <Objects_YVel, X
	LDA #$00
	STA <Objects_XVel, X
	INC Objects_Var1, X

	JSR ShyGuyRestore
	JMP ShyGuyDraw

ShyGuyRestore:
	LDA <Temp_Var14
	STA <Objects_Y,X
	LDA <Temp_Var15
	STA <Objects_YHi, X
	RTS

ShyGuyGetBrick:
	LDA <Objects_DetStat, X
	AND #$04
	BEQ ShyGuyGetBrick2
	LDY #$00
	LDA Objects_Var2,X
	BEQ ShyGuyGetBrick0
	LDY #$02

ShyGuyGetBrick0:
	TYA
	STA Objects_Var1, X

ShyGuyGetBrick1:
	JMP ShyGuyDraw

ShyGuyGetBrick2:
	LDA Level_ChgTileEvent
	BNE ShyGuyGetBrick1
	LDA Object_TileFeetProp
	CMP #TILE_ITEM_COIN
	BCC ShyGuyGetBrick1
	AND #$0F
	TAY
	LDA BrickBustPowerUp, Y
	STA Objects_Var5, X
	LDA Brick_StarManFlash, Y
	STA Objects_Var7, X
	INC Objects_Var2, X

	LDA Object_TileFeetValue
	AND #$C0
	ORA #$01
	STA Level_ChgTileEvent
	LDA <Objects_Y, X
	SUB #$08
	STA Objects_LastTileY
	LDA <Objects_YHi, X
	SBC #$00
	STA Objects_LastTileYHi

	JSR SetObjectTileCoord

	JMP ShyGuyDraw

ShyGuyThrowDistance: .byte $40, $B0
ShyGuyCarryBrick:
	LDA #$10
	JSR Level_ObjCalcXBlockDiffs
	CMP #$04
	BCS ShyGuyCarryBrick2
	JSR Level_ObjCalcYBlockDiffs
	CMP #$02
	BCS ShyGuyCarryBrick2
	JSR FindEmptyEnemySlot
	CPX #$FF
	BEQ ShyGuyCarryBrick2

FoundEmptyForBrick:
	LDA #OBJ_BRICK
	STA Level_ObjectID,X

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDY <SlotIndexBackup
	LDA Objects_X,Y
	STA <Objects_X,X

	LDA Objects_Var5, Y
	STA Objects_Var5, X
	LDA Objects_Var7, Y
	STA Objects_Var7, X

	; Set X Hi
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	; Set Y/Hi
	LDA Objects_Y,Y
	SUB #16
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	LDA Objects_XVel, Y
	LDY #$20	 ; Y = $30
	ROL A
	BCC ThrowBrick	 ; If Buster's turned around, jump to PRG002_A5F2
	LDY #-$20	 ; Otherwise, Y = -$30

ThrowBrick:
	STY <Objects_XVel,X

	; Set Y velocity
	LDA #-$20
	STA <Objects_YVel,X
	LDA #$03
	STA Objects_SprAttr, X

	LDX <SlotIndexBackup
	LDA #$00
	STA Objects_Var1, X
	STA Objects_Var2, X

ShyGuyCarryBrick2:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	ADD #$04
	STA Objects_Frame, X

ShyGuyCarryBrick3:
	JMP ShyGuyDraw


ShyGuyWait:
	LDA #SPR_BEHINDBG
	ORA Objects_SprAttr,X
	STA Objects_SprAttr,X
	LDA #$10
	JSR Level_ObjCalcXBlockDiffs
	CMP #$04
	BCS ShyGuyCarryBrick3

	INC Objects_Var1,X
	BNE ShyGuyCarryBrick3

ShyGuySurprise:
	
Object_CheckIfNormalState:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	RTS		 ; Return


BrickBust_MicroGoomba:
	LDA #$04	 ; A = 4 (the Microgoomba that falls out of a Piledriver)

PRG003_A4DD:
	STA <Temp_Var16	 ; Input value -> Temp_Var16

	; Crumbling brick sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDA #$00
	STA TempA
	LDA Level_ObjectID,X
	CMP #OBJ_ICEBLOCK
	BNE PRG003_A4E9
	LDA #$01
	STA TempA

PRG003_A4E9:
	LDA Objects_State + 5
	BNE PRG003_A4E92

	LDA Objects_Var5, X
	BEQ PRG003_A4E92

	STA Level_ObjectID + 5
	LDA Objects_Var7, X
	STA PUp_StarManFlash
	LDA #OBJSTATE_INIT
	STA Objects_State + 5
	LDA #$C0
	STA <Objects_YVel + 5
	STA PowerUp_NoRaise
	LDY #$10
	LDA <Objects_XVel, X
	BPL PRG003_A4E91
	LDY #$F0

PRG003_A4E91:
	TYA
	STA <Objects_XVel + 5
	LDA <Objects_X, X
	STA <Objects_X + 5
	LDA <Objects_Y, X
	STA <Objects_Y  + 5
	LDA <Objects_XHi, X
	STA <Objects_XHi + 5
	LDA <Objects_YHi, X
	STA <Objects_YHi  + 5

PRG003_A4E92:
	JSR Object_SetDeadEmpty	; Destroy the Ice Block

	; Break apart into the four brick bust pieces
PRG003_A4EA:
	JSR BustBlock_Segment 	; Generate Ice block segment

	LDA TempA
	STA SpecialObj_Var2,Y

PRG003_A4EB:
	DEC <Temp_Var16		; Temp_Var16--
	BPL PRG003_A4EA		; While Temp_Var16 >= 0, loop!

	RTS		 ; Return

Piledriver_YOff:	.byte $01, $00, $02, $04, $05, $02

	; "Bust block" is an ice block that smashed into wall or a Microgoomba brick getting busted
	; First four are the brick bits, the last is the microgoomba
BustBlock_YOffByInput:	.byte -$04, -$04, $04, $04, $00
BustBlock_YHiOffByInput:	.byte  $FF,  $FF, $00, $00, $00
BustBlock_YVelByInput:	.byte $C0, $C0, $D0, $D0, $D0
BustBlock_XVelByInput:	.byte $F8, $08, $F8, $08, $00 

	; Generates a segment of the busted brick (or microgoomba in the case of the Piledriver)
BustBlock_Segment:
	LDY #$07	 ; Y = 7 (wider expanse of special object slots)

	JSR SpecialObj_FindEmptyAbortY	 ; Find an empty special object slot or don't come back here...

	; Temp_Var1 = Ice Block's Y
	LDA <Objects_Y,X
	STA <Temp_Var1

	; Temp_Var3 = Ice Block's Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var3

	; Temp_Var2 = Ice Block's X
	LDA <Objects_X,X
	STA <Temp_Var2

	; X = Temp_Var16 (input value for Ice Block)
	LDX <Temp_Var16

	; Add Y offset by input
	LDA <Temp_Var1
	ADD BustBlock_YOffByInput,X
	STA SpecialObj_YLo,Y
	LDA <Temp_Var3
	ADC BustBlock_YHiOffByInput,X
	STA SpecialObj_YHi,Y

	; X Lo = Temp_Var2
	LDA <Temp_Var2
	STA SpecialObj_XLo,Y

	; Set Ice Block Y Velocity by input
	LDA BustBlock_YVelByInput,X
	STA SpecialObj_YVel,Y

	; Set Ice Block X Velocity by input
	LDA BustBlock_XVelByInput,X
	STA SpecialObj_XVel,Y

	LDA #SOBJ_BRICKDEBRIS	 ; Busting brick, input value 4 only
 
	CPX #$04	 ; X = 4
	BNE PRG003_A54E	 ; If input value <> 4, jump to PRG003_A54E

	LDA #SOBJ_MICROGOOMBA	 ; Otherwise, micro Goomba

PRG003_A54E:
	STA SpecialObj_ID,Y	 ; Set appropriate ID

	LDA #$ff
	STA SpecialObj_Data,Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG003_A567:
	RTS		 ; Return

Twirler_InitXVel:	.byte $08, -$08
Twirl_DropXVel: .byte $18, $E8

ObjInit_Twirling:
	JSR Level_ObjCalcXDiffs

	; Set twirler X velocity towards Player
	LDA Twirler_InitXVel,Y
	STA <Objects_XVel,X

	; Set vertically flipped
	LDA #SPR_VFLIP
	STA Objects_FlipBits,X

	DEC <Objects_Y,X	 ; Start one pixel higher

	LDY <Objects_Y,X
	INY	
	BNE PRG003_A580
	DEC <Objects_YHi,X	 ; Apply carry
PRG003_A580:

	RTS		 ; Return

; FIXME: Anybody want to claim this?
; $A581
	.byte $F8, $08

ObjNorm_TwirlingShell:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR TwirlShell_Draw	 	; Draw the twirling shell enemy

	LDA <Player_HaltGame
	BNE PRG003_A5EF	 ; If gameplay halted, jump to PRG003_A5EF

	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath

	LDA Level_ObjectID,X
	CMP #OBJ_BUZZYBEATLE
	BNE PRG003_A59A	 ; If object has not become a Buzzle Beatle, jump to PRG003_A59A

	JMP Object_SetShellState ; Set shell state and don't come back!

PRG003_A59A:
	LDY #$00	 ; Y = 0

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A5A3	 ; 8 ticks on, 8 ticks off; jump to PRG003_A5A3

	INY		 ; Y = 1

PRG003_A5A3:
	TYA
	STA Objects_Frame,X	 ; Toggle frame 0/1

	JSR Object_ApplyXVel	 ; Apply X velocity

	; Maintain Y Velocity = -$01 (sticks to ceiling)
	LDA #-$01
	STA <Objects_YVel,X

	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$08
	BNE PRG003_A5CA	 ; If still detecting ceiling, jump to PRG003_A5CA

	; No more ceiling!

	INC Objects_Var7,X	 ; Var7++

	LDA Objects_Var7,X
	CMP #$02
	BGE PRG003_A5DB	 	; If Var7 >= 2, jump to PRG003_A5DB

	JSR Object_AboutFace	; Turn around
	JSR Object_ApplyXVel	; Apply X velocity
	JMP PRG003_A5CF		; Jump to PRG003_A5CF

PRG003_A5CA:
	; Var7 = 0
	LDA #$00
	STA Objects_Var7,X

PRG003_A5CF:
	JSR Level_ObjCalcXDiffs	

	LDA <Temp_Var16
	ADD #$30
	CMP #$60
	BGE PRG003_A5EF	 ; If Player is not close enough, jump to PRG003_A5EF

PRG003_A5DB:

	; Go into "kicked" state!
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	LDA ObjGroupRel_Idx
	ASL A		; 2 byte index for ObjectGroup02_CollideJumpTable
	TAY		; Y = offset into ObjectGroup_CollideJumpTable

	LDA ObjectGroup02_CollideJumpTable,Y
	STA Level_ObjectID,X	 ; Change into the appropriate target object

	JSR Level_ObjCalcXDiffs
	LDA Twirl_DropXVel, Y
	STA <Objects_XVel,X

PRG003_A5EF:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A5F8	 ; If object has not hit a wall, jump to PRG003_A5F8

	JSR Object_AboutFace	 ; Otherwise, turn around...

PRG003_A5F8:
	RTS		 ; Return

	; Unused data I think?  Possibly was for the twirling shell

TwirlShell_Draw:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

	LDA Objects_Frame,X
	CMP #$02
	BLT PRG003_A613	 ; If frame < 2, jump to PRG003_A613

	; Clear horizontal flip on frame 2+
	LDA Objects_FlipBits,X
	AND #~SPR_HFLIP
	STA Objects_FlipBits,X

PRG003_A613:
	JMP Object_ShakeAndDraw	 ; Draw shelled enemy and don't come back!

ObjInit_DonutLift: 
	RTS		 ; Return

ObjNorm_DonutLift:
	JSR Object_SetPaletteFromAttr	 ; Set palette

	LDY #$5a	 ; Y = $5A (Patterns for donut lift, vertical only)

	LDA Level_7Vertical
	BNE PRG003_A62A	 ; If this level is vertical, jump to PRG003_A62A

	LDA Level_TilesetIdx
	CMP #$01
	BNE PRG003_A62D	 ; If tileset is not Mini-Fortress style, jump to PRG003_A62D

	LDY #$12	 ; Y = $12 (Patterns for donut lift, Mini-Fortress only)

PRG003_A62A:

	; Mini-Fortress or vertical orientation only...

	STY PatTable_BankSel+4

PRG003_A62D:
	JSR Object_AnySprOffscreen
	BNE PRG003_A64E	 ; If object falls off-screen at all, jump to PRG003_A64E (destroys it)

	JSR Object_ShakeAndDraw		; Draw donut lift

	LDA <Player_HaltGame
	BNE PRG003_A651	 ; If gameplay is halted, jump to PRG003_A651 (RTS)

	LDA Objects_Var7,X
	BNE PRG003_A66A	 ; If Var7 is non-zero, jump to PRG003_A66A

	JSR Object_HitTest	 ; Do Player to object collision test

	LDA Objects_PlayerHitStat,X
	BNE PRG003_A652	 ; If Player is not touching object, jump to PRG003_A652

	LDA Level_ChgTileEvent
	BNE PRG003_A651	 ; If a tile change event is active, jump to PRG003_A651

	JSR DonutLift_ChangeBlock	; Do block change

PRG003_A64E:
	JSR Object_SetDeadEmpty	 ; Mark as dead/empty

PRG003_A651:
	RTS		 ; Return

PRG003_A652:
	DEC <Objects_Var5,X	 ; Var5--
	BNE PRG003_A65A	 	; If Var5 > 0, jump to PRG003_A65A

	INC Objects_Var7,X	 ; Var7++

	RTS		 ; Return

PRG003_A65A:
	LDA <Counter_1
	AND #$07
	STA Objects_Timer4,X	 ; Timer4 = 0 to 7

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_A669	 ; If Player has not touched donut lift, jump to PRG003_A669 (RTS)

	JSR PRG003_A67C

PRG003_A669:
	RTS		 ; Return

PRG003_A66A:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y limit

	LDA <Objects_YVel,X
	CMP #$40
	BGS PRG003_A677	 ; If donut lift is moving downward faster than $40, jump to PRG003_A677

	; Gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG003_A677:
	JSR Object_HitTest	 ; Do Player to object collision detection
	BCC PRG003_A691	 ; If no collision, jump to PRG003_A691 (RTS)

PRG003_A67C:
	LDA <Player_YVel
	BMI PRG003_A691	 ; If Player is moving upward, jump to PRG003_A691 (RTS)

	; Otherwise, lock Player at 31 pixels above donut lift
	LDA <Objects_Y,X
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Player is not in air
	LDA #$00
	STA <Player_InAir

PRG003_A691:
	RTS		 ; Return

DonutLift_ChangeBlock:
	; Queue tile change event
	LDA #$80
	STA Level_ChgTileEvent

	; Block change to occur at Y+1
	LDA <Objects_Y,X
	ADD #$01
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	LDA <Objects_XHi,X
	STA Level_BlockChgXHi
	LDA <Objects_X,X
	STA Level_BlockChgXLo

	RTS		 ; Return

ObjNorm_Explosion:
	JSR Object_DeleteOffScreen
	LDA TrapSet
	BEQ NoExplosionYet
	JMP MineDoExplode

NoExplosionYet:
	RTS
	; Bob-omb's starting X velocity depending on where Player is
BobOmb_StartXVel:	.byte $08, -$08

	; Bob-omb's starting X velocity depending on where Player is
BobOmbExp_StartXVel:	.byte $10, -$10

ObjInit_BobOmb:
	JSR Level_ObjCalcXDiffs

	; Start Bob-omb moving towards Player
	LDA BobOmb_StartXVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_BobOmbExplode:
	LDA #$80
	STA Objects_Timer, X
	RTS		 ; Return

ObjNorm_BobOmb:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Objects_Var5,X
	CMP #$02
	BEQ PRG003_A6DD	 ; If Var5 = 2 (Exploding), jump to PRG003_A6DD

	LDA Objects_Timer2, X
	BEQ PRG003_A6DC

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoLimit
	LDA #(SPR_PAL1 | SPR_BEHINDBG)
	STA Objects_SprAttr, X
	JMP Object_ShakeAndDraw

PRG003_A6DC:
	JSR Object_ShakeAndDraw	 ; Normally draw Bob-omb (Except when exploding)

	LDA <Player_HaltGame
	BNE PRG003_A6E8	 ; If gameplay halted, jump to PRG003_A6E8 (RTS)

	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

PRG003_A6DD:
	LDA <Objects_Var5,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BobOmb_WalkAround		; 0: Unsquashed Bob-omb minding his own business
	.word BobOmb_FlashToExplode	; 1: Squashed Bob-omb who then flashes and explodes
	.word BobOmb_DoExplosion	; 2: Do the explosion, kill things, etc.
	.word BobOmb_Unstable

PRG003_A6E8:
	RTS		 ; Return

BobOmb_WalkAround:
	
	LDA Objects_PrevDetStat, X
	AND #$04
	BNE BobOmb_WalkAround1

	LDA <Objects_DetStat, X
	AND #$04
	BEQ BobOmb_WalkAround1

	JSR Level_ObjCalcXDiffs

	; March toward Player
	LDA BobOmbExp_StartXVel,Y
	STA <Objects_XVel,X

BobOmb_WalkAround1:

	JSR Object_InteractWithWorld	 ; Do standard movements

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

PRG003_A739:
	JSR Object_HandleBumpUnderneath
	BCC PRG003_A75E	 ; If Bob-omb wasn't hit from underneath, jump to PRG003_A75E

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_A75E	 ; If Player didn't touch Bob-omb, jump to PRG003_A75E (RTS)


PRG003_A74B:
	LDA Objects_Property, X
	BEQ PRG003_A74D
	INC <Objects_Var5,X
	INC <Objects_Var5,X

PRG003_A74D:
	INC <Objects_Var5,X

	LDA #OBJSTATE_SHELLED
	STA Objects_State, X
	LDA #$ff
	STA Objects_Timer,X

	; Little bounce for the Player
	LDA #-$30
	STA <Player_YVel

	JMP PRG003_A7FE	 ; Just do Bob-omb death

PRG003_A75E:
	RTS		 ; Return

PRG003_A75F:
	.byte $10, $20, $30, $40, $FC, $F8, $F4, $F0

BobOmb_Unstable:

	LDA Objects_PrevDetStat, X
	BNE BobOmb_Unstable1

	LDA Objects_DetStat, X
	BEQ BobOmb_Unstable1

	JMP BobOmb_Explode

BobOmb_Unstable1:
	JSR PRG003_A79F
	LDY Object_SprRAM, X
	LDA <Counter_1
	AND #$01
	BEQ BobOmb_Unstable2
	TYA
	TAX
	DEC Sprite_RAM,X
	DEC Sprite_RAM+4,X

BobOmb_Unstable2:
	RTS


BobOmb_FlashToExplode:
	LDA Objects_Timer,X
	BNE PRG003_A798	 ; If timer not expired, jump to PRG003_A798

	; Timer expired...

BobOmb_Explode:
	; Var3 = 0
	LDA #$00
	STA Objects_Var3,X

	; Set internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Reset timer to $28 (length of explosion)
	LDA #$10
	STA Objects_Timer,X

	; Ba-boom
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Since Bob-omb is exploding, he no longer needs to enforce his pattern bank
	INC Objects_DisPatChng,X

SetRotatingColor:
	LDA #$10
	STA RotatingColor_Cnt

	RTS		 ; Return


PRG003_A798:

	; Bob-omb's timer hasn't gone out yet...

	CMP #$40
	BGE PRG003_A79F	 ; If timer >= $40, jump to PRG003_A79F
 
	STA Objects_ColorCycle,X	 ; Otherwise, start flashing

PRG003_A79F:
	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A7CC	 ; If Bob-omb has not hit floor, jump to PRG003_A7CC

	; This whole block works to get the X velocity arithmetically divided by 2
	LDA <Objects_XVel,X
	PHP		 ; Save CPU state
	; Get absolute value of X velocity
	BPL PRG003_A7B0
	JSR Negate

PRG003_A7B0:
	LSR A		 ; Divide by 2
	PLP		 ; Restore CPU state
	BPL PRG003_A7B7	 ; If the X velocity was positive, jump to PRG003_A7B7
	JSR Negate	 ; Otherwise, make this negative again

PRG003_A7B7:
	STA <Objects_XVel,X	 ; X velocity now divided by 2

	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	JSR Object_HitGround	 ; Align to floor

	PLA		 ; Restore Y velocity
	BMI PRG003_A7CC	 ; If it's negative, jump to PRG003_A7CC

	; Bob-omb was falling downward...
	LSR A		; Divide by 2
	JSR Negate	 ; Negate it (bounce back up)
	CMP #$fc
	BGE PRG003_A7CC	 ; If the velocity was small enough, then just stop

	STA <Objects_YVel,X	 ; Otherwise, bounce away

PRG003_A7CC:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A7DC	 ; If Bob-omb did not hit a wall, jump to PRG003_A7DC

	JSR Object_AboutFace
PRG003_A7DC:
	JSR Object_HitTest
	BCC PRG003_A7F0	 ; If Player and Bob-omb didn't collide, jump to PRG003_A7F0 (RTS)

	; Otherwise, set Bob-omb's state to 4 (Held, doesn't really make sense)
	LDA #OBJSTATE_HELD
	STA Objects_State,X

PRG003_A7F0:
	RTS		 ; Return

BobOmb_Kill:
	; Player bounces
	LDA #-$30
	STA <Player_YVel

	; Set Bob-omb state to Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; A little bounce from the Bob-omb
	LDA #-$10
	STA <Objects_YVel,X

PRG003_A7FE:

	; "Kick" noise
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	RTS		 ; Return

	; X and Y offsets for the exploding Bob-omb stars
BombStars_XOff:	.byte -$04, $04, $08, $04, -$04, -$08, $00, $08, $08, $00, -$08, -$08
BombStars_YOff:	.byte -$08, -$08, $00, $08, $08, $00, $08, $04, -$04, -$08, -$04, $04

BobOmb_DoExplosion:
	LDA <Player_HaltGame
	BNE PRG003_A82E	 ; If gameplay is halted, jump to PRG003_A82E

	INC <Objects_Var4,X	 ; Otherwise, Var4++

PRG003_A82E:
	LDA Objects_Timer,X
	BNE PRG003_A836	 ; If timer has not expired, jump to PRG003_A836

	JMP Object_SetDeadEmpty	 ; Otherwise, mark Bob-omb as Dead/Empty and don't come back!

PRG003_A836:
	JSR Object_CalcSpriteXY_NoHi

	; Temp_Var16 = 5
	LDA #$05
	STA <Temp_Var16

PRG003_A83D:
	; Temp_Var1 = Bob-omb's sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1	

	; Temp_Var2 = Bob-omb's sprite X + 4
	LDA <Objects_SpriteX,X
	ADD #$04
	STA <Temp_Var2

	LDA <Objects_Var4,X
	LSR A		 ; Var4 / 2
	PHA		 ; Save value

	; Temp_Var3 = 0 to 3, depending on Var4 / 2
	AND #$03
	STA <Temp_Var3

	LDX <Temp_Var16	 ; X = Temp_Var16

	PLA		 ; Restore Var4 / 2

	AND #$04	 ; Mask 0-3
	BEQ PRG003_A85C	 ; If result is zero, jump to PRG003_A85C

	; Otherwise, X += 6
	TXA
	ADD #$06
	TAX

PRG003_A85C:
	LDA <Temp_Var1
	ADD BombStars_YOff,X
	STA <Temp_Var1

	LDA <Temp_Var2
	ADD BombStars_XOff,X
	STA <Temp_Var2

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG003_A85C	 ; While Temp_Var3 >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	JSR Sprite_NoCarryIfVisible
	BCS PRG003_A89D	 ; If this star is not visible, jump to PRG003_A89D

	LDA <Temp_Var16
	ASL A
	ASL A		; A = Temp_Var16 * 4 (one sprite per star)
	ADC Object_SprRAM,X	 ; Add the base Sprite_RAM offset
	TAY		 ; -> 'Y'

	; Star Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Star X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; Star pattern
	LDA #$73
	STA Sprite_RAM+$01,Y

	LDA <Counter_1
	LSR A	
	LSR A	
	ADD <SlotIndexBackup
	AND #$03	 ; Palette select 0 to 3
	STA Sprite_RAM+$02,Y	 ; Set attributes

	JSR PRG003_BD1E	 ; Uses part of the "Tail" hurt code, checks if Player has been hit by explosion

PRG003_A89D:
	DEC <Temp_Var16	 ; Temp_Var16--
	BPL PRG003_A83D	 ; While Temp_Var16 >= 0, loop!

	JSR Object_AnySprOffscreen
	BNE PRG003_A8D2	 ; If any part of the exploding Bob-omb has fallen off-screen, jump to PRG003_A8D2

	JSR BobOmb_CalcULOffXY	; (large bounding box for explosion)

	; Temp_Var13 = 0
	LDA #$00
	STA <Temp_Var13

	JSR PRG000_DC09	 ; Object-to-object collision test sans visibility check and bounding box calculation
	BCC PRG003_A8D2	 ; If there hasn't been a collision, jump to PRG003_A8D2 (RTS)

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Set object to state Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,Y

	; Killed object bounces up a bit
	LDA #-$30
	STA Objects_YVel,Y

	; Halt horizontal movement
	LDA #$00
	STA Objects_XVel,Y

	; Var3 works as a kill counter for things killed by the explosion
	LDA Objects_Var3,X
	INC Objects_Var3,X

	INC Exp_Earned	 ; Get score for that

PRG003_A8D2:

BobOmb_CheckExplodables:
	JSR BackUpPosition
	LDA Objects_Timer,X
	AND #$07
	TAY
	JSR OffsetPosition
	LDX <SlotIndexBackup
	JSR CheckBreakables
	JSR RestorePosition

NoMoreExplodables:
	RTS

ExplodeXOffsets:
	.byte -$10, -$10, -$10, $00, $10, $10, $10, $00

ExplodeYOffsets
	.byte -$08, $08, $18, $18, $18, $08, -$08, -$08

BackUpPosition:
	LDA <Objects_X, X
	STA BackUpX
	LDA <Objects_XHi, X
	STA BackUpXHi
	LDA <Objects_Y, X
	STA BackUpY
	LDA <Objects_YHi, X
	STA BackUpYHi
	RTS

OffsetPosition:
	JSR OffsetPositionX
	JSR OffsetPositionY
	RTS

OffsetPositionX:
	LDA ExplodeXOffsets, Y
	BMI OffsetPositionX1
	ADD <Objects_X, X
	STA <Objects_X, X
	LDA <Objects_XHi, X
	ADC #$00
	STA <Objects_XHi, X
	RTS

OffsetPositionX1:
	JSR Negate
	STA TempA
	LDA <Objects_X, X
	SUB TempA
	STA <Objects_X, X
	LDA <Objects_XHi, X
	SBC #$00
	STA <Objects_XHi, X
	RTS

OffsetPositionY:
	LDA ExplodeYOffsets, Y
	BMI OffsetPositionY1
	ADD <Objects_Y, X
	STA <Objects_Y, X
	LDA <Objects_YHi, X
	ADC #$00
	STA <Objects_YHi, X
	RTS

OffsetPositionY1:
	JSR Negate
	STA TempA
	LDA <Objects_Y, X
	SUB TempA
	STA <Objects_Y, X
	LDA <Objects_YHi, X
	SBC #$00
	STA <Objects_YHi, X
	RTS

RestorePosition:
	LDX SlotIndexBackup
	LDA BackUpX
	STA <Objects_X, X
	LDA BackUpXHi
	STA <Objects_XHi, X
	LDA BackUpY
	STA <Objects_Y, X
	LDA BackUpYHi
	STA <Objects_YHi, X
	RTS

CheckBreakables:
	LDY #(OTDO_Water - Object_TileDetectOffsets)
	JSR Object_DetectTile
	JSR CheckExplodableTile
	BNE No_Exploads
	JSR ExplodeBreakBlocks

No_Exploads:
	RTS

CheckExplodableTile:
	CMP #TILE_PROP_SOLID_ALL
	BCC NotBreakable
	AND #$0F
	CMP #$0C
	BEQ ExplodeBreakBlocks
	CMP #$0D
	BEQ ExplodeBreakBlocks

NotBreakable:
	RTS

ExplodeBreakBlocks:
	LDA Object_LevelTile
	LDY Object_TileProp
	CPY #$F0
	BCC ExplodeBreakBlocks1

	AND #$C0

ExplodeBreakBlocks1:
	EOR #$01
	STA Level_ChgTileEvent

	LDA ObjTile_DetYLo
	AND #$F0
	STA Level_BlockChgYLo
	LDA ObjTile_DetYHi
	STA Level_BlockChgYHi
	
	LDA ObjTile_DetXLo
	AND #$F0
	STA Level_BlockChgXLo
	LDA ObjTile_DetXHi
	STA Level_BlockChgXHi

	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA Level_BlockChgYLo
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA Level_BlockChgXLo
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel
	RTS

	; Calculates an upper left X/Y offset
BobOmb_CalcULOffXY:
	; Temp_Var3 = Bob-omb's Sprite X - 24
	LDA <Objects_SpriteX,X	 
	SUB #24
	STA <Temp_Var3

	; Temp_Var7 = Bob-omb's Sprite Y - 24
	LDA <Objects_SpriteY,X
	SUB #24
	STA <Temp_Var7

	; Temp_Var4 and Temp_Var8 = $40
	LDA #$40
	STA <Temp_Var4
	STA <Temp_Var8

	RTS		 ; Return
MagicStarOffset:
	.byte $00, $10, $20

ObjNorm_MagicStar:
	
	JSR Object_DeleteOffScreen
	JSR Object_WorldDetect8
	JSR Magic_Star_Action
	JSR Object_ShakeAndDrawMirrored
	JSR Object_HitTest
	BCC PRG003_A92D	 ; If Player is not touching it, jump to PRG003_A92D

	JSR Increase_Magic_Stars
	JSR GetLevelBit
	STA <Temp_Var1
	STY <Temp_Var2
	LDA Objects_Var1, X
	TAY
	LDA <Temp_Var2
	ADD MagicStarOffset, Y
	TAY
	LDA <Temp_Var1
	ORA Magic_Stars_Collected1, Y
	STA Magic_Stars_Collected1, Y
	JMP Object_SetDeadEmpty

PRG003_A92D:
	RTS

Magic_Star_Action:
	LDA Objects_Property, X
	JSR DynJump

	.word ObjNorm_DoNothing
	.word Object_InteractWithWorld
	.word MagicStar_CheckEnemies
	.word MagicStar_CheckPSwitch
	.word MagicStar_CheckItemBlock
	.word MagicStar_CheckClearedBlock
	.word MagicStar_SpinnersActive

MagicStar_CheckEnemies:
	LDY #$04

CheckEnemies:
	CPY <SlotIndexBackup
	BEQ NoCheck
	LDA Objects_State, Y
	CMP #OBJSTATE_KILLED
	BCS NoCheck

	CMP #OBJSTATE_DEADEMPTY
	BNE Check_Done

NoCheck:
	DEY
	BPL CheckEnemies

	LDA #$01
	STA Objects_Property, X

Check_Done:
	PLA
	PLA
	RTS

MagicStar_CheckPSwitch:
	LDA Level_PSwitchCnt
	BNE MagicStar_CheckPSwitch1
	PLA
	PLA
	RTS

MagicStar_CheckPSwitch1:
	JMP Object_InteractWithWorld

MagicStar_CheckItemBlock:
	LDY #(OTDO_Water - Object_TileDetectOffsets)
	JSR Object_DetectTile
	LDA Object_LevelTile
	AND #$3F
	BNE MagicStar_CheckItemBlock1
	LDA #$01
	STA Objects_Property, X
	LDA #$D0
	STA Objects_YVel, X
	LDA Objects_Y, X
	SUB #$10
	STA Objects_Y, X
	LDA Objects_YHi, X
	SBC #$00
	STA Objects_YHi, X
	RTS

MagicStar_CheckItemBlock1:
	PLA
	PLA
	RTS

MagicStar_CheckClearedBlock:
	LDY #(OTDO_Water - Object_TileDetectOffsets)
	JSR Object_DetectTile
	AND #$3F
	BNE MagicStar_CheckItemBlock1
	LDA #$01
	STA Objects_Property, X
	RTS

MagicStar_SpinnersActive:
	LDY #$04
	LDX #$09

NextSpinnerCheck:
	LDA SpinnerBlockTimers, X
	BEQ NextSpinnerCheck1
	DEY
	BPL NextSpinnerCheck1
	LDX <SlotIndexBackup
	LDA #$01
	STA Objects_Property, X
	LDA #SND_LEVELUNK
	STA Sound_QLevel1
	RTS

NextSpinnerCheck1:
	DEX
	BPL NextSpinnerCheck
	PLA
	PLA
	RTS



ObjInit_MagicStar1:
	LDA #$00
	STA Objects_Var1, X
	JMP ObjInit_MagicStar

ObjInit_MagicStar2:
	LDA #$01
	STA Objects_Var1, X
	JMP ObjInit_MagicStar

ObjInit_MagicStar3:
	LDA #$02
	STA Objects_Var1, X

ObjInit_MagicStar:

	JSR GetLevelBit
	STA <Temp_Var1
	STY <Temp_Var2
	LDA Objects_Var1, X
	TAY
	LDA <Temp_Var2
	ADD MagicStarOffset, Y
	TAY
	LDA <Temp_Var1
	AND Magic_Stars_Collected1, Y
	BEQ Dont_Kill_Star

Kill_Star:
	JSR Object_Delete

Dont_Kill_Star:
	RTS		 ; Return

ObjInit_Explosion:
	RTS

Star_Vel:
	.byte -$20, -$17, $00, $17, $20, $17, $00, -$17
Star_VelEnd

Explode_Stars:
	LDY #(Star_VelEnd - Star_Vel - 1)

PRG003_AEF1:
	; Explosion star
	LDA #SOBJ_EXPLOSIONSTAR
	STA SpecialObj_ID,Y

	; Star X +4
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Star Y +16
	LDA <Objects_Y,X
	ADD #16
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,X

	; Set Y velocity
	LDA Star_Vel,Y
	STA SpecialObj_YVel,Y

	; X is rotated around by offset
	TYA
	ADD #$02
	AND #$07
	TAX

	; Set X velocity
	LDA Star_Vel,X
	STA SpecialObj_XVel,Y

	; SpecialObj_Timer = $3F
	LDA #$3F
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	DEY		 ; Y--
	BPL PRG003_AEF1	; While Y >= 0, loop!

	RTS		 ; Return

ObjInit_PiranhaSidewaysR:
	; Right-way piranha +16 X (basically start outside of pipe instead of inside)
	LDA #16
	ADD <Objects_X,X
	STA <Objects_X,X

ObjInit_PiranhaSidewaysL:

	; Start X + 1 over
	LDA <Objects_X,X
	ADD #$01
	STA <Objects_Var5,X

	; Start Y + 7 over
	LDA <Objects_Y,X
	ADD #$07
	STA <Objects_Y,X

	RTS		 ; Return


ObjNorm_PiranhaSideways:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR SidePiranha_Draw	 ; Draw piranha
	JSR Player_HitEnemy	 ; Player to piranha collision

	LDA <Player_HaltGame
	BNE PRG003_AF9C	 ; If gameplay halted, jump to PRG003_AF9C

	; Var3 is the animation timer; toggles frame 0 and 1 every 8 ticks
	INC Objects_Var3,X	; Var3++
	LDA Objects_Var3,X
	LDY #$00	 ; Y = 0
	AND #$08	 
	BEQ PRG003_AF60	 ; 8 ticks on, 8 ticks off; jump to PRG003_AF60
	INY		 ; Y = 1
PRG003_AF60:
	TYA		 
	STA Objects_Frame,X	 ; Update frame

	; Perform the state action of Var4 (0-3)
	LDA <Objects_Var4,X
	AND #$03
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word SidePiranha_HideInPipe	; Piranha hides in pipe until timer expires
	.word SidePiranha_Emerge	; Piranha emerges from pipe
	.word SidePiranha_Chomp		; Piranha sits there and chomps for a bit
	.word SidePiranha_Receed	; Piranha goes back into pipe

SidePiranha_Emerge:
	LDA <Objects_Var5,X
	SUB #25
	CMP <Objects_X,X
	BGE PRG003_AF95	 ; If (Var5 - 25) >= Piranha's X, jump to PRG003_AF95

	LDA #-$10	; Leftward moving piranha
	BNE PRG003_AF8B	 ; Jump (technically always) to PRG003_AF8B

SidePiranha_Receed:
	LDA <Objects_X,X
	ADD #$01
	CMP <Objects_Var5,X
	BGE PRG003_AF95	 ; If piranha's X >= Var5, jump to PRG003_AF95

	LDA #$10	; Rightward moving piranha

PRG003_AF8B:
	STA <Objects_XVel,X	 ; Update X velocity

	JMP Object_ApplyXVel	 ; Apply X velocity and don't come back!

SidePiranha_Chomp:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

PRG003_AF95:
	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Reset timer to $38
	LDA #$38
	STA Objects_Timer,X

PRG003_AF9C:
	RTS		 ; Return

SidePiranha_HideInPipe:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

	BEQ PRG003_AF95	 ; Otherwise, jump to PRG003_AF95

PRG003_AFA4:
	RTS		 ; Return

SidePiranha_EndSprXOff:
	.byte 16, 0

SidePiranha_Draw:
	LDA #$20	 ; A = $20 (leftward piranha attributes)

	LDY Level_ObjectID,X
	CPY #OBJ_PIRANHASIDEWAYSLEFT
	BEQ PRG003_AFB2	 ; If this is a leftward piranha, jump to PRG003_AFB2

	LDA #$60	 ; A = $60 (rightward piranha attributes)

PRG003_AFB2:
	STA Objects_FlipBits,X	 ; Set piranha attributes

	LDA <Objects_X,X
	PHA		 ; Save piranha's X

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG003_AFC9	 ; If piranha is not horizontally flipped, jump to PRG003_AFC9

	ASL Objects_SprHVis,X

	; Piranha's X += 8 (Piranha is 24 pixels wide, of which there's no routine for exactly)
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X

PRG003_AFC9:
	JSR Object_ShakeAndDraw	 ; Draw most of piranha

	PLA		 ; Restore 'X'
	STA <Objects_X,X	 ; -> 'X'

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG003_AFDC	 ; If piranha is NOT horizontally flipped, jump to PRG003_AFDC

	INY		 ; Y = 1

PRG003_AFDC:
	LDA <Objects_SpriteX,X	 ; Get piranha's sprite X
	ADD SidePiranha_EndSprXOff,Y
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X for piranha's remaining bit

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Set sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y

	; Temp_Var1 = vertical visibility
	LDA Objects_SprVVis,X
	STA <Temp_Var1

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1
	BCS PRG003_AFFA	 ; If piranha's last bit isn't vertically visible, jump to PRG003_AFFA

	STA Sprite_RAM+$10,Y	 ; Otherwise, set the Y

PRG003_AFFA:
	LDA Sprite_RAM+$02,Y	; Get attribute value from earlier piranha segment
	AND #~$03		; Clear palette select
	ORA #SPR_PAL2		; Set palette select 2
	STA Sprite_RAM+$12,Y	; -> Sprite's attribute

	; Use pattern $85
	LDA #$85
	STA Sprite_RAM+$11,Y

	RTS		 ; Return

ObjInit_WaterCurrent:
	RTS		 ; Return

CurrentUpward_YAccel:	.byte -$03, -$03, -$02, -$01, $00, $00, $00, $00, $00
CurrentDownward_YAccel:	.byte  $03,  $02,  $01,  $00, $00, $00, $00, $00, $00

ObjNorm_WaterCurrent:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	JSR Object_AnySprOffscreen
	ORA <Player_HaltGame
	BNE PRG003_B197	 ; If object falls off-screen or gameplay is halted, jump to PRG003_B197

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$08
	CMP #$20
	BGE PRG003_B18C	 ; If Player is not close enough, jump to PRG003_B18C

	JSR Level_ObjCalcYDiffs

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B157	 ; If this is a downward current, jump to PRG003_B157

	; For upward current...

	; Negate Temp_Var16
	LDA <Temp_Var16	
	JSR Negate	
	STA <Temp_Var16	
	DEY		 ; Y-- (change direction)

PRG003_B157:
	CPY #$00
	BNE PRG003_B18C	 ; If Player is on wrong side of current object, jump to PRG003_B18C

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = index relative of Player's Y offset

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BNE PRG003_B177	 ; If this is not a downard current, jump to PRG003_B177

	; Downward current...

	LDA <Player_YVel
	CMP #$3b
	BGS PRG003_B18C	 ; If Player's Y velocity >= $3B, jump to PRG003_B18C

	ADD CurrentDownward_YAccel,Y	 ; Push Player downward

	JMP PRG003_B186	 ; Jump to PRG003_B186

PRG003_B177:
	LDA Player_HitCeiling
	BNE PRG003_B18C	 ; If Player just hit off ceiling, jump to PRG003_B18C

	LDA <Player_YVel
	CMP #-$3C
	BMI PRG003_B18C	 ; If Player's Y velocity is already moving faster than -$3C, jump to PRG003_B18C

	ADD CurrentUpward_YAccel,Y	 ; Push Player upward

PRG003_B186:
	STA <Player_YVel	; Update Player's Y velocity

	; Flag Player as mid-air
	LDA #$01
	STA <Player_InAir

PRG003_B18C:
	INC <Objects_Var5,X	 ; Var5++

	LDA <Objects_Var5,X
	AND #$0f
	BNE PRG003_B197	 ; 1:16 ticks proceed, otherwise jump to PRG003_B197

	JSR Current_GenerateBubble	; Generate a bubble

PRG003_B197:
	RTS		 ; Return

Current_GenerateBubble:
	LDY #$01
	JSR SpecialObj_FindEmptyAbortY	; Find a free special object in one of the first two slots or don't come back!

	; SpecialObj_Timer = $28
	LDA #$28
	STA SpecialObj_Timer,Y

	; A bubble
	LDA #SOBJ_BUBBLE
	STA SpecialObj_ID,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,Y

	STY <Temp_Var1	 ; Special object index -> Temp_Var1

	; Apply a bit of randomness to the bubble's X
	TYA
	ADC RandomN,Y
	AND #$17
	ADD <Objects_X,X
	LDY <Temp_Var1		 ; Y = special object index
	STA SpecialObj_XLo,Y	 ; Store slightly random adjusted X -> Bubble X

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B1D7	 ; If this is a downard current, jump to PRG003_B1D7

	; Bubble appears at Y - 8
	LDA <Objects_Y,X
	SBC #$08
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = -$80
	LDA #-$80
	STA SpecialObj_YVel,Y

	RTS		 ; Return

PRG003_B1D7:
	; Bubble appears at Y + 3
	LDA <Objects_Y,X
	ADC #$03
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X	; Bug? They don't apply the carry (ADC) here!
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = $7F
	LDA #$7f
	STA SpecialObj_YVel,Y
	RTS		 ; Return

MineTrigger: .byte $20 , $18

ObjInit_FloatMine:
	LDA <Objects_X, X
	SUB #$04
	STA <Objects_X, X
	LDA <Objects_XHi, X
	SBC #$00
	STA <Objects_XHi, X
	LDA #$01
	STA Objects_InWater, X
	LDA Objects_Property, X
	BEQ ObjInit_FloatMine0
	LDA #$02
	STA Objects_Var1, X

ObjInit_FloatMine0:
	RTs

ObjNorm_FloatMine:
	LDA <Player_HaltGame
	BEQ DoMine
	JMP Mine_JustDraw

DoMine:
	JSR Object_HitTestRespond
	JSR Object_DeleteOffScreen
	JSR Object_GetAttrAndMoveTiles
	
	LDA Objects_Var1, X
	BEQ CanFreeMine

	LDA Objects_InWater, X
	BEQ MineWaterSolid

	JSR Object_ApplyYVel_NoLimit
	LDA Objects_Var1, X
	BEQ MineWaterSolid

	LDA <Counter_1
	AND #$03
	BNE MineWaterSolid

	LDA <Objects_YVel, X
	CMP #$E8
	BCS AccelMineUp
	LDA #$E8
	BNE SetYMineUpVel

AccelMineUp:
	SUB #$01

SetYMineUpVel:
	STA <Objects_YVel, X
	JMP MineWaterSolid
	
CanFreeMine:
	JSR Level_ObjCalcXDiffs
	LDA <Temp_Var16
	BPL WillFreeMine
	JSR Negate

WillFreeMine:
	CMP MineTrigger, Y
	BCS Mine_JustDraw
	INC Objects_Var1, X


MineWaterSolid:
	LDA Object_TileFeetProp
	AND #TILE_PROP_SOLID_ALL
	BEQ Mine_JustDraw
	JMP MineDoExplode

Mine_JustDraw:
	JSR Object_Draw16x32Sprite
	LDA Objects_SprHVis, X
	AND #$20
	BNE NoMineDraw
	LDA Objects_SprVVis, X
	BNE NoMineDraw
	
	LDY Object_SprRAM, X

	LDA #$85
	STA Sprite_RAM + 17, Y
	LDA #$A5
	STA Sprite_RAM + 21, Y

	LDA Objects_SpriteY, X
	STA Sprite_RAM + 16, Y
	ADD #$10
	STA Sprite_RAM + 20, Y

	LDA Objects_SpriteX, X
	ADD #$10
	STA Sprite_RAM + 19, Y
	STA Sprite_RAM + 23, Y

	LDA Sprite_RAM + 2, Y
	STA Sprite_RAM + 18, Y
	STA Sprite_RAM + 22, Y

NoMineDraw:
	RTS


MineDoExplode:
	LDA #OBJ_BOBOMBEXPLODE
	STA Level_ObjectID, X
	LDA #OBJSTATE_SHELLED
	STA Objects_State,X
	LDY Objects_SpawnIdx,X	 ; Get the spawn index of this object
	LDA Level_ObjectsSpawned,Y
	AND #$7f
	STA Level_ObjectsSpawned,Y
	RTS

ObjInit_Ninji:
	LDA #$20
	STA Objects_Timer, X
	RTS

Ninji_Facing: .byte SPR_HFLIP, $00

ObjNorm_Ninji:
	LDA <Player_HaltGame
	BNE ObjNorm_NinjiDraw

	JSR Object_DeleteOffScreen 	
	JSR Player_HitEnemy
	JSR ObjNorm_NinjiDraw
	JSR Object_InteractWithWorld	 	; Move, detect, interact with blocks of world
	JSR Object_HandleBumpUnderneath

	JSR Level_ObjCalcXDiffs

	LDA Ninji_Facing, Y
	STA Objects_FlipBits, X

	LDA Objects_Var1, X
	JSR DynJump

	.word Ninji_Idle
	.word Ninji_Jump
	.word Ninji_Hover
	.word Ninji_ThrowStar
	.word Ninji_Fall

ObjNorm_NinjiDraw:
	JSR Object_ShakeAndDraw
	LDA Objects_Var1, X
	CMP #02
	BNE NinjiDrawStar2

NinjiDrawStar:
	LDY Object_SprRAM, X
	LDA #$B9
	STA Sprite_RAM + 9, Y
	STA Sprite_RAM + 13, Y
	
	LDA #SPR_PAL3
	STA Sprite_RAM + 10, Y
	ORA #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM + 14, Y
	 
	LDA Sprite_RAM + 3, Y
	STA Sprite_RAM + 11, Y
	LDA Sprite_RAM + 7, Y
	STA Sprite_RAM + 15, Y
	
	LDA Sprite_RAM , Y
	SUB #$10
	STA Sprite_RAM + 8, Y
	STA Sprite_RAM + 12, Y
NinjiDrawStar2:
	RTS

NinjiStarXVel: .byte $20, $E0
NinjiStarYVel: .byte $60, $58, $50, $48, $40, $38, $30, $28, $20, $10

Ninji_Jumps: .byte $B0, $BC, $C8, $D4
Ninji_Idle:
	LDA Objects_Timer, X
	BNE Ninji_IdleRTS
	INC Objects_Var1, X
	LDA RandomN
	AND #$03
	TAY
	LDA Ninji_Jumps, Y
	STA <Objects_YVel, X
	INC Objects_Frame, X

Ninji_IdleRTS:
	RTS

Ninji_Jump:
	LDA <Objects_YVel, X
	BMI Ninji_Jump1
	INC Objects_Var1, X
	LDA #$08
	STA Objects_Timer, X

Ninji_Jump1:
	RTS

Ninji_Hover:
	LDA #$FF
	STA <Objects_YVel, X
	LDA Objects_Timer, X
	BNE Ninji_Hover1
	INC Objects_Var1, X

Ninji_Hover1:
	RTS

Ninji_ThrowStar:
	LDA #$00
	STA Objects_Frame, X

	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back!

	LDA #SOBJ_NINJASTAR
	STA SpecialObj_ID,Y

	; Set Boomerang at Boomerang Bro's position
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	SUB #$10
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	STY TempY
	LDA Objects_Y,X
	SUB #$10
	STA Objects_Y, X
	LDA Objects_YHi, X
	SBC #$00
	STA Objects_YHi, X
	JSR Object_CalcHomingVels
	LDA Objects_TargetingYVal, X
	ASL A
	STA SpecialObj_YVel, Y
	LDA Objects_TargetingXVal, X
	ASL A
	STA SpecialObj_XVel, Y
	LDA Objects_Y,X
	ADD #$10
	STA Objects_Y, X
	LDA Objects_YHi, X
	ADC #$00
	STA Objects_YHi, X
	INC Objects_Var1, X
	RTS		 ; Return

Ninji_Fall:
	LDA Objects_DetStat, X
	AND #$04
	BEQ Ninji_FallRTS
	LDA #$60
	STA Objects_Timer, X
	LDA #$00
	STA Objects_Var1, X
	STA Objects_Frame, X

Ninji_FallRTS:
	RTS

NinjiIdleTimes:
	.byte $30, $40, $38, $48

CheepCheepHopper_InitXVel:	.byte $0C, -$0C

ObjInit_CheepCheepHopper:
	JSR Level_ObjCalcXDiffs

	; Set hopper's initial X velocity
	LDA CheepCheepHopper_InitXVel,Y
	STA <Objects_XVel,X
	RTS		 ; Return


ObjNorm_CheepCheepHopper:
	JSR Object_DeleteOffScreen	; Delete object if it falls too far off-screen
	JSR Object_SetHFlipByXVel 	; Set horizontal flip by travel direction
	JSR Object_ShakeAndDraw	 	; Draw Cheep Chep

	LDA <Player_HaltGame
	BNE PRG003_B47A	 ; If gameplay is halted, jump to PRG003_B47A

	JSR Object_Move	 	; Do standard movements
	JSR Player_HitEnemy	 ; Player to Cheep Cheep collision

	LDA Objects_InWater,X
	BEQ PRG003_B471	 	; If Cheep Cheep is NOT in water, jump to PRG003_B471

	JSR Level_ObjCalcXDiffs	

	LDY #-$30	 ; Y = -$30

	LDA <Temp_Var16
	ADD #$40
	CMP #$80
	BGE PRG003_B46F	 ; If Cheep Cheep is not close enough to Player, jump to PRG003_B46F

	LDY #-$60	 ; Otherwise, Y = -$60
PRG003_B46F:
	STY <Objects_YVel,X	 ; Update Y velocity

PRG003_B471:

	; Toggle frame 0/1
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

PRG003_B47A:
	RTS		 ; Return

Tornado_InitXVel:	.byte $08, -$08

ObjInit_Tornado:
	JSR Level_ObjCalcXDiffs

	; Set initial X velocity towards Player
	LDA Tornado_InitXVel,Y
	STA <Objects_XVel,X

	; Var4 = $A5
	LDA #$a5
	STA <Objects_Var4,X

	RTS		 ; Return

Tornado_ParticleOffsets:
	.byte $18, $18, $17, $17, $16, $15, $14, $13, $11, $0F, $0D, $0B, $09, $07, $05, $02
	.byte $12, $12, $11, $11, $10, $0F, $0F, $0E, $0C, $0B, $09, $08, $06, $05, $03, $01
	.byte $0E, $0E, $0D, $0D, $0C, $0C, $0B, $0B, $09, $08, $07, $06, $05, $04, $02, $01
	.byte $0A, $0A, $09, $09, $09, $08, $08, $07, $07, $06, $05, $04, $03, $02, $02, $00
	.byte $07, $07, $06, $06, $06, $06, $05, $05, $04, $04, $03, $03, $02, $02, $01, $00
	.byte $03, $03, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01, $00, $00, $00
	.byte $02, $02, $01, $01, $01, $01, $01, $01, $01, $01, $01, $00, $00, $00, $00, $00
	.byte $01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

Tornado_ScatterY:
	.byte $00, $0C, $18, $24, $30, $3C, $48, $54

	; Causes wider to narrow spreading based on position of tornado particle
Tornado_SpreadFreq:
	.byte $38, $30, $28, $20, $18, $10, $08, $00

Tornado_ParticleDivCnt:
	.byte $01, $02

PRG003_B51C:
	.byte $01, $02, $01, $FF, $20, $E0

Tornado_MaskOffset:
	.byte $09, $09, $09, $08, $07, $06, $07, $08

ObjNorm_Tornado:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BNE PRG003_B534	 ; If gameplay is halted, jump to PRG003_B534

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG003_B534:
	LDY <Objects_Var4,X	 ; Y = Var4
	BNE PRG003_B53B	 ; If Var4 <> 0, jump to PRG003_B53B

	JMP Object_Delete	 ; Delete object and don't come back!

PRG003_B53B:
	LDA <Counter_1
	AND #$01
	BNE PRG003_B543	 ; Every other tick, jump to PRG003_B543

	DEC <Objects_Var4,X	 ; Var4--

PRG003_B543:
	CPY #$40
	BGE PRG003_B551	 ; If Var4 >= $40, jump to PRG003_B551

	; They possibly intended this to divide Counter_1, but because of
	; the previous AND instruction, this will shift it to nothing...
	LSR A
	LSR A
	LSR A
	LSR A

	ADD #$03
	JMP PRG003_B55D	 ; Jump to PRG003_B55D

PRG003_B551:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, by counter / 16

	LDA Tornado_MaskOffset,Y

PRG003_B55D:
	STA <Objects_Var5,X	 ; -> Var5

	STA <Temp_Var15		 ; -> Temp_Var15

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA Tornado_ParticleDivCnt,Y
	STA <Temp_Var13		 ; -> Temp_Var13

	JSR Object_CalcSpriteXY_NoHi	 ; Calculate sprites

	; Draw 7 scatter particles to represent the tornado
	LDX #$07	 ; X = 7
PRG003_B578:
	STX <Temp_Var16	 ; -> Temp_Var16

	JSR Tornado_ScatterParticle	 ; Scatters tornado particle
	JSR Tornado_DrawParticle	 ; Draw the tornado particle

	DEX		 ; X--
	BPL PRG003_B578	 ; While X >= 0, loop
 
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Player_IsDying
	ORA Player_OffScreen
	BNE PRG003_B5C2	 ; If Player is dead or off-screen, jump to PRG003_B5C2 (RTS)

	LDA Objects_Var3,X
	BEQ PRG003_B5C3	 ; If Var3 = 0, jump to PRG003_B5C3

	LDA <Counter_1
	AND #$1f
	ORA #$20
	STA Player_TwisterSpin	 ; Set Player as twirling from Tornado

	LDY #$00	 ; Y = 0

	LDA <Player_Y
	CMP #48
	BLT PRG003_B5A4	 ; If Player Y < 48, jump to PRG003_B5A4

	INY		 ; Y = 1

PRG003_B5A4:

	; Var6 keeps a copy of how it has accelerate the Player
	LDA Objects_Var6,X
	CMP Tornado_PlayerYLimit,Y
	BEQ PRG003_B5B3	 ; If Var6 = Player Y limit, jump to PRG003_B5B3

	ADD Tornado_PlayerYAccel,Y	 ; Accelerate!
	STA Objects_Var6,X	 ; Update Var6

PRG003_B5B3:
	STA <Player_YVel	 ; Set same to Player's Y velocity

	; Halt Player's horizontal movement
	LDA #$00
	STA <Player_XVel

	JSR Level_ObjCalcXDiffs	

	; Set a little plug-along value to the Player
	LDA Tornado_PlayerXVelAdj,Y
	STA Player_CarryXVel

PRG003_B5C2:
	RTS		 ; Return


PRG003_B5C3:
	JSR Level_ObjCalcXDiffs	

	; Palette select 0/1 depending on which side the particle is on
	TYA
	STA Objects_FlipBits,X

	BEQ PRG003_B5D3	 ; If on the zero side, jump to PRG003_B5D3

	; Otherwise, negate Temp_Var16
	LDA <Temp_Var16
	JSR Negate
	STA <Temp_Var16

PRG003_B5D3:

	LDA <Temp_Var16
	CMP #$10
	BGE PRG003_B5EF	 ; If Temp_Var16 >= $10, jump to PRG003_B5EF

	LDA <Player_Y
	CMP #112
	BLT PRG003_B5EF	 ; If Player Y < 112, jump to PRG003_B5EF

	INC Objects_Var3,X	 ; Var3++

	; Push Player upward
	DEC <Player_Y
	DEC <Player_Y

	STA <Player_InAir ; Flag Player as mid-air

	; Upward Player!
	LDA #-$20
	STA <Player_YVel

	; Var6 = last set Player Y velocity
	STA Objects_Var6,X

PRG003_B5EF:
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = 0-7, based on upper 3 bits of Temp_Var16
	STY <Temp_Var1	 ; -> Temp_Var1

	LDA Tornado_PlayerXVelAdj2,Y

	LDY Objects_FlipBits,X
	BNE PRG003_B604	 ; If on the 1 side, jump to PRG003_B604

	JSR Negate	 ; Otherwise, negate value from Tornado_PlayerXVelAdj2

PRG003_B604:
	STA Player_CarryXVel	 ; -> Player_XVelAdj

	LDA <Temp_Var16	
	CMP #$10
	BGE PRG003_B61C	 ; If Temp_Var16 >= $10, jump to PRG003_B61C

	LDA <Player_Y
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY		 ; Y = upper 4 bits of Player's position (i.e. the tile grid row)

	; Accelerate Player based on his vertical position
	LDA <Player_YVel
	ADD Tornado_PlayerYVelAccelByRow,Y
	STA <Player_YVel

PRG003_B61C:
	RTS		 ; Return

Tornado_PlayerYLimit:	.byte $40, -$40
Tornado_PlayerYAccel:	.byte $04, -$04
Tornado_PlayerXVelAdj:	.byte -$08, $08

Tornado_PlayerXVelAdj2:
	.byte $18, $10, $0A, $06, $00, $00, $00, $00

Tornado_PlayerYVelAccelByRow:
	.byte $10, $04, -$08, -$08, -$08, -$08, -$08, -$08, -$02, -$02, -$02, -$02, $10, $10, $10, $10

Tornado_ScatterParticle:
	TXA		  
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var14	 ; Temp_Var14 = 'X' << 4

	; Temp_Var15 += Tornado_SpreadFreq[X]
	LDA <Temp_Var15
	ADD Tornado_SpreadFreq,X
	STA <Temp_Var15

	LDA <Temp_Var15
	AND #%00001111
	TAY		 ; Y = lower 4 bits of Temp_Var15

	LDA <Temp_Var15
	AND #%00010000
	BEQ PRG003_B659	 ; If Temp_Var15 bit 4 is NOT set, jump to PRG003_B659

	; Sort of negates 'Y'
	TYA
	EOR #$ff
	TAY

PRG003_B659:
	LDA #$00

	CPY #$10
	BEQ PRG003_B668	 ; If 'Y' = $10, jump to PRG003_B668

	TYA

	AND #%00001111
	ORA <Temp_Var14	 ; OR in Temp_Var14

	TAY

	LDA Tornado_ParticleOffsets,Y	 ; A = Tornado_ParticleOffsets[Y]

PRG003_B668:
	STA <Temp_Var10		 ; -> Temp_Var10 (particle offset X)

	LDA <Temp_Var15
	AND #%00001111
	TAY		 ; Y = lower 4 bits of Temp_Var15 

	LDA <Temp_Var15
	AND #%00010000
	BNE PRG003_B679	 ; If Temp_Var15 bit 4 is set, jump to PRG003_B679

	; Sort of negates 'Y'
	TYA
	EOR #$ff
	TAY

PRG003_B679:
	LDA #$00

	CPY #$10
	BEQ PRG003_B693	 ; If 'Y' = $10, jump to PRG003_B693

	TYA

	AND #%00001111
	ORA <Temp_Var14	 ; OR in Temp_Var14

	TAY

	LDA Tornado_ParticleOffsets,Y

	LSR A
	LSR A

	LDY <Temp_Var13	 ; Y = Temp_Var13

	DEY		 ; Y--

	BEQ PRG003_B693	 ; If Y = 0, jump to PRG003_B693

	LSR A

	DEY		 ; Y--
	BEQ PRG003_B693	 ; If Y = 0, jump to PRG003_B693 (... next line)

PRG003_B693:
	STA <Temp_Var9	; -> Temp_Var9 (particle offset Y)

	LDA <Temp_Var15
	AND #%00110000
	BEQ PRG003_B6B1	 ; If neither bit 4 or 5 is set, jump to PRG003_B6B1

	CMP #%00010000
	BEQ PRG003_B6A6	 ; If bit 4 is not set, jump to PRG003_B6A6

	CMP #%00110000
	BEQ PRG003_B6B2	 ; If bit 4 and 5 are not set, jump to PRG003_B6B2

	JSR PRG003_B6B2	 ; Negate Temp_Var10

PRG003_B6A6:
	LDY #$01	 ; Y = 1

PRG003_B6A8:
	; Negate Temp_Var9/10
	LDA Temp_Var9,Y
	JSR Negate
	STA Temp_Var9,Y

PRG003_B6B1:
	RTS		 ; Return

PRG003_B6B2:
	LDY #$00	 ; Y = 0
	BEQ PRG003_B6A8	 ; Jump (technically always) to PRG003_B6A8

PRG003_B6B6:
	.byte $00, $02, $04, $06, $08, $06, $04, $02, $00, $02, $04, $06, $08, $06, $04, $50

Tornado_Masks:
	.byte $0F, $03, $01, $00, $00, $00, $00, $00

Tornado_DrawParticle:
	LDY <SlotIndexBackup 	; Y = object's slot index

	LDA Objects_Var5,Y
	BEQ PRG003_B6B1	 ; If Var5 = 0, jump to PRG003_B6B1 (RTS)

	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	TXA	; object slot index -> 'A'
	AND Tornado_Masks,Y
	STA <Temp_Var1	 ; -> Temp_Var1

	LDA <Counter_1
	AND Tornado_Masks,Y
	CMP <Temp_Var1
	BNE PRG003_B6B1	 ; If masked counter value = Temp_Var1, jump to PRG003_B6B1 (RTS)

	CPX #$06
	BLT PRG003_B6F3	 ; If object slot < 6, jump to PRG003_B6F3

	JSR Object_GetRandNearUnusedSpr

	LDX <SlotIndexBackup		 ; X = object slot index
	BGS PRG003_B6FD	 ; Jump (technically always) to PRG003_B6FD

PRG003_B6F3:
	TXA

	ASL A
	ASL A	; A *= 4 (next sprite over)

	LDX <SlotIndexBackup	 ; X = object slot index
	ADD Object_SprRAM,X	 ; Base Sprite_RAM offset

	TAY		 ; Sprite_RAM offset -> 'Y'

PRG003_B6FD:
	STY <Temp_Var14	 ; -> Temp_Var14

	LDA <Counter_1
	AND #$0f		; 0-15 counter value
	ADD Objects_SpriteY,X	; Add 0-15 to SpriteY

	; Temp_Var1 (Sprite Y) = Temp_Var16 + Tornado_ScatterY[X] + Temp_Var9
	LDX <Temp_Var16	
	ADD Tornado_ScatterY,X
	ADD <Temp_Var9
	STA <Temp_Var1

	BCS PRG003_B753	 	; If carry set, jump to PRG003_B753 (went too low, so skip it)

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$07	 ; A = 0-7
	ADD <Temp_Var16	 ; 'A' += Temp_Var16
	TAX		 ; -> 'X'

	; Temp_Var2 (Sprite X) = Tornado's Sprite X + Temp_Var10
	LDA PRG003_B6B6,X ; A = PRG003_B6B6[X]
	CLC		 ; Clear carry
	LDX <SlotIndexBackup		 ; X = object slot index
	ADC Objects_SpriteX,X
	ADD <Temp_Var10
	STA <Temp_Var2

	JSR Sprite_NoCarryIfVisible	
	BCS PRG003_B753	 ; If this particle is not visible, jump to PRG003_B753

	LDY <Temp_Var14		 ; Y = Temp_Var14

	; Set particle sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Set particle sprite X
	LDA <Temp_Var2	
	STA Sprite_RAM+$03,Y

	; Pattern $17
	LDA #$17
	STA Sprite_RAM+$01,Y

	LDX #$03	 ; X = 3

	LDA <Temp_Var15
	AND #$3F
	CMP #$20
	BLT PRG003_B74F	 ; If lower 5 bits of Temp_Var15 < $20, jump to PRG003_B74F

	LDX #$01	 ; Otherwise, X = 1

PRG003_B74F:

	; Set particle sprite attributes
	TXA
	STA Sprite_RAM+$02,Y

PRG003_B753:
	LDX <Temp_Var16	 ; X = Temp_Var16

ObjInit_Blooper:
	RTS		 ; Return


Blooper_YVelAccel:	
	.byte $02, -$02

Blooper_YVelLimit:
	.byte $24, -$24

PRG003_B763:
	.byte $00, $10, $00, $01, $FF

Blooper_FlipTowardsPlayer:
	.byte SPR_HFLIP, $00

ObjInit_BlooperWithKids:

	; Var7 = 4 (kids left)
	LDA #$04
	STA Objects_Var7,X

	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	RTS		 ; Return

ObjNorm_Blooper:
	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPER
	BNE PRG003_B781	 ; If this is not a straight Blooper, jump to PRG003_B781

	; Just a regular Blooper...

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BEQ PRG003_B77B	 ; If gameplay is not halted, jump to PRG003_B77B

	JMP Object_ShakeAndDrawMirrored	 ; Otherwise, draw Blooper and don't come back!

PRG003_B77B:
	JSR Player_HitEnemy	 ; Do Player to Blooper hit detection!
	JMP PRG003_B78B	 ; Jump to PRG003_B78B

PRG003_B781:
	JSR TailEnemy_DoStandard	 ; A Blooper with kids... gotta do Tail updates!

	LDA <Player_HaltGame
	BEQ PRG003_B78B	 ; If gameplay is not halted, jump to PRG003_B78B

	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_B78B:
	LDA Objects_Timer,X
	BEQ PRG003_B7A2	 ; If timer = 0, jump to PRG003_B7A2

	STA Objects_ColorCycle,X	; Cycle colors

	CMP #$01
	BNE PRG003_B79F	 ; If timer <> 1, jump to PRG003_B79F

	; Var7 = 0
	LDA #$00
	STA Objects_Var7,X

	JSR Blooper_LaunchKids	 ; Blooper launches off his four spawn

PRG003_B79F:
	JMP PRG003_B85C	 ; Jump to PRG003_B85C

PRG003_B7A2:
	LDA <Objects_Var5,X
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA <Objects_YVel,X
	ADD Blooper_YVelAccel,Y
	STA <Objects_YVel,X

	CMP Blooper_YVelLimit,Y
	BNE PRG003_B7B6	 ; If Blooper is not at his velocity limit, jump to PRG003_B7B6

	INC <Objects_Var5,X	 ; Otherwise, Var5++

PRG003_B7B6:
	LDA <Objects_YVel,X

	LDY Objects_FlipBits,X
	BEQ PRG003_B7C0	 ; If Blooper is not flipped, jump to PRG003_B7C0

	JSR Negate	 ; Otherwise, negate Y velocity

PRG003_B7C0:
	LDY <Objects_YVel,X
	BMI PRG003_B7DD	 ; If Bloope is moving upward, jump to PRG003_B7DD

	TXA
	LSR A
	BCC PRG003_B7D2	 ; If Blooper is an "even" slot, jump to PRG003_B7D2

	LDY #$00	 ; Y = 0

	LDA <Player_FlipBits
	BNE PRG003_B7CF	 ; If Blooper is flipped, jump to PRG003_B7CF

	INY		 ; Y = 1

PRG003_B7CF:
	JMP PRG003_B7D5	 ; Jump to PRG003_B7D5

PRG003_B7D2:
	JSR Level_ObjCalcXDiffs

PRG003_B7D5
	; Blooper faces Player
	LDA Blooper_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	LDA #$00	 ; A = 0

PRG003_B7DD:
	STA <Objects_XVel,X	 ; Update X Velocity

	JSR Object_WorldDetectN1	 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG003_B7EB	 ; If Blooper hit a wall, jump to PRG003_B7EB

	JSR Object_ApplyXVel	 ; Otherwise, apply X Velocity

PRG003_B7EB:
	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	CMP #$08
	BLS PRG003_B814	 ; If Y velocity < $08, jump to PRG003_B814

	LDA <Player_Y	
	PHA		 ; Save Player's Y

	SBC #23
	STA <Player_Y	 ; Subtract 23 from Player's Y

	LDA <Player_YHi
	PHA		 ; Save Player Y Hi
	SBC #$00	 ; Apply carry
	STA <Player_YHi	

	JSR Level_ObjCalcYDiffs

	; Restore Player Y/Hi
	PLA
	STA <Player_YHi
	PLA
	STA <Player_Y

	DEY		 ; Y--
	BEQ PRG003_B810	 ; If Y = 0, jump to PRG003_B810

	PLA		 ; Restore Y velocity

	LDA #$08
	PHA		 ; Save 8 instead

PRG003_B810:
	; Set velocity to $08
	LDA #$08
	STA <Objects_YVel,X

PRG003_B814:
	LDA <Objects_DetStat,X
	AND #$0c
	BNE PRG003_B826	 ; If Blooper hit floor or ceiling, jump to PRG003_B826

	LDA <Objects_YVel,X
	BPL PRG003_B823	 ; If Blooper is not moving upward, jump to PRG003_B823

	LDA Objects_InWater,X
	BEQ PRG003_B826	 ; If Blooper is not in water, jump to PRG003_B826

PRG003_B823:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

PRG003_B826:
	PLA		 ; Restore Y Velocity
	STA <Objects_YVel,X	 ; Update Y Veocity

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA #$01	; A = 1

	LDY <Objects_YVel,X
	BPL PRG003_B833	 ; If Blooper is not moving upward, jump to PRG003_B833

	LSR A		; A = 0

PRG003_B833:
	STA Objects_Frame,X	 ; Set frame based on movement

	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPER
	BEQ PRG003_B85F	 ; If this is a normal Blooper, jump to PRG003_B85F

	CMP #OBJ_VEGGIEGUY
	BNE PRG003_B85C	 ; If this is NOT a Blooper that launches children, jump to PRG003_B85C

	INC Objects_Var2,X	; Var2++

	LDA Objects_Var2,X
	AND #$3f
	BNE PRG003_B85C	 ; If Var2 hasn't hit 64 ticks yet, jump to PRG003_B85C

	LDA Objects_Var7,X
	CMP #$04
	BNE PRG003_B859	 ; If Var7 <> 4, jump to PRG003_B859

	; After all this, set timer to $40
	LDA #$40
	STA Objects_Timer,X

	BNE PRG003_B85C	 ; Jump (technically always) to PRG003_B85C

PRG003_B859:
	INC Objects_Var7,X	 ; Var7++

PRG003_B85C:
	JMP Tail_DrawAndHurtPlayer	 ; Jump to Tail_DrawAndHurtPlayer

PRG003_B85F:
	JMP Object_ShakeAndDrawMirrored	 ; Draw Blooper and don't come back!

BlooperKid_YVel:	.byte $F8, $08, $08, $F8
BlooperKid_XVel:	.byte $08, $08, $F8, $F8
BlooperKid_Data:	.byte $00, $00, $01, $01
BlooperKid_UNKD:	.byte $00, $01, $01, $00

Blooper_LaunchKids:

	; Temp_Var1 = 3
	LDA #$03
	STA <Temp_Var1

PRG003_B876:
	JSR SpecialObj_FindEmptyAbort

	; Blooper child
	LDA #SOBJ_BLOOPERKID
	STA SpecialObj_ID,Y

	; Blooper child X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Blooper child Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y

	; Blooper child Y Hi
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	LDX <Temp_Var1	 ; X = Temp_Var1

	LDA BlooperKid_YVel,X
	STA SpecialObj_YVel,Y

	LDA BlooperKid_XVel,X
	STA SpecialObj_XVel,Y

	LDA BlooperKid_Data,X
	STA SpecialObj_Data,Y

	LDA BlooperKid_UNKD,X
	STA SpecialObj_Var1,Y

	LDA #$ff
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup	 ; X = object slot index
	DEC <Temp_Var1		 ; Temp_Var1--
	BPL PRG003_B876	 ; While Temp_Var1 >= 0, loop 

	RTS		 ; Return

Object_SetHFlipByXVel:
	; Clear horizontal flip
	LDA Objects_FlipBits,X	 
	AND #~SPR_HFLIP

	LDY <Objects_XVel,X
	BEQ PRG003_B8C6		; If not moving horizontally, jump to PRG003_B8C6
	BMI PRG003_B8C3		; If moving leftward, jump to PRG003_B8C3

	; Moving to the right
	ORA #SPR_HFLIP	 ; Set horizontal flip

PRG003_B8C3:
	STA Objects_FlipBits,X	 ; Update flip bits

PRG003_B8C6:
	RTS		 ; Return

	; Temp_Var2 is an X input
	; I don't really understand this function, but it determines horizontal
	; visibility by Sprite X somehow. Carry set if not visible.
Sprite_NoCarryIfVisible:
	LDA Objects_SprVVis,X	 
	BNE PRG003_B8E7	 ; If any of the sprites are vertically off-screen, jump to PRG003_B8E7

	LDA <Objects_SpriteY,X
	CMP #208
	BGE PRG003_B8E7	 ; If sprite Y >= 208, jump to PRG003_B8E7

	LDY #$40	 ; Y = $40

	LDA <Objects_SpriteX,X
	BMI PRG003_B8DA	 ; If sprite X >= $80, jump to PRG003_B8DA

	LDY #$C0	 ; Y = $C0

PRG003_B8DA:
	CPY <Temp_Var2	 ; Compare $40 or $C0 to input X value

	EOR Objects_SprHVis,X

	BMI PRG003_B8E5	 ; If there are inappropriate horizontally off-screen sprites (??) jump to PRG003_B8E5

	BLT PRG003_B8E7	 ; If input X value < 'Y', jump to PRG003_B8E7 (carry clear, but will set carry)
	BGE PRG003_B8E9	 ; If input X value >= 'Y', jump to PRG003_B8E9 (carry set, but will be clear)

PRG003_B8E5:
	BLT PRG003_B8E9	 ; If input X value < 'Y', jump to PRG003_B8E9 (carry clear)

PRG003_B8E7:
	SEC		 ; Set carry
	RTS		 ; Return

PRG003_B8E9:
	CLC		 ; Clear carry
	RTS		 ; Return

Chomp_JumpYVels:	.byte -$20, -$30
Chomp_XVels:		.byte $20, -$20

ObjNorm_ChainChompFree:
	JSR Object_CheckIfNormalState
	BEQ PRG003_B8F7	 ; If in normal state, jump to PRG003_B8F7

	JMP Tail_DrawAndHurtPlayer	 ; Otherwise, jump to Tail_DrawAndHurtPlayer

PRG003_B8F7:
	LDA <Player_HaltGame
	BEQ PRG003_B8FE	 ; If gameplay is not halted, jump to PRG003_B8FE

	JMP PRG003_BB17	 ; Jump to PRG003_BB17

PRG003_B8FE:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

	; Toggle frame
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_Move
	JSR Player_HitEnemy
	LDA Objects_DetStat, X
	AND #$03
	BEQ PRG003_B932

	LDA Objects_XVel, X
	JSR Negate
	STA  Objects_XVel, X

PRG003_B932:
	LDA Objects_DetStat, X
	AND #$08
	BEQ PRG003_B933
	JSR Object_HitCeiling

PRG003_B933:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_B95A	 ; If chomp has not hit ground, jump to PRG003_B95A

	JSR Object_HitGround	 ; Align to floor

	LDA RandomN,X
	AND #$01
	TAY		 ; Y = random 0 or 1

	; Random jump velocity of two
	LDA Chomp_JumpYVels,Y
	STA <Objects_YVel,X

	JSR Level_ObjCalcXDiffs
	; Set X velocity in facing direction
	LDA Chomp_XVels,Y
	STA <Objects_XVel,X

	LDA RandomN, X
	AND #$02
	BEQ PRG003_B95A
	LDA <Objects_XVel, X
	PHP
	LSR A
	PLP
	BPL PRG003_B959
	ORA #$80

PRG003_B959:
	STA <Objects_XVel, X
	LDA <Objects_YVel, X
	ASL A
	STA <Objects_YVel, X

PRG003_B95A:
	
	JMP Enemy_DeleteIfOffAndDrawTail	 ; Jump to Enemy_DeleteIfOffAndDrawTail

ObjInit_FireSnake:
	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	; Set X velocity = 0
	LDA #$00
	STA <Objects_XVel,X

	BEQ PRG003_B96E	 ; Jump (technically always) to PRG003_B96E

ObjInit_Pyrantula:
	; Var5 = random value 
	LDA RandomN,X
	STA <Objects_Var5,X

PRG003_B96E:
	; Var7 = 4
	LDA #$04
	STA Objects_Var7,X

	RTS		 ; Return

	; Initializes the buffer which holds "tail" X and Y coordinates
Object_InitTailBuffer:
	LDY #$01	 ; Y = 1
PRG003_B976:
	LDA Buffer_Occupied,Y
	BEQ PRG003_B983	 ; If this buffer slot is empty, jump to PRG003_B983

	DEY		 ; Y--
	BPL PRG003_B976	 ; While Y >= 0, loop!

	; Giving up...

	; Do NOT return to caller
	PLA
	PLA
	JMP Object_SetDeadAndNotSpawned	; Fire Chomp can't be created...

PRG003_B983:
	; Mark buffer slot as occupied
	LDA #$01
	STA Buffer_Occupied,Y

	JSR Object_CalcSpriteXY_NoHi

	; Sprite Y -> Temp_Var1
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Sprite X -> Temp_Var2
	LDA <Objects_SpriteX,X
	STA <Temp_Var2

	TYA		
	STA Objects_Var6,X	 ; Store Buffer_Occupied slot index -> Var6

	LSR A
	ROR A
	LSR A
	LSR A	; A = $00 or $20

	; Copy sprite X and Y into buffer space
	TAX		 ; -> 'X'
	LDY #$1f	 ; Y = $1F
PRG003_B99E:
	LDA <Temp_Var1
	STA Object_BufferY,X
	LDA <Temp_Var2
	STA Object_BufferX,X

	INX		 ; X++

	DEY		 ; Y--
	BPL PRG003_B99E	 ; While Y >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	RTS		 ; Return

RotoDisc_VelAccels:
	.byte $01, $FF, $01, $FF, $01, $FF, $01, $FF, $02, $FE, $02, $FE

PRG003_B9BB:
	.byte $00, $03, $01

RotoDisc_VelLimits:
	.byte $10, $F0, $10, $F0, $10, $F0, $10, $F0

PRG003_B9C6:
	.byte $28, $D8, $28, $D8


ObjNorm_Pyrantula:
	LDA <Player_HaltGame
	BEQ PRG003_B9D4	 ; If gameplay is not halted, jump to PRG003_B9D4

	JSR Object_DeleteOffScreen
	JMP Object_ShakeAndDrawMirrored	 ; Jump (indirectly) to PRG003_BB17 (draws enemy) and don't come back!

PRG003_B9D4:

	LDA Objects_Timer,X
	BEQ PRG003_BA08	 ; If timer expired, jump to PRG003_BA08

	CMP #$10
	BNE PRG003_B9F2	 ; If timer <> $10, jump to PRG003_B9F2

PRG003_B9EF:
	JSR FireChomp_SpitFire	 ; Spit fire towards Player

PRG003_B9F2:

	LDA #$02
	STA Objects_Frame,X

PRG003_BA02:
	JSR Object_DeleteOffScreen
	JMP Object_ShakeAndDrawMirrored	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BA08:
	LDA <Counter_1
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X
	JSR PyrantulaMove	 ; Move and explode when out of fire balls!
	JSR Player_HitEnemy

Enemy_DeleteIfOffAndDrawTail:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JMP Tail_DrawAndHurtPlayer	 ; Jump to Tail_DrawAndHurtPlayer

FireChomp_XVelLimit:	.byte $0A, -$0A, $10, -$10
FireChomp_XVelAccel:	.byte $01, -$01, $01, -$01

FireChomp_FlipTowardsPlayer:	.byte SPR_HFLIP, $00

FireChomp_YVelLimit:	.byte $12, -$12
FireChomp_YVelAccel:	.byte $01, -$01

PyrantulaMove:
	JSR Object_GetAttrAndMoveTiles

	INC Objects_Var2,X	 ; Var2++

	LDA Objects_Var2,X
	AND #$7f
	BNE PRG003_BA4C	 ; 128 ticks on, 128 ticks off; jump to PRG003_BA4C

	LDA Objects_Var7,X
	BEQ PRG003_BA4C	 ; If Var7 = 0, jump to PRG003_BA4C

	; Timer = $20
	LDA #$20
	STA Objects_Timer,X

PRG003_BA4C:
	JSR Level_ObjCalcXDiffs

	LDA Objects_Var7,X
	BNE PRG003_BA5C	 ; If Var7 <> 0, jump to PRG003_BA5C

	; Y += 2
	INY
	INY

PRG003_BA5C:
	INC Objects_Var3,X	 ; Var3++

	LDA Objects_Var3,X
	LSR A
	BCC PRG003_BA72	 ; Every other tick, jump to PRG003_BA72

	LDA <Objects_XVel,X
	CMP FireChomp_XVelLimit,Y
	BEQ PRG003_BA72	 ; If Fire Chomp's X velocity is at limit, jump to PRG003_BA72

	; Otherwise, accelerate!
	ADD FireChomp_XVelAccel,Y
	STA <Objects_XVel,X

PRG003_BA72:
	LDA Object_TileWallProp
	CMP #TILE_ITEM_COIN
	BCS PRG003_BA73
	AND #$0F
	CMP #TILE_PROP_CLIMBABLE
	BNE PRG003_BA73
	JSR Object_ApplyXVel	 ; Apply X velocity

PRG003_BA73:
	LDA <Player_Y
	PHA		 ; Save Player's Y

	ADD #$00	; Add ... zero?
	STA <Player_Y	; Update Player's Y (pointless!)

	LDA <Player_YHi
	PHA		 ; Save Player's Y Hi

	ADC #$00	 ; Apply carry
	STA <Player_YHi	 ; Update Player's Y Hi

	JSR Level_ObjCalcYDiffs

	PLA		 
	STA <Player_YHi	; Restore Player's Y Hi

	PLA
	STA <Player_Y	; Restore Player's Y

	LDA Objects_Var3,X
	LSR A
	BCC PRG003_BAA0	 ; Every other count of Var3, jump to PRG003_BAA0

	LDA <Objects_YVel,X
	CMP FireChomp_YVelLimit,Y
	BEQ PRG003_BAA0	 ; If Fire Chomp's Y velocity is at limit, jump to PRG003_BAA0

	; Otherwise, accelerate!
	ADD FireChomp_YVelAccel,Y
	STA <Objects_YVel,X

PRG003_BAA0:
	LDA Object_TileFeetProp
	CMP #TILE_ITEM_COIN
	BCS PRG003_BAA1
	AND #$0F
	CMP #TILE_PROP_CLIMBABLE
	BNE PRG003_BAA1
	JMP Object_ApplyYVel_NoLimit	 ; Apply Y velocity and don't come back!

PRG003_BAA1:
	RTS
	; Moves all tail segments based on screen scroll change
TailEnemy_MoveTailWithScroll:

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	ADD #31		; +31
	TAY		; -> 'Y'

	LDX #$1f	 ; X = $1F (all buffer entries)
PRG003_BAB0:
	; Update X by scroll
	LDA Object_BufferX,Y 
	SUB Level_ScrollDiffH
	STA Object_BufferX,Y

	; Update Y by scroll
	LDA Object_BufferY,Y
	SUB Level_ScrollDiffV
	STA Object_BufferY,Y

	DEY		 ; Y-- (previous buffer)
	DEX		 ; X-- (decrement counter)
	BPL PRG003_BAB0	; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

FireChompTail_Patterns:
	.byte $65, $65, $65, $65

FireChompTail_Attributes:
	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1, SPR_PAL1


	; For objects which have "tails", like the Fire Snake, Blooper w/ kids, etc.
Tail_DrawAndHurtPlayer:
	JSR Object_DetermineHorzVis	 ; Determine is object is horizontally visible

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	PHA	; Save offset
	TAY	; -> 'Y'

	; Set buffer X
	LDA <Objects_X,X
	SUB <Horz_Scroll
	ADD Level_ScrollDiffH
	STA Object_BufferX,Y

	; Set buffer Y
	LDA <Objects_Y,X
	SUB Level_VertScroll
	ADD Level_ScrollDiffV
	STA Object_BufferY,Y

	PLA		 ; Restore offset
	ADD #$1e	 ; Add $1E (other end of the buffer)

	TAY		 ; -> 'Y'

	LDX #$1e	 ; X = $1E (going to work backward)
PRG003_BAFF:
	; Subtract and push down the line X
	LDA Object_BufferX,Y 
	SUB Level_ScrollDiffH
	STA Object_BufferX+1,Y

	; Subtract and push down the line Y
	LDA Object_BufferY,Y
	SUB Level_ScrollDiffV
	STA Object_BufferY+1,Y

	DEY		 ; Y-- (previous buffer byte)
	DEX		 ; X-- (previous buffer count)
	BPL PRG003_BAFF	 ; While X >= 0, loop!

PRG003_BB17:
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_VEGGIEGUY
	BEQ PRG003_BB24	 ; If this is a Blooper who launches off kids, jump to PRG003_BB24

	CMP #OBJ_BLOOPERWITHKIDS
	BNE PRG003_BB2A	 ; If this is not a Blooper w/ kids, jump to PRG003_BB2A

PRG003_BB24:
	JSR Object_ShakeAndDrawMirrored	 ; Draw object
	JMP PRG003_BB36	 ; Jump to PRG003_BB36

PRG003_BB2A:
	CMP #OBJ_PYRANTULA
	BEQ PRG003_BB24	 ; If this is not a Fire Chomp, jump to PRG003_BB33

	; For a Fire Chomp....

	;LDA Objects_Frame,X
	;BEQ PRG003_BB24	 ; If frame = 0, jump to PRG003_BB24

PRG003_BB33:
	JSR Object_ShakeAndDraw	 ; Draw object, not mirrored

PRG003_BB36:
	LDA Object_SprRAM,X
	ADD #$08
	STA <Temp_Var5		 ; Temp_Var5 = Sprite_RAM offset two bytes over

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	ADD #$07
	STA <Temp_Var4		 ; Temp_Var4 = offset 7 bytes into the X/Y buffer

	LDA Objects_Var7,X
	BNE PRG003_BB52	 ; If Var7 <> 0, jump to PRG003_BB52

	JMP PRG003_BBF5	 ; Jump to PRG003_BBF5

PRG003_BB52:
	STA <Temp_Var16		 ; Var7 -> Temp_Var16 (Tail length)


	; TAIL DRAW / HURT LOGIC
	; The following 

PRG003_BB54:
	LDY <Temp_Var4		 ; Y = offset into X/Y Buffer

	; Temp_Var1 = Buffer Y @ Temp_Var4
	LDA Object_BufferY,Y
	STA <Temp_Var1	

	; Temp_Var2 = Buffer X @ Temp_Var4 + 4
	LDA Object_BufferX,Y
	ADD #$04
	STA <Temp_Var2

	JSR Sprite_NoCarryIfVisible
	BCS PRG003_BBE0	 ; If carry set, sprite is not visible, jump to PRG003_BBE0

	LDY <Temp_Var5		 ; Y = Temp_Var5 (Sprite_RAM offset)

	; Store Y and X into sprite RAM
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	LDA Level_ObjectID,X
	CMP #OBJ_ROTODISCCLOCKWISE
	BGE PRG003_BBBE	 ; Basically if a Blooper jump to PRG003_BBBE

	; Fire Snake, Fire Chomp, or freed Chain Chomp

	CMP #OBJ_PYRANTULA
	BNE PRG003_BB9B	 ; If not a Fire Chomp, jump to PRG003_BB9B

	; Fire Chomp only

	LDA <Temp_Var16
	ASL A
	ADC Level_NoStopCnt
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	LDA FireChompTail_Patterns,X
	STA Sprite_RAM+$01,Y

	LDA FireChompTail_Attributes,X
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	JMP PRG003_BBDD	 ; Jump to PRG003_BBDD

PRG003_BB9B:
	CMP #OBJ_CHAINCHOMPFREE
	BEQ PRG003_BBB2	 ; If a freed Chain Chomp, jump to PRG003_BBB2

	; Fire snake

	; Sets the carry
	LDA Level_NoStopCnt
	LSR A
	LSR A

	; Something removed here
	NOP
	NOP

	LDA #$8b	 ; A = $8B
	BCC PRG003_BBAC	 ; 4 ticks on, 4 ticks off; jump to PRG003_BBAC

	LDA #$89	 ; A = $89

PRG003_BBAC:
	STA Sprite_RAM+$01,Y	 ; Store pattern $89 or $8B

	JMP PRG003_BBD2	 ; Jump to PRG003_BBD2

PRG003_BBB2:

	; Freed Chain Chomp 

	; Chain link pattern
	LDA #$BD
	STA Sprite_RAM+$01,Y

	; Palette select 3
	LDA #SPR_PAL3
	STA Sprite_RAM+$02,Y

	BNE PRG003_BBE0	 ; Jump (technically always) to PRG003_BBE0

PRG003_BBBE:
	LDA <Temp_Var16
	ASL A	
	ADC Level_NoStopCnt

	LDX #$b5	 ; X = $B5

	AND #$08
	BNE PRG003_BBCC	 ; 8 ticks on, 8 ticks off; jump to PRG003_BBCC

	LDX #$b7	 ; X = $B7

PRG003_BBCC:
	TXA		 ; Pattern -> 'X'
	STA Sprite_RAM+$01,Y	 ; Set pattern

	LDX <SlotIndexBackup	 ; X = object slot index
PRG003_BBD2:
	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Copies attribute from one sprite to the other
	LDA Sprite_RAM+$02,Y
	LDY <Temp_Var5
	STA Sprite_RAM+$02,Y

PRG003_BBDD:
	JSR Tail_CheckHurtPlayer	; Have the tail hurt the Player by touching it

PRG003_BBE0:
	LDA <Temp_Var4
	ADD #$08
	STA <Temp_Var4

	LDA <Temp_Var5
	ADD #$04
	STA <Temp_Var5

	DEC <Temp_Var16		 ; Temp_Var16-- (one less tail segment)

	BEQ PRG003_BBF5	 ; If out of segments, jump to PRG003_BBF5
	JMP PRG003_BB54	 ; Otherwise, loop!

PRG003_BBF5:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

RotoDiscSpin:
	LDA <Objects_Var4,X
	BEQ PRG003_BC6D		; If Var4 = 0, jump to PRG003_BC6D (RTS)

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_Var4,X
	CMP #$01
	BEQ PRG003_BC6D	 ; If Var4 = 1, jump to PRG003_BC6D

	; Var4 > 1...

	LSR A
	TAY		 ; Y = Var4 / 2

	INC Objects_Var3,X	; Var3++

	LDA Objects_Var3,X	; A = Var3
	AND PRG003_B9BB-1,Y	; -1 because Y will always be at least 1
	BNE PRG003_BC6D	 	; If masking of Var3 is non-zero, jump to PRG003_BC6D (RTS)

	LDA <Objects_Var4,X
	SUB #$02
	ASL A		; A = (Var4 - 2) << 1
	AND #%11111100	; Keep all bits but the lower 2
	PHA		; Save this value

	ADD Objects_TargetingXVal,X
	TAY		; -> 'Y'

	LDA <Objects_Var4,X
	AND #$01
	BEQ PRG003_BC2A	 ; If Var4 bit 0 is not set, jump to PRG003_BC2A
	INY		 ; Otherwise Y++
PRG003_BC2A:

	LDA <Objects_XVel,X
	CMP RotoDisc_VelLimits,Y
	BNE PRG003_BC3F	 ; If X velocity is not at its limit, jump to PRG003_BC3F

	PHA		 ; Save X Vel

	LDA Objects_TargetingXVal,X
	EOR #$01
	STA Objects_TargetingXVal,X

	TYA
	EOR #$01
	TAY

	PLA		 ; Restore X Vel

PRG003_BC3F:
	ADD RotoDisc_VelAccels,Y ; Accelerate
	STA <Objects_XVel,X	 ; Update X Velocity

	PLA		 ; Restore indexing value

	ADD Objects_TargetingYVal,X
	TAY		 ; -> 'Y'

	LDA <Objects_Var4,X
	AND #$01
	BEQ PRG003_BC52	 ; If Var4 bit 0 is not set, jump to PRG003_BC52
	INY		 ; Otherwise, Y++
PRG003_BC52:

	LDA <Objects_YVel,X
	CMP RotoDisc_VelLimits,Y
	BNE PRG003_BC67	 ; If Y velocity is not at its limit, jump to PRG003_BC67

	PHA		 ; Save Y velocity

	LDA Objects_TargetingYVal,X
	EOR #$01
	STA Objects_TargetingYVal,X

	TYA
	EOR #$01
	TAY

	PLA		 ; Restore Y velocity

PRG003_BC67:
	ADD RotoDisc_VelAccels,Y ; Accelerate
	STA <Objects_YVel,X	 ; Update Y Velocity

PRG003_BC6D:
	RTS		 ; Return

FireChomp_SpitFire:
	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!
 
	; Fire Chomp's fireball
	LDA #SOBJ_PYRANTULAFIRE
	STA SpecialObj_ID,Y

	; Calculate a flight path towards Player
	LDA #$14
	JSR BoomBoom_CalcFlightPath

	; Send fireball along flight path
	LDA <Temp_Var1
	STA SpecialObj_YVel,Y
	LDA <Temp_Var2
	STA SpecialObj_XVel,Y

	; Set coordinates as offset from Fire Chomp
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	RTS		 ; Return

	; Calculates flying Boom Boom's path so he flies towards Player
BoomBoom_CalcFlightPath:
	STA <Temp_Var2	; Store input value -> Temp_Var2

	; Backup 'X' and 'Y'
	TXA
	PHA
	TYA
	PHA

	JSR Level_ObjCalcYDiffs
	STY <Temp_Var3		 ; Store Y difference indicator -> Temp_Var3

	; Get absolute value of Y difference
	LDA <Temp_Var16
	BPL PRG003_BCAA
	JSR Negate
PRG003_BCAA:
	STA <Temp_Var13		 ; -> Temp_Var13
 
	JSR Level_ObjCalcXDiffs
	STY <Temp_Var4		 ; Store X difference indicator -> Temp_Var4

	; Get absolute value of X difference
	LDA <Temp_Var16
	BPL PRG003_BCB8
	JSR Negate
PRG003_BCB8:
	STA <Temp_Var14		 ; -> Temp_Var14

	LDY #$00	 ; Y = 0
	LDA <Temp_Var14	
	CMP <Temp_Var13	
	BGE PRG003_BCCB	 ; If Y difference >= X difference, jump to PRG003_BCCB

	INY		 ; Y = 1

	; Swap differences (so greater difference will be in Temp_Var14)
	PHA
	LDA <Temp_Var13
	STA <Temp_Var14
	PLA
	STA <Temp_Var13

PRG003_BCCB:
	LDA #$00
	STA <Temp_Var12	; Clear Temp_Var12
	STA <Temp_Var1	; Clear Temp_Var1

	LDX <Temp_Var2		 ; X = Temp_Var2 (original input value)

PRG003_BCD3:
	LDA <Temp_Var12
	ADD <Temp_Var13		; A = Temp_Var12 + Temp_Var13 (the lesser difference)
	CMP <Temp_Var14		
	BLT PRG003_BCE0	 	; If (Temp_Var12 + Temp_Var13) < Temp_Var14 (the greater difference), jump to PRG003_BCE0

	; If (Temp_Var12 + Temp_Var13) >= Temp_Var14

	SBC <Temp_Var14		 ; Subtract total from Temp_Var14
	INC <Temp_Var1		 ; Temp_Var1++

PRG003_BCE0:
	STA <Temp_Var12		 ; Update Temp_Var12 with the previous total
	DEX		 	; X--
	BNE PRG003_BCD3		; While X >= 0, loop!

	TYA		 ; A = 0 or 1
	BEQ PRG003_BCF2	 ; If zero (don't need to swap), jump to PRG003_BCF2

	; Swap Temp_Var1 and Temp_Var2
	LDA <Temp_Var1
	PHA	
	LDA <Temp_Var2
	STA <Temp_Var1
	PLA	
	STA <Temp_Var2

PRG003_BCF2:
	LDA <Temp_Var1		 ; A = Temp_Var1

	LDY <Temp_Var3		 ; Y = Temp_Var3 (Y difference indicator)
	BEQ PRG003_BCFD	 	; If Player was lower than object, jump to PRG003_BCFD

	; Otherwise, negate Temp_Var1
	JSR Negate
	STA <Temp_Var1

PRG003_BCFD:
	LDA <Temp_Var2		 ; A = Temp_Var2

	LDY <Temp_Var4		 ; Y = Temp_Var4 (X difference indicator)
	BEQ PRG003_BD08	 	; If Player was lower than object, jump to PRG003_BD08

	; Otherwise, negate Temp_Var2
	JSR Negate
	STA <Temp_Var2

PRG003_BD08:

	; Restore 'Y' and 'X'
	PLA
	TAY
	PLA
	TAX 

	RTS		 ; Return

Tail_PlayerYOff:	.byte $12, $04	; Offset to Player Sprite Y for small/ducking, or not
Tail_PlayerYLimit:	.byte $0E, $18	; Limit value

	; For enemies with tails (e.g. Fire Snake, Fire Chomp, Blooper with Kids),
	; checks if the Player has touched any part of their tail and should be hurt.
Tail_CheckHurtPlayer:
	LDA <Temp_Var16
	ADD <Counter_1
	LSR A
	BCC PRG003_BD60	 ; Every other tick, jump to PRG003_BD60 (RTS)

	LDA Objects_Var1,X
	BNE PRG003_BD60	 ; If Var1 <> 0, jump to PRG003_BD60 (RTS)

PRG003_BD1E:
	LDY #$00	 ; Y = 0

	LDA <Player_Suit
	BEQ PRG003_BD2A	 ; If Player is small, jump to PRG003_BD2A

	LDA Player_IsDucking
	BNE PRG003_BD2A	 ; If Player is ducking, jump to PRG003_BD2A

	INY		 ; Y = 1

PRG003_BD2A:
	LDA <Temp_Var1
	CMP #$c3
	BGE PRG003_BD60	 ; If Temp_Var1 >= $C3, jump to PRG003_BD60 (RTS)

	ADD #$08
	SUB <Player_SpriteY
	SUB Tail_PlayerYOff,Y
	CMP Tail_PlayerYLimit,Y
	BGE PRG003_BD60	 ; If Player is not in good Y range, jump to PRG003_BD60 (RTS)

	LDA <Temp_Var2
	ADD #$04
	SUB <Player_SpriteX
	SBC #$00
	CMP #$10
	BGE PRG003_BD60	 ; If Player is not in good X range, jump to PRG003_BD60 (RTS)

	LDA Player_StarInv
	BNE PRG003_BD60	 ; If Player is invincible by Starman, jump to PRG003_BD60 (RTS)

Player_HurtIfNotDieOffBehind:
	ORA Player_IsDying  	; If Player is dying...
	ORA Player_OffScreen	; ... off-screen ...
	BNE PRG003_BD60	 	; ... jump to PRG003_BD60 (RTS)

	JSR Player_GetHurt	; Otherwise, hurt Player!

PRG003_BD60:
	RTS		 ; Return

FireSnake_XVelTowardsPlayer:	.byte $08, -$08

FireSnake_FlipForTick:	.byte $00, $00, SPR_HFLIP, SPR_HFLIP
FireSnake_FrameForTick:	.byte $00, $01, $00, $01

FireSnake_JumpYVel:	.byte -$1A, -$20, -$26, -$2C, -$32, -$38, -$3E, -$44

FireSnake_RandomTimer3Vals:	.byte $50, $70, $00, $70, $50, $00, $00, $00

ObjNorm_FireSnake:
	LDA Level_NoStopCnt
	LSR A
	AND #$03
	TAY		 ; Y = 0 to 3

	; Set flip bit for this tick
	LDA FireSnake_FlipForTick,Y
	STA Objects_FlipBits,X

	; Set frame for this tick
	LDA FireSnake_FrameForTick,Y
	STA Objects_Frame,X

	LDA <Player_HaltGame
	BEQ ObjNorm_FireSnake1	 ; If gameplay is NOT halted, jump to PRG003_BD95

	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

ObjNorm_FireSnake1:
	JSR Object_WorldDetect4	 ; Detect against the world
	JSR FireSnake_ChangeSolids

	LDA <Objects_DetStat, X
	AND #(HIT_DET_RIGHT | HIT_DET_LEFT)
	BEQ PRG003_BD91

	JSR Object_AboutFace

PRG003_BD91:
	LDA <Objects_DetStat, X
	AND #HIT_DET_CEIL
	BEQ PRG003_BD91_2

	JSR Object_HitCeiling

PRG003_BD91_2:
	JSR TailEnemy_DoStandard	 ; Do standard tailed enemy states

PRG003_BD95:

	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoLimit

	LDA <Objects_YVel,X
	BMI PRG003_BDA8	 ; If Fire Snake is moving upward, jump to PRG003_BDA8

	CMP #$18
	BGE PRG003_BDAA	 ; If Fire Snake is moving at $18 downward, jump to PRG003_BDAA

PRG003_BDA8:
	INC <Objects_YVel,X	 ; Fire Snake's light gravity

PRG003_BDAA:
	LDA <Objects_DetStat, X
	AND #HIT_DET_GRND
	BEQ PRG003_BDE6

	JSR Object_HitGround	 ; Align Fire Snake to ground
	LDA #$00
	STA Objects_XVel, X

	LDA Objects_PrevDetStat, X
	AND #HIT_DET_GRND
	BNE PRG003_BDE7

	LDA Level_ChgTileEvent
	BNE PRG003_BDAB

	LDA Objects_LastProp, X
	CMP #TILE_PROP_SOLID_TOP
	BCS PRG003_BDAB

	AND #$0F
	CMP #TILE_PROP_ENEMY
	BNE PRG003_BDAB

	LDA Level_ChgTileEvent
	BNE PRG003_BDAB

	JSR SetObjectTileCoord
	LDA Objects_LastTile, X
	JSR DrawEnemyTempBlock
	BEQ PRG003_BDAB

	EOR #$01
	STA Level_ChgTileEvent 

PRG003_BDAB:

	LDA Objects_Property, X
	BNE PRG003_BDE7

	LDA #$15
	STA Objects_Timer, X

PRG003_BDE7:

	LDA Objects_Timer,X
	BNE PRG003_BDE6	 ; If timer not expired, jump to PRG003_BDE6

	LDY #$00
	LDA #$10
	JSR Level_ObjCalcYBlockDiffs
	CMP #$80
	BCS PRG003_BDE6_Divert2

	CMP #$08
	BCS PRG003_BDE6_Divert1

	TAY
	JMP PRG003_BDE6_Divert2


PRG003_BDE6_Divert1:
	LDY #$07

PRG003_BDE6_Divert2:
	; Fire Snake's random hop
	LDA FireSnake_JumpYVel,Y
	STA <Objects_YVel,X

	JSR Level_ObjCalcYDiffs

	CPY #$00
	BNE PRG003_BDDB	; If Player is lower than Fire Snake, jump to PRG003_BDDB

	LDA RandomN,X
	AND #$07
	TAY		 ; Y = 0 to 7, random

	; Random timer 3 reload value
	LDA FireSnake_RandomTimer3Vals,Y
	STA Objects_Timer3,X

PRG003_BDDB:
	JSR Level_ObjCalcXDiffs

	; Set X velocity towards Player
	LDA FireSnake_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

	JMP PRG003_BDE6	 ; Jump to PRG003_BDE6 (... right down below)

PRG003_BDE6:
	JMP Enemy_DeleteIfOffAndDrawTail	 ; Delete if off-screen, draw tail, and don't come back!

PRG003_BDE9:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

TailEnemy_DoStandard:
	LDA Objects_Var1,X
	BEQ TailEnemy_InitOrHalt	 ; If Var1 = 0, jump to TailEnemy_InitOrHalt

	LDY <Player_HaltGame
	BEQ PRG003_BDFA	 ; If gameplay is not halted, jump to PRG003_BDFA

	; Do not return to caller!
	PLA
	PLA

	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BDFA:
	; Jump based on Var1
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TailEnemy_InitOrHalt		; 0: Action to take initially or when gameplay is halted
	.word TailEnemy_DrawAndWaitTimer2	; 1: Draws object and waits for timer 2 to expire; WILL NOT RETURN TO CALLER!
	.word TailEnemy_DoDeath			; 2: Does "wiggle death" and draws tail; WILL NOT RETURN TO CALLER!

TailEnemy_InitOrHalt:
	JSR Object_CheckIfNormalState
	BEQ PRG003_BE1D	 ; If in normal state, jump to PRG003_BE1D

	; Not in normal state...

	; Var1 = 1 (next internal state)
	LDA #$01
	STA Objects_Var1,X

	LSR A
	STA <Objects_XVel,X	; Stop horizontal velocity

	; Color cycle!
	LDA #$10
	STA Objects_ColorCycle,X

	; Timer2 = 8
	LDA #$08
	STA Objects_Timer2,X

	RTS		 ; Return

PRG003_BE1D:
	LDA Level_ObjectID,X
	CMP #OBJ_FIRESNAKE
	BNE PRG003_BE27	 ; If this is NOT a Fire Snake, jump to PRG003_BE27

	JMP Object_HandleBumpUnderneath	 ; Otherwise just handle getting bumped underneath and don't come back!

PRG003_BE27:
	JMP Player_HitEnemy	 ; Handle full enemy-to-Player collision and don't come back!

TailEnemy_DrawAndWaitTimer2:
	LDA Objects_Timer2,X	 
	BNE PRG003_BE37	 ; If timer2 is not expired, jump to PRG003_BE37

	INC Objects_Var1,X	 ; Var1++ (next internal state)

	; Timer2 = $FF
	LDA #$ff
	STA Objects_Timer2,X

PRG003_BE37:
	; Do NOT return to caller!
	PLA
	PLA

	JMP Enemy_DeleteIfOffAndDrawTail	; Delete if off-screen, draw tail, and don't come back!

PRG003_BE3A:
	RTS		 ; Return

TailEnemy_DoDeath:
	LDA Objects_Timer2,X
	BNE PRG003_BE52	 ; If timer 2 is not expired, jump to PRG003_BE52

	; Timer 2 expired...

	STA Objects_Var1,X	 ; Var1 = 0 (Return to initial internal state)

	; Removes bit 7 (vertical flip)
	ASL Objects_FlipBits,X
	LSR Objects_FlipBits,X

	; Little hop upward
	LDA #-$10
	STA <Objects_YVel,X

	JMP PRG003_BE37	; Draw tail, Do NOT return to caller, and don't come back!


PRG003_BE52:

	; Sets vertical flip bit 7
	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BMI PRG003_BE67	 ; If enemy moving upward, jump to PRG003_BE67

	CMP #$18
	BGE PRG003_BE6B	 ; If enemy moving downward >= $18, jump to PRG003_BE6B

PRG003_BE67:
	; Apply gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG003_BE6B:
	LDY #$08	 ; Y = $08

	LDA Level_NoStopCnt
	AND #$08
	BEQ PRG003_BE76	 ; 8 ticks on, 8 ticks off; jump to PRG003_BE76

	LDY #-$08	 ; Y = -$08

PRG003_BE76:
	STY <Objects_XVel,X	 ; Set X velocity as $08 or -$08

	JMP PRG003_BE37	; Draw tail, Do NOT return to caller, and don't come back!

FireSnake_ChangeSolids:
	LDA Level_ChgTileEvent
	BEQ FireSnake_ChangeSolids1
	RTS

FireSnake_ChangeSolids1:
	LDA Object_TileFeetProp
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_ENEMYSOLID)
	BNE FireSnake_ChangeSolids5

	LDA Objects_YVel, X
	BPL FireSnake_ChangeSolids2

	LDA Objects_Y, X
	SUB #$08
	AND #$F0
	STA Level_BlockChgYLo
	LDA Objects_YHi, X
	SBC #$00
	STA Level_BlockChgYHi
	JMP FireSnake_ChangeSolids3

FireSnake_ChangeSolids2:
	LDA Objects_Y, X
	ADD #$10
	AND #$F0
	STA Level_BlockChgYLo
	LDA Objects_YHi, X
	ADC #$00
	STA Level_BlockChgYHi

FireSnake_ChangeSolids3:
	LDA Objects_X, X
	ADD #$08
	AND #$F0
	STA Level_BlockChgXLo
	LDA Objects_XHi, X
	ADC #$00
	STA Level_BlockChgXHi
	LDA Object_TileFeetValue
	EOR #$01
	STA Level_ChgTileEvent
	JMP FireSnake_ChangeSolids8

FireSnake_ChangeSolids5:
	LDA Object_TileWallProp
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_ENEMYSOLID)
	BNE FireSnake_ChangeSolids10
	
	LDA Objects_XVel, X
	BPL FireSnake_ChangeSolids6

	LDA Objects_X, X
	SUB #$08
	AND #$F0
	STA Level_BlockChgXLo
	LDA Objects_XHi, X
	SBC #$00
	STA Level_BlockChgXHi
	JMP FireSnake_ChangeSolids7

FireSnake_ChangeSolids6:
	LDA Objects_X, X
	ADD #$10
	AND #$F0
	STA Level_BlockChgXLo
	LDA Objects_XHi, X
	ADC #$00
	STA Level_BlockChgXHi

FireSnake_ChangeSolids7:
	LDA Objects_Y, X
	ADD #$04
	AND #$F0
	STA Level_BlockChgYLo
	LDA Objects_YHi, X
	ADC #$00
	STA Level_BlockChgYHi
	LDA Object_TileWallValue
	EOR #$01
	STA Level_ChgTileEvent
	
FireSnake_ChangeSolids8:
	JSR SpecialObj_FindEmpty
	BMI FireSnake_ChangeSolids9

FireSnake_ChangeSolids9:

	LDA #SOBJ_POOF
	STA SpecialObj_ID, Y
	LDA #$20	 
	STA SpecialObj_Data, Y
	LDA Level_BlockChgXLo
	STA SpecialObj_XLo, Y
	LDA Level_BlockChgYLo
	STA SpecialObj_YLo, Y
	LDA Level_BlockChgYHi
	STA SpecialObj_YHi, Y
	
FireSnake_ChangeSolids10:
	RTS

ObjInit_RotoDiscDualCW:
	LDY #$03	 ; Y = 3
	LDA PRG003_B9C6+1
	BNE PRG003_BE87	 ; Jump (technically always) to PRG003_BE87

ObjInit_RotoDiscDualCCW:
	LDY #-$02	; Y = -$02

	; Set initial Y velocity
	LDA PRG003_B9C6

PRG003_BE87:
	STA <Objects_YVel,X
	STY <Temp_Var1	 ; Temp_Var1 = -$02

	LDA #$00
	STA <Objects_XVel,X
	STA Objects_XVelFrac,X
	STA Objects_YVelFrac,X

	LDA <Objects_X,X
	STA Objects_Var13,X	
	SUB #$30
	STA <Objects_X,X

	LDA <Objects_XHi,X
	STA Objects_Var10,X

	SBC #$00
	STA <Objects_XHi,X

	LDA <Objects_Y,X
	STA Objects_Var14,X

	ADD <Temp_Var1	
	STA <Objects_Y,X

	LDA #$00
	LDY <Temp_Var1
	BPL PRG003_BEBA
	LDA #$ff
PRG003_BEBA:
	ADC <Objects_YHi,X
	STA Objects_Var1,X

	RTS		 ; Return


ObjNorm_RotoDiscDualOpp:

	JSR ObjNorm_RotoDisc	 ; Partly a regular RotoDisc...

	; Backup the Y coordinates
	LDA <Objects_Y,X
	PHA
	LDA <Objects_YHi,X
	PHA

	; Calculate an opposite Y for the secondary RotoDisc
	LDA Objects_Var14,X
	SUB <Objects_Y,X
	PHA

	LDA Objects_Var1,X
	SBC <Objects_YHi,X
	TAY

	PLA
	ADD Objects_Var14,X
	STA <Objects_Y,X

	TYA
	ADC Objects_Var1,X
	STA <Objects_YHi,X

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of the RotoDisc
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of the RotoDisc
	JSR RotoDisc_CollideAndCycle	 ; Test for collision and cycle the second RotoDisc

	; Restore the Y coordinates
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	RTS		 ; Return

ObjNorm_RotoDiscDualOpp2:
	JSR ObjNorm_RotoDisc	 ; Partly a regular RotoDisc...

	; Backup the X coordinates
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA

	; Calculate an opposite X for the secondary RotoDisc
	LDA Objects_Var13,X
	SUB <Objects_X,X
	PHA

	LDA Objects_Var10,X
	SBC <Objects_XHi,X
	TAY
	PLA

	ADD Objects_Var13,X
	STA <Objects_X,X

	TYA
	ADC Objects_Var10,X
	STA <Objects_XHi,X

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of the RotoDisc
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of the RotoDisc
	JSR RotoDisc_CollideAndCycle	 ; Test for collision and cycle the second RotoDisc

	; Restore the X coordinates
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_RotoDiscDual:
	JSR ObjNorm_RotoDisc	 ; Partly a regular RotoDisc...

	; Backup all of the coordinates
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA
	LDA <Objects_Y,X
	PHA
	LDA <Objects_YHi,X
	PHA


	; Calculate an opposite X and opposite Y for the secondary RotoDisc
	LDA Objects_Var13,X
	SUB <Objects_X,X
	PHA

	LDA Objects_Var10,X
	SBC <Objects_XHi,X
	TAY

	PLA
	ADD Objects_Var13,X
	STA <Objects_X,X
	TYA
	ADC Objects_Var10,X
	STA <Objects_XHi,X

	LDA Objects_Var14,X
	SUB <Objects_Y,X
	PHA

	LDA Objects_Var1,X
	SBC <Objects_YHi,X
	TAY

	PLA
	ADD Objects_Var14,X
	STA <Objects_Y,X

	TYA
	ADC Objects_Var1,X
	STA <Objects_YHi,X

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of the RotoDisc
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of the RotoDisc
	JSR RotoDisc_CollideAndCycle	 ; Test for collision and cycle the second RotoDisc

	; Restore all of the coordinates
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_RotoDisc:
	LDA <Player_HaltGame
	BNE PRG003_BFAE	 ; If gameplay is halted, jump to PRG003_BFAE

	; Var4 = 6
	LDA #$06
	STA <Objects_Var4,X

	JSR RotoDiscSpin 		; Do Rotodisc spin logic
	JSR Object_DeleteOffScreen_N2	; Delete if falls off-screen
RotoDisc_CollideAndCycle:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the sprite
	JSR Player_HitEnemy	 	; Player to Rotodisc collision detection

PRG003_BFAE:

	; Toggle between frame 0 and 1
	LDA <Counter_1
	AND #$01
	STA Objects_Frame,X

	; Cycle colors
	LDA <Counter_1
	LSR A
	LSR A
	STA Objects_ColorCycle,X

	JMP Object_ShakeAndDraw	 ; Draw Rotodisc and don't come back!

; Rest of ROM bank was empty

Increase_Magic_Stars:
	LDA Sound_QLevel1
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap
	INC Magic_Stars
	LDA Magic_Stars
	AND #$0F
	CMP #$0A
	BCC No_HBros_Inc
	LDA Magic_Stars
	AND #$F0
	CLC
	ADC #$10
	STA Magic_Stars

No_HBros_Inc:
	RTS
