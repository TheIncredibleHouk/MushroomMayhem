; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-06-03 20:09:21.000000000 -0500
; Distribution package date: Sun Jun 10 18:21:30 UTC 2012
;---------------------------------------------------------------------------
	; STANDARD HORIZONTAL SCREEN
Tile_Mem_Addr:	
	; This breaks up the overall "tile" layout memory into screen-based chunks
	; With a screen width of 256 pixels, that makes 16 blocks across every "screen",
	; NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 28 POTENTIAL rows per screen
	; but the status bar occludes one, so only 27 rows are stored... 
	; Up to 15 screens!
	.word Tile_Mem,       Tile_Mem+$01B0, Tile_Mem+$0360, Tile_Mem+$0510, Tile_Mem+$06C0, Tile_Mem+$0870, Tile_Mem+$0A20, Tile_Mem+$0BD0
	.word Tile_Mem+$0D80, Tile_Mem+$0F30, Tile_Mem+$10E0, Tile_Mem+$1290, Tile_Mem+$1440, Tile_Mem+$15F0, Tile_Mem+$17A0


	; ALTERNATE VERTICAL SCREEN

	; Each "screen" (stacked vertically) is made up of 15 rows of tiles
	; which amounts to $F0 bytes per screen; the following split LUT defines tile memory
	; offsets gapped by $F0... not sure why they had to make the address lookup into two LUTs
	; like they did, but whatever... 16 vertical screens available

	; High bytes are separate from low
Tile_MemH = HIGH(Tile_Mem)

	; Vertical low byte, per screen
Tile_Mem_AddrVL:
	.byte $00, $F0, $E0, $D0, $C0, $B0, $A0, $90, $80, $70, $60, $50, $40, $30, $20, $10

	; Vertical high byte, per screen
Tile_Mem_AddrVH:
	.byte Tile_MemH+$0, Tile_MemH+$0, Tile_MemH+$1, Tile_MemH+$2
	.byte Tile_MemH+$3, Tile_MemH+$4, Tile_MemH+$5, Tile_MemH+$6
	.byte Tile_MemH+$7, Tile_MemH+$8, Tile_MemH+$9, Tile_MemH+$A
	.byte Tile_MemH+$B, Tile_MemH+$C, Tile_MemH+$D, Tile_MemH+$E



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This table contains commands for Video_Misc_Updates which tells
; it how to generate certain graphical elements programatically
;
; Format:
;	[2B TVA][CMD][DATA]
;	TVA: Target Video Address, typ. inside the nametable somewhere
;	CMD: 	- Bit 7 set = Use vertical updates (32B) else use horizontal (1B)
;		- Bit 6 set = Means that there is only one byte of DATA, repeated
;		- Bits 0-5  = Count of bytes to write directly to PPU 
;	DATA: Raw byte(s) to write to the PPU, count specified by CMD
; After a data chunk has been read, a new TVA is expected, or a $00 byte which terminates the stream.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Remember that the left edge is typically clipped, so nothing is visible there...
Video_Upd_Table: ; $803E
	.word Graphics_Buffer	; $00 - Graphics buffer for dynamically generated content
	.word Video_DoStatusBar ; $01 - status bar (vertical level)
	.word Video_DoStatusBar	; $02 - status bar (typical)
	.word $A000		; $03 - ???
	.word $A06F		; $04 - ???
	.word Video_DoStatusBar; $05 - status bar appropriate for horizontal mirroring
	.word Video_DoPalUpd	; $06 - Updates palettes per values in the $07BE+ Palette_* vars; used during fade in/out routines

StatusBar	.macro

;@@@@@@@@@@@@@@@@@@@@@@@@@@

	vaddr \1 + $00
	.byte $02, $FF, $80		; Upper left corner

	vaddr \1 + $02
	.byte VU_REPEAT | $16, $81	; Bar across the top

	vaddr \1 + $18
	.byte $08, $75, $FB, $FB, $FC, $FB, $FB, $F9, $FF 		; Upper left corner

;------
	vaddr \1 + $20
	.byte $20, $FF, $90, $EE, $D1, $D1, $D1, $D1, $D1, $D1, $DA, $DB, $E9, $E9, $E9, $E9, $EA, $FE, $FE, $FE, $FE, $FE, $D8, $74, $74, $76, $FA, $FA, $FD, $FA, $FA, $F8, $FF

	vaddr \1 + $40
	.byte $20, $FF, $90, $EF, $30, $30, $30, $30, $30, $30, $FE, $D0, $30, $30, $30, $30, $FE, $D7, $30, $30, $30, $FE, $D5, $30, $30, $76, $FA, $FA, $FD, $FA, $FA, $F8, $FF

;----	
	vaddr \1 + $60
	.byte $02, $FF, $83

	vaddr \1 + $62
	.byte VU_REPEAT | $16, $93	; Bar across the top

	vaddr \1 + $78
	.byte $0A, $77, $F7, $F7, $F6, $F7, $F7, $A3, $FF, $FF, $90		; Upper left corner

	vaddr \1  + $82
	.byte VU_REPEAT | 28 , $FE

	vaddr \1 + $9E
	.byte $04, $92, $FF, $FF, $A0

	vaddr \1 + $A2
	.byte VU_REPEAT | $1C, $A1	; Bar across the top

	vaddr \1 + $BE
	.byte $02, $A2, $FF

	; Terminator
	.byte $00
	.endm

	; Typical status bar (vertical level)

	; Typical status bar (non-vertical level)
Video_DoStatusBar:
	StatusBar $2B00

PAGE_C000_ByTileset: ; $83D6
	.byte 10

	; List of A000 pages to switch to by Level_Tileset
PAGE_A000_ByTileset: ; $83E9
	.byte 11

	; The normal level VROM page cycle set
PT2_Anim:	.byte $80, $82, $84, $86, $88, $8A, $8C, $8E
PSwitch_Anim: .byte $C0, $C2, $C4, $C6, $C8, $CA, $CC, $CE
PT2_Anim2:	.byte $D0, $D2, $D4, $D6, $D8, $DA, $DC, $DE
PSwitch_Anim2: .byte $E0, $E2, $E4, $E6, $E8, $EA, $EC, $EE
PT2_Anim3:	.byte $F0, $F2, $F4, $F6, $F8, $FA, $FC, $FE
PT2_Anim4:	.byte $5E, $5E, $5E, $5E, $5E, $5E, $5E, $5E

SPR_Anim:
	.byte $90, $91, $92, $93

Suit_Anim:
	.byte $03, $04, $05

PAUSE_ResumeSprites:
	.byte $C1, $C3, $C5, $C7, $C9, $CB, $CD, $CF
	.byte $C1, $D1, $D3, $D5, $D7, $D9, $DB, $CF

PAUSE_ExitSprites:
	.byte $E1, $F1, $F3, $F5, $F7, $F9, $FB, $EF
	.byte $E1, $E3, $E5, $E7, $E9, $EB, $ED, $EF


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; IntReset_Part2
	;
	; Part 2 of the Reset routine...
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IntReset_Part2:
	LDA PPU_STAT	 ;
	BPL IntReset_Part2 ; Wait until VBlank

	JSR SaveRam_Backup

	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg
	STA PPU_CTL1	 ; Most likely just to disable further Resets

	; Note: This is setting up the address $7F00 @ $00/$01, the last page of SRAM
	LDY #$00	 ; Y = $00
	STY <Temp_Var1	 ; <Temp_Var1 = $00
	LDA #$7f	 ; A = $7F
	STA <Temp_Var2	 ; <Temp_Var2 = $7F

	; The following loop clears all of $6000 - $7FFF ... a lot of RAM!
PRG030_8437:
	LDA #$00	 	; A = 0
	STA [Temp_Var1],Y	; Clear 
	DEY			; Y--
	BNE PRG030_8437	 	; While Y is not zero, loop (since Y started at 0, this does a full 256 bytes)

	; This decrement then moves to $7E, $7D ... $60
	DEC <Temp_Var2	 ; Next lower page
	LDA <Temp_Var2	 ; Get page -> A
	CMP #$5f	 ; 
	BNE PRG030_8437	 ; If A <> $5F, loop again (clears down to $6000)

	JSR SaveRam_Restore
	; Clear $07FF - $0000, excluding $01xx
	LDY #$07
	JSR Clear_RAM_thru_ZeroPage

	; Reset_Latch = $5A (magic value that prevents reset vector from being run)
	LDA #$5a
	STA Reset_Latch

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	LDA #HIGH(8000)

	; Lowest byte of the N-Spade score
	LDA #LOW(8000)

PRG030_845A:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables
	

	; Load title screen graphics
	LDA #$78
	STA PatTable_BankSel

	LDA #$7a	
	STA PatTable_BankSel+1

	LDA #$78
	STA PatTable_BankSel + 2

	LDA #$79
	STA PatTable_BankSel + 3

	LDA #$7A
	STA PatTable_BankSel + 4

	LDA #$4D
	STA PatTable_BankSel + 5

	; Load page 24 into A000 and page 25 into C000
	LDA #24	 
	STA PAGE_A000

	LDA #25	 
	STA PAGE_C000

	JSR PRGROM_Change_Both2	

	LDA #$20
	STA Update_Select	 ; Update_Select = $20 (Title Screen)
	STA IRQ_Mode	 

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	JSR Do_Title_Screen	; Do the title screen!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BEGINNING INITIALIZATION OF WORLD MAP!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG030_84A0:

	; Load page 11 into A000 and page 10 into C000
	LDA #10
	STA PAGE_C000

	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_Both2	


	JSR Load_Save	 ; Initialize map variables (page 11)

	LDA #$01
	STA Map_Operation	; Map_Operation = 0 ("World X" intro)

	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; Stop Update_Select activity temporarily while we initialize
	INC UpdSel_Disable


PRG030_84D7:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	;SR Reset_PPU_Clear_Nametables

	LDA #$00
	STA Level_Tileset	; Level_Tileset = 0
	STA IRQ_Mode	; Raster Effects disabled
	STA UpdSel_Disable 	; Stop Update_Select activity
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0

	; Update_Select = $C0
	LDA #$c0	 	
	STA Update_Select

	; Load world map graphics
	LDA #$14
	STA PatTable_BankSel

	LDX #$20
	STX PatTable_BankSel+2

	INX
	STX PatTable_BankSel+3

	INX
	STX PatTable_BankSel+4
	
	LDA #$7B
	STA PatTable_BankSel+5

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10

	; Init Player's on map
	LDX Total_Players
	DEX		 ; X = Total_Players-1

PRG030_8552:
	; Set Player's Y position
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X

	; Set Player's X position
	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X

	LDA Map_Entered_X,X
	STA <World_Map_X,X

	DEX		 ; X--
	BPL PRG030_8552	 ; If more players to initialize, loop!

	LDA #$00	 
	STA Level_Tileset	 ; Map uses Level_Tileset = 0
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)
	STA <Map_EnterLevelFX	 ; Scratch = 0
	STA <Map_Intro_CurStripe ; Start with the first "strip" of erasing the World X intro box
	STA <Map_WarpWind_FX	 ; No warp whistle wind effects
	STA Map_Intro_Tick	 ; Map_Intro_Tick = 0 (forces init in some functions)

PRG030_857E:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = current Player index

	LDA World_Map_Power	; X = Player's current world map power
	STA Map_Power_Disp	; Set as powerup currently displayed 

	LDY #$00	 ; "Darkness" flag (only works correctly on World 8 level 2)

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10

	JSR Scroll_Map_SpriteBorder	; Draw sprite-based border on map

	; Set A000 page to 12
	LDA #12
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR Map_Reload_with_Completions	 	; Load map and set already completed levels

	INC Top_Needs_Redraw
	INC Bottom_Needs_Redraw

	LDA Inventory_Open	
	BNE PRG012_85CE		; If Inventory is open, jump to PRG012_85CE

	; If Inventory is not open
	LDX Player_Current	; X = Player_Current

	LDA Map_Previous_Dir,X 	; Get Player's previous moment direction
	STA <World_Map_Dir,X	; Restore it

PRG012_85CE:
	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync

	LDY Player_Current	; Y = current Player index

	; This sets up the scroll correctly given wherever the Player last was on the map
	LDA Map_Prev_XOff,Y	 
	STA <Scroll_Temp	 ; Scroll_Temp = X offset
	LDA Map_Prev_XHi,Y	 ; A = hi byte of X offset
	JSR Scroll_Update_Ranges ; Off to Scroll_Update_Ranges...

	LDA #$00	 
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0

	LDA <Scroll_ColumnL	
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	LDA StatusBar_FirstInit
	BNE No_StatusbarInit

	INC StatusBar_FirstInit
	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

No_StatusbarInit:
	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #24		
	STA MMC3_PAGE	 

	LDA #$00	 		; Commit graphics in Graphics_Buffer
	JSR Video_Do_Update		; Do it!

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	; Clear all the map object Y to zero!
	LDY #$0d	 ; Y = $D
	LDA #$00	 ; A = 0
PRG030_8617:
	STA Map_Object_ActY,Y
	DEY		 ; Y--
	BPL PRG030_8617	 ; While Y >= 0, loop!

	LDY Player_Current	 ; Y = Player_Current
	LDA Map_Prev_XOff,Y	 ; Get player's previous X offset (low byte)
	STA <Horz_Scroll	 ; Set the scroll to that
	STA <Scroll_Temp
		 
	LDA Map_Prev_XHi,Y	 ; Get player's previous X offset (high byte) 
	STA <Horz_Scroll_Hi	 ; Store as current scroll "high"
	JSR Scroll_Update_Ranges

PRG030_8646:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	; Pushes any buffered graphics thru
	LDA #$00	 	
	JSR Video_Do_Update	

	LDA Map_DrawPanState
	BNE PRG030_8646	 	; If some kind of map drawing/panning activity is occurring, loop around

	LDA Map_Operation
	BNE PRG030_86A2	 	; If map operation is anything besides zero, jump to PRG030_86A2

	; Map_Operation = 0 ... the "World X" intro
	; Used at the beginning of a world, and alternating players
	LDA Inventory_Open
	BNE PRG030_86A2	; If inventory is open, jump to PRG030_86A2

	; Set bank at A000 to page 11
	LDA #11	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$0E 		; X = 14 (standard $00 aligned box)

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG030_8670	 	; If Horz_Scroll = 0, jump to PRG030_8670

	LDX #$10		; Otherwise, X = 16 (map halfway scroll $80 aligned box)
PRG030_8670:
	LDA Player_Current
	BEQ PRG030_8676		; If Player_Current = 0 (Mario), jump to PRG030_8676
	INX		 	; Otherwise, increment X (use Luigi's name!)

PRG030_8676:
	TXA		 	; A = X ($0E/$0F, $10/$11)
	JSR Video_Do_Update	; Do the World X intro box!

	;JSR Map_ConfigWorldIntro	; Apply the world number and lives count

	; Push the buffered update
	LDA #$00
	JSR Video_Do_Update	 

PRG030_86A2:
	LDA #$00
	STA Inventory_Open	; Inventory_Open = 0

	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 11
	LDA #11	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Switch bank A000 to page 27
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects
	JSR Map_DayNightPalette

	; ; Switch bank A000 to page 26
	; LDA #24
	; STA PAGE_A000
	; JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

WorldMap_Loop:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!

	; Switch bank A000 to page 11 
	LDA #11
	STA PAGE_A000	
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11 -- animate world map

	LDA InvFlip_Counter
	BNE PRG030_86F9	 	; If InvFlip_Counter <> 0, jump to PRG030_86F9

	LDA Inventory_Open	
	BEQ PRG030_8715	 	; If Inventory_Open = 0, jump to PRG030_8715

PRG030_86F9:
	; Inventory_Open <> 0 && InvFlip_Counter = 0 ...

	; Switch bank A000 to page 26
	LDA #24	
	STA PAGE_A000
	JSR PRGROM_Change_A000
	;JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000	

	JSR WorldMap_UpdateAndDraw	 ; Update and draw map graphics
	JMP WorldMap_Loop	 	; Loop back around...

PRG030_8715:
	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_DoMap	 		; Do the map!

	LDA Map_Operation
	CMP #$02	 
	BLT PRG030_8732	 		; If Map_Operation < 2, jump to PRG030_8732 

	; Map_Operation >= 2...

	; Switch bank A000 to page 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR StatusBar_Update	; Update status bar

PRG030_8732:
	LDY Map_Operation
	CPY #$10
	BEQ PRG030_87BD

	JMP WorldMap_Loop
	; LDY Map_Operation
	; CPY #$0d	 
	; BNE PRG030_873F	 		; If Map_Operation <> $D (Normal), jump to PRG030_873F

	; LDA <Map_WarpWind_FX
	; CMP #$03	 
	; BEQ PRG030_874F	 		; If Map_WarpWind_FX = 3 (initialize for warp island), jump to PRG030_874F

PRG030_873F:
	; Map_WarpWind_FX <> 3 or Map_Operation <> $D...

	; CPY #$04
	; BEQ PRG030_874F	 		; If Map_Operation <> $4, jump to PRG010_874F

	; CPY #$0f	 
	; BLT WorldMap_Loop	 	; If Map_Operation < $F (edge scroll), jump to WorldMap_Loop

	; Map_Operation >= $F...

; 	LDX Player_Current	
; 	LDA Map_Player_SkidBack,X
; 	BEQ PRG030_87BD			; If Map_Player_SkidBack = 0, jump to PRG030_87BD

; PRG030_874F:
; 	; Switch bank A000 to page 26
; 	LDA #24
; 	STA PAGE_A000
; 	JSR PRGROM_Change_A000
; 	JSR Palette_FadeOut	 		; Fade out
; 	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Likely just using this for VSync

; 	; Disable the display
; 	LDA #$00	 
; 	STA <PPU_CTL2_Copy
; 	STA PPU_CTL2	 

; 	; Stop Update_Select activity temporarily
; 	INC UpdSel_Disable

; 	LDA <Map_WarpWind_FX
; 	BNE PRG030_8772	 		; If Map_WarpWind_FX <> 0 (warp wind is active), jump to PRG030_8772

; 	LDA Map_Operation
; 	CMP #$04	 
; 	BNE PRG030_8775	 		; If Map_Operation <> 4, jump to PRG030_8775

; PRG030_8772:
; 	JMP PRG030_857E			; Jump to PRG030_857E (partial loop back)

; PRG030_8775:
; 	; Map_Operation <> 4

; 	LDX Player_Current

; 	; Store current map scroll positions and Player positions 
; 	; into the respective backup variables...
; 	LDA <Horz_Scroll
; 	STA Map_Prev_XOff,X

; 	LDA <Horz_Scroll_Hi	
; 	STA Map_Prev_XHi,X

; 	LDA <World_Map_Y,X
; 	STA Map_Entered_Y,X

; 	LDA <World_Map_XHi,X
; 	STA Map_Entered_XHi,X

; 	LDA <World_Map_X,X
; 	STA Map_Entered_X,X

; 	LDA #$00
; 	STA Map_Player_SkidBack,X

PRG030_879B:
	; Switch to the other Player (if any!)
	INX
	STX Player_Current
	CPX Total_Players
	BNE PRG030_87A9	 	; If not at the total Player count, jump to PRG030_87A9

	LDA #$00	 
	STA Player_Current	; Otherwise, back to 0 (basically keeps at 0 for 1P or goes 0, 1, 0, 1...)
PRG030_87A9:

	LDA Player_Current
	TAX		 
	; LDA Player_Lives,X	
	; BMI PRG030_879B	 	; If Player's lives are negative (dead!), jump to PRG030_879B (makes assumption at least ONE Player is alive...)

	LDA #$00
	STA Map_Operation		; Map_Operation = 0
	STA Map_PlayerLost2PVs	; Clear Map_PlayerLost2PVs

	JMP PRG030_84D7	 	; Jump to PRG030_84D7 (partial loop)

PRG030_87BD:
	; Map_Operation >= $F...

	JSR GraphicsBuf_Prep_And_WaitVSync	; Vertical sync

	; Copy the Player's positions into respective backup variables
	LDX Player_Current
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X

	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X

	LDA <World_Map_Y,X
	STA Map_Entered_Y,X

	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X

	LDA <World_Map_X,X	
	STA Map_Entered_X,X	

	LDA #$00
	STA <Map_EnterLevelFX		; Map_EnterLevelFX = 0
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = 0
	STA Update_Select		; Update_Select = 0
	STA World_EnterState		; World_EnterState = 0
 
	JSR Map_Clear_EntTranMem	; Clear entrance transition memory

	; Set initial "high" parts of VRAM addresses
	LDA #$28	 
	STA Map_EntTran_BVAddrH	 	; top VRAM high
	STA Map_EntTran_BVAddrH+2	; left VRAM high
	STA Map_EntTran_BVAddrH+3	; right VRAM high

	LDA #$2a	 
	STA Map_EntTran_BVAddrH+1	; bottom VRAM high

	LDA #$00	 
	STA Map_EntTran_BVAddrL	 	; top VRAM low
	STA Map_EntTran_BVAddrL+3	; right VRAM low

	LDA #$1f	 
	STA Map_EntTran_BVAddrL+2	; left VRAM low
	STA Map_EntTran_TBCnt	 	; Map_EntTran_TBCnt also happens to be $1f

	LDA #$e0	 
	STA Map_EntTran_BVAddrL+1	; bottom VRAM low

	LDA #$17	 
	STA Map_EntTran_LRCnt	 	; Map_EntTran_LRCnt = $17


	; Top 0, bottom 1, right 2, left 3
	LDX #$03	 	; X = 3
PRG030_881D:
	LDA <Scroll_ColumnL
	AND #$0f
	ASL A	
	ADD Map_EntTran_BVAddrL,X	; adds 2 per column scrolled
	STA Map_EntTran_BVAddrL,X
	DEX		 	; X--
	BPL PRG030_881D	 	; While X >= 0, loop!

	LDA Map_EntTran_BVAddrL+2
	AND #$1f	 
	STA Map_EntTran_BVAddrL+2

; level transition effect
	LDA #$01
	STA Map_EntTran_Cnt	 ; Map_EntTran_Cnt = $30

	LDA #SND_MAPENTERLEVEL
	STA Sound_QMap	 ; Play "enter level" sound effect!

	LDA #$00
	STA Sound_QLevel1

	LDA #$FF
	STA Map_Transition_Column

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Waiting for vertical sync


	LDY #$FC
	LDA #$F8

EnterEffect_ClearEdge:
	CMP Sprite_RAMX, Y
	BNE EnterEffect_NoClear

	STA Sprite_RAMY, Y

EnterEffect_NoClear:
	DEY
	DEY
	DEY
	DEY
	BNE EnterEffect_ClearEdge

EnterEffect_SpriteStart:
	LDY #$00

Enter_CheckSprites:	
	LDA Sprite_RAMX, Y
	ADD #$10
	CMP Map_Transition_Column
	BCC Enter_SkipSprite

	LDA #$F8
	STA Sprite_RAMY, Y
	
	LDA #$00
	STA Sprite_RAMX, Y

Enter_SkipSprite:
	INY
	INY
	INY
	INY
	CPY #$C0
	BNE Enter_CheckSprites

	LDA #$F8
	STA Map_Transition_SpriteIndex

	LDA #$20
	STA Map_Transition_SpriteY

EnterEffect_SpriteLoop:
	LDY Map_Transition_SpriteIndex
	LDA Map_Transition_SpriteY
	STA Sprite_RAMY, Y
	STA Sprite_RAMY + 4, Y
	
	LDA Map_Transition_Column
	SUB #$10
	STA Sprite_RAMX, Y
	
	ADD #$08
	STA Sprite_RAMX + 4, Y

	LDA #$01
	STA Sprite_RAMAttr, Y
	STA Sprite_RAMAttr + 4, Y

	LDA #$27
	STA Sprite_RAMTile, Y

	LDA #$0B
	STA Sprite_RAMTile + 4, Y

	LDA Map_Transition_SpriteIndex
	SUB #$08
	STA Map_Transition_SpriteIndex

	LDA Map_Transition_SpriteY
	ADD #$10
	STA Map_Transition_SpriteY

	LDA Map_Transition_SpriteY
	CMP #$B0
	BCC EnterEffect_SpriteLoop

	LDA #$28
	STA Graphics_Buffer 

	LDA Map_Transition_Column
	ADD <Horz_Scroll
	LSR A
	LSR A
	LSR A
	ADD #$80
	STA Graphics_Buffer + 1
	
	LDA #$D2
	STA Graphics_Buffer + 2

	LDA #$FF
	STA Graphics_Buffer + 3

	LDA #$00
	STA Graphics_Buffer + 4
	STA Graphics_Queue

	JSR GraphicsBuf_Prep_And_WaitVSync
	
	LDA #$00
	JSR Video_Do_Update

	LDA #%10100000
	STA <PPU_CTL1_Copy
	STA PPU_CTL1

	LDA #%00011000
	STA <PPU_CTL2_Copy
	STA PPU_CTL2

	LDA PPU_STAT

	LDA #$20
	STA PPU_VRAM_ADDR

	LDA #$00
	STA PPU_VRAM_ADDR
	
	LDA <Horz_Scroll
	STA PPU_SCROLL

	LDA <Vert_Scroll
	STA PPU_SCROLL

	DEC Map_Transition_Column
	DEC Map_Transition_Column
	DEC Map_Transition_Column
	DEC Map_Transition_Column


	LDA Map_Transition_Column
	CMP #$18
	BCC TransitionComplete
	JMP EnterEffect_SpriteStart

; level transition effect

TransitionComplete:
PRG030_88AD:
	; Completed the entrance transition...

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Waiting for vertical sync

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	; Disable display
	LDA #$00
	STA PPU_CTL2

PRG030_88C8:
	; Clearing scroll variables
	LDA #$00
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA <Vert_Scroll_Hi
	STA <Vert_Scroll
	STA <Scroll_ColumnR
	STA <Scroll_ColumnL
	STA <Scroll_LastDir

	STA <Temp_Var1	; Temp_Var1 = 0

	LDX #$05	
	STX <Temp_Var2	; Temp_Var2 = 5

	; Going to clear memory from $9D to $01
	LDY #$9d	; Y = $9D
PRG030_88E9:
	STA [Temp_Var1],Y	; Clear this byte
	DEY		 	; Y--
	BNE PRG030_88E9	 	; While Y <> 0, loop!

PRG030_891A:

	; Non-2P Mode begin!

	; Set bank C000 to page 22 and A000 to page 12
	LDA #22
	STA PAGE_C000

	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	; The ultimate output is properly configured
	; Level_ObjPtr_AddrL/H and Level_ObjPtrOrig_AddrL/H (object list pointer)
	; Level_LayPtr_AddrL/H and Level_LayPtrH_AddrL/H (tile layout pointer)
	; Level_Tileset
	JSR Map_PrepareLevel	 

	; Clears $80 bytes starting at Player_XHi ($75, gameplay context)
	LDY #$80	 ; Y = $80
	LDA #$00	 ; A = 0
	STA Level_HorzScrollLock	 ; Level_HorzScrollLock = 0 

PRG030_8975: 
	STA Player_XHi,Y
	DEY		 ; Y--
	BNE PRG030_8975	 ; While Y >= 0, loop!

PRG030_897B:
	; Level junctions enter here, to continue with preparation to display!

	LDA #$00	
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0
	STA LeftRightInfection

	LDX #$07

Clear_CarryedObjects:	
	LDY Objects_Global, X
	BNE Keep_HeldState
	
	STA Objects_BeingHeld, X

Keep_HeldState:	
	DEX
	BPL Clear_CarryedObjects
	
	JSR MagicStar_ClearRadar
	JSR LevelLoad			; Load the level layout data!
	JSR InitStarsBackground
	; JSR ClearBlockedAreas
	
	LDA #$00
	LDX #$09

CancelSpinners:
	STA SpinnerBlocksTimers, X
	STA SpinnerBlocksActive, X
	STA SpinnerBlocksX, X
	STA SpinnerBlocksPoof, X
	DEX
	BPL CancelSpinners

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

PRG030_89AB:
	JSR Reset_PPU_Clear_Nametables2		; Blank display, clear nametables


PRG030_8AE7:
	; Normal gameplay...

	; Clear Update_Request
	LDA #$00
	STA Update_Request

	; Vertical mirroring
	LDA #$01
	STA MMC3_MIRROR

	LDA #$02	 ; A = 2
	LDX #$c0	 ; X = $C0 (Normal style updating)

	LDY Level_7Vertical

PRG030_8B03:
	STX Update_Select	; Set Update_Select

	;JSR Video_Do_Update	; Video update

	; Set bank at A000 to page 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	INC Ignore_VBlank
	
	JSR Scroll_Dirty_Update	 ; Entering level, do dirty update

	LDA #$00
	STA Ignore_VBlank

	; Changes pages at A000 and C000 to 26 and 6, respectively
	LDA #6
	STA PAGE_C000
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	LDA Level_JctCtl
	BNE PRG030_8B51	 	; If we're using a level junction override, jump to PRG030_8B51

	JMP PRG030_8B6D	 	; Otherwise, jump to PRG030_8B6D

PRG030_8B51:
	; Level junction override!  Copy in junction variables as appropriate
	;LDA Level_Jct_HS
	;STA <Horz_Scroll
	;LDA Level_Jct_HSHi
	;STA <Horz_Scroll_Hi
	;
	;LDA Level_Jct_VS
	;STA <Vert_Scroll
	;
	;LDA Level_Jct_VSHi
	;STA <Vert_Scroll_Hi

	; Junction complete (and inventory is NOT open)
	LDA #$00	 
	STA Inventory_Open
	STA Level_JctCtl

PRG030_8B6D:
	LDX Player_Current

	; LDA Player_FallToKing,X
	; BEQ PRG030_8B78	 	; If player is NOT bound for king's room, jump to PRG030_8B78

	; JMP PRG030_9009	 ; Jump to PRG030_9009

PRG030_8B78:
	LDA #$00	
	STA IRQ_Mode ; IRQ_Mode = $00 (Normal status bar)
	STA UpdSel_Disable	; Resume Update_Select activity

	; Set page @ A000 to 27
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	; LDA Level_Tileset
	; CMP #15
	; BNE PRG030_8B9A	 ; If Level_Tileset <> 15 (Bonus game intro), jump to PRG030_8B9A

	; ; Otherwise, set page @ C000 to 22
	; LDA #22
	; STA PAGE_C000
	; JSR PRGROM_Change_Both2

PRG030_8B9A:
	; Set page @ A000 to 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

	; Set page @ A000 as appropriate for this tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; This is the init code for the level "boxing out" effect removed in the US release

	; US VERSION DOES THIS:
	JMP PRG030_8CB8	 ; Jump to PRG030_8CB8 (skipping code related to the "Boxing out" effect, removed in US version)

PRG030_8CB8:
	; End of box-out effect (removed in US version)

	; Set page @ A000 as appropriate for Tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA #$00
	STA <Map_EnterLevelFX	 ; Map_EnterLevelFX = 0

	LDX #$c0	 	; X = $C0 (Normal style updating)
	LDA Level_7Vertical	
	BEQ PRG030_8CD1	 	; If not a vertical level, jump to PRG030_8CD1

PRG030_8CD1:
	STX Update_Select	 ; Set Update_Select as appropriate

Level_MainLoop:
	JSR GraphicsBuf_Prep_And_WaitVSync

	LDA SndCur_Map
	AND #$04	
	BNE PRG030_8DF4	; If enter level sound is still playing, jump to PRG030_8DF4

	LDA Level_MusicQueue
	BEQ PRG030_8DF4	 	; If Music Queue is empty, jump to PRG030_8DF4

	CMP SndCur_Music2
	BEQ PRG030_8DEF	 	; If we're queueing the BGM already playing, jump to PRG030_8DEF (don't re-queue)

	STA Sound_QMusic2	 ; Queue the song that's waiting in Level_MusicQueue

PRG030_8DEF:
	LDA #$00
	STA Level_MusicQueue	 ; Queue is emptied

PRG030_8DF4:
PRG030_8E1D:
PRG030_8E31:
PRG030_8E4F:
	; REGULAR LEVEL ANIMATIONS

	LDA Level_PauseFlag
	BNE Graphics_Anim

Graphics_Anim:
	LDA <Player_HaltGameZ
	BNE PRG030_8E5D

	LDA <Anim_Counter
	AND #$1C
	LSR A	
	LSR A		
	TAX
	LDA Level_PSwitchCnt
	BNE Graphics_Anim1

	LDA Background_Animations,X
	BNE Graphics_Anim2

Graphics_Anim1:
	LDA Background_Animations + 8,X

Graphics_Anim2:
	STA PatTable_BankSel+1 ; Set pattern for this tick
	TXA
	AND #$03
	TAX

	LDA SPR_Anim, X
	ADD SprAnimOffset
	STA PatTable_BankSel+3

PRG030_8E5D:
	; End of animations...

	LDA SndCur_Pause
	ORA Player_IsDying
	BNE PRG030_8E79	 ; Can't unpause game while pause sound is playing

	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG030_8E79	 ; If Player is NOT pressing START, jump to PRG030_8E79

	LDX #PAUSE_STOPMUSIC	 ; for Sound_QPause, pause sound

	LDA Level_PauseFlag
	EOR #$01	 
	STA Level_PauseFlag	 ; Toggle pause flag
 
	BNE PRG030_8E76	 ; If game is now paused, jump to PRG030_8E76

	LDA Pause_Menu
	BEQ Pause_NoExit

	LDA #$FF
	STA <Level_ExitToMap
	STA Map_ReturnStatus

	LDA #$00
	STA Player_Vehicle
	STA Player_Shell
	STA Player_FireDash
	STA Level_PSwitchCnt
	STA Player_Yolked
	STA Player_Oiled
	STA Player_Frozen
	STA Frozen_Frame
	BEQ PRG030_8E79

Pause_NoExit:
	LDX #PAUSE_RESUMEMUSIC	 ; for Sound_QPause, resume sound

PRG030_8E76:
	STX Sound_QPause ; Set appropriately

PRG030_8E79:
	LDA Level_PauseFlag
	BNE Pause_DoMenu
	JMP PRG030_8EAD	 	; If not paused, jump to PRG030_8EAD

Pause_DoMenu:
	; When game is paused...
	LDA #$32
	STA PatTable_BankSel+5	; Set patterns needed for P A U S E sprites

	LDA Pad_Input
	AND #PAD_SELECT | PAD_UP | PAD_DOWN
	BEQ Pause_SelectNotPressed

	LDA #SND_MAPPATHMOVE	 
	STA Sound_QMap	 
	
	LDA Pause_Menu
	EOR #$01
	STA Pause_Menu

Pause_SelectNotPressed:	
	JSR Sprite_RAM_Clear	 ; Clear other sprites

	LDA #$60
	STA <Temp_Var1

	LDA Pause_Menu
	ASL A
	ASL A
	ASL A
	TAX

	LDY #$00

Next_ResumeSprite:
	LDA PAUSE_ResumeSprites, X
	STA Sprite_RAMTile, Y

	LDA PAUSE_ExitSprites, X
	STA Sprite_RAMTile + 4, Y
	
	LDA #SPR_PAL1
	STA Sprite_RAMAttr, Y
	STA Sprite_RAMAttr + 4, Y

	LDA #$50
	STA Sprite_RAMY, Y	

	LDA #$60
	STA Sprite_RAMY + 4, Y

	LDA <Temp_Var1
	STA Sprite_RAMX, Y
	STA Sprite_RAMX + 4, Y
	ADD #$08
	STA <Temp_Var1

	TYA
	ADD #$08
	TAY
	INX

	CPY #$40
	BNE Next_ResumeSprite

	; Updates palette
	LDA #$06	 
	STA <Graphics_Queue

	; Nothing else to do while paused; loop!
	JMP Level_MainLoop


PRG030_8EAD:
	; Not paused!

	LDA <Player_IsDying
	BNE PRG030_8ECC	 	; If Player is dying, jump to PRG030_8ECC

	LDY <Scroll_LastDir	; Y = Scroll_LastDir

PRG030_8EC3:
	LDA <Horz_Scroll
	STA <Scroll_Temp	; Scroll_Temp = Horz_Scroll
	LDA <Horz_Scroll_Hi	; A = Horz_Scroll_Hi

PRG030_8EC9:
	JSR Scroll_Update_Ranges

PRG030_8ECC:
	LDA Level_JctCtl	 
	BEQ PRG030_8EE7	 	; If not junctioning, jump to PRG030_8EE7

	; Level junction!

	; Set page @ A000 to 27
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData

	; Set page @ A000 to 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JMP HandleLevelJunction	; Handle the junction!

PRG030_8EE7:
	; Not junctioning...

	JSR Scroll_Update

	LDA #$00
	STA PAGE_C000	 ; Load page 0 @ C000
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$08	 
	STA PAGE_A000	 ; Load page 8 @ A000

	; Change both A000/C000 pages!
	JSR PRGROM_Change_Both2

	JSR Player_DoGameplay	 ; Does just about everything that makes the Player in gameplay mode!

	LDA <Player_IsDying
	CMP #$03
	BEQ PRG030_8F31	 ; If dead due to TIME UP, jump to PRG030_8F31

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_Both2	 

	JSR Objects_HandleScrollAndUpdate

	; Load page 7 @ A000
	LDY #$07
	STY PAGE_A000
	JSR PRGROM_Change_A000


	; Color rotation effects, lava, donut lifts, arrow platforms,
	; brick busts, water/waterfall visual effects, bubbles, splashes,
	; pop-up coins, Special Objects, Cannon Fires, Player Projectiles,
	; and, last but not least (well, maybe least), "shell kill flashes"!
	JSR Gameplay_UpdateAndDrawMisc
	LDA Scroll_Updated
	BNE Game_NoBackgroundUpdate

	JSR DrawStarsBackground

Game_NoBackgroundUpdate:
	LDA Level_HAutoScroll
	BEQ PRG030_8F31	 ; If Auto Horizontal Scrolling is NOT active, jump to PRG030_8F31

	; Load page 9 @ A000
	LDA #$09
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR AutoScroll_Do	 ; Perform auto scroll, if any

PRG030_8F31:
	LDA <Level_ExitToMap
	BEQ PRG030_8F42	 ; If Level_ExitToMap flag is not set, jump to PRG030_8F42

	LDA Map_ReturnStatus
	BPL Skip_StatReset

	LDA Previous_Coins
	STA Player_Coins

	LDA Previous_Coins+1
	STA Player_Coins+1

	LDA Previous_Coins+2
	STA Player_Coins+2

	LDA Previous_Cherries
	STA Player_Cherries

	LDA Previous_Badge
	STA Player_Badge

	LDA Previous_PowerUp_Reserve
	STA PowerUp_Reserve

	LDA Previous_Stars
	STA Paper_Stars

	JSR GetLevelBit
	
	LDA Previous_Stars_Collected1
	STA Paper_Stars_Collected1, Y
	
	LDA Previous_Stars_Collected2
	STA Paper_Stars_Collected2, Y
	
	LDA Previous_Stars_Collected3
	STA Paper_Stars_Collected3, Y

	LDA <Player_IsDying
	BNE Player_DyingNoSuit

	LDA World_Map_Power
	STA Player_EffectiveSuit
	
Player_DyingNoSuit:	
	INC Force_StatusBar_Init

Skip_StatReset:
	JSR MagicStar_ClearRadar
	
	; Transfer Player's current power up to the World Map counterpart
	LDA Player_EffectiveSuit
	STA World_Map_Power

	LDA #$00
	STA LeftRightInfection
	STA Player_Oiled
	STA Player_Yolked
	STA Enemy_Health
	STA Enemy_Health_Mode

	LDA #$40
	STA Air_Time
	STA Force_StatusBar_Init

PRG030_8F42:

	; Load page 29 @ C000
	LDA #29
	STA PAGE_C000
	JSR PRGROM_Change_C000

	JSR BlockChange_Do	 ; Do Block Change event, if necessary

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_C000

	; If scroll updates need to be committed, jump to PRG030_8F80 
	LDA Scroll_ToVRAMHi
	BNE PRG030_8F80
	LDA Scroll_ToVRAMHA
	BNE PRG030_8F80

	; No scroll updates need committed...

	LDA Level_SkipStatusBarUpd
	BNE PRG030_8F80	 ; If requesting we skip the status bar updates for this frame, jump to PRG030_8F80

	LDA <Graphics_Queue
	BNE PRG030_8F80	 ; If we have a video update to do, skip the status bar updates for this frame, jump to PRG030_8F80

	; Switch bank A000 to page 26
	LDA #24	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA InvFlip_Counter
	BNE PRG030_8F7D	 ; If InvFlip_Counter <> 0 (flipping open Inventory), jump to PRG030_8F7D

	JSR StatusBar_Update	; Just update values on the status bar
	JSR Process_Spinners

	LDA Inventory_Open
	BEQ PRG030_8F85	 ; If Inventory is not open, jump to PRG030_8F85

PRG030_8F7D:
	;JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

PRG030_8F80:

	; StatusBar_UpdFl = 0 (we just updated it)
	LDA #$00
	STA StatusBar_UpdFl

PRG030_8F85:

	; Level_SkipStatusBarUpd = 0 (only skip updating for one frame)
	LDA #$00
	STA Level_SkipStatusBarUpd

	LDA <Level_ExitToMap
	BEQ PRG030_9006	 ; If not exiting to map, jump to PRG030_9006 (Level_MainLoop)

	LDX Player_Current	 ; X = Player_Current

	; Switch bank A000 to page 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

PRG030_8FA1:
	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

PRG030_8FA8:
	; World_EnterState = 0
	LDA #$00
	STA World_EnterState

	; Disable the display
	STA <PPU_CTL2_Copy
	STA PPU_CTL2	 

PRG030_8FB2:
	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = LDX Player_Current

	LDA Player_FallToKing,X
	BEQ PRG030_8FCA	 ; If not falling to the King's room, jump to PRG030_8FCA

	; Exiting to King's room...

	LDA Map_ReturnStatus
	BNE PRG030_8FCA	 ; If Player died, jump to PRG030_8FCA

	; Player is alive...

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	JMP PRG030_88C8	 ; Jump to PRG030_88C8

PRG030_8FCA:
	; Clear $06FF - $0000, excluding $01xx
	LDY #$06
	JSR Clear_RAM_thru_ZeroPage

	; Vert_Scroll_Off = 0
	LDA #$00
	STA Vert_Scroll_Off

	JMP PRG030_8FFC
	; Stop the music
	;LDA #MUS1_STOPMUSIC
	;STA Sound_QMusic1

	; LDA Map_ReturnStatus
	; BNE PRG030_8FFC	 ; If Player died, jump to PRG030_8FFC

	; LDA Player_RescuePrincess
	; BEQ PRG030_8FFC	 ; If not rescuing the Princess, jump to PRG030_8FFC

	; ; Load page 24 into A000 and page 25 into C000
	; LDA #25
	; STA PAGE_C000
	; LDA #24
	; STA PAGE_A000
	; JSR PRGROM_Change_Both2

	; LDA #%10101000
	; STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	; LDA #$20
	; STA Update_Select	 ; Update_Select = $20 (Title Screen... or ending in this case)

	; JMP Rescue_Princess	 ; Do the Princess Rescue sequence!!

PRG030_8FFC:

	; Player died or not rescuing the princess...

	LDA #%0101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	JMP PRG030_9097	 	; Jump to PRG030_9097

PRG030_9006:
	JMP Level_MainLoop	; Gameplay loop!

PRG030_9009:
	; Player is falling into king's room...

	;LDA #$c0
	;STA Update_Select	; Update_Select = $C0 (Normal)

	;LDA #$00
	;STA IRQ_Mode	; IRQ_Mode = $00 (Normal status bar)

	;LDA #$00
	;STA World_EnterState	; World_EnterState = 0
	;STA <Level_ExitToMap	; Level_ExitToMap = 0 (not going to exit to map)

	; Set page @ A000 to 27
	;LDA #27
	;STA PAGE_A000
	;JSR PRGROM_Change_A000

	;JSR EndWorldLetter_GenerateText	; Generate the text for the end-of-world letter

	; Resume Update_Select activity
	;LDA #$00
	;STA UpdSel_Disable

	; Set page @ A000 to 27
	;LDA #27
	;STA PAGE_A000
	;JSR PRGROM_Change_A000
	;JSR Setup_PalData	 ; Setup palette data

	; Switch bank A000 to page 26
	;LDA #24
	;STA PAGE_A000
	;JSR PRGROM_Change_A000
	;JSR Palette_FadeIn	 ; On page 26 -- Fade in

	; Load font graphics
	;LDA #$5e
	;STA PatTable_BankSel+1

	; Set page @ A000 to 27
	;LDA #27
	;STA PAGE_A000
	;JSR PRGROM_Change_A000

PRG030_904D:
	;JSR GraphicsBuf_Prep_And_WaitVSync	 ; VSync

	;JSR CineKing_DoWandReturn	 ; Do the returned wand scene!

	;LDA <Level_ExitToMap
	;BEQ PRG030_904D		; While Level_ExitToMap = 0, loop

	; Clear $06FF - $0000, excluding $01xx
	;LDY #$06
	;JSR Clear_RAM_thru_ZeroPage

	; Clear some relevant Player values
	;LDX Total_Players
	;DEX		 ; X = Total_Players - 1
	;LDA #$00	 ; Clear value
PRG030_9062:
	;STA Player_FallToKing,X
	;STA Map_ReturnStatus
	;STA Map_Prev_XOff,X
	;STA Map_Prev_XHi,X

	;DEX		 ; X--
	;BPL PRG030_9062	 ; While X >= 0, loop
	; Stop any music
	;LDA #MUS1_STOPMUSIC
	;STA Sound_QMusic1

	;INC World_Num	 ; Go to next world!

	;JMP PRG030_84A0	 	; Jump to PRG030_84A0 (initialize the world map!)

PRG030_9097:

	; Exiting to map somehow

	LDA #$c0
	STA Update_Select	; Update_Select = $C0 (Normal)

	LDA #$00
	STA IRQ_Mode	


	; Need to transfer Player's "gameplay score" to their "inventory" score storage...

	LDY #$06	 ; Y = 6

	; LDA Map_ReturnStatus
	; BNE PRG030_910C	 ; If Player died, jump to PRG030_910C

	; Player did not die...
	JMP PRG030_9128
	; Toad House and bonuses jump to PRG030_9128
; 	LDA Level_Tileset
; 	CMP #15
; 	BGE PRG030_9128	 ; If Level_Tileset >= 15 (some kind of Bonus Game), jump to PRG030_9128
; 	CMP #$07
; 	BEQ PRG030_9128	 ; If Level_Tileset = 7 (Toad House), jump to PRG030_9128

; 	; Typical levels go here...

; 	LDX Player_Current	 ; X = Player_Current

; 	; Set bonus appearance coordinates at your last valid location!
; 	LDA Map_Previous_Y,X
; 	STA Map_BonusAppY
; 	LDA Map_Previous_XHi,X
; 	STA Map_BonusAppXHi
; 	LDA Map_Previous_X,X
; 	STA Map_BonusAppX

; 	LDA Map_Entered_Y,X
; 	STA Map_Previous_Y,X

; 	LDA Map_Entered_XHi,X
; 	STA Map_Previous_XHi,X

; 	LDA Map_Entered_X,X
; 	STA Map_Previous_X,X

; 	LDA Map_Prev_XOff,X
; 	STA Map_Prev_XOff2,X

; 	LDA Map_Prev_XHi,X
; 	STA Map_Prev_XHi2,X

; 	JMP PRG030_9128	 ; Jump to PRG030_9128

; PRG030_910C:

; 	; Player returns to map dead

; 	LDY #$02	 ; Y = 2 (Will be the Map_Operation value)

; 	; Map_ReturnStatus = 0
; 	LDA #$00
; 	STA Map_ReturnStatus

; 	LDX Player_Current	 ; X = Player_Current

; 	; Skid backward
; 	LDA #$00
; 	STA Map_Player_SkidBack,X

; 	LDA Map_PlayerLost2PVs
; 	BNE PRG030_9128	 ; If Map_PlayerLost2PVs is set, jump to PRG030_9128

PRG030_9128:

	; Stop any music
	;LDA #MUS1_STOPMUSIC
	;STA Sound_QMusic1

	STY Map_Operation	 ; Map_Operation = 2
	JMP PRG030_84D7	 	; Jump to PRG030_84D7

PRG030_9149:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA World_EnterState
	BNE PRG030_9163	 ; If World_EnterState <> 0, jump to PRG030_9163

	; Otherwise, gotta player the game over music!
	LDA #MUS1_GAMEOVER
	STA Sound_QMusic1

PRG030_9163:

	; Load up graphics
	LDA #$14
	STA PatTable_BankSel
	LDA #$16
	STA PatTable_BankSel+1
	LDX #$20
	STX PatTable_BankSel+2
	INX
	STX PatTable_BankSel+3
	INX
	STX PatTable_BankSel+4
	INX
	STX PatTable_BankSel+5
	JSR SetPages_ByTileset


	; Set both Players to their previous map values
	LDX Total_Players
	DEX		 ; X = Total_Players - 1

PRG030_9185:
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X

	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X

	LDA Map_Entered_X,X
	STA <World_Map_X,X

	; Set Player's previous travel direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X
	LDA #$00
	STA MapBackgroundInit

	DEX		 ; X--
	BPL PRG030_9185	; While X >= 0, loop!

	JSR Scroll_Map_SpriteBorder	 ; Keep that map border going!

	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_Reload_with_Completions	 ; Load map and set already completed levels


	INC Top_Needs_Redraw
	INC Bottom_Needs_Redraw

	LDX Player_Current	 ; X = Player_Current

	; Set Player's previous movement direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDY #$00	 ; Y = 0

	LDA World_Num
	CMP #$07
	BNE PRG030_91D1	 ; If World_Num <> 7 (World 8), jump to PRG030_91D1

	; World 8 only...

	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_XHi,X
	CMP #$02
	BNE PRG030_91D1	 ; If Player is not on the "dark" part of World 8, jump to PRG030_91D1

	INY		 ; Y = 1 (enable the World 8 darkness)

PRG030_91D1:
	STY World_8_Dark	 ; Set World_8_Dark appropriately

	LDY Player_Current	 ; Y = Player_Current

	; Scroll updates
	LDA Map_Prev_XOff,Y
	STA <Scroll_Temp
	LDA Map_Prev_XHi,Y
	JSR Scroll_Update_Ranges

	LDA <Scroll_ColumnL
	STA <Scroll_ColumnR

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

	; Set page @ A000 to 26
	LDA #24		
	STA PAGE_A000
	JSR PRGROM_Change_A000

	;JSR StatusBar_Update_Cards	 ; Update status bar cards
	;JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	;JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	;JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	LDY Player_Current	 ; Y =  Player_Current

	LDA Map_Prev_XOff
	STA <Horz_Scroll
	STA <Scroll_Temp
	
	LDA Map_Prev_XHi
	STA <Horz_Scroll_Hi
	JSR Scroll_Update_Ranges

PRG030_9226:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	LDA Map_DrawPanState
	BNE PRG030_9226	 	; If some kind of map drawing/panning activity is occurring, loop around

	LDA World_EnterState
	BNE PRG030_9257	 ; If World_EnterState <> 0, jump to PRG030_9257

	; Set page @ A000 to 11
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$12 		; X = $12 (standard $00 aligned GAME OVER box)

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG030_924B	 	; If Horz_Scroll = 0, jump to PRG030_924B

	LDX #$13		; Otherwise, X = $13 (map halfway scroll $80 aligned GAME OVER box)

PRG030_924B:
	TXA		 ; A = X
	JSR Video_Do_Update	 ; Draw up the Game Over! box

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

PRG030_9257:
	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 27
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

; Map_DayPalette:	
; 	; Switch bank A000 to page 26
; 	LDA #24
; 	STA PAGE_A000
; 	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

PRG030_927E:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!

	LDA GameOver_State

	CMP #$06
	BEQ PRG030_929C	 ; If GameOver_State = 6 (Player aligning to start panel Y), jump to PRG030_929C

	CMP #$09
	BNE PRG030_927E	 ; If GameOver_State <> 9 (Player did not choose to END), jump to PRG030_927E (loop around)

	; Player chose to END...

	LDA Total_Players
	CMP #$01
	BEQ PRG030_92B6	 ; If Total_Players = 1, jump to PRG030_92B6

	; More than 2 Players

PRG030_929C:
	
	; Stop music
	;LDA #MUS1_STOPMUSIC
	;STA Sound_QMusic1

	; Switch bank A000 to page 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	; Fade out

	LDA GameOver_State
	CMP #$09
	BEQ PRG030_92B6	 ; If GameOver_State = 9 (Player chose to END), jump to PRG030_92B6

	JMP PRG030_9149	 ; Jump to PRG030_9149

PRG030_92B6:

	LDA #$00
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)

	LDX Player_Current	 ; X = Player_Current

	LDA Map_GameOver_CursorY
	AND #$08
	BNE PRG030_932A	 ; If Player chose to END, jump to PRG030_932A

	; Player's live reset to 4
	LDA #$04
	STA Player_Lives,X

	; Set up position variables
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X

	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X

	LDA <World_Map_Y,X
	STA Map_Entered_Y,X

	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X

	LDA <World_Map_X,X
	STA Map_Entered_X,X

	; Reset map variables
	LDA #$00
	STA Map_Player_SkidBack,X
	STA World_EnterState
	STA Map_GameOver_CursorY

	LDY #$3f	 ; Y = $3F (End of Mario's Map Completions)

	CPX #$00
	BEQ PRG030_9314	 ; If Player is Mario, jump to PRG030_9314

	LDY #$7f	 ; Y = $7F (End of Luigi's Map Completions)

PRG030_9314:
	LDA #$3f
	STA <Temp_Var1	 ; Temp_Var1 = $3F
 
PRG030_9318:
	TYA
	EOR #$40
	TAX


	DEY		 ; Y--
	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9318	 ; While Temp_Var1 >= 0, loop!

PRG030_932A:
	LDY Total_Players	 ; Y = Total_Players
	DEY		 ; Y = 0 if 1P, or 1 if 2P

PRG030_932E:
	LDA Player_Lives,Y
	BPL PRG030_933E	 ; If this Player isn't dead, jump to PRG030_933E

	DEY		 ; Y--
	BPL PRG030_932E	 ; While Y >= 0, loop

	; All Players are dead and have given up

	; Stop music
	;LDA #MUS1_STOPMUSIC
	;STA Sound_QMusic1

	; Reset game
	JMP IntReset_Part2

PRG030_933E:

	; A Player gave up, but there's one left

	;JSR GameOver_PlayerQuitCleanup	 ; Performs some cleanup work for the Player who left

	; Map_Operation = 0
	LDY #$00
	STY Map_Operation

	LDX Player_Current	 ; X = Player_Current
	JMP PRG030_879B	 ; Jump to PRG030_879B


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetPages_ByTileset
;
; This routine uses sets both A000 and C000 pages based on the active Level_Tileset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetPages_ByTileset:	; $94BB
	LDY Level_Tileset	 	; Y = Level_Tileset

	; Change A000 and C000 pages based on Page_A/C000_List
	LDA PAGE_C000_ByTileset,Y
	STA PAGE_C000
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000	 
	JMP PRGROM_Change_Both2		; JUMP to page routine, do not continue below...


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Video_Do_Update
;
; This very important subroutine takes an index value in 'A'
; and sets up to execute one of the Video_Upd_Table updates
; to the screen, e.g. A = 2 for the status bar.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Video_Do_Update:	; $94CD
	PHA		 ; Push A

	ASL A		 ; A << 1 (multiply by 2, looks up different address)
	TAY		 ; Y = A

	; Set update VRAM address high/low
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	; Set page @ A000 to 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Video_Misc_Updates	 

	PLA		 ; Pop A

	BNE PRG030_94EE	 ; If A <> 0, jump to PRG030_94EE
	STA Graphics_BufCnt	; Clear the buffer counter
	STA Graphics_Buffer	; Immediately terminate the buffer

PRG030_94EE:
	; Jump into SetPages_ByTileset to "correct" the tables back
	; (mainly A000)
	JMP SetPages_ByTileset

	; This LUTs are for the unused-in-US-release "Box out" effect when a level starts
	
	; This one selects the appropriate init values for everything
	; else based on what the vertical start position is...
;BoxOut_ByVStart:	.byte $00, $30, $70, $B0, $EF	; Needs to sync with GamePlay_VStart

;	; The init values, each column links to an above vertical start position
;BoxOut_InitVAddrH:	.byte $21, $22, $23, $28, $29
;BoxOut_InitVAddrL0:	.byte $6E, $2E, $2E, $6E, $6E
;BoxOut_InitVAddrL1:	.byte $8E, $4E, $4E, $8E, $8E
;BoxOut_InitVAddrL2:	.byte $73, $33, $33, $73, $73
;BoxOut_InitVAddrL3:	.byte $6D, $2D, $2D, $6D, $6D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Clear_EntTranMem
;
; Clears memory used by the entrance transition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Clear_EntTranMem:
	LDY #$1c	 ; Y = $1C

PRG030_9555:
	LDA #$00	 ; A = 0
	STA Map_EntTran_VLHalf,Y
	DEY		 ; Y--
	BPL PRG030_9555	 ; While Y >= 0, loop!
	RTS		 ; Return


;BoxOut_SetThisBorderVRAM:
;	; Map_EntTran_VAddrL/H += Map_EntTran_VRAMGap
;	LDA Map_EntTran_VAddrL
;	ADD Map_EntTran_VRAMGap
;	STA Map_EntTran_VAddrL
;	LDA Map_EntTran_VAddrH
;	ADC #$00
;	STA Map_EntTran_VAddrH
;
;	LDA Map_EntTran_InitValIdx
;	CMP #$04
;	BEQ PRG030_95AD	 ; If the initial index was 4, jump to PRG030_95AD (RTS)
;
;	LDA Map_EntTran_Temp
;	CMP #$ff	 
;	BNE PRG030_95AD	 ; If Map_EntTran_Temp <> $FF, jump to PRG030_95AD (RTS)
;
;	LDY Map_EntTran_BorderLoop	 ; Y = current border index (0-3: Top 0, bottom 1, right 2, left 3)
;
;	; Prevent out of range video writes
;	LDA Map_EntTran_BVAddrH,Y
;	CMP #$28	 
;	BGE PRG030_95AD	 	; If border's VRAM high address >= $28, jump to PRG030_95AD (RTS)
; 
;	LDA Map_EntTran_VAddrH
;	CMP #$23
;	BLT PRG030_95AD	 	; If border's VRAM high address < $23, jump to PRG030_95AD (RTS)
;
;	LDA Map_EntTran_VAddrL
;	CMP #$c0
;	BLT PRG030_95AD	 	; If border's VRAM low address < $C0, jump to PRG030_95AD (RTS)
;
;	; Set VRAM address to [$28][Map_EntTran_BVAddrL & $1f]
;	LDA #$28
;	STA Map_EntTran_VAddrH
;
;	LDA Map_EntTran_VAddrL
;	AND #$1f
;	STA Map_EntTran_VAddrL
;
;	LDA Map_EntTran_BorderLoop	 ; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
;	AND #$02	
;	BEQ PRG030_95AD	 	; If not doing right side update, jump to PRG030_95AD (RTS)
;
;	STX Map_EntTran_Temp	 ; Store X (LRCnt) into Map_EntTran_Temp
;
;PRG030_95AD:
;	RTS		 ; Return


	; As part of the "boxing out" effect, calculate adjusted VRAM 
	; addresses as fit to the arbitrary positioning of the screen
;BoxOut_CalcOffsets:
;	; I'll let someone else figure this out in particular,
;	; I'm not as concerned about a removed effect...
;
;	LDA Map_EntTran_VAddrL
;	AND #$c0
;	STA Map_EntTran_TileOff
;
;	LDA Map_EntTran_VAddrH
;	AND #$0f
;	STA Map_EntTran_VAddrHAdj
;
;	CLC
;	ROR Map_EntTran_VAddrHAdj
;	ROR Map_EntTran_TileOff
;	CLC
;	ROR Map_EntTran_VAddrHAdj
;	ROR Map_EntTran_TileOff
;	LDA Map_EntTran_VAddrL
;	AND #$1f
;	LSR A	
;	ADD Map_EntTran_TileOff
;	STA Map_EntTran_TileOff
;
;	RTS		 ; Return
;
;
;	; Determine which 8x8 of the tile layout we're going to need
;BoxOut_CalcWhich8x8:
;	LDA Map_EntTran_VAddrL
;	AND #$01
;	STA Map_EntTran_Tile8x8
;
;	LDA Map_EntTran_VAddrL
;	AND #$20	 
;	BNE PRG030_95EF	
;
;	ASL Map_EntTran_Tile8x8
;	JMP PRG030_95F3	 	; Jump to PRG030_95F3
;
;PRG030_95EF: 
;	SEC		 
;	ROL Map_EntTran_Tile8x8
;
;PRG030_95F3:
;	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Calc_NT2Addr_By_XY
;
; This calculates the Nametable 2 address where a modification
; is about to take place (e.g. when a hammer has broken a rock)
; X = X coordinate on map (e.g. MapPoof_X)
; A = Y coordinate on map (e.g. MapPoof_Y)
;
; High byte of address is in Temp_Var15
; Low byte of address is in Temp_Var16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Calc_NT2Addr_By_XY:

	; This rearranges 'A' such that the two highest bits become
	; the two lowest bits, and the other 6 are shifted up.
	; Basically a ROL without the carry being involved
	ASL A
	ADC #$00
	ASL A	
	ADC #$00
	STA <Temp_Var13	 	; Stored into Temp_Var13

	TXA		 	; A = X coordinate
	LSR A
	LSR A
	LSR A
	STA <Temp_Var14 	; Temp_Var14 = X coord >> 3
 
	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11		; Get just the lower 2 bits (which are the upper 2 bits of Y coordinate)
	ORA #$28		; OR $28 (upper byte of video address for Nametable 2)
	STA <Temp_Var15		; Store into Temp_Var15

	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11000000		; Get just the upper 2 bits of Temp_Var13
	ORA <Temp_Var14	; OR in Temp_Var14
	STA <Temp_Var16	; Store into Temp_Var16

	RTS		 ; Return



;BoxOut_PutPatternInStrip:
;	JSR BoxOut_CalcOffsets	 ; Calculate offset to tile
;	JSR BoxOut_CalcWhich8x8	 ; Calculate which 8x8 pattern of the tile layout we're going to use
;
;PRG030_9654:
;	; Correct base address for non-vertical levels
;	LDA Tile_Mem_Addr
;	STA <Map_Tile_AddrL
;	LDA Tile_Mem_Addr+1
;	STA <Map_Tile_AddrH
;
;PRG030_965E:
;	LDA Map_EntTran_VAddrH
;	AND #$08	 
;	BEQ PRG030_966C	 ; If "high" address is not halfway through vertically, jump to PRG030_966C
;
;	; Otherwise, offset halfway through screen
;	LDA <Map_Tile_AddrL
;	ADD #$f0
;	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $F0
;
;PRG030_966C:
;	LDA Level_Tileset
;	ASL A		
;	TAY		 
;
;	; Set Temp_Var13/14 to point to the layout data for this Tileset
;	LDA TileLayout_ByTileset,Y
;	STA <Temp_Var13	
;	LDA TileLayout_ByTileset+1,Y
;	STA <Temp_Var14	
;
;	LDY Map_EntTran_TileOff
;	LDA [Map_Tile_AddrL],Y	 ; Get the tile we're working on
;
;	TAY		 
;	LDA Map_EntTran_Tile8x8
;	ADD <Temp_Var14		
;	STA <Temp_Var14		
;	LDA [Temp_Var13],Y	 ; Get the specific 8x8 tile of the tile we're working on
;
;	STA <Scroll_ColorStrip,X ; Store into the strip
;	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update_Ranges
;
; This subroutine updates Scroll_ColumnL/R based on
; where the screen has currently scrolled to...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update_Ranges: 
	; Non-vertical map
	; Expected that 'A' is currently set to the "Hi byte" of the X Scroll coordinate

	; This loop puts the lower 4 bits of the "hi byte" X into the 
	; upper 4 bits of Scroll_Temp, and shifts Scroll_Temp 4 bits down... or basically,
	; Scroll_Temp = (Scroll_Temp >> 4) | (A << 4)

	; Most importantly, this has taken a pixel-based scroll X and a "high byte" of X
	; scroll and combined them into a reduced accuracy (column-based) value of where
	; we're at horizontally...

	LDX #$03	 ; X = 3
PRG030_9695:
	LSR A		 ; Pushes the LSb -> Carry
	ROR <Scroll_Temp	 ; Shift everything in Scroll_Temp to the right, and pull in the carry
	DEX		 ; X--
	BPL PRG030_9695	 ; If X >= 0, loop!

	LDA <Scroll_Temp	; A = result from loop...
	STA <Scroll_ColumnL	; Store as the current "left side" column
	ADD #16
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL + 16 (always -- 256/16 = 16 columns spanning the screen)
	RTS			; Return!
	 	; Return!

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Clear_RAM_thru_ZeroPage
	; 
	; Starting at the page provided in Y, this will clear everything
	; (except the stack space) $YY00 to $0000
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Clear_RAM_thru_ZeroPage:
	STY <Temp_Var2	 ; Save Y in <Temp_Var2
	LDY #$00	 ; Y = 0
	STY <Temp_Var1	 ; Clear <Temp_Var1
	TYA		 ; A = 0

	; Y is the initial input as the high byte of the address
	; low first then high, so [Temp_Var2][Temp_Var1]
PRG030_96D5:
	LDX <Temp_Var2	 ; X = current high byte of address in this case
	CPX #$01	 ; If we've reached the $01xx bank...
	BEQ PRG030_96DD	 ; ... skip the next line (don't clear the stack space!)
	STA [Temp_Var1],Y	 ; Otherwise, clear this byte
PRG030_96DD:
	DEY		 ; Y--
	BNE PRG030_96D5	 ; While Y <> 0, loop around again (goes $00, $FF, $FE, ... back to $00) again
	DEC <Temp_Var2	 ; Next lower bank
	BPL PRG030_96D5	 ; While we're >= bank $00
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GraphicsBuf_Prep_And_WaitVSync
;
; This subroutine takes Graphics_Queue and loads and address
; from Video_Upd_Table into the Video_Upd_Addr, then waits for
; a VBlank cycle to occur via reading the VBlank_Tick after
; force-setting it to zero.  This gets the system into a state
; where it can actually apply the update!
;
; See also GraphicsBuf_Prep_And_WaitVSyn2 in PRG024
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GraphicsBuf_Prep_And_WaitVSync:	; 96E5
	LDA <Graphics_Queue
	ASL A		 	
	TAY		 	; Y = Graphics_Queue * 2

	; Get the address where the video update data is
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL

	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	;LDA #%00011001
	;STA PPU_CTL2
	LDA #$01	
	STA <VBlank_TickEn	 ; Enable the VBlank tick
	
	LDA #$00	 
	STA <VBlank_Tick	 ; Force VBlank_Tick = 0, so we know when a VBlank has occurred

	; Waiting for VBlank...
PRG030_96FB:
	;LDA #%00011110
	;STA $2001
	LDA <VBlank_Tick
	BPL PRG030_96FB	

	LDA #$00	 
	STA <VBlank_TickEn	 ; Disable the VBlank

	CLI		 ; Enable further masked interrupts

	LDA #%00011111
	;STA $2001
	RTS		 ; Return


	; Tile_Mem_ClearA/B form a way to rapidly clear all of the tile
	; memory to a specific value (A), used in conjunction with the
	; proper iterative loop...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearA
;
; $1B0 is the size of one screen, so this essentially writes to the
; same place on all screens, offset by 'Y'.  Unfortunately since 
; one screen is $1B0, 'Y' cannot cover the entire space, so we have
; Tile_Mem_ClearB with a different offset...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearA:	; $9705
	STA Tile_Mem,Y	 
	STA Tile_Mem+$1B0,Y
	STA Tile_Mem+$360,Y
	STA Tile_Mem+$510,Y
	STA Tile_Mem+$6C0,Y
	STA Tile_Mem+$870,Y
	STA Tile_Mem+$A20,Y
	STA Tile_Mem+$BD0,Y
	STA Tile_Mem+$D80,Y
	STA Tile_Mem+$F30,Y
	STA Tile_Mem+$10E0,Y
	STA Tile_Mem+$1290,Y
	STA Tile_Mem+$1440,Y
	STA Tile_Mem+$15F0,Y
	STA Tile_Mem+$17A0,Y

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearB
;
; Similar to Tile_Mem_ClearA, writes to the same place on all screens,
; only this one begins at the 12th row (making up for the 'Y'
; register coming up short of a full screen)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearB:	; $9734
	STA Tile_Mem+$0C0,Y
	STA Tile_Mem+$270,Y
	STA Tile_Mem+$420,Y
	STA Tile_Mem+$5D0,Y
	STA Tile_Mem+$780,Y
	STA Tile_Mem+$930,Y
	STA Tile_Mem+$AE0,Y
	STA Tile_Mem+$C90,Y
	STA Tile_Mem+$E40,Y
	STA Tile_Mem+$FF0,Y
	STA Tile_Mem+$11A0,Y
	STA Tile_Mem+$1350,Y
	STA Tile_Mem+$1500,Y
	STA Tile_Mem+$16B0,Y
	STA Tile_Mem+$1860,Y
	RTS		 ; Return


AnimOffsets: .byte $00, $10, $20, $28
AnimStarts: .byte $80, $D0, $F0, $5E

LevelLoad_MapLevelName:
	
	LDA PAGE_A000
	PHA
	LDA PAGE_C000
	PHA

	JSR LevelLoad_Setup
	JSR LevelLoad_Bank
	JSR LevelLoad_Name
	JSR LevelLoad_HasStars

	PLA
	STA PAGE_C000
	PLA
	STA PAGE_A000
	
	JSR PRGROM_Change_A000
	JSR PRGROM_Change_C000
	RTS

LevelLoad:
	JSR LevelLoad_Init

LevelLoadQuick:
	JSR LevelLoad_Setup
	JSR LevelLoad_TransProps
	JSR LevelLoad_Bank
	JSR LevelLoad_Checkpoint
	JSR LevelLoad_ClearMem
	JSR LevelLoad_Gfx
	JSR LevelLoad_ExitInfo
	JSR LevelLoad_Animations
	JSR LevelLoad_Size
	JSR LevelLoad_StartPosition
	JSR LevelLoad_LoadPos
	JSR LevelLoad_Music
	JSR LevelLoad_HasStars
	JSR LevelLoad_ScrollType
	JSR LevelLoad_Effects
	JSR LevelLoad_Event
	JSR LevelLoad_Name
	JSR LevelLoad_Pointers
	JSR LevelLoad_WriteLevel
	JSR Sprite_RAM_Clear
	RTS
	
LevelLoad_Init:
	LDA #$00
	STA <Vert_Scroll

	INC Force_StatusBar_Init

	LDA #$0F
	STA StatusBar_Palette
	STA StatusBar_Palette + 1
	STA StatusBar_Palette + 2

	JSR ClearBuffers
	RTS

LevelLoad_Setup:
	LDA #$6
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA #$00
	STA <Temp_Var1
	STA <Temp_Var2

	LDA LevelLoadPointer
	CLC
	ROL A
	ROL <Temp_Var2
	
	ROL A
	ROL <Temp_Var2

	STA <Temp_Var1

	LDA <Temp_Var2
	ADD #$BC
	STA <Temp_Var2

	LDY #$00
	LDA [Temp_Var1],Y
	STA <Temp_Var3	; bank

	INY

	LDA [Temp_Var1],Y
	STA <Temp_Var14  ; lo address

	INY

	LDA [Temp_Var1],Y
	STA <Temp_Var15  ; hi address
	
	INY
	LDA [Temp_Var1],Y
	STA Level_Tileset
	RTS

LevelLoad_Checkpoint:
	LDA CheckPoint_Flag
	ORA Entering_From_Map
	BEQ LevelLoad_CheckpointRTS

	LDA CheckPoint_Flag
	CMP LevelLoadPointer
	BNE LevelLoad_CheckpointRTS

	LDA <Pad_Holding
	AND #PAD_SELECT
	BNE LevelLoad_CheckpointRTS

	LDA CheckPoint_Level
	STA LevelLoadPointer

LevelLoad_CheckpointRTS:	
	RTS


LevelLoad_TransProps:
	JSR LoadTileProperties
	JSR LoadTransitions
	RTS

LevelLoad_Bank:
	LDX <Temp_Var3
	STX PAGE_A000
	JSR PRGROM_Change_A000

	INX
	STX PAGE_C000
	JSR PRGROM_Change_C000
	RTS

LevelLoad_ClearBuffers:
	JSR ClearBuffers
	RTS

LevelLoad_ClearMem:

	LDY #$00
	LDA [Temp_Var14],Y
	
	LDY #$F0

LevelLoad_ClearMemLoop:
	DEY
	JSR Tile_Mem_ClearA
	JSR Tile_Mem_ClearB
	
	CPY #$00
	BNE LevelLoad_ClearMemLoop
	RTS

LevelLoad_Gfx:
	LDY #$01

	LDA [Temp_Var14],Y
	STA PatTable_BankSel

	LDY #$02

	; now we load palette index, we load palette later...
	LDA [Temp_Var14],Y
	STA PaletteIndex
	RTS

LevelLoad_ExitInfo:
	LDA Level_JctCtl
	BNE LevelLoad_SetExit

	LDA #$00
	STA Level_InitAction
	JMP LevelLoad_ExitInfoRTS

LevelLoad_SetExit:
    LDA ForcedSwitch 
	BEQ LevelLoad_SetExitPos

	LDA #$01
	STA Player_HaltTick

	JMP LevelLoad_ExitInfoRTS

LevelLoad_SetExitPos:
	LDA Player_XExit
	AND #$F0

	LDX Level_PipeExitDir
	BEQ LevelLoad_NoXOffset

	CPX #$03
	BCS LevelLoad_NoXOffset
	ORA #$08

LevelLoad_NoXOffset:
	STA <Player_X

	LDA Player_XExit
	AND #$0F
	STA <Player_XHi

	LDA Player_YExit
	AND #$F0
	STA <Player_YZ

	LDA Player_YExit
	AND #$0F
	STA Player_YHiZ

LevelLoad_ExitInfoRTS:
	RTS

LevelLoad_Animations:
; Load level size/width
	LDY #$03
	LDA [Temp_Var14], Y
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAX

	LDA AnimOffsets, X
	STA AnimOffset
	
	LDA AnimStarts, X
	STA PatTable_BankSel+1	

	STY TempY
	LDY #$00
	LDX AnimOffset

LevelLoad_AnimBankLoop:
	LDA PT2_Anim, X
	STA Background_Animations, Y
	INX
	INY
	CPY #$10
	BCC LevelLoad_AnimBankLoop

	LDY TempY
	LDA Level_PSwitchCnt
	BEQ LevelLoad_NormAnimBank	 	; If P-Switch not active, jump to PRG030_89C4

	LDA Background_Animations + 8
	STA PatTable_BankSel+1	

LevelLoad_NormAnimBank:
	RTS

LevelLoad_Size:
	LDY #$03
	LDA [Temp_Var14],Y
	AND #$0F
	
	STA <Level_Width
	STA Level_SizeOrig
	RTS

LevelLoad_StartPosition:
	LDA Level_JctCtl
	BNE LevelLoad_StartPositionRTS

	LDA <Pad_Holding
	AND #PAD_SELECT
	BNE LevelLoad_LoadPos
	
	LDA CheckPoint_Level
	BEQ LevelLoad_LoadPos

	CMP LevelLoadPointer
	BNE LevelLoad_LoadPos

	
	LDA CheckPoint_X
	STA <Player_X

	LDA CheckPoint_XHi
	STA <Player_XHi

	LDA CheckPoint_Y
	STA <Player_YZ

	LDA CheckPoint_YHi
	STA <Player_YHiZ
	RTS

LevelLoad_LoadPos:
; load X/Y starting position
	LDY #$04

	LDA [Temp_Var14], Y	
	AND #$0F
	STA <Player_XHi

	LDA [Temp_Var14], Y
	AND #$F0
	STA <Player_X

	LDY #$05

	LDA [Temp_Var14], Y
	AND #$0F
	STA <Player_YHiZ

	LDA [Temp_Var14], Y
	AND #$F0
	STA <Player_YZ

LevelLoad_StartPositionRTS:
	RTS

LevelLoad_Music:
	LDY #$06

	LDA [Temp_Var14], Y
	BEQ LevelLoad_MusicRTS
	LDX SndCur_Music2	; X = currently playing music

	CPX #MUS2B_PSWITCH
	BEQ LevelLoad_MusicRTS		; If playing the P-Tab music, don't queue this song right now
	
	CPX #MUS2A_INVINCIBILITY		
	BEQ LevelLoad_MusicRTS		; If playing the Invincibility music, don't queue this song right now

	; Queue this music to play
	STA Level_MusicQueue

LevelLoad_MusicRTS:
	STA Level_MusicQueueRestore
	RTS

LevelLoad_HasStars:
	LDY #$07
	LDA [Temp_Var14], Y
	STA Level_NoStars
	RTS

LevelLoad_ScrollType:
	LDY #$08
	; set scroll type
	LDA [Temp_Var14],Y
	AND #$03
	STA Level_FreeVertScroll

	LDX #$00
	CMP #$03
	BNE LevelLoad_ScrollNotLocked

	INX

LevelLoad_ScrollNotLocked:
	STX Level_HorzScrollLock
	RTS

LevelLoad_Pointers:
	STA Debug_Snap
	JSR ClearPointers	
	
	LDY #$08
	
	LDA [Temp_Var14],Y
	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var6	; temporarily store pointer count

	
	LDY #$2F
	LDX #$00

	LDA <Temp_Var6
	BEQ LevelLoad_PointersRTS

LevelLoad_PointerLoop:
	LDA #$05		; pointers are 6 bytes long
	STA <Temp_Var7

LevelLoad_StorePointer:
	LDA [Temp_Var14],Y
	STA Pointers, X
	INY
	INX
	DEC <Temp_Var7
	BPL LevelLoad_StorePointer
	
	DEC <Temp_Var6
	BNE LevelLoad_PointerLoop

LevelLoad_PointersRTS:
	RTS

LevelLoad_Effects:
	LDY #$09
	LDA [Temp_Var14],Y
	AND #$80
	STA MushroomBlocks_Enabled
	
	LDA [Temp_Var14],Y
	AND #$40
	STA ProjectileToSpinners

	LDA [Temp_Var14],Y
	AND #$10
	STA TreasureBox_Disabled

	LDA [Temp_Var14],Y
	AND #$20
	STA RhythmPlatformEnabed

	LDX #$01
	
	LDA [Temp_Var14],Y
	AND #$03
	STA PaletteEffect
	BEQ LevelLoad_SetDayNight

	DEX

LevelLoad_SetDayNight:
	STX DayNightActive
	
	LDA [Temp_Var14],Y
	AND #$0C
	LSR A
	LSR A
	ORA Player_CheatSub
	STA Player_Vehicle
	RTS

LevelLoad_Event:
	LDY #$0A
	LDA [Temp_Var14], Y
	STA EventType

	LDA #$00
	STA EventSwitch
	STA EventVar
	RTS

LevelLoad_Name:
	LDY #$0D
	LDX #$00

LevelLoad_NameLoop:
	LDA [Temp_Var14],Y
	STA LevelName, X

	INY
	INX
	CPX #28
	BNE LevelLoad_NameLoop
	RTS

LevelLoad_WriteLevel:

	LDY #$08
	
	LDA [Temp_Var14],Y
	AND #$F0
	LSR A
	LSR A
	STA <Temp_Var5
	LSR A
	ADD <Temp_Var5
	ADD #$27
	STA <Temp_Var5
	TYA
	ADD <Temp_Var5
	ADD <Temp_Var14
	STA <Temp_Var14
	BCC StartLevelWriting

	INC <Temp_Var15

StartLevelWriting:
	LDA #$00
	STA <Temp_Var8
	
	LDA #$60
	STA <Temp_Var9

	LDY #$00	

NextDecompressionCommand:
	LDA [Temp_Var14], Y
	CMP #$FF
	BNE GetDecompressionCommand

	JSR LoadSprites
	RTS

GetDecompressionCommand:
	AND #$C0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	
	JSR DecompressCommand
	JMP NextDecompressionCommand

SECOND_QUEST_DIVIDER = $FE

DecompressCommand:
	JSR DynJump

	.word RepeatTile
	.word SkipTiles
	.word RepeatPattern
	.word WriteRaw

RepeatTile:

	LDY #$00
	LDA [Temp_Var14], Y
	AND #$3F
	STA <Temp_Var10

	JSR NextLevelByte

RepeatTileLoop:
	LDX Level_Redraw
	BEQ SkipRepeat

	LDA [Temp_Var14], Y
	STA [Temp_Var8],Y

SkipRepeat:	
	JSR NextTileByte
	DEC <Temp_Var10
	BPL RepeatTileLoop

	JSR NextLevelByte
	RTS

SkipTiles: 
	LDY #$00
	LDA [Temp_Var14], Y
	AND #$3F
	TAX

SkipMore:	
	JSR NextTileByte

	DEX
	BPL SkipMore

	JSR NextLevelByte
	RTS

RepeatPattern:
	LDY #$00
	LDA [Temp_Var14], Y
	AND #$3F			; pattern repeat count
	STA <Temp_Var11

	JSR NextLevelByte

	LDA [Temp_Var14], Y
	STA <Temp_Var12		; pattern length

	LDX #$00

LoadPattern:
	JSR NextLevelByte
	
	LDA [Temp_Var14], Y
	STA Level_Objects, X		; load pattern, reusing LevelObjects area for this
	
	INX
	CPX <Temp_Var12
	BNE LoadPattern

	; now we have the pattern, time to write it out!
RepeatPatternToLevel:
	LDX #$00

DrawPattern:
	STA $7FFE
	LDA Level_Redraw
	BEQ SkipDrawPattern

	LDA Level_Objects, X
	STA [Temp_Var8], Y

SkipDrawPattern:	
	JSR NextTileByte
	INX
	CPX <Temp_Var12

	BNE DrawPattern
	DEC <Temp_Var11

	BNE RepeatPatternToLevel
	
	JSR NextLevelByte
	RTS

WriteRaw:
	LDY #$00
	LDA [Temp_Var14], Y
	AND #$3F
	STA <Temp_Var11

WriteRawLoop:
	JSR NextLevelByte
	LDA Level_Redraw
	BEQ SkipWriteRaw
	
	STA $7FFD
	LDA [Temp_Var14], Y
	STA [Temp_Var8], Y

SkipWriteRaw:	
	JSR NextTileByte
	DEC <Temp_Var11
	BNE WriteRawLoop
	JSR NextLevelByte
	RTS

LoadSprites:
	LDA #$01
	STA Level_Objects

LoadSpritesReset:
	LDX #$01

LoadSpriteLoop:
	JSR NextLevelByte

	LDA [Temp_Var14], Y
	STA Level_Objects, X
	CMP #SECOND_QUEST_DIVIDER
	BEQ CheckSecondQuest

	CMP #$FF
	BEQ LoadSpritesDone
	BNE ContinueSpriteLoop

CheckSecondQuest:
	CMP SecondQuest
	BEQ LoadSpritesReset
	BNE LoadSpritesDone

ContinueSpriteLoop:
	INX
	BCC LoadSpriteLoop

LoadSpritesDone:
	LDA #$FF
	STA Level_Objects, X
	RTS

LoadTileProperties:
	LDA #$00
	STA <Temp_Var7

	LDA Level_Tileset
	ADD #$A0
	STA <Temp_Var8

	LDA #6			; switch to the tile properties table
	STA PAGE_A000
	JSR PRGROM_Change_A000
	LDY #$00

CopyTileProps:
	LDA [Temp_Var7], Y
	STA TileProperties, Y
	DEY
	BNE CopyTileProps
	RTS

LoadTransitions:
	LDA #$00
	STA <Temp_Var7 
	STA <Temp_Var8
	
	LDA Level_Tileset
	
	CLC

	ROL A
	ROL <Temp_Var8

	ROL A
	ROL <Temp_Var8

	ROL A
	ROL <Temp_Var8

	ROL A
	ROL <Temp_Var8

	ROL A
	ROL <Temp_Var8

	ROL A
	ROL <Temp_Var8

	STA <Temp_Var7

	LDA <Temp_Var8
	ADD #$B0
	STA <Temp_Var8

	LDY #$00

CopyAll:
	LDA [Temp_Var7], Y
	STA FireBallTransitions, Y
	INY
	CPY #$20
	BNE CopyAll

	LDX #$00
	LDA [Temp_Var7], Y
	INY

CopyVineTiles:
	LDA [Temp_Var7], Y
	INY
	INX
	CPX #$04
	BNE CopyVineTiles

	LDX #$00
	LDA [Temp_Var7], Y

CopyPSwitchTiles:
	LDA [Temp_Var7], Y
	STA PSwitchTiles, X
	INY
	INX
	CPX #$04
	BNE CopyPSwitchTiles
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Randomize
;
; Shakes up the random number pool a bit!
; Anyone want to detail the algorithm, go right ahead...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Randomize:
	LDX #$00	
	LDY #$09

	LDA Random_Pool
	AND #$02	
	STA <Temp_Var1	

	LDA RandomN	
	AND #$02	
	EOR <Temp_Var1	
	CLC		
	BEQ PRG030_999A	

	SEC		
PRG030_999A:
	ROR Random_Pool,X
	INX		 
	DEY		 
	BNE PRG030_999A	 

	RTS		 ; Return

TileLayout_ByTileset:
	; Defines the 8x8 blocks to build a particular 16x16 "tile"

	.word $A000
	.word $A400
	.word $A800
	.word $AC00
	.word $B000
	.word $B400
	.word $B800
	.word $BC00
	.word $A000
	.word $A400
	.word $A800
	.word $AC00
	.word $B000
	.word $B400
	.word $B800
	.word $BC00
	.word $A000
	.word $A400
	.word $A800

PRG030_9AA1:
	.byte $01, $FF

PRG030_9AA3:
	.byte $08, $F8

PRG030_9AA5:
	.byte $00, $08


TileLayoutPage_ByTileset:
	; A000 page selected per-Level_Tileset...
	.byte 22
	.byte 22
	.byte 22
	.byte 22
	.byte 22
	.byte 22
	.byte 22
	.byte 22
	.byte 23
	.byte 23
	.byte 23
	.byte 23
	.byte 23
	.byte 23
	.byte 23
	.byte 23


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Dirty_Update
;
; This function performs a full-screen redraw of all tiles, 
; used when first showing map/level, but not for scrolling!
; (Though it does call the same routine USED for scrolling)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Dirty_Update:

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	STA <Scroll_RightUpd,X	; Current horizontal scroll stored into appropriate left/right value

PRG030_9AC5:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	; Buffers a single 8x8 column of tiles
	JSR Scroll_DoColumn

	; Set page @ A000 to 26
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Commits the buffer
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	 ; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	 ; A = Get the last 8 pixel location update
	ADD PRG030_9AA3,X	 ; Add an appropriate offset given the direction of travel
	STA <Scroll_RightUpd,X	 ; Update it!

	; Produce the attribute data and commits the buffer
	JSR Scroll_Do_AttrColumn
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	; Last direction to index the following
	LDA <Scroll_RightUpd,X	; Get updated column
	AND #$08	 	; Every half screen
	CMP PRG030_9AA5,X
	BNE PRG030_9B02	 	; For updating on half-tiles (??), jump to PRG030_9B02
	LDA <Scroll_ColumnR,X	
	ADD PRG030_9AA1,X
	STA <Scroll_ColumnR,X

PRG030_9B02:
	DEC Scroll_Cols2Upd	 ; Scroll_Cols2Upd--
	BNE PRG030_9AC5	 ; While Scroll_Cols2Upd <> 0, loop!

	LDA #$ff
	STA <Scroll_RightUpd		 ; Scroll_RightUpd = $ff (marker as in "not last updated"; flat for dirty)
	STA <Scroll_LeftUpd		 ; Scroll_LeftUpd = $ff (marker as in "not last updated"; flat for dirty)
	JMP SetPages_ByTileset	 ; JUMP to SetPages_ByTileset to reset pages (will take care of the RTS)

; PRG030_9B10:

; 	; Scroll_LastDir = 0
; 	LDA #$00
; 	STA <Scroll_LastDir

; 	; Vert_Scroll = $E0
; 	LDA #$e0
; 	STA <Vert_Scroll

; 	; Scroll_RightUpd = $E8
; 	ADD #$08
; 	STA <Scroll_RightUpd

; 	; Scroll_ColumnR = (Level_SizeOrig - 1) | $E0
; 	LDY Level_SizeOrig	 ; Y = Level_SizeOrig
; 	DEY		 ; Y--
; 	TYA
; 	ORA #$e0
; 	STA <Scroll_ColumnR

; PRG030_9B26:
; 	; Set proper Page @ A000 for tile layout data
; 	LDY Level_Tileset
; 	LDA TileLayoutPage_ByTileset,Y	
; 	STA PAGE_A000	 
; 	JSR PRGROM_Change_A000

; 	JSR VScroll_PageAndDoPatAttrRow	 ; Do the row of patterns and attributes for vertical scroll

; 	; Set page @ A000 to 26
; 	LDA #24
; 	STA PAGE_A000
; 	JSR PRGROM_Change_A000

; 	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates
; 	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates

; 	LDA <Vert_Scroll
; 	ADD #$08
; 	STA <Vert_Scroll

; 	CMP #$f0
; 	BNE PRG030_9B59	 ; If not changing to new screen, jump to PRG030_9B59

; 	INC <Scroll_VOffsetT		 ; Scroll_VOffsetT++

; 	; Loop vertical offset to new screen
; 	LDA <Scroll_VOffsetT
; 	AND #$0f
; 	STA <Scroll_VOffsetT

; 	JMP PRG030_9B66	 ; Jump to PRG030_9B66

; PRG030_9B59:
; 	LDA <Vert_Scroll
; 	AND #$08
; 	BNE PRG030_9B66	 ; If only halfway vertically through tile row, jump to PRG030_9B66

; 	; Otherwise, go to next row
; 	LDA <Scroll_VOffsetT
; 	ADD #$10
; 	STA <Scroll_VOffsetT

; PRG030_9B66:
; 	LDA <Vert_Scroll
; 	CMP #$d0
; 	BNE PRG030_9B26	 ; While Vert_Scroll <> $D0, loop!

; 	LDA #$00
; 	STA <Vert_Scroll	; Vert_Scroll = 0
; 	STA <Scroll_VertUpd	; Scroll_VertUpd = 0
; 	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update
;
; This subroutine updates one column of tiles worth
; of scroll (tile and attribute) as needed per
; changes in Horz_Scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update:
	LDA #$00
	STA Scroll_Updated

	LDX <Scroll_LastDir	; X = Scroll_LastDir

	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$f8		; Only caring about every 8 pixels (for valid comparison to Scroll_RightUpd)
	CMP <Scroll_RightUpd,X	; Compared to whichever update applies to the last scroll
	BEQ PRG030_9BA9	 	; If we are updated completely, jump to PRG030_9BA9

	CPX #$00
	BNE Scroll_Update1

	; Otherwise ..

Scroll_Update1:
	TAY		 	; Y = A (Horz_Scroll, 8 pixel aligned)

	LDA Scroll_Cols2Upd
	BNE PRG030_9B9B	 	; If columns remain to be updated, jump to PRG030_9B9B

	LDA <Horz_Scroll
	AND #$07		; How many pixels across a tile boundary of 8 (0 - 7)

	CPX #$00
	BNE PRG030_9B97	 	; If last scroll direction <> 0 (last moved left), jump to PRG030_9B97

	; Last moved right...
	CMP #$02
	BGE PRG030_9B9B	 	; If greater-or-equal to 2 pixels to the right, jump to PRG030_9B9B

	JMP PRG030_9BA9	 	; Otherwise, jump to PRG030_9BA9

PRG030_9B97:
	; Last moved left...

	CMP #$05
	BGE PRG030_9BA9	 ; If greater-or-equal to 5 pixels in (complement to 2 pixels from right case), jump to PRG030_9BA9

	; Otherwise...

PRG030_9B9B:
	STY <Scroll_RightUpd,X	 ; Store our right/left update

	LDA <Scroll_LastDir
	EOR #$01	 
	TAX

	LDA #$FF
	STA <Scroll_RightUpd,X	 ; Store $FF on the other side

	JSR Scroll_DoColumn	 ; Render a column of tiles...

PRG030_9BA9:
	LDA Scroll_UpdAttrFlag	
	BEQ PRG030_9BB1	 	; If Scroll_UpdAttrFlag is not set (not time to update attributes), jump to PRG030_9BB1 (RTS)

	LDA #$01
	STA Scroll_Updated
	JSR Scroll_Do_AttrColumn ; Otherwise, Render a column of attributes...

PRG030_9BB1:
	RTS		 ; Return

; VScroll_PageAndDoPatAttrRow:
; 	; Set proper Page @ A000 for tile layout data
; 	LDY Level_Tileset
; 	LDA TileLayoutPage_ByTileset,Y	
; 	STA PAGE_A000	 
; 	JSR PRGROM_Change_A000

; 	JSR VScroll_CalcPatternVRAMAddr	 ; Calculate start of pattern row
; 	JSR VScroll_DoPatternAndAttrRow	 ; Do the pattern row AND attributes

; PRG030_9BD2:
; 	RTS		 ; Return

PRG030_9BD3:	.byte $00, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_DoColumn	
;
; This subroutine renders a "column" of 8x8 blocks for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_DoColumn:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset

	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	; Related last update value
	AND #$08	 	; Take just whether we've moved onto an 8
	LSR A		 	
	LSR A		 
	LSR A		 
	STA <Scroll_OddEven	; <Scroll_OddEven is 0 for 0, 1 for 8
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$0f	 	; A is now 0-15
	CPX #$00	 	
	BNE PRG030_9BFD	 	; If Scroll_LastDir = 0 (last scrolled right), jump to PRG030_9BFD

	; Last scrolled left
	CMP #$04	 	
	BGE PRG030_9C01	 ; If the horizontal scroll is 4-15, jump to PRG030_9C01
	JMP PRG030_9C06	 ; Otherwise, jump to PRG030_9C06

PRG030_9BFD:
	; Last scrolled right
	CMP #12	
	BGE PRG030_9C06	 ; If the horizontal scroll is 12-15, jump to PRG030_9C06

PRG030_9C01:	; (Scrolled left and scroll is 4-15) OR (Scrolled right and scroll is 0-11)

	; Scroll_UpdAttrFlag = 1 (time to update attributes!)
	LDA #$01
	STA Scroll_UpdAttrFlag

PRG030_9C06:
	LDA Level_Tileset 
	ASL A		 ; A = Level_Tileset << 1 (index into TileLayout_ByTileset)
	TAY		 ; -> 'Y'
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var11		 
	STA <Temp_Var13		 

	; The following takes the high byte of the "TileLayout_ByTileset"
	; and either adds nothing or a jump of 512, and still adds a jump of
	; 256 to the after address 
	LDX TileLayout_ByTileset+1,Y	; X = High byte of address (block 0 of tile)
	LDA <Scroll_OddEven		; A = Scroll_OddEven
	BEQ PRG030_9C1B			; If Scroll_OddEven = 0, jump to PRG030_9C1B
	INX		 		; +256 (block 1)
	INX		 		; +256 (block 2) beginning of the right half

PRG030_9C1B:
	STX <Temp_Var12		; High byte [?] into Temp_Var12
	INX		 		; block 1 or 3, depending on Scroll_OddEven
	STX <Temp_Var14		; High byte [?] into Temp_Var14

	LDX <Scroll_LastDir		; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	 	; A = appropriate current column (right or left)
	AND #$f0	 	 	; Checking what screen we're on (every 16 columns is a screen's worth)
	LSR A		 
	LSR A		 
	LSR A		 
	TAY		 		; Y = ((Scroll_ColumnR & $F0) >> 3), or basically, 2 for every screen we've moved (for indexing...)

	; Set the address of the tiles we need to modify!
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var15	

	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var16	

	LDA #26	 		; Number of rows to update (NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 26)
	STA <Temp_Var1		; Temp_Var1 = 26 (see immediately above)
	LDA <Scroll_ColumnR,X	; Get the column we're on
	AND #$0f	 	; Make it relative to THIS screen, 0-15
	STA <Temp_Var2		; Temp_Var2 stores this value

	LDX #$00	 	; X = 0
PRG030_9C40:
	LDY <Temp_Var2		; Y = Temp_Var2 (screen relative column)
	LDA [Temp_Var15],Y	; Get tile to display
	TAY		 	; Tile becomes offset 'Y'

	; Store the top block for this tile
	LDA [Temp_Var11],Y
	STA Scroll_PatStrip,X

	; Store the bottom block for this tile
	LDA [Temp_Var13],Y
	STA Scroll_PatStrip+1,X

	LDA <Temp_Var2
	ADD #16	
	STA <Temp_Var2	 	; Temp_Var2 += 16 (next row in this column is 16 bytes down)
	BCC PRG030_9C5A	 	; If we haven't overflowed, jump to PRG030_9C5A
	INC <Temp_Var16	; Otherwise we need to increment the upper part of the tile address
PRG030_9C5A:
	INX		 
	INX		 ; X += 2 (two tiles added)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9C40	 ; If more tiles to go, loop!


	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	; A = last column value
	AND #$0f	 	; Screen column relative
	ASL A		 	; A << 1 (0, 2, 4, ... E)
	ORA <Scroll_OddEven	; Apply the odd/even (forms an 8x8 current column)
	STA Scroll_LastCol8	; Store this in Scroll_LastCol8

	LDA #$20	 	; 
	STA Scroll_ToVRAMHi	; Scroll_ToVRAMHi = $20
	JMP SetPages_ByTileset	; JUMP to SetPages_ByTileset (restores page A000 most importantly, and will do the RTS)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrColumn
;
; This subroutine renders a "column" of attributes for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG030_9C74:
	.byte $F1, $01

PRG030_9C76:
	.byte $ff, $0f

Scroll_Do_AttrColumn:
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Y = get column
	TYA		 	; A = Y
	AND #$01	 	; Get odd/even
	BEQ PRG030_9C87	 	; If even, jump to PRG030_9C87

	TYA		 	; A = back to column again
	ADD PRG030_9C76,X	; Add appropriate value, whether going right or left (-1 or +15)
	TAY		 	; Y = A

PRG030_9C87:
	STY <Temp_Var1		; column, possibly offset, into Temp_Var1
	LDA #$00	 	
	STA <Temp_Var2		; Temp_Var2 = 0

PRG030_9C8D:
	LDA <Temp_Var1		; A = Temp_Var1 (column, possibly offset)
	AND #$f0	 	; Figure out which SCREEN we're on
	LSR A		 
	LSR A		 
	LSR A		 	; A >> 3 (2 byte per screen index)
	TAY		 	; Y = A

	; Setup pointer to tile memory we need to be focusing on!
	LDA Tile_Mem_Addr,Y	
	STA <Temp_Var15		

	LDA Tile_Mem_Addr+1,Y	
	STA <Temp_Var16	

	LDX <Temp_Var2	 	; X = Temp_Var2
	LDA <Temp_Var1	 	; A = Temp_Var1
	AND #$0f	 	; Current screen-relative column
	TAY		 	; Y = A (screen relative column)
PRG030_9CA6:
	LDA [Temp_Var15],Y	; Get next tile
	AND #$c0	 	; Set attributes based on the "range" of the tile, like palette 0 for tiles 00-3f, palette 1 for tiles 40-7f, etc.
	STA <Scroll_ColorStrip,X	; Store this into the attribute strip
	TYA		 	; A = Y (the tile offset)
	ADD #16		 	; A += 16 (every tile row is 16 bytes)
	TAY		 	; Y = A
	BCC PRG030_9CB5	 	; If we didn't overflow, jump to PRG030_9CB5
	INC <Temp_Var16	; Increment the high byte
PRG030_9CB5:
	INX			; X++ (next byte in the Scroll_ColorStrip)
	STX <Temp_Var2		; Temp_Var2 = X
	CPX #27	
	BNE PRG030_9CD0	 	; If X <> 27, jump to PRG030_9CD0

	; X is 27, we need to go to the next page
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Get the column
	TYA		 	; A = Y
	AND #$01	 	; 
	BNE PRG030_9CCB	 	; If odd, jump to PRG030_9CCB
	TYA			; A = Y (back to the column)
	ADD PRG030_9C74,X
	TAY		 	; -> 'Y'
PRG030_9CCB:
	STY <Temp_Var1		; -> Temp_Var1
	JMP PRG030_9C8D	 	; Loop around again...

PRG030_9CD0:
	CPX #54
	BNE PRG030_9CA6	 ; If A <> 54, loop!


	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0 

PRG030_9CD8:
	; Attributes store colors for 4 tiles in one byte, this
	; forms the coloring information for all four blocks; this
	; also explains the odd-but-necessary offsets
	LDA <Scroll_ColorStrip,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+27,X
	LSR A		 
	LSR A		 ; A >>= 2 
	ORA <Scroll_ColorStrip+1,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+28,X

	STA Scroll_AttrStrip,Y
	INX		 ; X++
	INX		 ; X++
	CPY #$07	 
	BNE PRG030_9CF8	 ; If Y <> 7, jump to PRG030_9CF8

	; Only store half the attribute data on row 7
	LDA Scroll_AttrStrip,Y	
	AND #$0f
	STA Scroll_AttrStrip,Y	
	DEX		 ; X--	; Redo other half later!

PRG030_9CF8:
	INY		 ; Y++
	CPY #14	 	 
	BNE PRG030_9CD8	 ; If Y <> 14, loop!

	LDA #$23	 
	STA Scroll_ToVRAMHA	; Scroll_ToVRAMHA = $23
	LDX <Scroll_LastDir	
	LDA <Scroll_ColumnR,X	; Get column
	AND #$0f	 	; Screen relative
	LSR A		 	; A >> 1 (every two blocks when dealing with attributes)
	ORA #$c0	 	; $C0 is the base offset into Attribute Table 0/2
	STA Scroll_LastAttr	; Store into Scroll_LastAttr

	; Scroll_UpdAttrFlag = 0
	LDA #$00	 
	STA Scroll_UpdAttrFlag

	RTS		 	; Return!


; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ; VScroll_CalcPatternVRAMAddr
; ;
; ; Calculates Scroll_ToVRAMHi/Lo for patterns for the current vertical scroll
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcPatternVRAMAddr:
; 	LDX <Scroll_LastDir	; X = Scroll_LastDir

; 	; Calculate VRAM High into nametable for this offset
; 	LDA <Scroll_VOffsetT,X
; 	AND #$c0
; 	LSR A
; 	LSR A
; 	LSR A
; 	LSR A
; 	LSR A
; 	LSR A
; 	ADD #$20
; 	STA Scroll_ToVRAMHi

; 	; Calculate VRAM Low into nametable for this offset
; 	LDA <Scroll_VOffsetT,X
; 	AND #$30
; 	ASL A
; 	ASL A
; 	STA Scroll_LastOff8

; 	LDA <Vert_Scroll
; 	AND #$08
; 	BEQ PRG030_9D3E	 ; If not on odd row, jump to PRG030_9D3E (RTS)

; 	; +32 bytes to offset to reach next tile row in VRAM
; 	LDA Scroll_LastOff8
; 	ADD #32
; 	STA Scroll_LastOff8

; PRG030_9D3E:
; 	RTS		 ; Return


; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ; VScroll_DoPatternAndAttrRow
; ;
; ; This subroutine renders a "row" of 8x8 blocks for the vertical
; ; screen scrolling.  Also creates the attributes for the same.
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_DoPatternAndAttrRow:
; 	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

; 	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
; 	AND #$0f
; 	TAY		 ; Y = offset column

; 	; Get address of tile at this vertical position
; 	LDA Tile_Mem_AddrVL,Y
; 	STA <Map_Tile_AddrL
; 	LDA Tile_Mem_AddrVH,Y
; 	STA <Map_Tile_AddrH

; 	; Temp_Var9 = offset at leftmost column in current row
; 	LDA <Scroll_VOffsetT,X
; 	AND #$f0
; 	STA <Temp_Var9

; 	; Temp_Var10 = 0
; 	LDA #$00
; 	STA <Temp_Var10

; PRG030_9D5A:
; 	LDY <Temp_Var9		 ; Y = current offset along row
; 	LDA [Map_Tile_AddrL],Y	 ; Get tile here
; 	STA <Temp_Var11		 ; -> Temp_Var11

; 	INC <Temp_Var9		 ; Temp_Var9++ (next column)

; 	JSR TileLayout_GetBaseAddr	 ; Get tile layout address -> Temp_Var13/14

; 	LDX <Temp_Var10		 ; X = Temp_Var10

; 	LDA <Vert_Scroll
; 	AND #$08
; 	BEQ PRG030_9D6F	 ; If not vertically halfway on the tile, jump to PRG030_9D6F

; 	INC <Temp_Var14		 ; Otherwise, Temp_Var14++ (next row of layout)

; PRG030_9D6F:
; 	LDA [Temp_Var13],Y	 ; Get pattern of tile
; 	STA Scroll_PatStrip,X	 ; Store into pattern strip

; 	INX		 ; X++ (next pattern strip byte)

; 	; Temp_Var14 += 2 (next adjacent tile pattern)
; 	INC <Temp_Var14
; 	INC <Temp_Var14

; 	LDA [Temp_Var13],Y	 ; Get pattern of tile
; 	STA Scroll_PatStrip,X	 ; Store into pattern strip

; 	INX		 ; X++ (next pattern strip byte)

; 	STX <Temp_Var10		 ; X -> Temp_Var10

; 	CPX #$20
; 	BLT PRG030_9D5A	 ; If not at end of strip row, loop

; 	LDA Scroll_LastOff8
; 	CMP #$20
; 	BEQ PRG030_9D92	 ; If Scroll_LastOff8 = $20 (end of top row), jump to PRG030_9D92

; 	CMP #$a0
; 	BEQ PRG030_9D92	 ; If Scroll_LastOff8 = $A0 (end of bottom row), jump to PRG030_9D92

; 	BNE PRG030_9D98	 ; Otherwise, jump to PRG030_9D98 (RTS)

; PRG030_9D92:
; 	JSR VScroll_CalcAttributeVRAMAddr	; Calculate the attribute VRAM addresses
; 	JSR Scroll_Do_AttrRow	 		; Do row of attributes

; PRG030_9D98:
; 	RTS		 ; Return


; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ; VScroll_CalcAttributeVRAMAddr
; ;
; ; Calculates Scroll_ToVRAMHA/Scroll_LastAttr for attributes for the current vertical scroll
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcAttributeVRAMAddr:

; 	; VRAM High address to attributes
; 	LDA #$23
; 	STA Scroll_ToVRAMHA

; 	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

; 	; VRAM Low address to attributes
; 	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
; 	AND #$c0
; 	LSR A
; 	LSR A
; 	ADD #$c0
; 	STA Scroll_LastAttr

; 	LDA <Scroll_VOffsetT,X
; 	AND #$20
; 	BEQ PRG030_9DBB	

; 	; Scroll_LastAttr += 8
; 	LDA Scroll_LastAttr
; 	ADD #$08
; 	STA Scroll_LastAttr

; PRG030_9DBB:
; 	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrRow
;
; This subroutine renders a "row" of attributes for the
; screen scrolling.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Do_AttrRow:
	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$0f
	TAY		 ; Y = offset column

	; Get address of tile at this vertical position
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var9 = offset at leftmost column in current row
	LDA <Scroll_VOffsetT,X
	AND #$f0
	STA <Temp_Var9

	AND #$10
	BNE PRG030_9DDE

	LDA <Temp_Var9
	ADD #$10
	STA <Temp_Var9 

PRG030_9DDE:
	INC <Temp_Var9		 ; Temp_Var9++ (next column)

	; Temp_Var8 = 0
	LDA #$00
	STA <Temp_Var8
PRG030_9DE4:
	LDY <Temp_Var9		 ; Y = current offset along row
	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Y -= 15 (previous row; 15 because VScroll_TileQuads2Attrs already subtracted 1)
	TYA
	SUB #$0f
	TAY

	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Temp_Var9 += 2 (next 2 columns over)
	INC <Temp_Var9
	INC <Temp_Var9

	; Temp_Var8++ (next Scroll_AttrStrip byte)
	INC <Temp_Var8

	LDA <Temp_Var8
	CMP #$08
	BLT PRG030_9DE4	 ; While not at end of row, loop

	LDA Scroll_LastAttr
	CMP #$f8
	BNE PRG030_9E11

	LDY #$07	 ; Y = 7
PRG030_9E06:

	LDA Scroll_AttrStrip,Y
	AND #$0f
	STA Scroll_AttrStrip,Y

	DEY		 ; Y--
	BPL PRG030_9E06	 ; While Y >= 0, loop

PRG030_9E11:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TileLayout_GetBaseAddr
;
; Set layout pointer for the active tileset -> Temp_Var13/14
; also reloads 'Y' with the tile in Temp_Var11
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TileLayout_GetBaseAddr:
	LDA Level_Tileset 
	ASL A
	TAX		 ; X = Level_Tileset * 2

	; Set Temp_Var13/14 to point to the layout data for this Tileset
	LDA TileLayout_ByTileset,X
	STA <Temp_Var13
	LDA TileLayout_ByTileset+1,X
	STA <Temp_Var14

	LDY <Temp_Var11		 ; Y = tile temp

	RTS		 ; Return


VScroll_TileQuads2Attrs:
	LDX <Temp_Var8		 ; X = Temp_Var8 (Scroll_AttrStrip offset)

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	DEY		 ; Y--

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	RTS		 ; Return



	; This is basically a lookup for any given "Player Y Hi" shifted up 4 bits
PRG030_9E6C:
	.byte $00, $10, $20, $30, $40, $50, $60, $70, $80, $90, $A0, $B0, $C0, $D0, $E0, $F0

	; Translates the Player position into appropriate "high" value
	; as Vertical describes it ($0(00), $0(F0), $1(E0), ...)
LevelJct_GetVScreenH:
	; Y = Player_YHiZ
	; A = Player_Y

	CPY #$00
	BLS PRG030_9E8E	 ; If Y < 0 (i.e. if the Player Y High is less than zero, which shouldn't happen!), jump to PRG030_9E8E (RTS)

	ADD PRG030_9E6C,Y	; Player_Y += Player_YHiZ[Y]
	BCS PRG030_9E8A	 	; If carry set (overflow occurred), jump to PRG030_9E8A

	CMP #$f0	
	BLT PRG030_9E8E	 	; If result is < $F0, jump to PRG030_9E8E

PRG030_9E8A:
	; Add $10 and roll over 'Y' (Considered in the lower vertical half)
	ADD #$10
	INY	

PRG030_9E8E:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTile
;
; Get tile and slope for given position and offset
; for non-vertical ("normal") levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_X = Temp_Var16
Tile_XHi = Temp_Var15
Tile_Y = Temp_Var14
Tile_YHi = Temp_Var13
Player_GetTile:	; $9E9D

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo
	LDA <Tile_YHi
	BPL Tile_YNotUnderFlow

	LDA #$00
	STA <Tile_YHi
	STA <Tile_Y

Tile_YNotUnderFlow:	
	CMP #$01
	BCC Tile_YNotOverFlow

	LDA <Tile_Y
	CMP #$B0
	BCC Tile_YNotOverFlow

	LDA #$A8
	STA <Tile_Y

Tile_YNotOverFlow:	
	; Clear slope array
	LDA <Temp_Var16
	STA Tile_DetectionX
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Level_TileOff	 ; Level_TileOff = Temp_Var16 >> 4 (current column Player is in)

	LDA <Temp_Var15
	AND #$0f	
	ASL A		
	TAX		 ; X = (Temp_Var15 & $0F) << 1 (current "high" part of Player X shifted up by 1, indexing Tile Mem)

	; Set Map_Tile_AddrL/H to appropriate screen based on Player's position
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	LDA <Temp_Var13
	BEQ PRG030_9EC3	 ; If Temp_Var13 (Y Hi) = 0, jump to PRG030_9EC3

	INC <Map_Tile_AddrH ; Otherwise, go to second half of screen

PRG030_9EC3:
	LDA <Tile_Y
	STA Tile_DetectionY
	AND #$f0
	ORA <Level_TileOff	 ; Level_TileOff gets the Player's current row in the upper 4 bits

	; Level_TileOff is now Player's current offset in Tile Mem from the selected pointer

	STA <Temp_Var12		 ; ... and copied into Temp_Var12

	TAY		 	; Y = current offset
	LDA [Map_Tile_AddrL],Y	; Get tile here
	STA ActualTile_LastValue

	JSR PSwitch_SubstTileAndAttr
	STA Tile_LastValue
	TAY
	LDA TileProperties, Y
	STA Tile_LastProp
	RTS		 ; Return


PRG030_SUB_9F40:
	LDA #$00
	STA Raster_State 	; Reset Raster_State

	LDA Update_Request
	JMP PRG031_F499

	; Sub part of A0 mode of IRQ
PRG030_SUB_9F50:
	; Some kind of delay loop?
	LDX #$17	 ; X = $17
PRG030_9F52:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG030_9F52 ; While X > 0, loop

	; Latch this value, and force it into the counter!
	STA MMC3_IRQLATCH
	STA MMC3_IRQDISABLE
	STA MMC3_IRQENABLE
	RTS		 ; Return

; IntIRQ_32PixelPartition_Part5:

; 	; Some kind of delay loop?
; 	LDX #$13	 ; X = $13
; PRG030_9F80:
; 	NOP		 ; ?
; 	DEX		 ; X--
; 	BPL PRG030_9F80 ; While X > 0, loop

; 	; More NOPs
; 	NOP
; 	NOP
; 	NOP

; 	STA MMC3_IRQLATCH ; Latch A (last set to 27!)
; 	STA MMC3_IRQENABLE ; Enable IRQ again
; 	JMP PRG031_FA3C	 ; Jump to PRG031_FA3C

; IntIRQ_32PixelPartition_Part2:	; $9FA0
; 	LDA Update_Request	 
; 	AND #UPDATERASTER_32PIXSHOWSPR
; 	BNE PRG030_9FAA	 ; If UPDATERASTER_32PIXSHOWSPR is set, go to PRG030_9FAA

; 	; Otherwise, change loaded pattern tables to hide sprites that fall beneath the 32 pixel partition
; 	JMP IntIRQ_32PixPart_HideSprites

; PRG030_9FAA:

; 	; I think the following NOPs and loop are to help synchronize the IRQ
; 	; routine if it didn't perform the IntIRQ_32PixPart_HideSprites step
; 	NOP
; 	NOP
; 	NOP

; 	LDX #$03	 ; X = 3
; PRG030_9FAF:
; 	NOP		 ; ?
; 	DEX		 ; X--
; 	BPL PRG030_9FAF	 ; While X > 0, loop

; 	JMP IntIRQ_32PixelPartition_Part3

CalcParam1 = Temp_Var1
CalcParam2 = Temp_Var4
CalcResult = Temp_Var7

Add2ByteValue:
	LDA #$00
	STA <CalcParam1 + 2
	STA <CalcParam2 + 2


Add3ByteValue:
	LDA <CalcParam1
	ADD <CalcParam2
	STA <CalcResult
		
	LDA <CalcParam1 + 1
	ADC <CalcParam2 + 1
	STA <CalcResult + 1
		
	LDA CalcParam1 + 2
	ADC CalcParam2 + 2
	STA CalcResult + 2
	RTS

Subtract2ByteValue:
	LDA #$00
	STA <CalcParam1 + 2
	STA <CalcParam2 + 2

Subtract3ByteValue:
	LDA <CalcParam1
	SUB <CalcParam2
	STA <CalcResult
		
	LDA <CalcParam1 + 1
	SBC <CalcParam2 + 1
	STA <CalcResult + 1
		
	LDA <CalcParam1 + 2
	SBC <CalcParam2 + 2
	STA <CalcResult + 2
	RTS

DigitsParam = Temp_Var1

DigitsResult = Temp_Var10

DigitsCalcsLo:
	.byte $0A, $64, $E8, $10, $A0, $40

DigitsCalcsMid:
	.byte $00, $00, $03, $27, $86, $42

DigitsCalcsHi:
	.byte $00, $00, $00, $00, $01, $0F

BytesTo7Digits:
	LDX #$05
	BNE BytesToDigits

BytesTo6Digits:
	LDX #$04
	BNE BytesToDigits

BytesTo5Digits:
	LDX #$03
	BNE BytesToDigits

BytesTo4Digits:
	LDA #$00
	STA DigitsParam + 2

	LDX #$02
	BNE BytesToDigits

BytesTo3Digits:
	LDA #$00
	STA DigitsParam + 2

	LDX #$01
	BNE BytesToDigits

BytesTo2Digits:
	LDA #$00
	STA DigitsParam + 1
	STA DigitsParam + 2
	LDX #$00
	BNE BytesToDigits

BytesToDigits:
	
	LDA #$00
	STA <DigitsResult + 1, X
	LDA DigitsCalcsLo, X
	STA <CalcParam2

	LDA DigitsCalcsMid, X
	STA <CalcParam2 + 1

	LDA DigitsCalcsHi, X
	STA <CalcParam2 + 2

BytesToDigits0:
	JSR Subtract3ByteValue
	LDA <CalcResult + 2
	BMI BytesToDigits1

	INC <DigitsResult + 1, X
	LDA <CalcResult
	STA <DigitsParam

	LDA <CalcResult + 1
	STA <DigitsParam + 1

	LDA <CalcResult + 2
	STA <DigitsParam + 2
	JMP BytesToDigits0

BytesToDigits1:
	DEX
	BPL BytesToDigits


	LDA DigitsParam
	STA DigitsResult
	RTS

Check_For_Level_Exit:
	RTS

Double_Value:
	PHA
	AND #$80
	STA <Temp_Var1
	PLA
	ASL A
	ORA <Temp_Var1
	RTS

Half_Value:
	PHA
	AND #$80
	STA <Temp_Var1
	PLA
	LSR A
	ORA <Temp_Var1
	RTS



Reserve_Items:
	.byte $00
	.byte POWERUP_MUSHROOM
	.byte POWERUP_FIREFLOWER	
	.byte POWERUP_SUPERLEAF	
	.byte POWERUP_FROGSUIT	
	.byte POWERUP_SHELL		
	.byte POWERUP_HAMMERSUIT	
	.byte POWERUP_ICEFLOWER	
	.byte POWERUP_FOXLEAF	
	.byte POWERUP_NINJASHROOM 
	.byte POWERUP_STAR
	.byte $00
	.byte $00
	.byte $00
	.byte $00
	.byte $00
	.byte POWERUP_MEGASTAR

Player_NoItem:
	RTS

Player_UseItem:
	LDA <Player_HaltGameZ
	ORA Player_HaltTick
	BNE Player_NoItem

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ Player_NoItem

	LDA PowerUp_Reserve
	JSR DynJump
	
	.word Player_ItemNone
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemPowerUp
	.word Player_ItemStopWatch
	.word Player_ItemNone
	.word Player_ItemNone
	.word Player_ItemNone
	.word Player_ItemNone
	.word Player_ItemPowerUp

Player_ItemPowerUp:
	JSR Check_ExistingPowerUps
	BCS Player_ItemPowerUpRTS
	LDX #$02

Item_PowerupLoop:	
	LDA Objects_State + 5, X
	BEQ Item_MakePowerup
	DEX
	BPL Item_PowerupLoop
	BMI Player_ItemPowerUpRTS

Item_MakePowerup:
	LDY PowerUp_Reserve
	LDA #OBJ_POWERUP
	STA Objects_ID + 5, X

	LDA Reserve_Items, Y
	CMP #POWERUP_MEGASTAR
	BNE SetPowerUpType

	LDA #$01
	STA PowerUp_Property + 5, X

	LDA #POWERUP_STAR

SetPowerUpType:	
	STA PowerUp_Type + 5, X

	LDA #OBJSTATE_NORMAL
	STA Objects_State + 5, X

	LDA <Player_X
	STA <Objects_XZ + 5, X
	
	LDA <Player_XHi
	STA <Objects_XHiZ + 5, X

	LDA <Player_YZ
	ADD #$10
	STA <Objects_YZ + 5, X

	LDA <Player_YHiZ
	ADC #$00
	STA <Objects_YHiZ + 5, X

	LDA #$00
	STA PowerUp_Reserve

Player_ItemPowerUpRTS:
Player_ItemNone:
	RTS

Player_ItemStopWatch:
	LDA #$FF
	STA Stop_Watch
	
	LDA #$00
	STA PowerUp_Reserve
	RTS


Coin_X = Temp_Var2
Coin_Y = Temp_Var1
Coin_XHi = Temp_Var3
Coin_YHi = Temp_Var4
Produce_Coin:
	; Play coin sound
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	INC Coins_Earned_Buffer

	LDA Coin_X
	STA <Point_X

	LDA Coin_XHi
	STA <Point_XHi

	LDA Coin_Y
	STA <Point_Y

	LDA Coin_YHi
	STA <Point_YHi

	JSR CheckPoint_OffScreen
	BCC Produce_CoinRTS

	LDY #$03	 ; Y = 3

Produce_Coin_Loop:
	LDA CoinPUp_State,Y
	BEQ PRG000_C4A7	 ; If this coin slot state = 0, it's free, go use it!
	DEY		 ; Y--
	BPL Produce_Coin_Loop	 ; While Y >= 0, loop!

	; If all else fails, just overwrite the oldest slot!
	LDY #$03	 ; Y = 3

PRG000_C4A7:


	LDA #$01
	STA CoinPUp_State,Y	; Set coin state to 1

	LDA <Coin_Y		; Get input Y
	SUB Level_VertScroll	; Make relative to vertical scroll
	SBC #24	 		; Subtract 24
	STA CoinPUp_Y,Y	 	; Store as coin's Y

	LDA <Coin_X		; Get input X
	SUB <Horz_Scroll	; Make relative to horizontal scroll
	STA CoinPUp_X,Y	 	; Store as coin's X

	LDA #-5	 
	STA CoinPUp_YVel,Y	; Set Y Vel = -5

	LDA #$01	 
	STA CoinPUp_Counter,Y	; Set counter to 1

Produce_CoinRTS:
	RTS		 ; Return



Do_Wall_Jump:
	LDA Wall_Jump_Enabled
	BPL Jump_Right

	LDA #$20
	BNE Do_Jump_Off

Jump_Right:
	LDA #$E0

Do_Jump_Off:
	STA <Player_XVelZ
	STA <Player_EffXVel
	RTS

DoNightTransition:
	LDA <Counter_1
	AND #$03
	BNE NightTransRTS

	LDA NightTransition
	CMP #$01
	BEQ FinalNightTransition

	ASL A
	ASL A
	ASL A
	ASL A
	STA DAIZ_TEMP1

	LDA #$40
	SEC
	SBC DAIZ_TEMP1
	STA DAIZ_TEMP1
	
	LDA MasterPal_Data
	SEC
	SBC DAIZ_TEMP1
	BPL DontMaxNightColor
	LDA #$0F

DontMaxNightColor:
	STA Pal_Data + $10
	STA Palette_Buffer  + $10

SkipNightTransition:
	DEC NightTransition

NightTransRTS:
	RTS

FinalNightTransition:
	LDX #$0F

NextColorNight:
	LDA MasterPal_Data, X
	SEC
	SBC #$10
	BPL DontMaxColor2
	LDA MasterPal_Data, X

DontMaxColor2:
	STA Pal_Data, X
	STA Palette_Buffer, X
	DEX
	BPL NextColorNight
	LDA #$0F
	STA Pal_Data + $10
	STA Palette_Buffer + $10
	DEC NightTransition
	RTS
;;
DoDayTransition:
	LDA MasterPal_Data
	CMP #$0F
	BEQ DayTransRTS
	LDA <Counter_1
	AND #$03
	BNE DayTransRTS
	LDA MasterPal_Data
	CMP #$0F
	BEQ SkyDayTransition
	LDA DayTransition
	CMP #$01
	BEQ FinalDayTransition
	ASL A
	ASL A
	ASL A
	ASL A
	SEC
	SBC #$10
	STA DAIZ_TEMP1
	LDA MasterPal_Data
	SEC
	SBC DAIZ_TEMP1
	BPL DontMaxDayColor
	LDA #$0F

DontMaxDayColor:
	CMP MasterPal_Data
	BCC SkipMasterRestore
	LDA MasterPal_Data

SkipMasterRestore:
	STA Pal_Data + $10
	STA Palette_Buffer + $10

SkyDayTransition:
	DEC DayTransition

DayTransRTS:
	RTS

FinalDayTransition:
	LDX #$0F

NextColorDay:
	LDA MasterPal_Data, X
	STA Pal_Data, X
	STA Palette_Buffer, X
	DEX
	BPL NextColorDay

	LDA MasterPal_Data
	STA Pal_Data + $10
	STA Palette_Buffer + $10
	DEC DayTransition
	RTS

NextLevelByte:
	INC <Temp_Var14
	BNE DontIncVar5
	INC <Temp_Var15

DontIncVar5:
	RTS

Compression_Screen = Temp_Var6

Screen_Padding:
	.byte $00, $B0, $60, $10, $C0, $70, $20, $D0, $80, $30, $E0, $90, $40, $F0, $A0
Screen_PaddingHi:	
	.byte $00, $01, $03, $05, $06, $08, $0A, $0B, $0D, $0F, $10, $12, $14, $15, $17

NextTileByte:	
	LDA <Temp_Var8
	ADD #$01
	STA <Temp_Var8

	LDA <Temp_Var9
	ADC #$00
	STA <Temp_Var9

NextTileByte1:
	LDA <Temp_Var8
	AND #$0F
	BNE NextTileByteRTS

	INC <Compression_Screen

	LDA <Level_Width
	SUB <Compression_Screen
	BPL Next_Column

	LDY Level_Width
	LDA <Temp_Var8
	SUB Screen_Padding, Y
	STA <Temp_Var8

	LDA <Temp_Var9
	SBC Screen_PaddingHi, Y
	STA <Temp_Var9

	LDY #$00
	STY <Compression_Screen

NextTileByteRTS:
	RTS

Next_Column:
	LDA <Temp_Var8
	ADD #$A0
	STA <Temp_Var8

	LDA <Temp_Var9
	ADC #$01
	STA <Temp_Var9
	RTS

ClearPointers:
	LDX #59
	LDA #$FF

ClearPointerLoop:
	STA Pointers, X
	DEX
	BPL ClearPointerLoop
	RTS

ClearBuffers:
	LDX #$32
	LDA #$00

ClearBufferLoop:
	STA Object_BufferX, X
	STA Object_BufferY, X
	DEX
	BPL ClearBufferLoop
	RTS	

LevelLoad_SetScrollPos:
	LDA <Player_YZ
	LSR A
	LSR A
	LSR A
	LSR A
	STA DAIZ_TEMP1

	LDA <Player_YHiZ
	ASL A
	ASL A
	ASL A
	ASL A
	ORA DAIZ_TEMP1
	CMP #$04

	BCS LowerLimit
	LDA #$00
	BEQ Store_Vert_Scroll

LowerLimit:
	CMP #$13
	BCC DynaVScroll
	LDA #$EF
	BNE Store_Vert_Scroll

DynaVScroll:
	SEC
	SBC #$04
	AND #$0F
	ASL A
	ASL A
	ASL A
	ASL A

Store_Vert_Scroll:
	STA <Vert_Scroll
	LDA <Player_X
	LSR A
	LSR A
	LSR A
	LSR A
	STA DAIZ_TEMP1
	LDA <Player_XHi
	ASL A
	ASL A
	ASL A
	ASL A
	ORA DAIZ_TEMP1
	STA DAIZ_TEMP1
	LDA <Level_Width
	ASL A
	ASL A
	ASL A
	ASL A
	ORA #$08
	STA DAIZ_TEMP2
	
	LDA DAIZ_TEMP1
	SEC 
	SBC #$08
	BCS TryHScrollUpperLimit

	LDA #$00
	STA <Horz_Scroll
	STA <Horz_Scroll_Hi
	JMP Update_Columns

TryHScrollUpperLimit:
	LDA DAIZ_TEMP2 
	SEC
	SBC DAIZ_TEMP1
	BCS DynHScroll
	LDA <Level_Width
	STA <Horz_Scroll_Hi
	LDA #$00
	STA <Horz_Scroll
	JMP Update_Columns

DynHScroll:	
	LDA DAIZ_TEMP1 
	SEC
	SBC #$08
	STA DAIZ_TEMP1
	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Horz_Scroll_Hi
	
	LDA DAIZ_TEMP1
	AND #$0F
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Horz_Scroll
	
	LDA <Player_X
	AND #$0F
	ORA <Horz_Scroll
	STA <Horz_Scroll
	
	LDA Level_HorzScrollLock
	BEQ Update_Columns

	LDA #$00
	STA <Horz_Scroll
	
	LDA <Player_XHi
	STA <Horz_Scroll_Hi
	

Update_Columns:
	LDA #$01
	STA Scroll_LastDir

	LDA <Horz_Scroll
	STA <Scroll_Temp	; Scroll_Temp = Horz_Scroll

	LDA Level_JctCtl
	LDX <Horz_Scroll_Hi	; A = Horz_Scroll_Hi
	INX
	TXA

	JSR Scroll_Update_Ranges

	LDA <Horz_Scroll
	STA Level_AScrlPosH

	LDA <Horz_Scroll_Hi
	STA Level_AScrlPosHHi
	RTS

Map_Reload_with_Completions:

	; Clears all map tiles to $02 (all black tiles)
	JSR Tile_Mem_Clear

	; Fill 16x tile $4E every $1B0 (upper horizontal border)
	LDX #$30	 ; X = $30
	
PRG012_A462:
	TXA		 
	TAY		 

	LDA #$00	 
	JSR Tile_Mem_ClearB

	TYA		 
	ADD #$10	 
	TAY		 

	LDA #$01
	JSR Tile_Mem_ClearB
	INX		 ; X++
	CPX #$40
	BNE PRG012_A462	 ; While X <> $40, loop!

	; After these two, Map_Tile_Addr = Tile_Mem_Addr + $110
	LDA Tile_Mem_Addr
	ADD #$10	 
	STA <Map_Tile_AddrL

	LDA Tile_Mem_Addr+1
	ADC #$01	 
	STA <Map_Tile_AddrH

	LDY #$e0	 	; Offset to the bottom row
	LDA #$02	; Get the appropriate tile for the bottom row

PRG012_A4C9:
	JSR Tile_Mem_ClearB	; Place the tiles
	INY		 	; Y++
	CPY #$f0	 
	BNE PRG012_A4C9	 	; While Y <> $F0, jump to PRG012_A4C9

	; Temp_Var1/2 will form an address pointing at the beginning of this world's map tile layout...
	LDA PAGE_A000
	STA DAIZ_TEMP2

	LDA PAGE_C000	
	STA DAIZ_TEMP3

	LDA #6
	STA PAGE_A000

	JSR PRGROM_Change_A000

	LDA World_Num
	ASL A
	ASL A
	TAX

	LDA $B800, X
	STA PAGE_A000

	ADC #$01
	STA PAGE_C000

	INX

	LDA $B800, X
	STA <Temp_Var1

	INX

	LDA $B800, X
	STA <Temp_Var2

	LDY #$00

	JSR PRGROM_Change_A000
	JSR PRGROM_Change_C000

	LDA [Temp_Var1], Y
	STA PatTable_BankSel + 1

	INY

	LDA [Temp_Var1], Y
	STA PaletteIndex

	INY

	LDA [Temp_Var1], Y
	STA Sound_QMusic2

	INY

	LDA [Temp_Var1], Y
	ASL A
	ASL A
	ASL A
	ASL A
	STA WorldWidth
	
	INY

	LDA [Temp_Var1], Y
	STA <Temp_Var15
	STA <Temp_Var14

	LDA #$05
	CLC
	ADC <Temp_Var1
	STA <Temp_Var1
	BCC NoIncVar2Map

	INC <Temp_Var2

NoIncVar2Map:

	LDA #$00
	LDX #$00

Clear_MapPointers:
	STA MapPointers-1, X
	DEX
	BNE Clear_MapPointers
	LDY #$00
	LDX #$00
	
CopyMapPointers:
	LDA [Temp_Var1], Y
	STA MapPointers, X

	INX

	JSR Next_World_Byte
	LDA [Temp_Var1], Y
	STA MapPointers, X

	INX

	JSR Next_World_Byte

	LDA [Temp_Var1], Y
	STA MapPointers, X

	INX

	JSR Next_World_Byte

	DEC <Temp_Var15
	BNE CopyMapPointers
	
	LDA #$FF
	STA MapPointers, X

Map_ClearObjects:
	LDA #$00

	LDX #13

Map_ClearObjectsLoop:
	STA Map_Objects_IDs, X
	DEX
	BPL Map_ClearObjectsLoop

	LDX #$00

Map_LoadObjects:
	LDA [Temp_Var1], Y
	CMP #$FF
	BEQ Map_LoadTileProperties

	STA Map_Objects_IDs, X
	JSR Next_World_Byte

	LDA [Temp_Var1], Y
	AND #$0F
	ASL A
	ASL A
	ASL A
	ASL A
	STA Map_Objects_Y, X

	JSR Next_World_Byte
	
	LDA [Temp_Var1], Y
	AND #$0F
	ASL A
	ASL A
	ASL A
	ASL A

	STA Map_Objects_XLo, X

	LDA [Temp_Var1], Y
	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A

	STA Map_Objects_XHi, X

	JSR Next_World_Byte
	INX

	JMP Map_LoadObjects

Map_LoadTileProperties:
	JSR Next_World_Byte

	LDA PAGE_A000
	PHA

	JSR LoadTileProperties

	PLA
	STA PAGE_A000
	JSR PRGROM_Change_A000

PRG012_A496:
	LDY #$00	 	; Y = 0

PRG012_A498:
	LDA [Temp_Var1],Y	; Get byte from tile layout
	CMP #$ff	 
	BEQ PRG012_A4C1	 	; If it's $FF (terminator), jump to PRG012_A4C1

	STA DAIZ_TEMP2
	STY TempY

	;JSR Try_Replace_Tile

	LDY TempY
	STA [Map_Tile_AddrL],Y	; Copy byte to RAM copy of tiles
	INY		 	; Y++

	; 144 supports a 16x9 map screen (the left and right columns
	; each contain a normally invisible-until-scrolled tile)
	CPY #144	 	
	BNE PRG012_A498	 	; If Y <> 144, loop!

	; This does a 16-bit addition of 144 to the
	; address stored at [Temp_Var2][Temp_Var1]
	TYA
	ADD <Temp_Var1	
	STA <Temp_Var1	
	LDA <Temp_Var2	
	ADC #$00	
	STA <Temp_Var2

	; The tile layout for the map actually has a lot of
	; unused vertical space (used for level layout) so
	; this needs to add a significant amount more ($1b0)
	; to the Map_Tile_Addr
	LDA <Map_Tile_AddrL
	ADD #$b0	
	STA <Map_Tile_AddrL

	LDA <Map_Tile_AddrH
	ADC #$01
	STA <Map_Tile_AddrH
	JMP PRG012_A496	 	; Do next 144 bytes...

PRG012_A4C1:
	; Layout is loaded!

	; This places the tiles along the bottom (lower horizontal border)

	LDA #11
	STA PAGE_A000
	
	JSR PRGROM_Change_A000
	
	JSR FindCompletedLevels
	
	LDA DAIZ_TEMP2
	STA PAGE_A000

	JSR PRGROM_Change_A000

	LDA DAIZ_TEMP3
	STA PAGE_C000
	JSR PRGROM_Change_C000

	LDX #$00
	RTS		 ; Return

Next_World_Byte:
	INC <Temp_Var1
	BNE DontIncWorldVar2
	INC <Temp_Var2

DontIncWorldVar2:
	RTS


; Try_Replace_Tile:
; 	STA TempA
; 	CMP #$3E
; 	BNE Try_Replace_Tile1

; 	LDA DayNight
; 	BEQ Try_Replace_Tile1

; 	LDA #$3F
; 	RTS

; Try_Replace_Tile1:
; 	LDA TempA
; 	RTS


Find_Applicable_Pointer:
	LDA #$00
	STA Entering_From_Map
	
	;;; find proper pointer now
	LDA <Player_X
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1

	LDA <Player_XHi
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var1
	STA <Temp_Var2

	LDA <Player_YZ
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1

	LDA <Player_YHiZ
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var1
	STA <Temp_Var3

	LDA #$09
	STA <Temp_Var1

	LDX #$3C

FindPointerLoop:
	DEX
	DEX
	DEX
	DEX
	DEX
	DEX

	LDA <Temp_Var2
	SUB Pointers + 1, X
	CMP #$02
	BCS NextPointer

	LDA Pointers + 2, X
	SUB <Temp_Var3
	CMP #$03
	BCS NextPointer
	RTS		 ; Return

NextPointer:
	DEC <Temp_Var1
	BPL FindPointerLoop
	RTS

Climbing_Pointer:
	LDA <Player_SpriteY
	AND #$F0
	CMP #$F0
	BEQ Climbing_FindPointer

	CMP #$B0
	BCC Climbing_PointerRTS

Climbing_FindPointer:
	JSR Find_Applicable_Pointer	 ; Initialize level junction
 
	LDA <Temp_Var1
	BMI Climbing_PointerRTS
	
	JSR UsePointer
	INC Level_JctCtl

Climbing_PointerRTS:
	RTS

Do_Pointer_Effect:
	JSR Find_Applicable_Pointer	 ; Initialize level junction

	LDA <Temp_Var1
	BPL UsePointer

	LDA #$14
	STA Level_PipeMove
	RTS		; No pointer found, abort abort!

UsePointer:
	LDA #$00
	STA Level_HorzScrollLock

	LDA Pointers + 5, X
	AND #$80	; does this pointer exit the level?
	BEQ LevelJction

	LDA Pointers, X
	STA World_Num

	LDA Pointers + 3, X
	AND #$0F
	STA Map_Entered_XHi

	LDA Pointers + 3, X
	AND #$F0
	STA Map_Entered_X

	LDA Map_Entered_X
	AND #$80
	SUB #$80
	STA Map_Prev_XOff

	LDA Map_Entered_XHi
	SBC #$00
	STA Map_Prev_XHi
	BPL Pointer_SetExit

	LDA #$00
	STA Map_Prev_XOff
	STA Map_Prev_XHi

Pointer_SetExit:	

	LDA Pointers + 4, X
	AND #$F0
	STA Map_Entered_Y

	INC Level_ExitToMap

	LDA #$00
	STA Level_PipeMove
	STA Map_ReturnStatus
	STA Level_JctCtl
	RTS

LevelJction:
	
	LDA LevelLoadPointer
	STA PreviousLevel

	LDA Pointers, X
	STA LevelLoadPointer

	LDA Pointers + 3, X
	STA Player_XExit

	LDA Pointers + 4, X
	STA Player_YExit

	LDA Pointers + 5, X
	AND #$40
	STA Level_Redraw

	LDA Pointers + 5, X
	AND #$20
	STA Level_KeepObjects

	LDA Pointers + 5, X
	AND #$10
	STA Weather_Disabled

	LDA Pointers + 5, X
	AND #$0F
	STA Level_PipeExitDir	 ; Store into Level_PipeExitDir
	
	CMP #$03
	BLT Skip_Line_Up	 ; If Level_PipeExitDir < 3, jump to PRG026_AABD
	
	; Otherwise, don't center Player (better for starting on block)
	LDA <Player_X
	AND #$f0
	STA <Player_X

Skip_Line_Up:
	RTS


PSwitch_SubstTileAndAttr:
	LDY Level_PSwitchCnt	; Y = Level_PSwitchCnt
	BEQ PRG000_C85B	 	; If P-Switch not active, jump to PRG000_C85B (RTS)

	LDY #$0E
PRG000_C84A:

	CMP PSwitchTransitions,Y
	BNE PRG000_C858	 	; If this is not a match, jump to PRG000_C858

	INY
	LDA PSwitchTransitions,Y	; Get replacement tile
	RTS		 ; Return

PRG000_C858:
	DEY		 ; Y--
	DEY
	BPL PRG000_C84A	 ; While Y >= 0, loop!

PRG000_C85B:
	RTS		 ; Return

CheckSpriteOnFG:
	CMP #TILE_PROP_ITEM
	BCS NoBGPriority
	AND #TILE_PROP_FOREGROUND
	BEQ SetBGPriority
	LDA #$20

SetBGPriority:
	RTS

NoBGPriority:
	LDA #$00
	RTS

DoLevelEnding:
	
	RTS

GetLevelBit:

	LDA LevelNumber
	AND #$07
	TAY
	LDA #$01

ShiftLevelBit:
	CPY #$00
	BEQ HaveBit
	ASL A
	DEY
	BNE ShiftLevelBit

HaveBit:
	STA DAIZ_TEMP1
	LDA LevelNumber
	LSR A
	LSR A
	LSR A
	TAY
	LDA DAIZ_TEMP1
	RTS

MapGetTileBit:
	STA TempA
	LDA World_Num
	ASL A
	TAX
	LDA TempA
	AND #08
	BEQ LowerHalfTiles
	INX

LowerHalfTiles:
	LDA TempA
	AND #$07
	TAY
	LDA #$01
	CPY #$00
	BEQ FindTileBitRTS

FindTileBit:
	ASL A
	DEY
	BNE FindTileBit

FindTileBitRTS:
	RTS


; ClearBlockedAreas:
; 	LDA BlockedLevel
; 	BNE RemoveBlocksByRow
; 	RTS

; RemoveBlocksByRow:
; 	LDA World_Num
; 	ASL A
; 	TAX
; 	LDY #$00
; 	;LDA World_Complete_Tiles, X
; 	STA TempA

; IsBitSet:
; 	LDA TempA
; 	CLC
; 	ROR A
; 	STA TempA
; 	BCC NextCol
; 	LDA #$90
; 	STA $61F0, Y
; 	STA $6200, Y
; 	STA $6210, Y
; 	STA $6220, Y

; NextCol:
; 	INY
; 	CPY #$08
; 	BNE IsBitSet
; 	RTS

Player_Freeze:
	LDA Player_Frozen
	ORA Player_Invulnerable
	ORA Player_Invicible
	BEQ Player_FreezeNow
	RTS

Player_FreezeNow:
	LDA #$08
	STA Player_Frozen

	LDA #$00
	STA Player_IsClimbing

	LDA Frozen_Frame
	BNE Keep_Going

	LDA Player_Frame
	STA Frozen_Frame

Keep_Going:
	LDA #$02
	STA Palette_Buffer+$11

	LDA #$21
	STA Palette_Buffer+$12

	LDA #$30
	STA Palette_Buffer+$13
	RTS


StartXPositions:
	.byte $00, $54, $A8, $2A, $7E, $D2

StartYPositions:
	.byte $08, $10, $18, $20, $28, $30
	.byte $44, $38, $2C, $20, $14, $08

StartYPostions2:
	.byte $20, $43, $69, $86, $A7, $CE

StarPals:
	.byte SPR_PAL1, SPR_PAL2, SPR_PAL3, SPR_PAL1, SPR_PAL2, SPR_PAL3

InitStarsBackground:
	LDY #$07

InitStars_Loop:
	LDA RandomN, Y
	AND #$0F
	ADD StartXPositions, Y
	STA Weather_XPos, Y

	LDA PaletteEffect
	CMP #$03
	BNE Normal_WeatherParticle

	LDA StartYPostions2, Y
	BNE Store_WeatherParticle

Normal_WeatherParticle:
	
	LDA RandomN, Y
	LSR A
	LSR A
	LSR A
	LSR A
	ADD StartYPositions, Y

Store_WeatherParticle:
	STA Weather_YPos, Y
	DEY
	BPL InitStars_Loop
	RTS


Sprite_RAM_Clear:	; $FD84

	LDA #$F8	
	STA Sprite_RAMY + $FC
	STA Sprite_RAMY + $F8
	STA Sprite_RAMY + $F4
	STA Sprite_RAMY + $F0
	STA Sprite_RAMY + $EC
	STA Sprite_RAMY + $E8

Sprite_RAM_Clear_NotWeather:
	LDA #$F8
	STA Sprite_RAMY + $E4
	STA Sprite_RAMY + $E0
	STA Sprite_RAMY + $DC
	STA Sprite_RAMY + $D8
	STA Sprite_RAMY + $D4
	STA Sprite_RAMY + $D0
	STA Sprite_RAMY + $CC
	STA Sprite_RAMY + $C8
	STA Sprite_RAMY + $C4
	STA Sprite_RAMY + $C0
	STA Sprite_RAMY + $BC
	STA Sprite_RAMY + $B8
	STA Sprite_RAMY + $B4
	STA Sprite_RAMY + $B0
	STA Sprite_RAMY + $AC
	STA Sprite_RAMY + $A8
	STA Sprite_RAMY + $A4
	STA Sprite_RAMY + $A0
	STA Sprite_RAMY + $9C
	STA Sprite_RAMY + $98
	STA Sprite_RAMY + $94
	STA Sprite_RAMY + $90
	STA Sprite_RAMY + $8C
	STA Sprite_RAMY + $88
	STA Sprite_RAMY + $84
	STA Sprite_RAMY + $80
	STA Sprite_RAMY + $7C
	STA Sprite_RAMY + $78
	STA Sprite_RAMY + $74
	STA Sprite_RAMY + $70
	STA Sprite_RAMY + $6C
	STA Sprite_RAMY + $68
	STA Sprite_RAMY + $64
	STA Sprite_RAMY + $60
	STA Sprite_RAMY + $5C
	STA Sprite_RAMY + $58
	STA Sprite_RAMY + $54
	STA Sprite_RAMY + $50
	STA Sprite_RAMY + $4C
	STA Sprite_RAMY + $48
	STA Sprite_RAMY + $44
	STA Sprite_RAMY + $40
	STA Sprite_RAMY + $3C
	STA Sprite_RAMY + $38
	STA Sprite_RAMY + $34
	STA Sprite_RAMY + $30
	STA Sprite_RAMY + $2C
	STA Sprite_RAMY + $28
	STA Sprite_RAMY + $24
	STA Sprite_RAMY + $20
	STA Sprite_RAMY + $1C
	STA Sprite_RAMY + $18
	STA Sprite_RAMY + $14
	STA Sprite_RAMY + $10
	STA Sprite_RAMY + $C
	STA Sprite_RAMY + 8
	STA Sprite_RAMY + 4
	STA Sprite_RAMY + 0
	RTS

GetPowerBadgeY:
	LDA Player_Badge
	CMP #BADGE_PMETER
	RTS

Debris_X = Temp_Var7
Debris_Y = Temp_Var8

Common_MakeChains:
	JSR Common_MakeDebris
	
	LDA #CHAIN_DEBRIS
	STA BrickBust_Tile, Y

	LDA #SPR_PAL1
	STA BrickBust_Pal, Y
	RTS

Common_MakeBricks:
	JSR Common_MakeDebris

	LDA #BRICK_DEBRIS
	STA BrickBust_Tile, Y

	LDA #SPR_PAL3
	STA BrickBust_Pal, Y
	RTS

Common_MakeIce:
	JSR Common_MakeDebris
	LDA #ICE_DEBRIS
	STA BrickBust_Tile, Y

	LDA #SPR_PAL2
	STA BrickBust_Pal, Y
	RTS

Common_MakeDebris:
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDY Brick_Index

	; Set the brick bust
	LDA #$02
	STA BrickBust_En, Y

	; Brick bust upper Y
	LDA Debris_Y
	SBC Level_VertScroll
	STA Brick_DebrisYHi, Y

	; Brick bust lower Y
	ADD #$08
	STA Brick_DebrisY, Y

	; Brick bust X
	LDA Debris_X
	SUB <Horz_Scroll	
	STA Brick_DebrisX, Y

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA Brick_DebrisXDist, Y
	STA BrickBust_HEn, Y

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel, Y

	LDA Brick_Index
	EOR #$01
	STA Brick_Index
	RTS

Poof_X = Temp_Var1
Poof_Y = Temp_Var2
Poof_YHi = Temp_Var3

Common_MakePoof:
	LDY #$05

Common_MakePoof1:
	LDA SpecialObj_ID, Y
	BEQ Common_MakePoof2

	DEY
	BPL Common_MakePoof1

	CLC
	RTS

 Common_MakePoof2:
	LDA #SOBJ_POOF
	STA SpecialObj_ID, Y

	LDA #$20
	STA SpecialObj_Timer, Y
	STA SpecialObj_Data1, Y

	LDA <Poof_X
	STA SpecialObj_X, Y

	LDA <Poof_Y
	STA SpecialObj_Y, Y

	LDA <Poof_YHi
	STA SpecialObj_YHi, Y

	LDA #$00
	STA SpecialObj_XVel, Y
	STA SpecialObj_YVel, Y
	STA SpecialObj_Data2, Y

	LDA #SPR_PAL2
	STA SpecialObj_Data3, Y
	SEC
	RTS

Common_GetTempTile:
	LDY #$07

Common_FindTempTile:
	LDA SpinnerBlocksActive, Y
	BEQ Common_TempTileFound

	DEY
	BPL Common_FindTempTile

	CLC
	RTS

Common_TempTileFound:
	SEC
	RTS

Check_ExistingPowerUps:
	LDY #$05

PUpCheck_ContinueChecking:
	LDA Objects_ID, Y
	CMP #OBJ_POWERUP
	BNE PUpCheck_MoveAlong

	LDA Objects_State, Y
	CMP #OBJSTATE_NORMAL
	BNE PUpCheck_MoveAlong

	SEC
	RTS

PUpCheck_MoveAlong:
	INY
	CPY #$08
	BNE PUpCheck_ContinueChecking

	CLC
	RTS

	
RhythmPlatforming:
RhythmGraphics:
	.byte $60, $62, $64, $66

RhythmDelay:
	.byte $00, $5F, $90, $82, $00, $00, $00, $00, $80, $5F, $00

RhythmMeasures:
	.byte $00, $18, $23, $1E, $00, $00, $00, $00, $20, $18, $00

RhythmSet3:
	.byte $00, $03, $00, $FE, $00, $00, $00, $00, $04, $03, $00

RhythmPlatformsReset:
	STA RhythmMusic

	LDA #$00
	STA RhythmKeeper
	STA RhythmKeeper + 1
	STA RhythmKeeper + 2
	STA RhythmKeeper + 3
	STA RhythmKeeper + 4

RhythmPlatforms:
	LDA RhythmPlatformEnabed
	BEQ RhythmPlatforms0

	LDX #$00

	LDA SndCur_Music2
	BEQ RhythmPlatforms0

	LDY RhythmMusic
	BNE DoNotStoreRhythmMusic

	STA RhythmMusic

DoNotStoreRhythmMusic:
	CMP RhythmMusic
	BNE RhythmPlatformsReset

	LSR A
	LSR A
	LSR A
	LSR A
	TAX

	LDA RhythmDelay, X
	BEQ RhythmPlatforms0

	LDA RhythmKeeper
	CMP RhythmDelay, X
	BEQ RhythmPlatforms1

	INC RhythmKeeper

RhythmPlatforms0:
	RTS

RhythmPlatforms1:
	LDA RhythmKeeper + 1
	CMP RhythmMeasures, X
	BEQ RhythmPlatforms2

	INC RhythmKeeper + 1
	RTS

RhythmPlatforms2:
	LDA RhythmKeeper + 2
	CMP #$03
	BEQ RhythmPlatforms3

	LDA #SND_LEVELBLIP
	STA Sound_QLevel1
	INC RhythmKeeper + 2

	LDA #$00
	STA RhythmKeeper + 1
	RTS
	
RhythmPlatforms3:
	LDA #SND_MAPINVENTORYFLIP
	STA Sound_QMap

	LDA #$00
	STA RhythmKeeper + 1
	STA RhythmKeeper + 2

	LDA RhythmSet3, X
	STA RhythmKeeper

	INC RhythmKeeper + 3

	LDA RhythmKeeper + 3
	AND #$01
	TAY

	LDA RhythmGraphics, Y
	STA PatTable_BankSel

	LDX #$05
	
RhythmSwitchPlatforms:
	LDA TileProperties + $B0, X
	STA <Temp_Var1

	LDA TileProperties + $F0, X
	STA TileProperties + $B0, X

	LDA <Temp_Var1
	STA TileProperties + $F0, X
	
	LDA #$01
	STA Block_WasUpdated

	DEX
	BPL RhythmSwitchPlatforms
	RTS

UpdateRhythmTiles:
	LDA RhythmKeeper + 3
	AND #$03
	TAY
	LDA RhythmGraphics, Y
	STA PatTable_BankSel
	RTS

Player_Die:
	; Queue death song
	LDA Sound_QMusic1
	ORA #MUS1_PLAYERDEATH
	STA Sound_QMusic1


	LDA #$01
	STA Player_QueueSuit	 ; Queue change to "small"

	LDA #-64
	STA <Player_YVelZ ; Player_YVelZ = -64

	LDA #$30	 
	STA Event_Countdown ; Event_Countdown = $30 (ticks until dropped back to map)

	LDA #$01
	STA <Player_IsDying	 ; Player_IsDying = 1

	; Clear a bunch of stuff at time of death
	LDA #$00
	STA Player_Vehicle
	STA <Player_XVelZ
	STA Player_Flip	
	STA Player_Invulnerable
	STA Player_Invicible
	STA Player_StarInv
	STA Player_Shell
	STA Player_FireDash
	STA Level_PSwitchCnt
	STA Frozen_Frame
	STA Player_Frozen
	STA Player_EffectiveSuit

	LDX #$07

Player_DeathNoHold:	
	STA Objects_BeingHeld, X
	DEX
	BPL Player_DeathNoHold

	LDA #$0F
	STA Palette_Buffer + $11

	LDA #$16
	STA Palette_Buffer + $12

	LDA #$36
	STA Palette_Buffer + $13

	LDX <CurrentObjectIndexZ
	RTS		 ; Return

Point_MidX = Temp_Var8
Point_MidXHi = Temp_Var9
Point_X = Temp_Var10
Point_XHi = Temp_Var11
Point_Y = Temp_Var12
Point_YHi = Temp_Var13
Point_RelativeX = Temp_Var14
Point_RelativeY = Temp_Var15

CheckPoint_OffScreen:
	LDA <Point_X
	SUB <Horz_Scroll
	STA <Point_RelativeX

	LDA <Point_XHi
	SBC <Horz_Scroll_Hi
	BNE Point_OffScreen

	LDA <Point_Y
	SUB <Vert_Scroll
	STA <Point_RelativeY

	LDA <Point_YHi
	SBC <Vert_Scroll_Hi
	BNE Point_OffScreen

	SEC
	RTS

Point_OffScreen:
	CLC
	RTS	

Tile_WriteTempChange:
	JSR Common_GetTempTile
	BCC Tile_WriteTempChangeRTS

	LDA Tile_LastValue
	STA SpinnerBlocksReplace, Y

	LDA #$20
	STA SpinnerBlocksTimers, Y
	
	LDA #$01
	STA SpinnerBlocksActive, Y 

	LDA Block_ChangeY
	STA SpinnerBlocksY, Y	 ; Store into object slot

	LDA Block_ChangeYHi
	STA SpinnerBlocksYHi, Y ; Store Y Hi into object slot

	LDA Block_ChangeX
	STA SpinnerBlocksX, Y ; Store X Hi into object slot

	LDA Block_ChangeXHi	
	STA SpinnerBlocksXHi, Y; Store X Hi into object slot

	SEC
	RTS

Tile_WriteTempChangeRTS:
	RTS

Objects_DetectionTable:
	.byte $00, $01, $00, $01, $00, $01, $00, $01

Objects_ResetDetects:
	LDX #$07

Objects_ToggleDetectionLoop:	
	LDA <Counter_1
	AND #$01
	EOR Objects_DetectionTable, X
	STA Objects_ToggleDetect, X

	DEX
	BPL Objects_ToggleDetectionLoop

	RTS

Objects_AssignSprites:
	LDA #$30
	STA <Temp_Var1

	LDA Game_Counter
	STA <Temp_Var2
	
	LDY #$07

DistributeSprites:
	LDA <Temp_Var2
	AND #$07
	TAX

	LDA Objects_State, X
	BEQ DistributeNextSprite

	LDA <Temp_Var1
	STA Object_SpriteRAMOffset, X

	LDA Objects_SpritesRequested, X
	ASL A
	ASL A
	ADD <Temp_Var1
	STA <Temp_Var1

DistributeNextSprite:	
	INC <Temp_Var2
	DEY 
	BPL DistributeSprites

	LDA <Temp_Var1
	STA Sprite_FreeRAM

Debug_QuickRTS:
	RTS	


Debug_Code:
	LDA Player_Debug
	BEQ Debug_QuickRTS

	LDA <Pad_Holding
	AND #PAD_B
	BEQ Debug_CodeRTS

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ Debug_CodeRTS

	LDA Player_EffectiveSuit
	CMP #$08
	BEQ Debug_Code0

	CMP #$0B
	BCC Debug_Code1

	LDA #$FF
	BMI Debug_Code1

Debug_Code0:
	LDA #$0A

Debug_Code1:
	ADD #$02
	STA Player_QueueSuit

	LDA <Pad_Input
	AND #~PAD_SELECT
	STA <Pad_Input

Debug_CodeRTS:
	RTS	

Message_Handler:
	LDA PAGE_A000
	PHA

	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Messages_Display

	PLA
	STA PAGE_A000
	JSR PRGROM_Change_A000
	RTS	


Check_Timers:
	LDA Kill_Tally_Ticker
	BNE Killy_TallyTick

	STA Kill_Tally
	BEQ Check_StopWatch

Killy_TallyTick:	
	DEC Kill_Tally_Ticker

Check_StopWatch:
	LDA Stop_Watch
	BEQ Check_TimersRTS

	LDA <Counter_1
	AND #$01
	BEQ Check_TimersRTS

	DEC Stop_Watch
	LDA Stop_Watch
	AND #$1F
	BNE Check_TimersRTS

	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1

Check_TimersRTS:	
	RTS

MagicStar_ClearRadar:
	LDA Player_Badge
	CMP #BADGE_RADAR
	BCC MagicStar_ClearRadarRTS

	LDA #BADGE_RADARUNKNOWN
	STA Player_Badge

MagicStar_ClearRadarRTS:
	RTS

Generate_StatChecksum:
	LDY #(Player_Stats_Boundary_End - Player_Stats_Boundary_Start)

	LDA #$00
	STA <Temp_Var1
	STA <Temp_Var2

Generate_StatChecksum_Loop:
	LDA Player_Stats_Boundary_Start, Y
	ADD <Temp_Var1
	STA <Temp_Var1

	LDA <Temp_Var2
	ADC #$00
	STA <Temp_Var2

	DEY 
	BPL Generate_StatChecksum_Loop
	RTS

Generate_SaveChecksum:
	LDY #(Save_Ram_Boundary_End - Save_Ram_Boundary_Start - 3)

	LDA #$00
	STA <Temp_Var1
	STA <Temp_Var2

Generate_SaveChecksum_Loop:
	LDA Save_Ram_Boundary_Start, Y
	ADD <Temp_Var1
	STA <Temp_Var1

	LDA <Temp_Var2
	ADC #$00
	STA <Temp_Var2

	DEY 
	BPL Generate_SaveChecksum_Loop
	RTS

Save_Game:
	LDA <World_Map_X
	STA Map_Previous_X
	STA Map_Entered_X

	LDA <World_Map_XHi
	STA Map_Previous_XHi
	STA Map_Entered_XHi

	LDA <World_Map_Y
	STA Map_Previous_Y
	STA Map_Entered_Y

	LDA <Horz_Scroll
	STA Map_Prev_XOff

	LDA <Horz_Scroll_Hi	
	STA Map_Prev_XHi

	JSR Generate_StatChecksum

	LDY #(Player_Stats_Boundary_End - Player_Stats_Boundary_Start)

Save_GameLoop:	
	LDA Player_Stats_Boundary_Start, Y
	STA Save_Ram_Boundary_Start, Y
	DEY 
	BPL Save_GameLoop

	LDA <Temp_Var1
	STA Save_Ram_CheckSum

	LDA <Temp_Var2
	STA Save_Ram_CheckSum + 1
	RTS


SaveRam_Backup:
	LDY #(Save_Ram_Boundary_End - Save_Ram_Boundary_Start)
	
SaveRam_BackupLoop:
	LDA Save_Ram_Boundary_Start, Y
	STA Save_Ram_Backup, Y

	DEY
	BPL SaveRam_BackupLoop
	RTS

SaveRam_Restore:
	LDY #(Save_Ram_Boundary_End - Save_Ram_Boundary_Start)
	
SaveRam_RestoreLoop:
	LDA Save_Ram_Backup, Y
	STA Save_Ram_Boundary_Start, Y

	DEY
	BPL SaveRam_RestoreLoop
	RTS

Absolute_Param = Temp_Var15
Absolute_Value = Temp_Var16

Absolute_Add:
	LDA Absolute_Param
	BEQ Absolute_AddRTS

	BMI Absolute_AddSub

	ADD Absolute_Value

Absolute_AddRTS:
	RTS

Absolute_AddSub:
	SUB Absolute_Value
	RTS 

Player_TryGroundPound:
	LDA Player_EffectiveSuit
	CMP #MARIO_HAMMER
	BNE Player_TryGroundPoundRTS

	LDA <Player_InAir
	BEQ Player_EndGroundPound

	LDA Player_GroundPound
	BEQ Player_CanGroundPound

	STA Player_Flip

Player_CanGroundPound:
	LDA <Pad_Holding
	AND #PAD_DOWN
	BEQ Player_TryGroundPoundRTS

	LDA <Pad_Input
	AND #PAD_B
	BEQ Player_TryGroundPoundRTS

	LDA #$40
	STA <Player_YVelZ
	STA Player_GroundPound

	LDA #$00
	STA <Player_XVelZ
	RTS

Player_EndGroundPound:
	LDA Player_GroundPound
	BEQ Player_TryGroundPoundRTS

	LDA #$00
	STA Player_GroundPound
	STA Player_Flip

	LDA <Player_FlipBits
	AND #~SPR_VFLIP
	STA <Player_FlipBits

	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #$10
	STA Level_Vibration

	LDA Player_BoundBottom
	AND #$F0
	ORA #$08
	STA <Poof_Y

	LDA Player_BoundLeft
	SUB #$08
	STA <Poof_X
	JSR Common_MakePoof

	LDA #$F0
	STA SpecialObj_XVel, Y

	LDA <Poof_X
	ADD #$10
	STA <Poof_X

	JSR Common_MakePoof

	LDA #$10
	STA SpecialObj_XVel, Y

Player_TryGroundPoundRTS:
	RTS

Player_GroundPoundBump:
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

	LDA #$D0
	STA <Player_YVelZ
	RTS


SpecialObject_FindEmpty:
	LDY #$05

SpecialObject_FindEmptyNext:
	LDA SpecialObj_ID,Y
	BEQ SpecialObject_FindEmptyFound

	DEY
	BPL SpecialObject_FindEmptyNext	

	CLC
	RTS

SpecialObject_FindEmptyFound:
	SEC
	RTS



Object_FindEmptyX:
	LDX #$04

Object_FindEmptyX1:
	LDA Objects_ID, X
	LDA Objects_State, X
	BEQ Object_FindEmptyX2	 ; If this object slot's state is Dead/Empty, jump to PRG002_A5AE

	DEX		 ; X--
	BPL Object_FindEmptyX1	 ; While X >= 0, loop!
	CLC

	LDX <CurrentObjectIndexZ
	RTS

Object_FindEmptyX2:
	JSR Object_New

	LDA #OBJSTATE_NORMAL
	STA Objects_State, X

	LDA #$FF
	STA Objects_SpawnIdx, X

	SEC
	RTS

Object_FindEmptyY:
	LDY #$04

Object_FindEmptyY1:
	LDA Objects_State,Y
	BEQ Object_FindEmptyY2	 ; If this object slot's state is Dead/Empty, jump to PRG002_A5AE

	DEY		 ; X--
	BPL Object_FindEmptyY1	 ; While X >= 0, loop!
	CLC
	RTS

Object_FindEmptyY2:
	TYA
	TAX

	JSR Object_New

	LDA #OBJSTATE_NORMAL
	STA Objects_State, X

	LDA #$FF
	STA Objects_SpawnIdx, X

	LDX <CurrentObjectIndexZ
	SEC
	RTS
	

ObjNorm_BadgeShop:
	LDA #17
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JMP ObjNorm_BadgeShopDo

ObjInit_LiveTransition
	RTS

ObjNorm_LiveTransition:
	LDA Pointers
	STA LevelLoadPointer
	
	LDA <Vert_Scroll
	PHA

	LDA <Player_YZ
	PHA

	LDA <Player_YHiZ
	PHA

	LDA <Player_X
	PHA

	LDA Level_HAutoScroll
	PHA

	LDA <Horz_Scroll
	PHA

	LDA #$01
	STA Level_Redraw
	STA ForcedSwitch

	JSR LevelLoadQuick

	LDA #$09
	STA <Player_XHi
	STA Horz_Scroll_Hi
	STA Level_AScrlPosHHi

	PLA
	STA <Horz_Scroll
	STA Level_AScrlPosH

	PLA 
	STA Level_HAutoScroll

	PLA
	STA <Player_X

	PLA
	STA <Player_YHiZ

	PLA
	STA <Player_YZ

	PLA
	STA <Vert_Scroll

	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	
	JSR Setup_PalData	 ; Setup palette dataSetup_PalData

	LDX #$1F

Live_LoadPalette:
	LDA Pal_Data, X
	STA Palette_Buffer, X
	DEX
	BPL Live_LoadPalette

	LDA #$00
	STA PAGE_C000

	JSR PRGROM_Change_C000 
	LDA #$00
	STA Objects_ID
	STA Objects_ID+1
	STA Objects_ID+2
	STA Objects_ID+3
	STA Objects_ID+4
	STA <CurrentObjectIndexZ
	RTS