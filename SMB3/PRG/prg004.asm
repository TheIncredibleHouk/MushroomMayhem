; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup03 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $03 (i.e. objects starting at ID $6C) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*  
ObjectGroup03_InitJumpTable:
	.word ObjInit_Troopa	; Object $6C - OBJ_GREENTROOPA
	.word ObjInit_Troopa	; Object $6D - OBJ_REDTROOPA
	.word Object_MoveTowardsPlayer	; Object $6E - OBJ_PARATROOPAGREENHOP
	.word ObjInit_ParaTroopas	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.word ObjInit_BuzzyBeetle	; Object $70 - OBJ_BUZZYBEATLE
	.word ObjInit_Spiny	; Object $71 - OBJ_SPINY
	.word ObjInit_Goomba	; Object $72 - OBJ_GOOMBA
	.word ObjInit_ParaGoomba	; Object $73 - OBJ_PARAGOOMBA
	.word ObjInit_ZombieGoomba	; Object $74 - OBJ_ZOMBIEGOOMBA
	.word ObjInit_Waterfill	; Object $75 - OBJ_WATERFILLER
	.word Object_MoveTowardsPlayer	; Object $76 - OBJ_POISONMUSHROOM
	.word ObjInit_SwimmingCheep	; Object $77 - OBJ_GREENCHEEP
	.word ObjInit_BulletBill	; Object $78 - OBJ_BULLETBILL
	.word ObjInit_MissileMark	; Object $79 - OBJ_BULLETBILLHOMING
	.word ObjInit_Troopa	; Object $7A - OBJ_PURPLETROOPA
	.word ObjInit_BlueShell	; Object $7B - OBJ_BLUESHELL
	.word ObjInit_DeliveryLakitu	; Object $7C - OBJ_HELPER
	.word ObjInit_ParaZombieGoomba	; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.word ObjInit_DoNothing	; Object $7E - OBJ_BIGGREENHOPPER
	.word ObjInit_GiantRedPiranha	; Object $7F - OBJ_BIGREDPIRANHA
	.word ObjInit_ParaTroopas	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.word ObjInit_HammerBro		; Object $81 - OBJ_HAMMERBRO
	.word ObjInit_NinjaBro	; Object $82 - OBJ_NINJABRO
	.word ObjInit_Lakitu		; Object $83 - OBJ_LAKITU
	.word ObjInit_DoNothing	; Object $84 - OBJ_SPINYEGG
	.word Object_MoveTowardsPlayer	; Object $85 - OBJ_BLUESPINY
	.word ObjInit_IceBro		; Object $86 - OBJ_ICEBRO
	.word ObjInit_FireBro		; Object $87 - OBJ_FIREBRO
	.word ObjInit_PirateBro	; Object $88 - OBJ_PIRATEBRO
	.word ObjInit_ChainChomp	; Object $89 - OBJ_CHAINCHOMP
	.word ObjInit_Thwomp		; Object $8A - OBJ_THWOMP
	.word ObjInit_Thwomp	; Object $8B - OBJ_AngryTHWOMP
	.word ObjInit_DoNothing	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.word ObjInit_DoNothing	; Object $8D - OBJ_THWOMPUPDOWN
	.word ObjInit_DoNothing	; Object $8E - OBJ_THWOMPDIAGONALUL
	.word ObjInit_DoNothing	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup03_NormalJumpTable:
	.word ObjNorm_Troopa	; Object $6C - OBJ_GREENTROOPA
	.word ObjNorm_RedTroopa		; Object $6D - OBJ_REDTROOPA
	.word ObjNorm_BouncyTroopa	; Object $6E - OBJ_PARATROOPAGREENHOP
	.word ObjNorm_FlyingTroopa	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.word ObjNorm_BuzzyBeetle	; Object $70 - OBJ_BUZZYBEATLE
	.word ObjNorm_Spiny	; Object $71 - OBJ_SPINY
	.word ObjNorm_Goomba	; Object $72 - OBJ_GOOMBA
	.word ObjNorm_ParaGoomba	; Object $73 - OBJ_PARAGOOMBA
	.word ObjNorm_ZombieGoomba	; Object $74 - OBJ_ZOMBIEGOOMBA
	.word ObjNorm_Waterfill	; Object $75 - OBJ_WATERFILLER
	.word ObjNorm_PoisonMushroom	; Object $76 - OBJ_POISONMUSHROOM
	.word ObjNorm_SwimmingCheep	; Object $77 - OBJ_GREENCHEEP
	.word ObjNorm_BulletBill	; Object $78 - OBJ_BULLETBILL
	.word ObjNorm_MissileMark	; Object $79 - OBJ_BULLETBILLHOMING
	.word ObjNorm_PurpleTroopa	; Object $7A - OBJ_PURPLETROOPA
	.word ObjNorm_BlueShell		; Object $7B - OBJ_BLUESHELL
	.word ObjNorm_DeliveryLakitu	; Object $7C - OBJ_HELPER
	.word ObjNorm_ParaZombieGoomba	; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.word ObjNorm_GroundTroop	; Object $7E - OBJ_BIGGREENHOPPER
	.word ObjNorm_BigPiranha	; Object $7F - OBJ_BIGREDPIRANHA
	.word ObjNorm_FlyingTroopa	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.word ObjNorm_HammerBro		; Object $81 - OBJ_HAMMERBRO
	.word ObjNorm_NinjaBro	; Object $82 - OBJ_NINJABRO
	.word ObjNorm_Lakitu		; Object $83 - OBJ_LAKITU
	.word ObjNorm_SpinyEgg		; Object $84 - OBJ_SPINYEGG
	.word ObjNorm_GroundTroop	; Object $85 - OBJ_BLUESPINY
	.word ObjNorm_FireBro		; Object $86 - OBJ_ICEBRO
	.word ObjNorm_FireBro		; Object $87 - OBJ_FIREBRO
	.word ObjNorm_FireBro	; Object $88 - OBJ_PIRATEBRO
	.word ObjNorm_ChainChomp	; Object $89 - OBJ_CHAINCHOMP
	.word ObjNorm_Thwomp		; Object $8A - OBJ_THWOMP
	.word ObjNorm_AngryThwomp	; Object $8B - OBJ_AngryTHWOMP
	.word ObjNorm_AngryThwomp	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.word ObjNorm_ThwompVertical	; Object $8D - OBJ_THWOMPUPDOWN
	.word ObjNorm_ThwompVertical	; Object $8E - OBJ_THWOMPDIAGONALUL
	.word ObjNorm_ThwompVertical	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup03_CollideJumpTable:
	.word Object_Hold					; Object $6C - OBJ_GREENTROOPA
	.word Object_Hold					; Object $6D - OBJ_REDTROOPA
	.word OCSPECIAL_KILLCHANGETO |OBJ_GREENTROOPA	; Object $6E - OBJ_PARATROOPAGREENHOP
	.word OCSPECIAL_KILLCHANGETO |OBJ_REDTROOPA	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.word Object_Hold					; Object $70 - OBJ_BUZZYBEATLE
	.word Object_Hold					; Object $71 - OBJ_SPINY
	.word $0000					; Object $72 - OBJ_GOOMBA
	.word OCSPECIAL_KILLCHANGETO | OBJ_GOOMBA	; Object $73 - OBJ_PARAGOOMBA
	.word Object_Hold	; Object $74 - OBJ_ZOMBIEGOOMBA
	.word $0000	; Object $75 - OBJ_WATERFILLER (OCSPECIAL_KILLCHANGETO must be a mistake, but interesting!)
	.word $0000					; Object $76 - OBJ_POISONMUSHROOM
	.word $0000					; Object $77 - OBJ_GREENCHEEP
	.word $0000					; Object $78 - OBJ_BULLETBILL
	.word Object_Explode					; Object $79 - OBJ_BULLETBILLHOMING
	.word Object_Hold					; Object $7A - OBJ_PURPLETROOPA
	.word $0000					; Object $7B - OBJ_BLUESHELL
	.word $0000					; Object $7C - OBJ_HELPER
	.word $0000					; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.word $0000 | OBJ_PURPLETROOPA	; Object $7E - OBJ_BIGGREENHOPPER
	.word $0000					; Object $7F - OBJ_BIGREDPIRANHA
	.word $0000 | OBJ_PURPLETROOPA	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.word $0000			; Object $81 - OBJ_HAMMERBRO
	.word $0000			; Object $82 - OBJ_NINJABRO
	.word $0000			; Object $83 - OBJ_LAKITU
	.word $0000					; Object $84 - OBJ_SPINYEGG
	.word $0000					; Object $85 - OBJ_BLUESPINY
	.word $0000			; Object $86 - OBJ_ICEBRO
	.word $0000			; Object $87 - OBJ_FIREBRO
	.word $0000					; Object $88 - OBJ_PIRATEBRO
	.word $0000					; Object $89 - OBJ_CHAINCHOMP
	.word $0000					; Object $8A - OBJ_THWOMP
	.word $0000					; Object $8B - OBJ_AngryTHWOMP
	.word $0000					; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.word $0000					; Object $8D - OBJ_THWOMPUPDOWN
	.word $0000					; Object $8E - OBJ_THWOMPDIAGONALUL
	.word $0000					; Object $8F - OBJ_THWOMPDIAGONALDL

	
	; Object group $03 (i.e. objects starting at ID $6C) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup03_Attributes:
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6C - OBJ_GREENTROOPA
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6D - OBJ_REDTROOPA
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $70 - OBJ_BUZZYBEATLE
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $71 - OBJ_SPINY
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $72 - OBJ_GOOMBA
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $73 - OBJ_PARAGOOMBA
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $74 - OBJ_ZOMBIEGOOMBA
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $75 - OBJ_WATERFILLER
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $76 - OBJ_POISONMUSHROOM
	.byte OA1_PAL2  | OA1_HEIGHT32 | OA1_WIDTH16	; Object $77 - OBJ_GREENCHEEP
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $78 - OBJ_BULLETBILL
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $7A - OBJ_PURPLETROOPA
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $7B - OBJ_BLUESHELL
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $7C - OBJ_HELPER
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.byte OA1_PAL2 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $81 - OBJ_HAMMERBRO
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $82 - OBJ_NINJABRO
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $83 - OBJ_LAKITU
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $84 - OBJ_SPINYEGG
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $85 - OBJ_BLUESPINY
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $86 - OBJ_ICEBRO
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $87 - OBJ_FIREBRO
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $88 - OBJ_PIRATEBRO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $89 - OBJ_CHAINCHOMP
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8A - OBJ_THWOMP
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8B - OBJ_AngryTHWOMP
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8D - OBJ_THWOMPUPDOWN
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8F - OBJ_THWOMPDIAGONALDL

	; Object group $03 (i.e. objects starting at ID $6C) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup03_Attributes2:
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $6C - OBJ_GREENTROOPA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $6D - OBJ_REDTROOPA
	.byte OA2_TDOGRP1			; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OA2_TDOGRP1			; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $70 - OBJ_BUZZYBEATLE
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $71 - OBJ_SPINY
	.byte $00	; Object $72 - OBJ_GOOMBA
	.byte OA2_TDOGRP1			; Object $73 - OBJ_PARAGOOMBA
	.byte OA2_TDOGRP1			; Object $74 - OBJ_ZOMBIEGOOMBA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $75 - OBJ_WATERFILLER
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $76 - OBJ_POISONMUSHROOM
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $77 - OBJ_GREENCHEEP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $78 - OBJ_BULLETBILL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $7A - OBJ_PURPLETROOPA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $7B - OBJ_BLUESHELL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $7C - OBJ_HELPER
	.byte OA2_TDOGRP1	; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP2	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OA2_TDOGRP1	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $81 - OBJ_HAMMERBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $82 - OBJ_NINJABRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $83 - OBJ_LAKITU
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $84 - OBJ_SPINYEGG
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $85 - OBJ_BLUESPINY
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $86 - OBJ_ICEBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $87 - OBJ_FIREBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $88 - OBJ_PIRATEBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $89 - OBJ_CHAINCHOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $8A - OBJ_THWOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $8B - OBJ_AngryTHWOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8D - OBJ_THWOMPUPDOWN
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup03_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $6C - OBJ_GREENTROOPA
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $6D - OBJ_REDTROOPA
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $70 - OBJ_BUZZYBEATLE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_SHELL 	; Object $71 - OBJ_SPINY
	.byte OA3_HALT_NORMALONLY 				; Object $72 - OBJ_GOOMBA
	.byte OA3_HALT_NORMALONLY 				; Object $73 - OBJ_PARAGOOMBA
	.byte OA3_HALT_NORMALONLY				; Object $74 - OBJ_ZOMBIEGOOMBA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE			; Object $75 - OBJ_WATERFILLER
	.byte OA3_HALT_NORMALONLY 					; Object $76 - OBJ_POISONMUSHROOM
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $77 - OBJ_GREENCHEEP
	.byte OA3_HALT_NORMALONLY 					; Object $78 - OBJ_BULLETBILL
	.byte OA3_HALT_NORMALONLY 					; Object $79 - OBJ_BULLETBILLHOMING
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $7A - OBJ_PURPLETROOPA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $7B - OBJ_BLUESHELL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE 				; Object $7C - OBJ_HELPER
	.byte OA3_HALT_NORMALONLY 	; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $7E - OBJ_BIGGREENHOPPER
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $7F - OBJ_BIGREDPIRANHA
	.byte OA3_HALT_NORMALONLY | OA3_SHELL 			; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OA3_HALT_NORMALONLY 					; Object $81 - OBJ_HAMMERBRO
	.byte OA3_HALT_NORMALONLY 					; Object $82 - OBJ_NINJABRO
	.byte OA3_HALT_NORMALONLY 					; Object $83 - OBJ_LAKITU
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $84 - OBJ_SPINYEGG
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_SHELL 			; Object $85 - OBJ_BLUESPINY
	.byte OA3_HALT_NORMALONLY 					; Object $86 - OBJ_ICEBRO
	.byte OA3_HALT_NORMALONLY 					; Object $87 - OBJ_FIREBRO
	.byte OA3_HALT_NORMALONLY 			; Object $88 - OBJ_PIRATEBRO
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $89 - OBJ_CHAINCHOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8A - OBJ_THWOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8B - OBJ_AngryTHWOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8D - OBJ_THWOMPUPDOWN
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup03_PatTableSel:
	.byte OPTS_SETPT6 | $4F	; Object $6C - OBJ_GREENTROOPA
	.byte OPTS_SETPT6 | $4F	; Object $6D - OBJ_REDTROOPA
	.byte OPTS_SETPT6 | $4F	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OPTS_SETPT6 | $4F	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OPTS_SETPT5 | $0B	; Object $70 - OBJ_BUZZYBEATLE
	.byte OPTS_SETPT5 | $0B	; Object $71 - OBJ_SPINY
	.byte OPTS_SETPT6 | $4F	; Object $72 - OBJ_GOOMBA
	.byte OPTS_SETPT6 | $4F	; Object $73 - OBJ_PARAGOOMBA
	.byte OPTS_SETPT6 | $13	; Object $74 - OBJ_ZOMBIEGOOMBA
	.byte OPTS_SETPT5 | $12	; Object $75 - OBJ_WATERFILLER
	.byte OPTS_NOCHANGE; Object $76 - OBJ_POISONMUSHROOM
	.byte OPTS_SETPT6 | $4F	; Object $77 - OBJ_GREENCHEEP
	.byte OPTS_SETPT6 | $4F	; Object $78 - OBJ_BULLETBILL
	.byte OPTS_SETPT5 | $4C	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OPTS_SETPT6 | $4F	; Object $7A - OBJ_PURPLETROOPA
	.byte OPTS_SETPT5 | $0B	; Object $7B - OBJ_BLUESHELL
	.byte OPTS_NOCHANGE	; Object $7C - OBJ_HELPER
	.byte OPTS_SETPT6 | $13	; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.byte OPTS_SETPT5 | $3D	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OPTS_SETPT5 | $3D	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OPTS_SETPT6 | $4F	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OPTS_SETPT5 | $4E	; Object $81 - OBJ_HAMMERBRO
	.byte OPTS_SETPT5 | $4E	; Object $82 - OBJ_NINJABRO
	.byte OPTS_NOCHANGE	; Object $83 - OBJ_LAKITU
	.byte OPTS_SETPT5 | $0B	; Object $84 - OBJ_SPINYEGG
	.byte OPTS_SETPT5 | $0B	; Object $85 - OBJ_BLUESPINY
	.byte OPTS_SETPT5 | $4E	; Object $86 - OBJ_ICEBRO
	.byte OPTS_SETPT5 | $4E	; Object $87 - OBJ_FIREBRO
	.byte OPTS_SETPT5 | $4E	; Object $88 - OBJ_PIRATEBRO
	.byte OPTS_SETPT5 | $0E	; Object $89 - OBJ_CHAINCHOMP
	.byte OPTS_SETPT5 | $12	; Object $8A - OBJ_THWOMP
	.byte OPTS_SETPT5 | $12	; Object $8B - OBJ_AngryTHWOMP
	.byte OPTS_SETPT5 | $12	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OPTS_SETPT5 | $12	; Object $8D - OBJ_THWOMPUPDOWN
	.byte OPTS_SETPT5 | $12	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OPTS_SETPT5 | $12	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup03_KillAction:
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6C - OBJ_GREENTROOPA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6D - OBJ_REDTROOPA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $70 - OBJ_BUZZYBEATLE
	.byte KILLACT_JUSTDRAWMIRROR	; Object $71 - OBJ_SPINY
	.byte KILLACT_NORMALANDKILLED	; Object $72 - OBJ_GOOMBA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $73 - OBJ_PARAGOOMBA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $74 - OBJ_ZOMBIEGOOMBA
	.byte KILLACT_JUSTDRAW16X16	; Object $75 - OBJ_WATERFILLER
	.byte KILLACT_NORMALANDKILLED	; Object $76 - OBJ_POISONMUSHROOM
	.byte KILLACT_JUSTDRAW16X16	; Object $77 - OBJ_GREENCHEEP
	.byte KILLACT_JUSTDRAW16X16	; Object $78 - OBJ_BULLETBILL
	.byte KILLACT_JUSTDRAW16X16	; Object $79 - OBJ_BULLETBILLHOMING
	.byte KILLACT_JUSTDRAWMIRROR	; Object $7A - OBJ_PURPLETROOPA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $7B - OBJ_BLUESHELL
	.byte KILLACT_JUSTDRAW16X16	; Object $7C - OBJ_HELPER
	.byte KILLACT_JUSTDRAWMIRROR		; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.byte KILLACT_GIANTKILLED	; Object $7E - OBJ_BIGGREENHOPPER
	.byte KILLACT_POOFDEATH		; Object $7F - OBJ_BIGREDPIRANHA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte KILLACT_JUSTDRAW16X32	; Object $81 - OBJ_HAMMERBRO
	.byte KILLACT_JUSTDRAW16X32	; Object $82 - OBJ_NINJABRO
	.byte KILLACT_NORMALSTATE	; Object $83 - OBJ_LAKITU
	.byte KILLACT_JUSTDRAW16X16	; Object $84 - OBJ_SPINYEGG
	.byte KILLACT_JUSTDRAWMIRROR	; Object $85 - OBJ_BLUESPINY
	.byte KILLACT_JUSTDRAW16X32	; Object $86 - OBJ_ICEBRO
	.byte KILLACT_JUSTDRAW16X32	; Object $87 - OBJ_FIREBRO
	.byte KILLACT_JUSTDRAW16X32	; Object $88 - OBJ_PIRATEBRO
	.byte KILLACT_JUSTDRAW16X16	; Object $89 - OBJ_CHAINCHOMP
	.byte KILLACT_NORMALANDKILLED	; Object $8A - OBJ_THWOMP
	.byte KILLACT_NORMALANDKILLED	; Object $8B - OBJ_AngryTHWOMP
	.byte KILLACT_NORMALANDKILLED	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte KILLACT_NORMALANDKILLED	; Object $8D - OBJ_THWOMPUPDOWN
	.byte KILLACT_NORMALANDKILLED	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte KILLACT_NORMALANDKILLED	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) pattern index starts
	; These are used for all states except "normal"

OG3_POff .func (\1 - ObjectGroup03_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup03_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG3_POff(ObjP6C), OG3_POff(ObjP6D), OG3_POff(ObjP6E), OG3_POff(ObjP6F)
	.byte OG3_POff(ObjP70), OG3_POff(ObjP71), OG3_POff(ObjP72), OG3_POff(ObjP73)
	.byte OG3_POff(ObjP74), OG3_POff(ObjP75), OG3_POff(ObjP76), OG3_POff(ObjP77)
	.byte OG3_POff(ObjP78), OG3_POff(ObjP79), OG3_POff(ObjP7A), OG3_POff(ObjP7B)
	.byte OG3_POff(ObjP7C), OG3_POff(ObjP7D), OG3_POff(ObjP7E), OG3_POff(ObjP7F)
	.byte OG3_POff(ObjP80), OG3_POff(ObjP81), OG3_POff(ObjP82), OG3_POff(ObjP83)
	.byte OG3_POff(ObjP84), OG3_POff(ObjP85), OG3_POff(ObjP86), OG3_POff(ObjP87)
	.byte OG3_POff(ObjP88), OG3_POff(ObjP89), OG3_POff(ObjP8A), OG3_POff(ObjP8B)
	.byte OG3_POff(ObjP8C), OG3_POff(ObjP8D), OG3_POff(ObjP8E), OG3_POff(ObjP8F)


	; Object group $03 (i.e. objects starting at ID $6C) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_PURPLETROOPA, there is an assumption
	; that the initial bytes at ObjectGroup03_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup03_PatternSets:
	; (End restricted alignment space)

	JMP GiantEnemy_Draw	; The special exception as noted above!!
ObjP75:
	.byte $81, $83

ObjP89:
	.byte $91, $93, $9D, $9F, $9D, $9F

ObjP8A:
ObjP8C:
ObjP8D:
ObjP8E:
ObjP8F:
	.byte $99, $9B, $B9, $BB, $95, $97, $B5, $B7, $9D, $9F, $BD, $BF

ObjP8B:
	.byte $9D, $9F, $BD, $BF, $91, $93, $B1, $B3,  $91, $93, $B1, $B3

ObjP7F:
	.byte $A1, $A3, $A5, $A7, $A9, $AB, $AD, $AF

ObjP7B:
	.byte $AD, $AD, $AF, $B1, $AD, $AD

ObjP7E:
	.byte $8D, $8F, $93, $95, $99, $8F, $9B, $9D, $B1, $B3, $B5, $B7
ObjP7C:
	.byte $9F, $9F, $87, $89, $AB, $AB, $A9, $A9
ObjP6C:
ObjP6D:
ObjP6E:
ObjP6F:
ObjP80:
ObjP7A:
	.byte $CB, $C5, $C3, $C5, $FD, $FD, $FD, $FD, $FD, $FD, $D1, $D1, $D3, $D5
ObjP70:
	.byte $95, $97, $91, $93, $9B, $9B, $9B, $9B, $A1, $A1, $9B, $9B, $A3, $A5
ObjP71:
	.byte $81, $83, $85, $87, $89, $89, $89, $89, $89, $89, $8F, $8F, $8B, $8D
ObjP72:
ObjP73:
	.byte $D9, $DB, $DB, $D9, $D9, $DB, $EB, $EB

ObjP74:
ObjP7D:
	.byte $D9, $DB, $DB, $D9, $DB, $DB

ObjP78:
ObjP79:
	.byte $BD, $BF, $B9, $BB, $DD, $DF, $B5, $B7

ObjP76:
	.byte $79, $79, $79, $79, $79, $79
ObjP77:
	.byte $E7, $E9, $E7, $EF, $E7, $EF, $AD, $AF, $B9, $BB, $B9, $BB
ObjP84:
	.byte $99, $99, $BB, $BB, $81, $83
ObjP85:
	.byte $81, $83, $85, $87, $89, $89, $89, $89, $89, $89, $8F, $8F, $8B, $8D

ObjP83:
	.byte $9F, $41, $BD, $BD
	.byte $9F, $41, $9D, $9D


ObjP88:
	.byte $8D, $8F, $B5, $B7, $8D, $8F, $A5, $A7
	.byte $91, $93, $B5, $B7, $91, $93, $A5, $A7
	

ObjP86:
ObjP87:
	.byte $81, $83, $B5, $B7, $81, $83, $A5, $A7
	.byte $85, $87, $B5, $B7, $85, $87, $A5, $A7

ObjP81:
	.byte $B1, $B3, $B5, $B7, $B1, $B3, $A5, $A7
	.byte $BD, $BF, $B5, $B7, $BD, $BF, $A5, $A7

ObjP82:
	.byte $95, $97, $A1, $A3, $95, $97, $B9, $BB
	.byte $99, $9B, $A1, $A3, $99, $9B, $B9, $BB

ObjInit_Waterfill:
	LDA #$40
	STA Objects_XVelZ, X
	RTS

ObjNorm_Waterfill:
	LDA <Objects_XHiZ, X
	BEQ ObjNorm_Waterfill1
	BMI ObjNorm_Waterfill_RTS
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State, X
	RTS

ObjNorm_Waterfill1:
	LDA <Objects_XZ, X
	AND #$0F
	BNE ObjNorm_Waterfill_RTS
	
	JSR Object_DetectTile
	CMP #TILE_PROP_SOLID_TOP
	BCC FillWater

	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA <Objects_YZ, X
	CLC
	SBC Level_VertScroll
	STA Brick_DebrisYHi

	; Brick bust lower Y
	ADD #$08
	STA Brick_DebrisY

	; Brick bust X
	LDA <Objects_XZ, X
	SUB <Horz_Scroll	
	STA Brick_DebrisX

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA Brick_DebrisXDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

FillWater:
	LDA Tile_LastValue
	EOR #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate

	; Set all of the block change coordinates to remove the ice brick
	LDA <Objects_YHiZ,X
	STA Block_ChangeYHi

	LDA <Objects_YZ,X
	AND #$f0
	STA Block_ChangeY

	LDA <Objects_XHiZ,X
	STA Block_ChangeXHi

	LDA <Objects_XZ,X
	AND #$f0
	STA Block_ChangeX

ObjNorm_Waterfill_RTS:
	JSR Object_ApplyXVel
	JSR Object_Draw
	LDA Object_SpriteRAMOffset, X 
	TAX
	DEC Sprite_RAM, X
	DEC Sprite_RAM + 4, X
	RTS

	; A "hammer brother" object has special purpose when 
	; Player has entered through a enemy battle object


NinjaBro_JumpYVel:	.byte -$60, -$30
NinjaBro_JumpWait: .byte $C0, $FF
NinjaBro_WaitTimers: .byte $30, $48, $18, $60
NinjaBro_CanFallThrough: .byte $00, $30

NinjaBro_Frame = Objects_Data1
NinjaBro_Action = Objects_Data2
NinjaBro_RangeLeft = Objects_Data3
NinjaBro_RangeRight = Objects_Data4
NinjaBro_ThrowStarTimer = Objects_Data5
NinjaBro_HoldStarTimer = Objects_Data6
NinjaBro_WalkDirection = Objects_Data7
NinjaBro_FallThrough = Objects_Data8
NinjaBro_WalkDirectionBackup = Objects_Data9

ObjInit_NinjaBro:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer

	LDA <Objects_XVelZ, X
	STA NinjaBro_WalkDirection, X

	LDA <Objects_XZ, X
	SUB #$10
	STA NinjaBro_RangeLeft, X

	LDA <Objects_XZ, X
	ADD #$10
	STA NinjaBro_RangeRight, X
	RTS		 ; Return
	
ObjNorm_NinjaBro:
	LDA <Player_HaltGameZ
	BEQ NinjaBro_Norm

	LDA <Objects_TilesDetectZ,X
	AND #HIT_GROUND
	BEQ NinjaBro_HaltNoDraw


	JMP NinjaBros_Draw

NinjaBro_HaltNoDraw:
	RTS

NinjaBro_Norm:

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA NinjaBro_WalkDirection, X
	STA <Objects_XVelZ, X

	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	
	LDA NinjaBro_FallThrough, X
	BEQ NinjaBro_DetectTiles

	DEC NinjaBro_FallThrough, X
	JMP NinjaBro_Done

NinjaBro_DetectTiles:
	LDA <Objects_TilesDetectZ, X
	AND #~HIT_CEILING
	STA <Objects_TilesDetectZ, X

	JSR Object_InteractWithTiles

NinjaBro_SkipTiles:
	LDA <Objects_TilesDetectZ,X
	AND #HIT_GROUND
	BNE NinjaBro_OnGround

NinjaBro_Done:
	RTS

NinjaBro_OnGround:
	LDA Objects_PreviousTilesDetect, X
	AND #HIT_GROUND
	BNE NinjaBro_BeenOnGround

	LDA <Objects_YVelZ, X
	BNE NinjaBro_BeenOnGround

	JSR NinjaBro_MakePoof

	LDA NinjaBro_WalkDirectionBackup, X
	BEQ NinjaBro_BeenOnGround

	STA NinjaBro_WalkDirection, X

NinjaBro_BeenOnGround:
	JSR Object_FacePlayer
	JSR Object_HandleBumpUnderneath
	JSR Object_AttackOrDefeat

	LDA NinjaBro_HoldStarTimer, X
	BEQ NinjaBro_HotHolding

	DEC NinjaBro_HoldStarTimer, X
	BNE NinjaBro_CheckJump

	LDA RandomN + 1, X
	AND #$03
	TAY 
	LDA NinjaBro_WaitTimers, Y
	STA NinjaBro_ThrowStarTimer, X
	JSR NinjaBro_ThrowStar
	
NinjaBro_HotHolding:
	LDA NinjaBro_ThrowStarTimer, X
	BNE NinjaBro_DecHamTimer

	LDA #$18
	STA NinjaBro_HoldStarTimer, X
	BNE NinjaBro_CheckJump

NinjaBro_DecHamTimer:
	DEC NinjaBro_ThrowStarTimer, X

NinjaBro_CheckJump:
	LDA Objects_Timer, X
	BNE NinjaBro_NoJump

	LDY #$00
	LDA Objects_SpriteY, X
	CMP #$30
	BCS NinjaBro_NotTop

	INY
	BNE NinjaBro_DoJump

NinjaBro_NotTop:
	CMP #$70
	BCS NinjaBro_DoJump

	LDA RandomN, X
	AND #$08
	LSR A
	LSR A
	LSR A
	TAY

NinjaBro_DoJump:
	LDA NinjaBro_JumpYVel, Y
	STA <Objects_YVelZ, X

	LDA NinjaBro_CanFallThrough, Y
	STA NinjaBro_FallThrough, X

	LDA RandomN, X
	AND #$10
	LSR A
	LSR A
	LSR A
	LSR A
	TAY

	LDA NinjaBro_JumpWait, Y
	STA Objects_Timer, X

	JSR NinjaBro_MakePoof

	LDA NinjaBro_WalkDirection, X
	STA NinjaBro_WalkDirectionBackup, X

	LDA #$00
	STA NinjaBro_WalkDirection, X

NinjaBro_NoJump:
	LDA <Objects_XZ, X
	CMP NinjaBro_RangeLeft, X
	BEQ NinjaBro_TurnAround

	CMP NinjaBro_RangeRight, X
	BNE NinjaBro_Animate

NinjaBro_TurnAround:
	LDA NinjaBro_WalkDirection, X
	EOR #$FF
	ADD #$01
	STA NinjaBro_WalkDirection, X

NinjaBro_Animate:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ NinjaBros_NoAnimate

	INC NinjaBro_Frame, X

NinjaBros_NoAnimate:
	LDA #$00
	STA <Temp_Var2

	LDA NinjaBro_Frame, X
	LSR A
	LSR A
	LSR A
	LSR A
	AND #$01
	STA <Temp_Var1

	LDA NinjaBro_HoldStarTimer, X
	BEQ NinjaBros_FinishAnimate

	LDA #$02
	STA <Temp_Var2

NinjaBros_FinishAnimate:

	LDA <Temp_Var1
	ORA <Temp_Var2
	STA Objects_Frame, X

NinjaBros_Draw:
	LDA Object_SpriteRAMOffset, X
	ADD #$08
	STA Object_SpriteRAMOffset, X

	JSR Object_Draw16x32

	LDA NinjaBro_HoldStarTimer, X
	BEQ NinjaBros_Done

	JSR NinjaBro_DrawStar

NinjaBros_Done:
	RTS

NinjaBro_MakePoof:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE NinjaBro_PoofDone

	LDA <Objects_XZ, X
	STA <Poof_X

	LDA <Objects_YZ, X
	ADD #$08
	STA <Poof_Y

	LDA <Objects_YHiZ, X
	STA <Poof_YHi

	JSR Common_MakePoof

NinjaBro_PoofDone:
	RTS
Ninja_XVel:	.byte -$12, $12

NinjaXOffset:
	.byte $08, $F8
	.byte $00, $FF

NinjaTiles:
	.byte $89, $8B, $8B, $89

NinjaFlip:
	.byte SPR_PAL3 | $00, SPR_PAL3 | SPR_HFLIP

NinjaBro_DrawStar:

	LDY #$00
	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	BEQ NinjaBro_LeftSide

	INY

NinjaBro_LeftSide:
	LDA NinjaXOffset, Y
	STA <Temp_Var1

	LDY Object_SpriteRAMOffset, X

	LDA Sprite_RAMX, Y
	ADD <Temp_Var1
	STA Sprite_RAMX - 8, Y

	ADD #$08
	STA Sprite_RAMX - 4, Y

	LDA Sprite_RAMY, Y
	SUB #$06
	STA Sprite_RAMY - 8, Y

	LDA Sprite_RAMY + 4, Y
	SUB #$06
	STA Sprite_RAMY - 4, Y

	LDA #$A9
	STA Sprite_RAMTile - 8, Y
	STA Sprite_RAMTile - 4, Y

	LDA #SPR_PAL3
	STA Sprite_RAMAttr - 8, Y

	LDA #(SPR_PAL3 | SPR_VFLIP | SPR_HFLIP)
	STA Sprite_RAMAttr - 4, Y

	RTS		 ; Return

NinjaBro_ThrowStar:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BEQ NinjaBro_ThrowStarDo
	RTS

NinjaBro_ThrowStarDo:
	LDY #$00
	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	BEQ NinjaBro_ThrowLeft

	INY

NinjaBro_ThrowLeft:
	LDA NinjaXOffset, Y
	STA <Temp_Var1

	LDA NinjaXOffset + 2, Y
	STA <Temp_Var2

	JSR Object_PrepProjectile	

	LDA #SOBJ_NINJASTAR
	STA SpecialObj_ID,Y

	LDA <Objects_XZ, X
	ADD <Temp_Var1
	STA SpecialObj_X, Y

	LDA <Objects_XHiZ, X
	ADC <Temp_Var2
	STA SpecialObj_XHi, Y

	LDA <Objects_YZ, X
	SUB #$06
	STA SpecialObj_Y, Y

	LDA <Objects_YHiZ, X
	SBC #$00
	STA SpecialObj_YHi, Y

	JSR Object_AimProjectile

	LDA SpecialObj_XVel, Y
	JSR Double_Value
	STA SpecialObj_XVel, Y

	LDA SpecialObj_YVel, Y
	JSR Double_Value
	STA SpecialObj_YVel, Y
	
NinjaBro_ThrowDone:
	RTS


HammerBro_JumpYVel:	.byte -$60, -$30
HammerBro_JumpWait: .byte $C0, $FF
HammerBro_WaitTimers: .byte $18, $18, $30, $18
HammerBro_CanFallThrough: .byte $00, $30

HammerBro_Frame = Objects_Data1
HammerBro_Action = Objects_Data2
HammerBro_RangeLeft = Objects_Data3
HammerBro_RangeRight = Objects_Data4
HammerBro_ThrowHammerTimer = Objects_Data5
HammerBro_HoldHammerTimer = Objects_Data6
HammerBro_WalkDirection = Objects_Data7
HammerBro_FallThrough = Objects_Data8


ObjInit_HammerBro:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer

	LDA <Objects_XVelZ, X
	STA HammerBro_WalkDirection, X

	LDA <Objects_XZ, X
	SUB #$10
	STA HammerBro_RangeLeft, X

	LDA <Objects_XZ, X
	ADD #$10
	STA HammerBro_RangeRight, X
	RTS		 ; Return
	
ObjNorm_HammerBro:
	LDA <Player_HaltGameZ
	BEQ HammerBro_Norm

	JMP HammerBros_Draw

HammerBro_Norm:

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA HammerBro_WalkDirection, X
	STA <Objects_XVelZ, X

	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	
	LDA HammerBro_FallThrough, X
	BEQ HammerBro_DetectTiles

	DEC HammerBro_FallThrough, X
	JMP HammerBro_SkipTiles

HammerBro_DetectTiles:
	LDA <Objects_TilesDetectZ, X
	AND #~HIT_CEILING
	STA <Objects_TilesDetectZ, X

	JSR Object_InteractWithTiles

HammerBro_SkipTiles:
	JSR Object_FacePlayer
	JSR Object_HandleBumpUnderneath
	JSR Object_AttackOrDefeat

	LDA HammerBro_HoldHammerTimer, X
	BEQ HammerBro_HotHolding

	DEC HammerBro_HoldHammerTimer, X
	BNE HammerBro_CheckJump

	LDA RandomN + 1, X
	AND #$03
	TAY 
	LDA HammerBro_WaitTimers, Y
	STA HammerBro_ThrowHammerTimer, X
	JSR HammerBro_ThrowHammer
	
HammerBro_HotHolding:
	LDA HammerBro_ThrowHammerTimer, X
	BNE HammerBro_DecHamTimer

	LDA #$18
	STA HammerBro_HoldHammerTimer, X
	BNE HammerBro_CheckJump

HammerBro_DecHamTimer:
	DEC HammerBro_ThrowHammerTimer, X

HammerBro_CheckJump:
	LDA Objects_Timer, X
	BNE HammerBro_NoJump

	LDY #$00
	LDA Objects_SpriteY, X
	CMP #$30
	BCS HammerBro_NotTop

	INY
	BNE HammerBro_DoJump

HammerBro_NotTop:
	CMP #$70
	BCS HammerBro_DoJump

	LDA RandomN, X
	AND #$01
	TAY

HammerBro_DoJump:
	LDA HammerBro_JumpYVel, Y
	STA <Objects_YVelZ, X

	LDA HammerBro_CanFallThrough, Y
	STA HammerBro_FallThrough, X

	LDA RandomN, X
	AND #$10
	LSR A
	LSR A
	LSR A
	LSR A
	TAY

	LDA HammerBro_JumpWait, Y
	STA Objects_Timer, X


HammerBro_NoJump:

	LDA <Objects_XZ, X
	CMP HammerBro_RangeLeft, X
	BEQ HammerBro_TurnAround

	CMP HammerBro_RangeRight, X
	BNE HammerBro_Animate

HammerBro_TurnAround:
	LDA HammerBro_WalkDirection, X
	EOR #$FF
	ADD #$01
	STA HammerBro_WalkDirection, X

HammerBro_Animate:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ HammerBros_NoAnimate

	INC HammerBro_Frame, X

HammerBros_NoAnimate:
	LDA #$00
	STA <Temp_Var2

	LDA HammerBro_Frame, X
	LSR A
	LSR A
	LSR A
	LSR A
	AND #$01
	STA <Temp_Var1

	LDA HammerBro_HoldHammerTimer, X
	BEQ HammerBros_FinishAnimate

	LDA #$02
	STA <Temp_Var2

HammerBros_FinishAnimate:

	LDA <Temp_Var1
	ORA <Temp_Var2
	STA Objects_Frame, X

HammerBros_Draw:
	LDA Object_SpriteRAMOffset, X
	ADD #$08
	STA Object_SpriteRAMOffset, X

	JSR Object_Draw16x32

	LDA HammerBro_HoldHammerTimer, X
	BEQ HammerBros_Done

	JSR HammerBro_DrawHammer

HammerBros_Done:
	RTS

Hammer_XVel:	.byte -$12, $12

HammerXOffset:
	.byte $08, $F8
	.byte $00, $FF

HammerTiles:
	.byte $89, $8B, $8B, $89

HammerFlip:
	.byte SPR_PAL3 | $00, SPR_PAL3 | SPR_HFLIP

HammerBro_DrawHammer:

	LDY #$00
	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	BEQ HammerBro_LeftSide

	INY

HammerBro_LeftSide:
	LDA HammerXOffset, Y
	STA <Temp_Var1

	LDA HammerTiles, Y
	STA <Temp_Var2

	LDA HammerTiles + 2, Y
	STA <Temp_Var3

	LDA HammerFlip, Y
	STA <Temp_Var4

	LDY Object_SpriteRAMOffset, X

	LDA Sprite_RAMX, Y
	ADD <Temp_Var1
	STA Sprite_RAMX - 8, Y
	ADD #$08
	STA Sprite_RAMX - 4, Y

	LDA Sprite_RAMY, Y
	SUB #$06
	STA Sprite_RAMY - 8, Y
	STA Sprite_RAMY - 4, Y

	LDA <Temp_Var2
	STA Sprite_RAMTile - 8, Y

	LDA <Temp_Var3
	STA Sprite_RAMTile - 4, Y

	LDA <Temp_Var4
	STA Sprite_RAMAttr - 8, Y
	STA Sprite_RAMAttr - 4, Y

	RTS		 ; Return

HammerBro_ThrowHammer:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE HammerBro_ThrowDone

	LDY #$00
	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	BEQ HammerBro_ThrowToRight

	INY

HammerBro_ThrowToRight:
	
	LDA HammerXOffset, Y
	ADD <Objects_XZ, X
	STA <Temp_Var14

	LDA <Objects_XHiZ, X
	ADC HammerXOffset + 2, Y
	STA <Temp_Var15
	
	LDA Hammer_XVel, Y
	STA <Temp_Var16

	JSR Object_PrepProjectile
	BCC HammerBro_ThrowDone

	LDA #SOBJ_HAMMER
	STA SpecialObj_ID, Y

	LDA <Temp_Var16
	STA SpecialObj_XVel, Y

	LDA #$C0
	STA SpecialObj_YVel, Y

	LDA <Temp_Var14
	STA SpecialObj_X, Y

	LDA <Temp_Var15
	STA SpecialObj_XHi, Y

	LDA <Objects_YZ, X
	SUB #$06
	STA SpecialObj_Y, Y

	LDA <Objects_YHiZ, X
	SBC #$00
	STA SpecialObj_YHi, Y

HammerBro_ThrowDone:
	RTS

FireIcePirateBro_JumpWait: .byte $C0, $FF
FireIcePirateBro_WaitTimers: .byte $60, $40, $40, $40

FireIcePirateBro_Frame = Objects_Data1
FireIcePirateBro_Action = Objects_Data2
FireIcePirateBro_RangeLeft = Objects_Data3
FireIcePirateBro_RangeRight = Objects_Data4
FireIcePirateBro_SpitTimer = Objects_Data5
FireIcePirateBro_OpenMouthTimer = Objects_Data6
FireIcePirateBro_WalkDirection = Objects_Data7
FireIcePirateBro_FireIcePirateCount = Objects_Data8
FireIcePirateBro_WalkDirectionBackup = Objects_Data9
FireIcePirateBro_Projectile = Objects_Data10

ObjInit_FireBro:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer

	LDA <Objects_XVelZ, X
	STA FireIcePirateBro_WalkDirection, X

	LDA <Objects_XZ, X
	SUB #$10
	STA FireIcePirateBro_RangeLeft, X

	LDA <Objects_XZ, X
	ADD #$10
	STA FireIcePirateBro_RangeRight, X

	LDA #SOBJ_FIREBALL
	STA FireIcePirateBro_Projectile, X
	RTS		 ; Return

ObjInit_IceBro:
	JSR ObjInit_FireBro

	LDA #SOBJ_ICEBALL
	STA FireIcePirateBro_Projectile, X
	RTS		 ; Return

ObjInit_PirateBro:
	JSR ObjInit_FireBro

	LDA #SOBJ_CANNONBALL
	STA FireIcePirateBro_Projectile, X
	RTS		 ; Return
	
ObjNorm_FireBro:
	LDA <Player_HaltGameZ
	BEQ FireIcePirateBro_Norm

	JMP Object_Draw16x32

FireIcePirateBro_Norm:

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA FireIcePirateBro_WalkDirection, X
	STA <Objects_XVelZ, X

	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_FacePlayer
	JSR Object_HandleBumpUnderneath
	JSR Object_AttackOrDefeat

	LDA FireIcePirateBro_OpenMouthTimer, X
	BEQ FireIcePirateBro_NotOpen

	DEC FireIcePirateBro_OpenMouthTimer, X
	BNE FireIcePirateBro_CheckJump

	LDA FireIcePirateBro_FireIcePirateCount, X
	BEQ FireIcePirateBro_Reset

	DEC FireIcePirateBro_FireIcePirateCount, X

	JSR FireIcePirateBro_Shoot

	LDA #$18
	STA FireIcePirateBro_OpenMouthTimer, X
	BNE FireIcePirateBro_CheckJump

FireIcePirateBro_Reset:
	LDA RandomN + 1, X
	AND #$03
	TAY 
	LDA FireIcePirateBro_WaitTimers, Y
	STA FireIcePirateBro_SpitTimer, X

	LDA FireIcePirateBro_WalkDirectionBackup, X
	STA FireIcePirateBro_WalkDirection, X
	
FireIcePirateBro_NotOpen:
	LDA FireIcePirateBro_SpitTimer, X
	BNE FireIcePirateBro_DecFireIcePirateTimer

	LDA #$18
	STA FireIcePirateBro_OpenMouthTimer, X

	LDA RandomN, X
	AND #$01
	ADD #$01
	STA FireIcePirateBro_FireIcePirateCount, X

	LDA FireIcePirateBro_WalkDirection, X
	STA FireIcePirateBro_WalkDirectionBackup, X

	LDA #$00
	STA FireIcePirateBro_WalkDirection, X
	BEQ FireIcePirateBro_CheckJump

FireIcePirateBro_DecFireIcePirateTimer:
	DEC FireIcePirateBro_SpitTimer, X

FireIcePirateBro_CheckJump:
	LDA Objects_Timer, X
	BNE FireIcePirateBro_NoJump

	LDA #$C0
	STA <Objects_YVelZ, X

	LDA RandomN, X
	AND #$10
	LSR A
	LSR A
	LSR A
	LSR A
	TAY

	LDA FireIcePirateBro_JumpWait, Y
	STA Objects_Timer, X


FireIcePirateBro_NoJump:

	LDA <Objects_XZ, X
	CMP FireIcePirateBro_RangeLeft, X
	BEQ FireIcePirateBro_TurnAround

	CMP FireIcePirateBro_RangeRight, X
	BNE FireIcePirateBro_Animate

FireIcePirateBro_TurnAround:
	LDA FireIcePirateBro_WalkDirection, X
	EOR #$FF
	ADD #$01
	STA FireIcePirateBro_WalkDirection, X

FireIcePirateBro_Animate:
	LDA FireIcePirateBro_WalkDirection, X
	BEQ FireIcePirateBros_NoAnimate

	INC FireIcePirateBro_Frame, X

FireIcePirateBros_NoAnimate:
	LDA #$00
	STA <Temp_Var2

	LDA FireIcePirateBro_Frame, X
	LSR A
	LSR A
	LSR A
	LSR A
	AND #$01
	STA <Temp_Var1

	LDA FireIcePirateBro_OpenMouthTimer, X
	BEQ FireIcePirateBros_FinishAnimate

	LDA #$02
	STA <Temp_Var2

FireIcePirateBros_FinishAnimate:

	LDA <Temp_Var1
	ORA <Temp_Var2
	STA Objects_Frame, X

FireIcePirateBros_Draw:
	JMP Object_Draw16x32


FireIcePirate_XVel:
	.byte $E0, $20
	
FireIcePirate_XOffset:
	.byte $FE, $08
	.byte $FF, $00

FireIcePirateBro_Shoot:

	LDA Objects_SpritesHorizontallyOffScreen,X
	CMP #(SPRITE_0_INVISIBLE | SPRITE_1_INVISIBLE)
	BCS FireICePriateBro_NoShoot

	LDA Objects_SpritesHorizontallyOffScreen,X
	BEQ FireIcePirateBro_DoShoot

FireICePriateBro_NoShoot:
	RTS

FireIcePirateBro_DoShoot:
	LDY #$00

	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	BEQ FireIcePirateBro_SpitRight

	INY

FireIcePirateBro_SpitRight:
	
	LDA FireIcePirate_XOffset, Y
	STA <Temp_Var14

	LDA FireIcePirate_XOffset + 2, Y
	STA <Temp_Var15

	LDA FireIcePirate_XVel, Y
	STA <Temp_Var16

	JSR Object_PrepProjectile
	BCC FireIcePirateBro_ShootDone

	LDA FireIcePirateBro_Projectile, X
	STA SpecialObj_ID, Y

	LDA <Temp_Var16
	STA SpecialObj_XVel, Y

	LDA #$FE
	STA SpecialObj_YVel, Y

	LDA <Objects_XZ, X
	ADD <Temp_Var14
	STA SpecialObj_X, Y

	LDA <Objects_XHiZ, X
	ADC <Temp_Var15
	STA SpecialObj_XHi, Y

	LDA <Objects_YZ, X
	ADD #$04
	STA SpecialObj_Y, Y

	LDA <Objects_YHiZ, X
	ADC #$00
	STA SpecialObj_YHi, Y

	LDA FireIcePirateBro_Projectile, X
	CMP #SOBJ_CANNONBALL
	BNE FireIcePirateBro_ShootDone

	LDA #SND_LEVELBABOOM
	ORA Sound_QLevel1
	STA Sound_QLevel1

	LDA #$00
	STA SpecialObj_YVel, Y

	LDA #$02
	STA SpecialObj_Data3, Y
	
	LDA SpecialObj_Y, Y
	SUB #$02
	STA SpecialObj_Y, Y

	LDA SpecialObj_YHi, Y
	SBC #$00
	STA SpecialObj_YHi, Y
	RTS

FireIcePirateBro_ShootDone:
	LDA #SND_PLAYERFIRE
	ORA Sound_QPlayer
	STA Sound_QPlayer
	RTS

ObjInit_Thwomp:

	LDA #$10
	STA Objects_Health, X

	; Var4 = origin Y
	LDA <Objects_YZ, X
	STA Thwomp_StartY, X

	LDA <Objects_YHiZ, X
	STA Thwomp_StartYHi, X
	
	; center the X
	LDA <Objects_XZ,X
	ADD #$04
	STA <Objects_XZ,X

	LDA <Objects_XHiZ,X
	ADD #$00
	STA <Objects_XHiZ,X

PRG004_A676:
	RTS		 ; Return


Thwomp_Action = Objects_Data1
Thwomp_Ticker = Objects_Data2
Thwomp_StartY = Objects_Data3
Thwomp_StartYHi = Objects_Data4
Thwomp_TilesDetected = Objects_Data5

Thwomp_DetectXOffset:
	.byte $05, $14

ObjNorm_Thwomp:
	LDA <Player_HaltGameZ
	BEQ Thwomp_Normal

	JMP Thwomp_Draw

Thwomp_Normal:
	JSR Object_DeleteOffScreen
	
	LDA <Thwomp_Action, X
	JSR DynJump

	.word Thwomp_WaitForPlayer
	.word Thwomp_FallToGround
	.word Thwomp_ReturnToOrigin

Thwomp_WaitForPlayer:
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_XDistanceFromPlayer

	LDY #$00
	LDA <XDiff
	CMP #$50
	BCS Thwomp_KeepFrame

	INY

Thwomp_KeepFrame:
	TYA
	STA Objects_Frame, X

	LDA <XDiff
	CMP #$20
	BCS Thwomp_KeepWaiting

	INC <Thwomp_Action, X

	LDA #$00
	STA Thwomp_TilesDetected, X

	LDA #$02
	STA Objects_Frame, X

Thwomp_KeepWaiting:
	JMP Thwomp_Draw

Thwomp_FallToGround:
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat

	INC <Thwomp_Ticker, X
	LDA <Thwomp_Ticker, X
	AND #$01
	TAY

	LDA Objects_BoundLeft, X
	ADD Thwomp_DetectXOffset, Y
	STA Tile_DetectionX

	LDA Objects_BoundLeftHi, X
	ADC #$00
	STA Tile_DetectionXHi

	LDA Objects_BoundBottom, X
	STA Tile_DetectionY

	LDA Objects_BoundBottomHi, X
	STA Tile_DetectionYHi

	JSR Object_DetectTile
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCC Thwomp_NoHit

	JSR Object_HitGround

	INC Thwomp_TilesDetected, X
	LDA Thwomp_TilesDetected, X
	CMP #$03
	BCS Thwomp_DetectGrnd

	LDA #$20
	STA <Objects_YVelZ, X

	LDA Tile_LastProp
	CMP #TILE_ITEM_COIN
	BCC Thwomp_NoBump

	JSR Object_DirectBumpBlocks

Thwomp_NoBump:
	JMP Thwomp_Draw

Thwomp_DetectGrnd:
	LDA #$20
	STA Level_Vibration

	LDA #$30
	STA Objects_Timer, X

	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1
	INC <Thwomp_Action, X

Thwomp_NoHit:
	JMP Thwomp_Draw

Thwomp_ReturnToOrigin:

	LDA Objects_Timer, X
	BNE Thwomp_Draw

	LDA #$01
	STA Objects_Frame, X

	LDA #$F8
	STA <Objects_YVelZ, X
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat

	LDA <Objects_YZ, X
	CMP Thwomp_StartY, X
	BNE Thwomp_Draw

	LDA <Objects_YHiZ, X
	CMP Thwomp_StartYHi, X
	BNE Thwomp_Draw

	LDA #$00
	STA <Thwomp_Action, X

Thwomp_Draw:

	JSR Object_Draw16x32	 ; Draw left 2/3 of Thwomp

	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset

	; The right sprites appear +16 away from Thwomp's left
	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #SPRITE_2_INVISIBLE
	BNE Thwomp_DrawRTS

	LDA Objects_SpritesVerticallyOffScreen,X
	AND #SPRITE_0_INVISIBLE
	BNE Thwomp_Draw1

	LDA Objects_SpriteX, X
	ADD #$10
	STA Sprite_RAMX + 16,Y

	LDA Objects_SpriteY, X
	STA Sprite_RAMY + 16,Y

	LDA Sprite_RAMAttr,Y
	ORA #SPR_HFLIP
	STA Sprite_RAMAttr + 16,Y

	
	LDA Sprite_RAMTile, Y
	STA Sprite_RAMTile + 16, Y

Thwomp_Draw1:
	LDA Objects_SpritesVerticallyOffScreen,X
	AND #SPRITE_1_INVISIBLE
	BNE Thwomp_DrawRTS

	LDA Objects_SpriteX, X
	ADD #$10
	STA Sprite_RAMX + 20,Y

	LDA Objects_SpriteY, X
	ADD #$10
	STA Sprite_RAMY + 20,Y

	; Right sprite horizontally flipped
	LDA Sprite_RAMAttr + 8,Y
	ORA #SPR_HFLIP
	STA Sprite_RAMAttr + 20,Y

	LDA Sprite_RAMTile + 8, Y
	STA Sprite_RAMTile + 20, Y

Thwomp_DrawRTS:
	RTS		 ; Return


ObjNorm_AngryThwomp:
	LDA <Player_HaltGameZ
	BEQ AngryThwomp_Normal

	JMP Thwomp_Draw

AngryThwomp_Normal:
	JSR Object_DeleteOffScreen

	LDA <Thwomp_Action, X
	AND #$03

	JSR DynJump

	.word Thwomp_FallToGround
	.word AngryThwompWait
	.word Thwomp_FallToCeiling
	.word AngryThwompWait

AngryThwompWait:
	LDA Objects_Timer, X
	BNE AngryThwompWaitRTS

	JSR Object_CalcBoundBox
	JSR Object_XDistanceFromPlayer

	LDA <XDiff
	CMP #$40
	BCS AngryThwompWaitRTS

	INC <Thwomp_Action, X
	LDA Objects_Frame, X
	EOR #$01
	STA Objects_Frame, X

	LDA #$00
	STA Thwomp_TilesDetected, X

AngryThwompWaitRTS:
	JMP Thwomp_Draw


Thwomp_FallToCeiling:
	INC Reverse_Gravity
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat

	INC <Thwomp_Ticker, X
	LDA <Thwomp_Ticker, X
	AND #$01
	TAY

	LDA Objects_BoundLeft, X
	ADD Thwomp_DetectXOffset, Y
	STA Tile_DetectionX

	LDA Objects_BoundLeftHi, X
	ADC #$00
	STA Tile_DetectionXHi

	LDA Objects_BoundTop, X
	STA Tile_DetectionY

	LDA Objects_BoundTopHi, X
	STA Tile_DetectionYHi

	JSR Object_DetectTile
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCC AngryThwomp_NoHit

	JSR Object_HitCeiling

	INC Thwomp_TilesDetected, X
	LDA Thwomp_TilesDetected, X
	CMP #$03
	BCS AngryThwomp_DetectCeil

	LDA #$E0
	STA <Objects_YVelZ, X

	LDA Tile_LastProp
	CMP #TILE_ITEM_COIN
	BCC AngryThwomp_NoBump

	JSR Object_DirectBumpBlocks

AngryThwomp_NoBump:
	JMP Thwomp_Draw

AngryThwomp_DetectCeil:
	LDA #$20
	STA Level_Vibration

	LDA #$30
	STA Objects_Timer, X

	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1
	INC <Thwomp_Action, X

AngryThwomp_NoHit:
	JMP Thwomp_Draw


ObjNorm_ThwompVertical:
;	JSR Thwomp_Draw		; Draw Thwomp
;	 
;	LDA <Player_HaltGameZ
;	BNE PRG004_A831	 ; If gameplay is halted, jump to PRG004_A831 (RTS)
;
;	JSR Object_DeleteOffScreen_N2	 ; Delete if Thwomp falls off-screen
;	JSR Object_AttackOrDefeat	 ; Do Player to Thwomp collision
;
;	LDA <Objects_Data2,X	 ; Var5 is internal state
;	AND #$03	 	; Limit 0-3
;
;	JSR DynJump
;
;	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
;	.word ThwompVert_Reverse
;	.word ThwompVert_Slide
;	.word ThwompVert_Reverse
;	.word ThwompVert_Slide
;
;ThwompVert_Reverse:
;	LDA Objects_Timer,X
;	BNE PRG004_A81E	 ; If timer not expired, jump to PRG004_A81E (RTS)
;
;	; Thwomp turns around...
;
;	; Negate X velocity
;	LDA <Objects_XVelZ,X
;	JSR Negate
;	STA <Objects_XVelZ,X
;
;	; Negate Y velocity
;	LDA <Objects_YVelZ,X
;	JSR Negate
;	STA <Objects_YVelZ,X
;
;	INC <Objects_Data2,X	 ; Var5++ (next internal state)
;
;	; Set timer to $80
;	LDA #$80
;	STA Objects_Timer,X
;
;PRG004_A81E:
;	RTS		 ; Return
;
;ThwompVert_Slide:
;	LDA Objects_Timer,X
;	BNE PRG004_A82B	 ; If timer not expired, jump to PRG004_A82B
;
;	INC <Objects_Data2,X	 ; Var5++
;
;	; Set timer to $3C
;	LDA #$3c
;	STA Objects_Timer,X
;
;PRG004_A82B:
;	JSR Object_ApplyXVel	 	; Apply X velocity
;	JSR Object_ApplyYVel_NoGravity	; Apply Y velocity
;
;PRG004_A831:
	RTS		 ; Return

OrangeCheep_Accel:	.byte $01, $FF
OrangeCheep_Limit:	.byte $10, $F0

ObjNorm_OrangeCheep:

Pirate_CannonX:
	.byte $30, -$30

Pirate_CannonxPos:
	.byte $00, -$08

PirateBro_SpitCannon:
	JSR SpecialObject_FindEmptyAbort	; Find an empty special object slot or don't come back

	; Fireball sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Fireball at Y + 3
	LDA <Objects_YZ,X
	ADD #$0B
	STA SpecialObj_Y,Y
	LDA <Objects_YHiZ,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Fireball Y Vel
	LDA #$00
	STA SpecialObj_YVel,Y

	STY <Temp_Var1		 ; Special object slot index -> Temp_Var1

	JSR Object_XDistanceFromPlayer

	STY DAIZ_TEMP1
	; Spit fire towards Player!
	LDA Pirate_CannonX,Y
	LDY <Temp_Var1		; Y = special object slot
	STA SpecialObj_XVel,Y

	LDY DAIZ_TEMP1
	LDA <Objects_XZ,X
	ADD Pirate_CannonxPos, Y
	LDY <Temp_Var1
	STA SpecialObj_X,Y
	

	LDA #SOBJ_CANNONBALL
	STA SpecialObj_ID,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data1,Y
	RTS

Giant_HVisBit:	.byte $20, $80	; Not horizontally flipped, horizontally flipped
Giant_HXOff:	.byte $10, $00	; Not horizontally flipped, horizontally flipped

SpinyEggDud_FlipTowardsPlayer:	.byte SPR_HFLIP, $00

ObjNorm_SpinyEggDud:

	RTS		 ; Return

SpinyEgg_HatchFacePlayerFlip:	.byte SPR_HFLIP, $00

SpinyEgg_Frame = Objects_Data1
ObjNorm_SpinyEgg:
	LDA <Player_HaltGameZ
	BEQ SpinyEgg_Norm

	JMP SpinyEgg_Draw

SpinyEgg_Norm:
	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ SpinyEgg_Animate

	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE SpinEgg_NoBurst

	LDA <Objects_XZ, X
	STA Debris_X

	LDA <Objects_YZ, X
	STA Debris_Y

	JSR Common_MakeDebris
	LDA #$A7
	STA BrickBust_Tile, Y

	LDA #SPR_PAL1
	STA BrickBust_Pal, Y

SpinEgg_NoBurst:
	LDA #OBJ_SPINY
	STA Objects_ID, X
	JSR Object_MoveTowardsPlayer

SpinyEgg_Animate:
	INC SpinyEgg_Frame, X

SpinyEgg_Draw:
	JSR Object_DrawMirrored

	LDA SpinyEgg_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	BEQ SpinyEgg_FlipRight

	LDA Sprite_RAMAttr, Y
	ORA #SPR_VFLIP
	STA Sprite_RAMAttr, Y
	RTS		 ; Return

SpinyEgg_FlipRight:
	LDA Sprite_RAMAttr + 4, Y
	ORA #SPR_VFLIP
	STA Sprite_RAMAttr + 4, Y
	RTS

Lakitu_GraphicsTables:
	.byte $0B

ObjInit_Lakitu:

	LDY Objects_Property, X
	LDA Lakitu_GraphicsTables, Y
	STA PatTable_BankSel + 4

	LDA #$20
	STA ChaseVel_LimitHi, X

	LDA #$E0
	STA ChaseVel_LimitLo, X

	JSR Object_CalcBoundBox

	LDA #$FF
	STA Lakitu_EnemySlot, X 
	RTS		 ; Return


Lakitu_Frame = Objects_Data1
Lakitu_Action = Objects_Data2
Lakitu_BodyOffset = Objects_Data3
Lakitu_EnemySlot = Objects_Data4
Lakitu_EnemyOffset = Objects_Data5
Lakitu_MadePoof = Objects_Data6
Lakitu_SleepTime = Objects_Data7

ObjNorm_Lakitu:
	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE Lakitu_Alive

	JMP Lakitu_Die

Lakitu_Alive:
	LDA Objects_SlowTimer, X
	BEQ Lakitu_Do

	
	LDA <Horz_Scroll
	ADD #$40
	STA <Objects_XZ, X

	LDA <Horz_Scroll_Hi
	ADC #$01
	STA <Objects_XHiZ, X
	RTS

Lakitu_Do:
	LDA <Player_HaltGameZ
	BEQ Lakitu_Norm

	JMP Lakitu_Draw

Lakitu_Norm:
	JSR Object_ChasePlayer
	JSR Object_CalcBoundBox

	LDA <Vert_Scroll
	ADD #$14
	STA <Objects_YZ, X

	LDA #$00
	ADC #$00
	STA <Objects_YHiZ, X

	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Lakitu_DoAction
	JMP Lakitu_Draw

Lakitu_DoAction:
	LDA <Lakitu_Action, X
	JSR DynJump

	.word Lakitu_Wait
	.word Lakitu_Lower
	.word Lakitu_GetEnemy
	.word Lakitu_RaiseEnemy
	.word Lakitu_Raise
	.word Lakitu_Aim

Lakitu_Die:
	LDA <Player_HaltGameZ
	BNE Laktiu_DieDone

	LDA Lakitu_MadePoof, X
	BNE Lakitu_NoPoof

	LDA <Objects_XZ, X
	STA Poof_X

	LDA <Objects_YZ, X 
	ADD #$10
	STA Poof_Y

	LDA <Objects_YHiZ, X
	ADC #$00
	STA Poof_YHi
	JSR Common_MakePoof

	INC Lakitu_MadePoof, X

Lakitu_NoPoof
	JSR Object_Move

	LDA <Objects_YHiZ, X
	BEQ Laktiu_DieDone

	LDA <Objects_YZ, X
	CMP #$B0
	BCC Laktiu_DieDone

	LDA #$FF
	STA Objects_SlowTimer, X

	LDA #OBJSTATE_NORMAL
	STA Objects_State, X


	JSR Lakitu_Reset

	LDA #$00
	STA Objects_Frame, X

	LDA Objects_Orientation, X
	AND #~SPR_VFLIP
	STA Objects_Orientation, X

	RTS

Laktiu_DieDone:
	LDA #$01
	STA Objects_Frame, X

	LDA #SPR_VFLIP
	ORA Objects_Orientation, X
	STA Objects_Orientation, X

	JMP Object_DrawMirrored

Lakitu_Wait:
	LDA Objects_Timer, X
	BNE Lakitu_WaitDone

	INC <Lakitu_Action, X

Lakitu_WaitDone:
	RTS

Lakitu_Lower:
	INC Lakitu_BodyOffset, X
	LDY Lakitu_BodyOffset, X
	CPY #$10
	BCC Lakitu_LowerDone

	INC <Lakitu_Action, X

Lakitu_LowerDone:
	RTS

Lakitu_GetEnemy:
	LDA Objects_Property, X
	TAY
	LDA Lakitu_EnemyToss, Y
	STA <Temp_Var1

	LDA Lakitu_EnemyProperty, Y
	STA <Temp_Var2

	JSR Object_FindEmptyY
	BCC Lakitu_GetEnemyDone

	TYA
	STA Lakitu_EnemySlot, X

	LDA #OBJSTATE_NONE
	STA Objects_State, Y

	LDA <Temp_Var1
	STA Objects_ID, Y	

	LDA <Temp_Var2
	STA Objects_Property, Y

	INC <Lakitu_Action, X

Lakitu_GetEnemyDone:
	RTS

Lakitu_RaiseEnemy:
	INC Lakitu_EnemyOffset, X
	LDA Lakitu_EnemyOffset, X
	CMP #$0C
	BCC Lakitu_RaiseEnemyDone

	INC <Lakitu_Action, X
	LDA #$01
	STA Objects_Frame, X

Lakitu_RaiseEnemyDone:
	RTS

Lakitu_Raise:
	DEC Lakitu_BodyOffset, X
	BNE Lakitu_RaiseDone

	INC <Lakitu_Action, X

	LDA RandomN, X
	AND #$03
	TAY
	LDA Lakitu_AimTimers, Y
	STA Objects_Timer, X

Lakitu_RaiseDone:
	RTS

Lakitu_AimTimers:
	.byte $20, $40, $40, $10


Lakitu_WaitTimers:
	.byte $40, $40, $60, $30

Lakitu_Aim:
	LDA Objects_Timer, X
	BNE Lakitu_AimDone

	LDA <Objects_XZ, X
	AND #$0F
	BNE Lakitu_AimDone

	LDA <Objects_XZ, X
	ADD #$08
	STA Tile_DetectionX

	LDA <Objects_XHiZ, X
	STA Tile_DetectionXHi

	LDA <Objects_YZ, X
	SUB #$08
	STA Tile_DetectionY

	LDA <Objects_YHiZ, X
	SBC #$00
	STA Tile_DetectionYHi

	JSR Object_DetectTile

	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_ALL
	BCS Lakitu_AimDone

	LDY Lakitu_EnemySlot, X
	LDA #OBJSTATE_FRESH
	STA Objects_State, Y

	LDA <Objects_XZ, X
	STA Objects_XZ, Y

	LDA <Objects_XHiZ, X
	STA Objects_XHiZ, Y

	LDA <Objects_YZ, X
	SUB #$10
	STA Objects_YZ, Y

	LDA <Objects_YHiZ, X
	SBC #$00
	STA Objects_YHiZ, Y

	LDA #$00
	STA Objects_YVelZ, Y

	LDA <Objects_XVelZ, X
	STA Objects_XVelZ, Y

Lakitu_Reset:

	LDA RandomN, X
	AND #$03
	TAY
	LDA Lakitu_WaitTimers, Y
	STA Objects_Timer, X

	LDA #$00
	STA Lakitu_EnemyOffset, X
	STA Lakitu_BodyOffset, X
	STA Lakitu_MadePoof, X
	STA <Lakitu_Action, X
	STA Objects_Frame, X

	LDA #$FF
	STA Lakitu_EnemySlot, X


Lakitu_AimDone:
	RTS

Lakitu_Draw:
	LDA <Objects_SpriteY, X
	ADD #$10
	STA <Objects_SpriteY, X

	LDA Object_SpriteRAMOffset, X
	ADD #$04
	STA Object_SpriteRAMOffset, X
	JSR Object_Draw16x32Mirrored

	LDA Sprite_RAMY, Y
	STA <Temp_Var1

	LDA Sprite_RAMY + 8, Y
	STA Sprite_RAMY, Y

	LDA <Temp_Var1
	ADD Lakitu_BodyOffset, X
	BCS Lakitu_Draw_A
	STA Sprite_RAMY + 8, Y

Lakitu_Draw_A:
	LDA Sprite_RAMY + 4, Y
	STA <Temp_Var1

	LDA Sprite_RAMY + 12, Y
	STA Sprite_RAMY + 4, Y

	LDA <Temp_Var1
	ADD Lakitu_BodyOffset, X
	BCS Lakitu_Draw0
	STA Sprite_RAMY + 12, Y

Lakitu_Draw0:
	LDA Sprite_RAMX, Y
	ADD #$04
	BCS Lakitu_Draw1
	STA Sprite_RAMX, Y

Lakitu_Draw1:
	LDA Sprite_RAMX + 4, Y
	ADD #$04
	BCS Lakitu_Draw2

	STA Sprite_RAMX + 4, Y

Lakitu_Draw2:
	LDA Sprite_RAMAttr, Y
	AND #~SPR_PAL3
	ORA #SPR_PAL1
	STA Sprite_RAMAttr, Y

	LDA Sprite_RAMAttr + 4, Y
	AND #~SPR_PAL3
	ORA #SPR_PAL1
	STA Sprite_RAMAttr+ 4, Y

	TYA
	SUB #$04
	TAY

	LDA #$41
	STA Sprite_RAMTile, Y

	LDA Objects_SpriteX, X
	SUB #$04
	BCC Lakitu_Draw3
	STA Sprite_RAMX, Y
	
	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #SPRITE_0_INVISIBLE
	BNE Lakitu_Draw3

	LDA Sprite_RAMY + 4, Y
	STA Sprite_RAMY, Y


	LDA Sprite_RAMAttr + 4, Y
	STA Sprite_RAMAttr, Y

Lakitu_Draw3:
	LDA Lakitu_EnemySlot, X
	BMI Lakitu_DrawDone

	JSR Lakitu_DrawEnemy

Lakitu_DrawDone:
	RTS

Lakitu_EnemyToss:
	.byte OBJ_SPINYEGG, OBJ_BOBOMB

Lakitu_EnemyFrameLeft:
	.byte $99

Lakitu_EnemyFrameLeftAttr:
	.byte SPR_PAL1

Lakitu_EnemyFrameRight:
	.byte $99

Lakitu_EnemyProperty:
	.byte $00

Lakitu_EnemyFrameRightAttr:
	.byte SPR_PAL1 | SPR_HFLIP | SPR_VFLIP

Lakitu_DrawEnemy:
	LDA Lakitu_EnemyOffset, X
	STA <Temp_Var1

	LDA Objects_Property, X
	TAX

	LDA Sprite_RAMY + 12, Y
	CMP #$F8
	BEQ Lakitu_Enemy1

	SUB <Temp_Var1
	STA Sprite_RAMY + 20, Y

Lakitu_Enemy1:
	STA <Temp_Var3

	LDA Lakitu_EnemyFrameLeft, X
	STA Sprite_RAMTile + 20, Y

	LDA Lakitu_EnemyFrameLeftAttr, X
	STA Sprite_RAMAttr + 20, Y

	LDA Sprite_RAMX + 12, Y
	STA Sprite_RAMX + 20, Y
	ADD #$08
	STA <Temp_Var2

Lakitu_UnusedSprite:
	JSR Object_GetUnusedSprite

	LDA Objects_Property, X
	TAX

	LDA <Temp_Var3
	CMP #$F8
	BEQ Lakitu_DrawEnemyDone
	STA Sprite_RAMY, Y

	LDA Lakitu_EnemyFrameRight, X
	STA Sprite_RAMTile, Y

	LDA Lakitu_EnemyFrameRightAttr, X
	STA Sprite_RAMAttr, Y

	LDA <Temp_Var2
	STA Sprite_RAMX, Y

Lakitu_DrawEnemyDone:
	RTS
	

ObjInit_ParaGoomba:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer
	LDA #$80
	STA Objects_Timer, X
	RTS

ObjNorm_ParaGoomba:
	JSR ObjNorm_Goomba

	LDA Objects_State, X
	CMP #OBJSTATE_NORMAL
	BEQ ObjNorm_ParaGoomba1
	RTS

ObjNorm_ParaGoomba1:
	LDA <Player_HaltGameZ
	BNE ObjNorm_ParaGoomba2

	LDA Objects_Data5, X
	BNE ObjNorm_ParaGoomba4

	LDA Objects_Timer, X
	BNE ObjNorm_ParaGoomba2

	LDA  <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ ObjNorm_ParaGoomba3

	LDA #$00
	STA Objects_Data3, X
	INC Objects_Data5, X
	BNE ObjNorm_ParaGoomba2

ObjNorm_ParaGoomba2:
	CMP #$10
	BCS ObjNorm_ParaGoomba3

	LDA #$04
	STA Objects_Data3, X
	JMP ParaGoomba_Draw

ObjNorm_ParaGoomba3:
	LDA #$00
	STA Objects_Data3, X

	LDA  <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BNE ObjNorm_ParaGoomba31

	LDA #$04
	STA Objects_Data3, X

ObjNorm_ParaGoomba31:
	JMP ParaGoomba_Draw

ObjNorm_ParaGoomba4:
	INC Objects_Data3, X
	LDA Objects_Data3, X
	CMP #$30
	BCS ObjNorm_ParaGoomba5

ObjNorm_ParaGoomba41:

	LDA #$F0
	STA <Objects_YVelZ, X

	JMP ParaGoomba_Draw

ObjNorm_ParaGoomba5:
	LDY DayNight
	BPL ObjNorm_ParaGoomba51

	CMP #$40
	BCS ObjNorm_ParaGoomba51

	LDA #$00
	STA <Objects_YVelZ, X
	JMP ParaGoomba_Draw

ObjNorm_ParaGoomba51:
	LDA #$00
	STA Objects_Data5, X
	STA Objects_Data3, X
	LDA #$80
	STA Objects_Timer, X

ObjNorm_ParaGoomba6:
	JMP ParaGoomba_Draw

ObjNorm_ParaGoomba7:
	JMP ParaGoomba_Draw

ParaGoomba_Draw:
	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset

	; Left wing
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_AF31	 ; If this sprite is vertically off-screen, jump to PRG004_AF31

	SUB #10
	STA Sprite_RAM+$08,Y

PRG004_AF31:

	; Right wing
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ PRG004_AF3E	 ; If this sprite is vertically off-screen, jump to PRG004_AF3E

	SUB #10
	STA Sprite_RAM+$0C,Y

PRG004_AF3E:

	; Left wing sprite X
	LDA Sprite_RAM+$03,Y
	SUB #$02
	STA Sprite_RAM+$0B,Y

	; Right wing sprite X
	LDA Sprite_RAM+$07,Y
	ADD #$02
	STA Sprite_RAM+$0F,Y

	; Left wing attribute
	LDA #(SPR_HFLIP | SPR_PAL1)
	STA Sprite_RAM+$0A,Y

	; Right wing attribute
	LDA #SPR_PAL1
	STA Sprite_RAM+$0E,Y

	LDA Objects_Data3,X

	LDX #$cd	 ; X = $CD (Wing up pattern)
	AND #$04	 
	BNE PRG004_AF65	 ; 8 ticks on, 8 ticks off; jump to PRG004_AF65

	LDX #$cf	 ; X = $CF (Wing down pattern)

PRG004_AF65:
	TXA		 
	STA Sprite_RAM+$09,Y	 ; Store left wing pattern
	STA Sprite_RAM+$0D,Y	 ; Store right wing pattern

	LDX <CurrentObjectIndexZ		 ; X = object slot index

	RTS		 ; Return

ObjInit_ZombieGoomba:
	LDA #$01
	STA Objects_Health, X

	LDA #HIT_GROUND
	STA Objects_PreviousTilesDetect, X
	LDA Objects_Property, X
	BNE ObjInit_ZombieGoomba1

	LDA #$00
	STA Objects_Data5, X

ObjInit_ZombieGoomba1:
	JMP Object_MoveTowardsPlayer
	
ObjNorm_ZombieGoomba:
	JSR Object_DeleteOffScreen	; Delete if off-screen

	LDA <Player_HaltGameZ
	BEQ ObjNorm_ZombieGoomba0
	JMP Goomba_Draw	 ; If gameplay is not halted, jump to PRG004_AF7D

ObjNorm_ZombieGoomba0:
	LDA Objects_Data5, X
	BEQ ObjNorm_ZombieGoomba1
	JMP Zombie_Wait

ObjNorm_ZombieGoomba1:
	
	JSR Object_HitTest
	BCC Zombie_NoInfection

	LDA LeftRightInfection
	BNE DontPoofInfect

	LDA #$17
	STA Player_SuitLost
	LDA #$80
	STA Player_QueueSuit

	LDA #$01
	STA LeftRightInfection
	LDA #$71
	STA Player_FlashInv
	BNE Zombie_NoInfection

DontPoofInfect:
	JSR Player_GetHurt

Zombie_NoInfection:
	JSR Object_FacePlayerOnLanding
	JSR Object_Move

	JSR Object_InteractWithOtherObjects
	BCC Zombie_NoInfection1

	LDA #$00
	STA <Objects_Data2, X

Zombie_NoInfection1:

	LDA <Objects_TilesDetectZ, X
	AND #HIT_CEILING
	BEQ Zombie_Detect1

	JSR Object_HitCeiling
	JMP Zombie_Detect2

Zombie_Detect1:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ Zombie_Detect2

	JSR Object_HitGround

Zombie_Detect2:

	LDA <Objects_TilesDetectZ, X
	AND #(HIT_LEFTWALL | HIT_RIGHTWALL)
	BEQ Zombie_Move

	LDA <Objects_XVelZ, X
	STA TempA
	JSR Object_HitWall
	LDA TempA
	STA <Objects_XVelZ, X

	LDA Objects_PreviousTilesDetect, X
	AND #HIT_GROUND
	BNE Zombie_Detect3

	LDA Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ Zombie_Move

	JSR Object_Reverse
	JMP Zombie_Move

Zombie_Detect3:
	LDA DayNight
	BNE Zombie_Detect4

	LDA #$D4
	BNE Zombie_Detect5

Zombie_Detect4:
	LDA #$C8

Zombie_Detect5:
	STA <Objects_YVelZ, X

Zombie_Move:
	LDA Objects_InWater,X
	BEQ Zombie_Move1
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State, X
	LDA #$1f
	STA Objects_Timer,X
	RTS

Zombie_Move1:
	JSR Object_HandleBumpUnderneath
	JMP Goomba_Draw

Zombie_Interact:

Zombie_Wait:
	LDA Objects_Property, X
	JSR DynJump

	.word ObjNorm_DoNothing
	.word Zombie_InsideBlock
	.word Zombie_InsideGround


Zombie_CheckDistances:
	.byte $D0, $28

Zombie_InsideBlock:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE Zombie_InsideBlock1

	JSR Object_DetectTileCenter
	LDA Tile_LastValue
	AND #$3F
	CMP #$01
	BNE Zombie_InsideBlock0
	LDA #$00
	STA Objects_Data5, X
	RTS

Zombie_InsideBlock0:

	LDA #$10
	JSR Object_XDistanceFromPlayer
	CMP #$03
	BCS Zombie_InsideBlock1

	LDA Block_NeedsUpdate   
	BNE Zombie_InsideBlock1

	JSR Zombie_Crumbles

	JSR Object_DetectTileCenter
	LDA Tile_LastValue
	AND #$C0
	ORA #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate
	
	JSR SetObjectTileCoordAlignObj
	LDA #$01
	STA Objects_Data5, X
	LDA #$E0
	STA Objects_YVelZ, X
	LDA #$00
	STA Objects_XVelZ, X

Zombie_InsideBlock1:
	RTS

Zombie_InsideGround:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE Zombie_InsideGround2

	LDA #$10
	JSR Object_XDistanceFromPlayer
	CMP #$03
	BCS Zombie_InsideGround1

	LDA Block_NeedsUpdate
	BNE Zombie_InsideGround1

	JSR Zombie_Crumbles
	LDA #$C0
	STA Objects_YVelZ, X
	LDA #$00
	STA Objects_XVelZ, X
	STA Objects_Data5, X
	RTs

Zombie_InsideGround1:
	JSR Object_DetectTileCenter
	LDA Tile_LastValue
	AND #$01
	BEQ Zombie_InsideGround2

	LDA Block_NeedsUpdate
	BNE Zombie_InsideGround2

	LDA Tile_LastValue
	AND #$FE
	STA Block_UpdateValue
	INC Block_NeedsUpdate
	
	JSR SetObjectTileCoordAlignObj

Zombie_InsideGround2
	RTS

Zombie_Crumbles:
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA <Objects_YZ, X
	ADD #$08
	CLC
	SBC Level_VertScroll
	STA Brick_DebrisYHi

	; Brick bust lower Y
	ADD #$08
	STA Brick_DebrisY

	; Brick bust X
	LDA <Objects_XZ, X
	SUB <Horz_Scroll	
	STA Brick_DebrisX

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA Brick_DebrisXDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel
	
	JSR Object_DetectTileCenter
	LDA Tile_LastValue
	AND #$FE
	ORA #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate

	JSR SetObjectTileCoordAlignObj
	RTS

ObjInit_ParaZombieGoomba:
	LDA #$06
	STA Objects_Property, X
	LDA #$01
	STA Objects_Health, X
	RTS

ObjNorm_ParaZombieGoomba:
	LDA <Player_HaltGameZ
	BNE ObjNorm_ParaZombieGoomba1

	JSR Object_DeleteOffScreen
	JSR DoPatrol
	LDA <Objects_YVelZ, X
	BPL ObjNorm_ParaZombieGoomba0

	INC Objects_Data3, X
	BNE ObjNorm_ParaZombieGoomba01

ObjNorm_ParaZombieGoomba0:
	LDA #$00
	STA Objects_Data3, X

ObjNorm_ParaZombieGoomba01:
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_InteractWithOtherObjects

	JSR Object_HitTest
	BCC ObjNorm_ParaZombieGoomba1

	LDA LeftRightInfection
	BNE ObjNorm_ParaZombieGoomba2

	LDA #$17
	STA Player_SuitLost
	LDA #$80
	STA Player_QueueSuit

	LDA #$01
	STA LeftRightInfection
	LDA #$71
	STA Player_FlashInv

ObjNorm_ParaZombieGoomba2:
	JSR Player_GetHurt

ObjNorm_ParaZombieGoomba1:
	JSR Goomba_Draw

ParaZombieGoomba_Draw:
	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset

	; Left wing
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ ParaZombieGoomba_Draw1	 ; If this sprite is vertically off-screen, jump to PRG004_AF31

	SUB #08
	STA Sprite_RAM+$08,Y

ParaZombieGoomba_Draw1:

	; Right wing
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ ParaZombieGoomba_Draw2	 ; If this sprite is vertically off-screen, jump to PRG004_AF3E

	SUB #08
	STA Sprite_RAM+$0C,Y

ParaZombieGoomba_Draw2:

	; Left wing sprite X
	LDA Sprite_RAM+$03,Y
	SUB #$04
	STA Sprite_RAM+$0B,Y

	; Right wing sprite X
	LDA Sprite_RAM+$07,Y
	ADD #$04
	STA Sprite_RAM+$0F,Y

	; Left wing attribute
	LDA #(SPR_HFLIP | SPR_PAL1)
	STA Sprite_RAM+$0A,Y

	; Right wing attribute
	LDA #SPR_PAL1
	STA Sprite_RAM+$0E,Y

	LDA Objects_Data3,X

	LDX #$ED	 ; X = $CD (Wing up pattern)
	AND #$04	 
	BNE ParaZombieGoomba_Draw3	 ; 8 ticks on, 8 ticks off; jump to PRG004_AF65

	LDX #$Ef	 ; X = $CF (Wing down pattern)

ParaZombieGoomba_Draw3:
	TXA		 
	STA Sprite_RAM+$09,Y	 ; Store left wing pattern
	STA Sprite_RAM+$0D,Y	 ; Store right wing pattern

	LDX <CurrentObjectIndexZ		 ; X = object slot index

	RTS		 ; Return

ObjNorm_JumpingCheepCheep:
	LDA <Player_HaltGameZ
	BNE PRG004_B0BA	 ; If gameplay is halted, jump to PRG004_B0BA

	INC <Objects_Data2,X	 ; Var5++

	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoGravity	; Apply Y velocity
	JSR Object_WorldDetectN1	; Detect against world

	INC <Objects_YVelZ,X	 ; YVel++

	JSR Object_AttackOrDefeat	 ; Player to Cheep Cheep collision

PRG004_B0BA:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

PRG004_B0BD:
	LDA <Objects_Data2,X
	LSR A
	LSR A
	LSR A
	AND #$01	 ; A = 0 or 1

	LDY Objects_Data4,X
	BEQ PRG004_B0CC	 ; If Var1 = 0, jump to PRG004_B0CC

	ADD #$03	 ; A = 3 or 4

PRG004_B0CC:
	STA Objects_Frame,X	 ; Set object frame

	;JSR Object_FlipByXVel	 ; Apply X velocity

	JMP GroundTroop_DrawNormal	 ; Draw and don't come back!

SwimCheep_CurrentFrame = Objects_Data1
ObjInit_SwimmingCheep:
	JSR InitPatrol

	LDA #$F8
	STA ChaseVel_LimitLo, X

	LDA #$08
	STA ChaseVel_LimitHi, X
	
	RTS

ObjNorm_SwimmingCheep:
	LDA <Player_HaltGameZ
	BNE Cheep_Draw

	JSR Object_DeleteOffScreen
	JSR DoPatrol
	JSR Object_FaceDirectionMoving
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_DetectTiles
	JSR Object_InteractWithTilesWallStops

ObjNorm_SwimmingCheep1:
	LDA Object_VertTileProp, X
	BNE ObjNorm_SwimmingCheep2

	JSR Object_HitCeiling

ObjNorm_SwimmingCheep2:
	INC <SwimCheep_CurrentFrame,X	 ; Var5++

	; Toggle frame 0/1
	LDA <SwimCheep_CurrentFrame,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

Cheep_Draw:
	JMP Object_Draw

BulletBill_XAccel:	.byte $01, -$01
BulletBill_XLimit:	.byte $18, -$18

BulletBill_FlipBits:	.byte SPR_HFLIP, $00

ObjInit_BulletBill:
	LDA #$02
	STA Objects_Frame, X
	RTS

ObjNorm_BulletBill:
	LDA <Player_HaltGameZ
	BNE PRG004_B1C2	 ; If gameplay is halted, jump to PRG004_B1C2

	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat	 	; Player to Bullet Bill collision
	JSR Object_ApplyXVel	 	
	JSR Object_ApplyYVel_NoGravity

PRG004_B1C2:
	JMP DrawBullet

ObjInit_MissileMark:
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1
	RTS

Missile_Flash = Objects_Data5
Missile_HomingDisabled = Objects_Data3
ObjNorm_MissileMark:
	LDA <Player_HaltGameZ
	BNE PRG004_B1C2	 ; If gameplay is halted, jump to PRG004_B1C2

	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen

	LDA Objects_PlayerProjHit, X
	AND #HIT_ICEBALL
	STA Missile_HomingDisabled, X

	LDA Objects_Timer, X
	BEQ ObjNorm_MissileMarkA
	
	LDA Objects_Timer, X
	
	LDA #$18
	STA ChaseVel_LimitHi, X

	LDA #$E8
	STA ChaseVel_LimitLo, X

	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoGravity
	JMP DrawBullet
	 
ObjNorm_MissileMarkA:
	LDA Missile_HomingDisabled, X
	BEQ ObjNorm_MissileMarkC

	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoGravity
	JMP ObjNorm_MissileMarkA1

ObjNorm_MissileMarkC:
	INC Missile_Flash, X

	LDA Missile_Flash, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_SpriteAttributes,X

	JSR Object_ChasePlayer

ObjNorm_MissileMarkA1:
	JSR Object_CalcBoundBox
	JSR Object_InteractWithPlayer
	JSR Object_DetectTiles
	
	LDA <Objects_TilesDetectZ, X
	BEQ DrawBullet

	LDA #$01
	STA Explosion_Timer, X

DrawBullet:
	LDA #$00
	STA Objects_Orientation, X

	LDA Objects_XVelZ, X
	BMI DrawBullet1

	LDA #SPR_HFLIP
	STA Objects_Orientation, X

DrawBullet1:
	LDA Objects_XVelZ, X
	BEQ DrawBullet2

	CMP #$02
	BCC DrawBullet2

	CMP #$FE
	BCS DrawBullet2
	BCC ObjNorm_MissileMark1

DrawBullet2:
	LDA #$00
	STA <Temp_Var1
	BEQ ObjNorm_MissileMark2

ObjNorm_MissileMark1:
	LDA #$02
	STA <Temp_Var1

	LDA Objects_YVelZ, X
	BEQ ObjNorm_MissileMark2

	CMP #$08
	BCC ObjNorm_MissileMark2

	CMP #$F8
	BCS ObjNorm_MissileMark2
	AND #$80
	EOR #$80
	ROL A
	ROL A
	ROL A
	ORA #$01
	STA <Temp_Var1

ObjNorm_MissileMark2:
	LDA Objects_Frame, X
	BNE ObjNorm_MissileMark2_1

	LDA Objects_YVelZ, X
	BMI ObjNorm_MissileMark2_1

	LDA #SPR_VFLIP
	STA Objects_Orientation, X

ObjNorm_MissileMark2_1:
	LDA <Temp_Var1
	STA Objects_Frame, X
	CMP #$02
	BEQ ObjNorm_MissileMark3

	LDA #$4F
	STA PatTable_BankSel + 5

ObjNorm_MissileMark3:
	JMP Object_Draw


ObjInit_SpikeCheep:

	RTS		 ; Return

ObjInit_Goomba:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer

	LDA Objects_Property, X
	BEQ ObjInit_Goomba1

	LDA #SPR_VFLIP
	STA Objects_Orientation, X

ObjInit_Goomba1:
	RTS


Goomba_CurrentFrame = Objects_Data1
Goomba_DeathTimer = Objects_Data2

ObjNorm_Goomba:
	LDA <Player_HaltGameZ
	BNE Goomba_DrawNoAnimate

	LDA Objects_State, X
	CMP #OBJSTATE_KILLED

	BNE ObjNorm_Goomba0
	JMP Goomba_Death

ObjNorm_Goomba0:
	JSR Object_DeleteOffScreen
	LDA DayNight
	BNE ObjNorm_Goomba1

	JSR Object_FacePlayerOnLanding

ObjNorm_Goomba1:

	LDA Objects_Property, X
	BEQ ObjNorm_Goomba02

	LDA #$01
	STA Reverse_Gravity

ObjNorm_Goomba02:
	JSR Object_Move
	JSR Object_CalcBoundBox	
	JSR Object_AttackOrDefeat
	JSR Object_InteractWithOtherObjects
	BCS Goomba_DrawNoAnimate

	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_HandleBumpUnderneath

Goomba_Draw:
	INC Goomba_CurrentFrame, X
	LDA Goomba_CurrentFrame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

ObjNorm_Goomba4:
Goomba_DrawNoAnimate:
	LDA Objects_Orientation, X
	ORA #SPR_HFLIP
	EOR #SPR_HFLIP
	STA Objects_Orientation, X

	JSR Object_Draw
	LDA Sprite_RAM + 2, Y
	EOR #SPR_HFLIP
	STA Sprite_RAM + 6, Y

	RTS

Goomba_Death:
	LDA Objects_Health, X
	BPL Goomba_Death1
	JMP Goomba_Draw
	 
Goomba_Death1:
	INC Goomba_DeathTimer, X
	LDA Goomba_DeathTimer, X
	CMP #20
	BNE Goomba_Death2

	JMP Object_SetDeadEmpty

Goomba_Death2:
	LDA #$03
	STA Objects_Frame, X
	
	LDA #$00
	STA <Objects_YVelZ, X

	LDA #$00
	STA Objects_Orientation, X
	JMP Object_DrawMirrored

FlyingTroopa_StartX = Objects_Data6
FlyingTroopa_StartXHi = Objects_Data7

ObjInit_ParaTroopas:
	LDA <Objects_YZ, X
	ADD #$10
	STA <Objects_YZ, X

	LDA <Objects_YHiZ, X
	ADC #$00
	STA <Objects_YHiZ, X

	LDA #$20 
	STA Objects_Data8, X
	STA Objects_Data9, X

	LDA Objects_Property, X
	AND #$FE
	CMP #$04
	BNE ObjInit_ParaTroopas1

	LDA <Objects_YZ, X
	ADD #$30
	STA <Objects_YZ, X

	LDA <Objects_YHiZ, X
	ADC #$00
	STA <Objects_YHiZ, X

ObjInit_ParaTroopas1:
	LDA <Objects_XZ, X
	STA FlyingTroopa_StartX, X

	LDA <Objects_XHiZ, X
	STA FlyingTroopa_StartXHi, X
	JMP InitPatrol

ObjNorm_FlyingTroopa:
	LDA <Player_HaltGameZ
	BNE ObjNorm_FlyingTroopa2

	JSR Object_DeleteOffScreen

ObjNorm_FlyingTroopa0:
	JSR DoPatrol
	JSR Object_FaceDirectionMoving
	JSR Object_CalcBoundBox
	JSR Object_DetectTiles
	JSR Object_InteractWithTilesWallStops
	JSR Object_AttackOrDefeat

	INC <Koopa_CurrentFrame,X
	LDA <Koopa_CurrentFrame,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

ObjNorm_FlyingTroopa2:
	JMP Troopa_Draw

ObjInit_Troopa:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer
	LDA <Objects_YZ, X
	ADD #$10
	STA <Objects_YZ, X

	LDA <Objects_YHiZ, X
	ADC #$00
	STA <Objects_YHiZ, X
	RTS


Koopa_CurrentFrame = Objects_Data1

ObjNorm_PurpleTroopa:
	JSR ObjNorm_RedTroopa
	LDA Objects_State, X
	CMP #OBJSTATE_NORMAL
	BEQ ObjNorm_PurpleTroopa1

	LDA #$FF
	STA Explosion_Timer, X

ObjNorm_PurpleTroopa1:
	RTS
ObjNorm_RedTroopa:
	LDA <Player_HaltGameZ
	BNE ObjNorm_Troopa1

	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_FaceDirectionMoving
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_InteractWithOtherObjects
	BCS RedTroopa_Draw

	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

	LDA Objects_PreviousTilesDetect, X
	AND #HIT_GROUND
	BEQ Troopa_Animate

	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BNE Troopa_Animate

	JSR Object_Reverse
	JSR Object_ApplyXVel

Troopa_Animate:
	INC <Koopa_CurrentFrame, X

RedTroopa_Draw:
	LDA <Koopa_CurrentFrame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JMP Troopa_Draw

ObjNorm_Troopa:
	LDA <Player_HaltGameZ
	BNE ObjNorm_Troopa1

ObjNorm_Troopa0:
	
	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_FaceDirectionMoving
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_InteractWithOtherObjects
	BCS ObjNorm_Troopa1

	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

	INC <Koopa_CurrentFrame, X
	LDA <Koopa_CurrentFrame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

ObjNorm_Troopa1:
	JMP Troopa_Draw


ObjNorm_PoisonMushroom:
	LDA <Player_HaltGameZ
	BNE ObjNorm_PoisonMushroom1

	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE ObjNorm_PoisonMushroom0

	LDA #$80
	STA CompleteLevelTimer
	JMP Object_PoofDie

ObjNorm_PoisonMushroom0:
	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

ObjNorm_PoisonMushroom1:
	JMP Object_DrawMirrored

Bouncey_FlutterTime: = Objects_Data2

ObjNorm_BouncyTroopa:
	LDA <Player_HaltGameZ
	BEQ ObjNorm_BouncyTroopa0

	JMP Troopa_Draw

ObjNorm_BouncyTroopa0:
	LDA  <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ ObjNorm_BouncyTroopa1

	LDA Objects_PreviousTilesDetect, X
	AND #HIT_GROUND
	BNE ObjNorm_BouncyTroopa1

	LDA #$00
	STA <Bouncey_FlutterTime, X
	LDA #$C0
	STA Objects_YVelZ, X
	BNE ObjNorm_BouncyTroopa2

ObjNorm_BouncyTroopa1:
	LDA DayNight
	BPL ObjNorm_BouncyTroopa2

	LDA <Objects_YVelZ, X
	BMI ObjNorm_BouncyTroopa2

	LDA <Bouncey_FlutterTime, X
	CMP #$10
	BCS ObjNorm_BouncyTroopa2

	INC <Bouncey_FlutterTime, X
	LDA #$00
	STA Objects_YVelZ, X

ObjNorm_BouncyTroopa2:
	JMP ObjNorm_Troopa

ObjNorm_GroundTroop:
	RTS

Buzzy_Frame = Objects_Data1

ObjInit_BuzzyBeetle:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer
	RTS
	
ObjNorm_BuzzyBeetle:
	LDA <Player_HaltGameZ
	BEQ Buzzy_Norm

	JMP Buzzy_Draw

Buzzy_Norm:
	JSR Object_DeleteOffScreen

	LDA Objects_Property, X
	BEQ Buzzy_NormGravity

	INC Reverse_Gravity
	LDA Objects_Orientation, X
	ORA #SPR_VFLIP
	STA Objects_Orientation, X

Buzzy_NormGravity:
	JSR Object_Move
	JSR Object_CalcBoundBox

	LDA Objects_Property, X
	BEQ Buzzy_NoDrop

	JSR Object_XDistanceFromPlayer
	
	LDA <XDiff
	CMP #$30
	BCS Buzzy_NoDrop

	LDA #OBJSTATE_KICKED
	STA Objects_State, X

	JSR Object_MoveTowardsPlayer

	LDA <Objects_XVelZ, X
	JSR Double_Value
	STA <Objects_XVelZ, X

	LDA #$00
	STA Objects_Property, X

Buzzy_NoDrop:
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_InteractWithOtherObjects
	JSR Object_AttackOrDefeat
	JSR Object_FaceDirectionMoving

	INC <Buzzy_Frame, X
	LDA <Buzzy_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

Buzzy_Draw:
	JMP Object_Draw

Spiny_Frame = Objects_Data1

ObjInit_Spiny:
	JSR Object_CalcBoundBox
	JSR Object_MoveTowardsPlayer
	RTS
	
ObjNorm_Spiny:
	LDA <Player_HaltGameZ
	BEQ Spiny_Norm

	JMP Spiny_Draw

Spiny_Norm:
	JSR Object_DeleteOffScreen

	LDA Objects_Property, X
	BEQ Spiny_NormGravity

	INC Reverse_Gravity
	LDA Objects_Orientation, X
	ORA #SPR_VFLIP
	STA Objects_Orientation, X

Spiny_NormGravity:
	JSR Object_Move
	JSR Object_CalcBoundBox

	LDA Objects_Property, X
	BEQ Spiny_NoDrop

	JSR Object_XDistanceFromPlayer
	
	LDA <XDiff
	CMP #$30
	BCS Spiny_NoDrop

	LDA #OBJSTATE_KICKED
	STA Objects_State, X

	JSR Object_MoveTowardsPlayer

	LDA <Objects_XVelZ, X
	JSR Double_Value
	STA <Objects_XVelZ, X

	LDA #$00
	STA Objects_Property, X

Spiny_NoDrop:
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	JSR Object_InteractWithOtherObjects
	JSR Object_AttackOrDefeat
	JSR Object_FaceDirectionMoving

	INC <Spiny_Frame, X
	LDA <Spiny_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

Spiny_Draw:
	JMP Object_Draw

Troopa_YOffByFrame:
	.byte $06, $05

	; Basically select first and second column if the frame is even and the
	; second and third if the frame is odd for the foot sprite patterns.
Troopa_FootByEvenOddFrame:
	.byte $C7, $C9, $C7	; Even
	.byte $F9, $FB, $F9	; Odd

Troopa_Draw:
	LDA Objects_State, X
	CMP #OBJSTATE_NORMAL
	BEQ Troopa_DoDraw

	RTS

Troopa_DoDraw:
	LDA Object_SpriteRAMOffset,X
	ADD #$08
	STA Object_SpriteRAMOffset,X

	LDY Objects_Frame,X	 ; Y = current frame

	LDA Troopa_YOffByFrame,Y
	TAY		 ; Sprite Y offset -> 'Y'

	; For the following GroundTroop_DrawOffsetInY call:
	; This draws the troopa's "middle", which incidentally includes
	; the head (minus the top), although the simplicity of the function 
	; will set the attributes wrong on the head (wrong palette) which
	; will be corrected below...

	JSR GroundTroop_DrawOffsetInY	 ; Draw with specified offset

	; Temp_Var2 = FlipBits
	LDA Objects_Orientation,X
	STA <Temp_Var2

	BEQ PRG004_B4FB	 ; If not flipped (i.e. horizontal), jump to PRG004_B4FB

	; Y += 4 (next sprite, deciding which sprite to place the head on)
	INY
	INY
	INY
	INY

PRG004_B4FB:

	; Starting here, we begin the process of drawing the tip of the head,
	; correcting the lower head's attribute, and drawing the feet...

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_B520	 ; If this sprite is vertically off-screen, jump to PRG004_B520

	; We use -8 Sprite_RAM offsets here because of the initial +8 before...

	; -16 to get to tip of head
	SUB #16
	STA Sprite_RAM-$08,Y	 ; Store sprite Y

	; Tip of Troopa's head pattern
	LDA #$c1
	STA Sprite_RAM-$07,Y

	; Copy the same X coordinate
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM-$05,Y

	LDA Sprite_RAM+$02,Y
	AND #~$03	 ; Clear old palette select
	ORA #SPR_PAL3	 ; Set correct palette select
	STA Sprite_RAM-$06,Y	 ; Set on upper head
	STA Sprite_RAM+$02,Y	 ; Set on lower head

PRG004_B520:

	; Sprite on opposite side of whatever we just put the head on
	TYA
	EOR #$04
	TAY

	LDA Objects_ID,X

	CMP #OBJ_PURPLETROOPA
	BEQ PRG004_B55D

	CMP #OBJ_PARATROOPAGREENHOP
	BLT PRG004_B55D	 ; If this is not a paratroopa, jump to PRG004_B55D

DrawWings:
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_B55D	 ; If sprite was found to be vertically off-screen, jump to PRG004_B55D

	; The wing sprite is Y-8 from the body
	SUB #$08
	STA Sprite_RAM-$08,Y

	; Temp_Var1 = $CD (pattern for wing up)
	LDA #$CD
	STA <Temp_Var1

	LDA <Koopa_CurrentFrame,X
	ADC #$02
	AND #$04
	BEQ PRG004_B548	 ; 4 ticks on, 4 ticks off; jump to PRG004_B548

	; Temp_Var1 = $CF (pattern for wing down)
	LDA #$CF
	STA <Temp_Var1 

PRG004_B548:

	; Set correct wing pattern
	LDA <Temp_Var1
	STA Sprite_RAM-$07,Y

	; Copy Sprite X
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM-$05,Y

	LDA Sprite_RAM+$02,Y
	AND #~$03	 ; Clear old palette select
	ORA #SPR_PAL1	 ; Use proper palette select for wing
	STA Sprite_RAM-$06,Y	 ; Set wing attribute

PRG004_B55D:

	; Time for the left foot...

	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_B56D	 ; If left bottom of troopa is off-screen, jump to PRG004_B56D

	; Left foot appears at Sprite Y + 16
	ADD #16
	STA Sprite_RAM+$08,Y

PRG004_B56D:
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ PRG004_B57A	 ; If right bottom of troopa is off-screen, jump to PRG004_B57A

	; Right foot appears at Sprite Y + 16
	ADD #16
	STA Sprite_RAM+$0C,Y

PRG004_B57A:
	; Copy Sprite X for left foot
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM+$0B,Y

	; Copy Sprite X for right foot
	LDA Sprite_RAM+$07,Y
	STA Sprite_RAM+$0F,Y

	LDA Sprite_RAM+$02,Y
	AND #~$03	 ; Clear old palette select
	ORA #SPR_PAL3	 ; Set correct palette select

	STA Sprite_RAM+$0A,Y	 ; Set left foot attribute
	STA Sprite_RAM+$0E,Y	 ; Set right foot attribute

	LDA Objects_Frame,X

	LDX #$00	 ; X = 0

	LSR A
	BCC PRG004_B59E	 ; On even frames, jump to PRG004_B59E

	; On odd frames, X = 3
	INX
	INX
	INX

PRG004_B59E:
	LDA <Temp_Var2
	BEQ PRG004_B5A3	 ; If not flipped (horizontally), jump to PRG004_B5A3

	INX		 ; Otherwise, X++

PRG004_B5A3:

	; Left foot pattern
	LDA Troopa_FootByEvenOddFrame,X
	STA Sprite_RAM+$09,Y

	; Right foot pattern
	LDA Troopa_FootByEvenOddFrame+1,X
	STA Sprite_RAM+$0D,Y

	LDX <CurrentObjectIndexZ	 ; X = object slot index
	RTS		 ; Return

GiantEnemy_Draw:
	LDA Objects_ID,X
	CMP #OBJ_HELPER
	BNE PRG004_B5D6	 ; If this is not a Giant Goomba, jump to PRG004_B5D6

	; Giant Goomba only...

	LDA Objects_Orientation,X
	PHA		 ; Save flip bits

	AND #~SPR_HFLIP
	STA <Temp_Var1	 ; Temp_Var1 = flip bits sans horizontal flip

	; Set horizontal flip only if Var5 bit 2 is set
	LDA <Objects_Data2,X
	AND #$04
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ORA <Temp_Var1
	STA Objects_Orientation,X

	JSR PRG004_B5D6 	; Otherwise, draw like any other

	PLA
	STA Objects_Orientation,X	; Restore flip bits

	RTS		 ; Return

PRG004_B5D6:

	; Save X/Hi and Y
	LDA <Objects_XZ,X
	PHA
	LDA <Objects_XHiZ,X
	PHA
	LDA <Objects_YZ,X
	PHA

	CLC	

	LDY Objects_Orientation,X
	BMI PRG004_B5E7	 ; If vertically flipped, jump to PRG004_B5E7

	ADC #$08	 ; Otherwise, add 8

PRG004_B5E7:
	STA <Objects_YZ,X ; -> Y

	LDA <Objects_YHiZ,X
	PHA		 ; Save Y Hi

	ADC #$00
	STA <Objects_YHiZ,X	 ; Apply carry

	; Temp_VarNP0 = sprite horizontal visibility bits
	LDA Objects_SpritesHorizontallyOffScreen,X
	STA Temp_VarNP0

	LDA Objects_Orientation,X
	AND #SPR_HFLIP
	BEQ PRG004_B60D	 ; If not horizontally flipped, jump to PRG004_B60D

	ASL Objects_SpritesHorizontallyOffScreen,X

	; Add 8 to X
	LDA <Objects_XZ,X
	ADD #$08
	STA <Objects_XZ,X
	LDA <Objects_XHiZ,X
	ADC #$00
	STA <Objects_XHiZ,X

PRG004_B60D:
	JSR Object_Draw16x32	 ; Draw left 2/3 of Giant Enemy

	; Restore Y/Hi and X/Hi
	PLA
	STA <Objects_YHiZ,X
	PLA
	STA <Objects_YZ,X
	PLA
	STA <Objects_XHiZ,X
	PLA
	STA <Objects_XZ,X

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0
;
;	LDA Objects_Orientation,X
;	AND #SPR_HFLIP
;	BEQ PRG004_B629	 ; If not horizontally flipped, jump to PRG004_B629
;
;	INY		 ; Y = 1
;
;PRG004_B629:
;	LDA Temp_VarNP0	
;	AND Giant_HVisBit,Y
;	BNE PRG004_B68A	 ; If sprite is not visible, jump to PRG004_B68A
;
;	SEC	; Carry set if Timer4 is expired
;
;	LDA Objects_Timer4,X
;	BEQ PRG004_B638	 ; If Timer4 is expired, jump to PRG004_B638
;
;	LSR A	; Otherwise, set carry by timer
;
;PRG004_B638:
;
;	; Temp_Var2 = Sprite X
;	LDA <Objects_SpriteX,X
;	SBC #$00
;	ADD Giant_HXOff,Y
;	STA <Temp_Var2	
;
;	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset
;
;	; Set Sprite Xs
;	LDA <Temp_Var2
;	STA Sprite_RAM+$13,Y
;	STA Sprite_RAM+$17,Y
;
;	; Vertical visibilty -> Temp_Var1
;	LDA Objects_SpritesVerticallyOffScreen,X
;	STA <Temp_Var1	
;
;	LDA <Objects_SpriteY,X	
;	ADD #$08
;	LSR <Temp_Var1
;	BCS PRG004_B65E	 ; If this sprite is vertically off-screen, jump to PRG004_B65E
;
;	STA Sprite_RAM+$10,Y	 ; Otherwise, set Sprite Y
;
;PRG004_B65E:
;	LSR <Temp_Var1
;	BCS PRG004_B668	 ; If this sprite is vertically off-screen, jump to PRG004_B668
;
;	ADD #16			; Lower sprite is +16 Y
;	STA Sprite_RAM+$14,Y	 ; Set lower Sprite Y
;
;PRG004_B668:
;
;	; Copy attributes
;	LDA Sprite_RAM+$02,Y
;	STA Sprite_RAM+$12,Y
;	STA Sprite_RAM+$16,Y
;
;	LDA Objects_Orientation,X
;	BPL PRG004_B68A	 ; If not vertically flipped, jump to PRG004_B68A
;
;	; Otherwise, swap Sprite Ys
;	LDA Sprite_RAM+$10,Y
;	PHA
;	LDA Sprite_RAM+$14,Y
;	SUB #$08
;	STA Sprite_RAM+$10,Y
;	PLA
;	SUB #$08
;	STA Sprite_RAM+$14,Y
;
;PRG004_B68A:
;	LDA Objects_ID,X
;	CMP #OBJ_HELPER
;	BNE PRG004_B694	 ; If this is not a Giant Goomba, jump to PRG004_B694
;
;	JMP PRG004_B719	 ; Jump to PRG004_B719
;
;PRG004_B694:
;
;	; The only other Giant Enemy that uses this routine at this point are the Giant Troopas,
;	; so from here on out it's Giant Troopa code. 
;
;	LDA Objects_State,X
;	CMP #OBJSTATE_NORMAL
;	BEQ PRG004_B69E	 ; If Giant Troopa's state is Normal, jump to PRG004_B69E
;
;	JMP PRG004_B73E	 ; Jump to PRG004_B73E
;
;PRG004_B69E:
;	LDY #$00	 ; Y = 0
;
;	LDA Objects_Orientation,X
;	AND #SPR_HFLIP
;	BEQ PRG004_B6A9	 ; If Giant Troopa is not horizontally flipped, jump to PRG004_B6A9
;
;	LDY #$04	 ; Y = 4
;
;PRG004_B6A9:
;	STY <Temp_Var4	 ; Temp_Var4 = 0 or 4 (which sprite to use)
;
;	TYA
;	ADD Object_SpriteRAMOffset,X	; Set base offset
;
;	TAY
;	LDA Sprite_RAM+$00,Y
;
;	CMP #$f8
;	BEQ PRG004_B6BE	 ; If sprite vertically not visible, jump to PRG004_B6BE
;
;	SUB #$08
;	STA Sprite_RAM+$00,Y
;
;PRG004_B6BE:
;	LDA Sprite_RAM+$08,Y
;
;	CMP #$f8
;	BEQ PRG004_B6CB	 ; If sprite vertically not visible, jump to PRG004_B6CB
;
;	SUB #$08
;	STA Sprite_RAM+$08,Y
;
;PRG004_B6CB:
;
;	; Palette select 3
;	LDA Sprite_RAM+$02,Y
;	ORA #SPR_PAL3
;	STA Sprite_RAM+$02,Y
;	STA Sprite_RAM+$0A,Y
;
;	LDA <Temp_Var4	 
;	EOR #$04	 ; Use "other" sprite
;	ADD Object_SpriteRAMOffset,X	 ; Add base offset
;	TAY		 ; -> 'Y'
;
;	; Palette select 3
;	LDA Sprite_RAM+$0A,Y
;	ORA #SPR_PAL3
;	STA Sprite_RAM+$0A,Y
;
;	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset
;
;	; Top of rear part of shell pattern
;	LDA #$91
;	STA Sprite_RAM+$11,Y
;
;	LDA Objects_Frame,X
;	LSR A
;
;	LDA #$9f	 ; Foot pattern for odd frames
;
;	BCS PRG004_B6F9	 ; If odd frame, jump to PRG004_B6F9
;
;	LDA #$97	 ; Foot pattern for even frames
;
;PRG004_B6F9:
;	STA Sprite_RAM+$15,Y	 ; Store proper foot pattern
;
;	LDA Objects_ID,X
;	CMP #OBJ_BIGGREENHOPPER
;	BLT PRG004_B710	 ; If this is not a Giant Paratroopa, jump to PRG004_B710
;
;	LDA Objects_Frame,X
;	LSR A
;
;	LDA #$b9	 ; Wing up pattern
;
;	BCC PRG004_B70D	 ; If even frame, jump to PRG004_B70D
;
;	LDA #$bb	 ; Wing down pattern
;
;PRG004_B70D:
;	STA Sprite_RAM+$11,Y	 ; Set proper wing pattern
;
;PRG004_B710:
;
;	; Palette select 3
;	LDA Sprite_RAM+$16,Y
;	ORA #SPR_PAL3
;	STA Sprite_RAM+$16,Y
;
;	RTS		 ; Return
;
;PRG004_B719:
;
;	; Giant Goomba only...
;
;	LDA Objects_State,X
;	CMP #OBJSTATE_SQUASHED
;	BEQ PRG004_B72B	 ; If Giant Goomba is in state Squashed (Giant Goomba Only), jump to PRG004_B72B
;
;	; Otherwise, use standard Goomba patterns
;
;	LDA #$85
;	STA Sprite_RAM+$11,Y
;	LDA #$8b
;	STA Sprite_RAM+$15,Y
;
;	RTS		 ; Return
;
;PRG004_B72B:
;
;	; Giant Goomba is squashed
;
;	; Squashed goomba patterns
;	LDA #$71
;	STA Sprite_RAM+$11,Y
;	LDA #$bd
;	STA Sprite_RAM+$15,Y
;
;	; Mirror sprite
;	LDA Sprite_RAM+$16,Y
;	EOR #SPR_HFLIP
;	STA Sprite_RAM+$16,Y
;
;	RTS		 ; Return
;
;PRG004_B73E:
;
;	; Giant Troopa is non-normal state...
;
;	; Shell patterns
;	LDA #$b1
;	STA Sprite_RAM+$11,Y
;	LDA #$b5
;	STA Sprite_RAM+$15,Y
;
;	; Mirror the shell
;	LDA Sprite_RAM+$12,Y
;	EOR #SPR_HFLIP
;	STA Sprite_RAM+$12,Y
;	STA Sprite_RAM+$16,Y
;
;	RTS		 ; Return

ObjInit_GiantDRYPIRANHA:
	LDA #4		; A = 4
	BNE PRG004_B75A	; Jump (technically always) to PRG004_B75A

ObjInit_GiantRedPiranha:
	LDA #12	 	; A = 12

PRG004_B75A:
	ADD <Objects_XZ,X
	STA <Objects_XZ,X	; Set centering X

	LDY #$21	 ; Y = $21

	; Var5 = original Y
	LDA <Objects_YZ,X
	STA <Objects_Data2,X
	
	; Objects_TargetingYVal = $21
	TYA
	STA Objects_TargetingYVal,X

	; Var7 = original Y Hi
	LDA <Objects_YHiZ,X
	STA Objects_Data3,X

	; Set priority
	LDA #SPR_BEHINDBG
	STA Objects_Orientation,X
	RTS		 ; Return

GiantPiranha_TimerReloads:
	.byte $30, $30, $30, $30

ObjNorm_BigPiranha:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA <Objects_Data1,X
	AND #$03
	BNE PRG004_B78C	 ; If (Var4 & 3) <> 0 (internal state 0 means Piranha is fully retracted), jump to PRG004_B78C

	; Set all sprites as horizontally off-screen (piranha is fully retracted in pipe)
	LDA #$ff
	STA Objects_SpritesHorizontallyOffScreen,X

	JMP PRG004_B79D	 ; Jump to PRG004_B79D

PRG004_B78C:

	; Toggle frame 0/1
	LDA GameCounter
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR GiantPiranha_Draw	 ; Draw the giant piranha
	JSR Object_AttackOrDefeat	 ; Player to piranha collision

PRG004_B79D:
	LDA <Player_HaltGameZ
	BNE PRG004_B7FD	 ; If gameplay is halted, jump to PRG004_B7FD (RTS)

	INC Objects_Data3,X	 ; Var3++

	LDA <Objects_Data1,X
	AND #$03	; Keep internal state counter 0-3

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GiantPiranha_HideInPipe	; 0: Retracted in pipe
	.word GiantPiranha_Emerge	; 1: Emerging
	.word GiantPiranha_Chomp	; 2: Chomp
	.word GiantPiranha_Retract	; 3: Retract

GiantPiranha_Emerge:

	; Objects_TargetingYVal = $21
	; Var5 = original Y 
	; Var7 = original Y Hi

	LDA <Objects_Data2,X		; Original Y
	SUB Objects_TargetingYVal,X	; subtract TargetingYVal
	PHA				; Save it

	LDA Objects_Data3,X
	SBC #$00
	STA <Temp_Var1			; Temp_Var1 = Original Y Hi, carry applied

	PLA		 ; Restore the Original Y difference
	CMP <Objects_YZ,X
	LDA <Temp_Var1
	SBC <Objects_YHiZ,X
	BCS PRG004_B7F0	 ; Basically if Giant Piranha is at his Y and Y Hi highest point, jump to PRG004_B7F0

	LDA #-$10	 ; A = -$10
	BNE PRG004_B7E6	 ; Jump (technically always) to PRG004_B7E6

GiantPiranha_Retract:
	LDA <Objects_YZ,X
	ADD #$01
	PHA		 ; Save Y + 1

	LDA <Objects_YHiZ,X
	ADC #$00
	STA <Temp_Var1	 ; Temp_Var1 = carry applied to Y Hi

	PLA		 ; Restore Y + 1

	CMP <Objects_Data2,X
	LDA <Temp_Var1	
	SBC Objects_Data3,X
	BCS PRG004_B7F0	 ; Basically if Giant Piranha is at his Y and Y Hi origin, jump to PRG004_B7F0

	LDA #$10	 ; A = $10

PRG004_B7E6:

	; Giant Piranha is not fully extended/retracted...

	STA <Objects_YVelZ,X	 ; Set Y velocity as appropriate
	JMP Object_ApplyYVel_NoGravity	 ; Apply Y velocity and don't come back!!

GiantPiranha_Chomp:
	LDA Objects_Timer,X
	BNE PRG004_B80F	 ; If timer not expired, jump to PRG004_B80F

PRG004_B7F0:
	INC <Objects_Data1,X	 ; Var4++ (next internal state)

	LDA <Objects_Data1,X
	AND #$03
	TAY		 ; Y = 0 to 3, based on internal state

	LDA GiantPiranha_TimerReloads,Y	 ; Get timer reload value for this state
	STA Objects_Timer,X	 ; Reload timer

PRG004_B7FD:
	RTS		 ; Return

GiantPiranha_HideInPipe:
	LDA Objects_Timer,X
	BNE PRG004_B80F	 ; If timer not expired, jump to PRG004_B80F

	JSR Object_XDistanceFromPlayer

	LDA <Temp_Var16
	ADD #$18
	CMP #$31
	BGE PRG004_B7F0	 ; If Player is not too close, jump to PRG004_B7F0

PRG004_B80F:
	RTS		 ; Return

GiantPiranha_Draw:

GroundTroop_DrawNormal:
	LDY #$00	; Y = 0 (Sprite Y offset)

GroundTroop_DrawOffsetInY:
	LDA #$00	; A = 0 (draw non-mirrored sprite)

PRG004_B938:
	STA <Temp_Var9		 ; Temp_Var9 = $00 (non-mirrored sprite) or SPR_VFLIP (mirrored sprite), depending on entry
	STY <Temp_Var1		 ; Temp_Var1 = Sprite Y offset

	JSR Object_CalcSpriteXY_NoHi

	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite_RAM offset

	LDA Objects_SpritesVerticallyOffScreen,X
	LSR A
	BCC SkipPRG004_B9BA	 	; If this sprite is vertically off-screen, jump to PRG004_B9BA (RTS)
	RTS

SkipPRG004_B9BA
	; Temp_Var3 = horizontal visibility bits
	LDA Objects_SpritesHorizontallyOffScreen,X
	STA <Temp_Var3

	LDA <Objects_SpriteY,X
	SUB <Temp_Var1

	ASL <Temp_Var3
	BCS PRG004_B959	 ; If this sprite is horizontally off-screen, jump to PRG004_B959

	STA Sprite_RAM+$00,Y	 ; Otherwise, set Sprite Y

PRG004_B959:
	ASL <Temp_Var3
	BCS PRG004_B960	 ; If this sprite is horizontally off-screen, jump to PRG004_B960

	STA Sprite_RAM+$04,Y	 ; Otherwise, set Sprite Y


	; The following block appears to be unused
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG004_B960:
	SEC		; Set carry??

	LDA Objects_Timer4,X
	BEQ PRG004_B96D	 ; If timer 4 is expired, jump to PRG004_B96D

	CMP #$40
	BLT PRG004_B96C	 ; If timer 4 < $40, jump to PRG004_B96C

	; Timer 4 >= $40...

	LSR A
	LSR A		 ; Divide timer4 by 4

PRG004_B96C:
	LSR A		 ; Divide timer4 by 2

PRG004_B96D:
	; No one cares about the accumulator value or the carry flag...
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Set left sprite X
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Temp_Var1 = current flip bits
	LDA Objects_Orientation,X
	STA <Temp_Var1
	ORA Objects_SpriteAttributes,X	 ; OR in the sprite attributes
	STA DAIZ_TEMP1
	LDA DAIZ_TEMP1

	ASL <Temp_Var9
	BCC PRG004_B986	 ; If Temp_Var9 was assigned to $00 at start, we jump to PRG004_B986

	AND #~SPR_HFLIP	 ; Clear horizontal flip if Temp_Var9 was $80 at start

PRG004_B986:
	STA Sprite_RAM+$02,Y	 ; Set left sprite attribute

	BCC PRG004_B98D	 ; If Temp_Var9 was assigned to $00 at start, we jump to PRG004_B98D

	ORA #SPR_HFLIP	 ; Set horizontal flip if Temp_Var9 was $80 at start

PRG004_B98D:
	STA Sprite_RAM+$06,Y	 ; Set right sprite attribute

	LDA Objects_Frame,X
	LDX ObjGroupRel_Idx	 ; X = object group relative index

	ASL A		 ; Multiply frame by 2

	ADD ObjectGroup03_PatternStarts,X	; Add in the base pattern set index

	TAX		 ; Frame * 2 + Pattern Start -> 'X'

	LDA ObjectGroup03_PatternSets,X	 ; Get the appropriate pattern for this frame

	BIT <Temp_Var1
	BVS PRG004_B9AF	 ; If horizontally flipped, jump to PRG004_B9AF

	; Store left sprite pattern
	STA Sprite_RAM+$01,Y

	LDA ObjectGroup03_PatternSets+1,X ; Get the next pattern

	; Store right sprite pattern
	STA Sprite_RAM+$05,Y

	JMP PRG004_B9B8	 ; Jump to PRG004_B9B8

PRG004_B9AF:
	; Store right sprite pattern
	STA Sprite_RAM+$05,Y

	LDA ObjectGroup03_PatternSets+1,X ; Get the next pattern

	; Store left sprite pattern
	STA Sprite_RAM+$01,Y

PRG004_B9B8:
	LDX <CurrentObjectIndexZ	 ; X = object slot index

PRG004_B9BA:
	RTS		 ; Return

Chomp_Frame = Objects_Data1
Chomp_Charges = Objects_Data2
Chomp_PinX = Objects_Data3
Chomp_PinY = Objects_Data4
Chomp_Charging = Objects_Data5
Chomp_CanCharge = Objects_Data6
Chomp_XChainMax = Objects_Data7
Chomp_YChainMax = Objects_Data8

ObjInit_ChainChomp:

	; Fill in all of the following with the Chain Chomp's Pining X coordinate
	LDA <Objects_XZ,X
	ADD #$08
	STA Chomp_PinX,X
	SUB #$04
	STA ChainChomp_ChainX1, X
	STA ChainChomp_ChainX2, X
	STA ChainChomp_ChainX3, X
	STA ChainChomp_ChainX4, X

	LDA <Objects_YZ,X
	ADD #$08
	STA Chomp_PinY,X
	SUB #$08
	STA ChainChomp_ChainY1, X
	STA ChainChomp_ChainY2, X
	STA ChainChomp_ChainY3, X
	STA ChainChomp_ChainY4, X

	LDA <Objects_YZ,X
	SUB #$10
	STA <Objects_YZ,X

	LDA <Objects_YHiZ,X
	SBC #$00
	STA <Objects_YHiZ,X

	JSR Object_MoveTowardsPlayerFast

	LDA #$04
	STA Chomp_Charges, X

	RTS		 ; Return


Chomp_ChargeTimers:
	.byte $40, $60, $50, $70, $50, $40, $60, $60

Chomp_ChargeXVel:
	.byte $40, $38, $30, $28, $20, $40, $38, $30

Chomp_ChargeYVel:
	.byte $FF, $F0, $E0, $D0, $C0, $00, $F0, $E0

Chomp_Restrain:
	
	LDA Chomp_XChainMax, X
	BEQ RestrainY

	JSR MaxOutChainsX
	LDA Chomp_Charging, X
	BNE RestrainXCharging

	LDY #$00
	LDA <Objects_XZ, X
	SUB Chomp_PinX, X
	BMI Chomp_Restrain1

	INY

Chomp_Restrain1:
	LDA <Objects_XVelZ, X
	BEQ Chomp_RestrainXRTS

	AND #$80
	CMP MaxChainVelCmp, Y
	BNE Chomp_RestrainXRTS

	LDA <Objects_XVelZ, X
	EOR #$FF
	ADD #$01
	STA <Objects_XVelZ, X

Chomp_RestrainXRTS:
	RTS

RestrainXCharging:
	LDA #$00
	STA <Objects_XVelZ, X
	STA <Objects_YVelZ, X

RestrainY:
	LDA Chomp_YChainMax, X
	BEQ RestraintRTS

	JSR MaxOutChainsY

	LDA <Objects_YVelZ, X
	BPL RestraintRTS

	LDA #$00
	STA <Objects_YVelZ, X
	STA <Objects_XVelZ, X

RestraintRTS:
	RTS

MaxChainVelCmp:
	.byte $80, $00

MaxOutChainsX:
	LDY #$00
	LDA <Objects_XZ, X
	SUB Chomp_PinX, X
	BMI MaxOutChainsX1

	INY

MaxOutChainsX1:
	LDA ChainChomp_ChainX4, X
	ADD ChainOffset, Y

	STA ChainChomp_ChainX3, X
	ADD ChainOffset, Y

	STA ChainChomp_ChainX2, X
	ADD ChainOffset, Y

	STA ChainChomp_ChainX1, X
	JSR EvenOutYChains

MaxOutChainsX2:
	RTS

MaxOutChainsY:
	LDA ChainChomp_ChainY4, X
	ADD ChainOffset
	STA ChainChomp_ChainY3, X
	ADD ChainOffset
	STA ChainChomp_ChainY2, X
	ADD ChainOffset
	STA ChainChomp_ChainY1, X
	JSR EvenOutXChains
	RTS

EvenOutYChains:
	LDA <Objects_YZ, X
	ADD #$08
	STA <Temp_Var2

	LDA ChainChomp_ChainY4, X
	SUB <Temp_Var2
	JSR Half_Value
	JSR Half_Value
	
	STA <Temp_Var3

	LDA <Temp_Var2

	ADD <Temp_Var3
	STA ChainChomp_ChainY1, X

	ADD <Temp_Var3
	STA ChainChomp_ChainY2, X

	ADD <Temp_Var3
	STA ChainChomp_ChainY3, X
	RTS

EvenOutXChains:
	LDA <Objects_XZ, X
	ADD #$08
	STA <Temp_Var2

	LDA ChainChomp_ChainX4, X
	SUB <Temp_Var2
	JSR Half_Value
	JSR Half_Value
	
	STA <Temp_Var3

	LDA <Temp_Var2

	ADD <Temp_Var3
	STA ChainChomp_ChainX1, X

	ADD <Temp_Var3
	STA ChainChomp_ChainX2, X

	ADD <Temp_Var3
	STA ChainChomp_ChainX3, X
	RTS

ObjNorm_ChainChomp:

	LDA <Player_HaltGameZ
	BEQ ChompNorm

	LDA Chomp_Charging, X
	CMP #$02
	BCS NoChainDraw

	JSR Chomp_DrawChains

NoChainDraw:
	JMP Object_Draw

ChompNorm:
	LDA #$60
	JSR Object_DeleteOffScreenRange

	LDA Chomp_Charging, X
	JSR DynJump

	.word Chomp_BounceAround
	.word Chomp_ChargeAtPlayer
	.word Chomp_Free

ChargeSignCheck:
	.byte $00, $80

Chomp_BounceAround:
	JSR Object_Move
	JSR Chomp_MoveChains
	JSR Chomp_Restrain
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat	 
	JSR Object_FaceDirectionMoving
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

	LDA Chomp_CanCharge, X
	BEQ Chomp_NoCharge

	JSR Object_XDistanceFromPlayer
	CMP #$20
	BCC Chomp_NoCharge

	LDA <Objects_XZ, X
	SUB Chomp_PinX, X
	AND #$80
	CMP ChargeSignCheck, Y
	BNE Chomp_NoCharge

	JSR Chomp_Charge
	LDA #$00
	STA Chomp_CanCharge, X
	JMP ChompAnimate

Chomp_NoCharge:
	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ ChompAnimate

	LDA #$01
	STA Chomp_CanCharge, X

	LDA #$E8
	STA <Objects_YVelZ, X

	LDA #$10
	JSR Object_DetectTileAhead
	CMP #TILE_PROP_SOLID_ALL
	BCC NoBounceHigher

	LDA #$D0
	STA <Objects_YVelZ, X

NoBounceHigher:
	LDA <Objects_XVelZ, X
	BNE ChompAnimate

	JSR Object_MoveAwayFromPlayerFast

ChompAnimate:
	INC <Chomp_Frame, x
	LDA <Chomp_Frame, x
	LSR A
	LSR A

	LDY Chomp_Charging, X
	BNE Chomp_NotFastAnim

	LSR A

Chomp_NotFastAnim:
	AND #$01
	STA Objects_Frame, X
	JSR Chomp_DrawChains
	JMP Object_Draw

Chomp_ChargeAtPlayer:
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoGravity
	JSR Chomp_MoveChains
	JSR Chomp_Restrain
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat	 
	JSR Object_FaceDirectionMoving
	
	LDA Objects_Timer, X
	BNE Chomp_ChargeAtPlayer1

	DEC Chomp_Charges, X
	BEQ Chomp_GetFree

	LDA #$00
	STA Chomp_Charging, X
	STA <Objects_XVelZ, X
	
Chomp_ChargeAtPlayer1:
	JMP ChompAnimate

Chomp_GetFree:
	JSR Object_MoveTowardsPlayerFast

	LDA Chomp_PinX, X
	SUB <Objects_XZ, X

	JSR Half_Value
	ADD <Objects_XZ, X
	STA <Debris_X

	LDA Chomp_PinY,  X
	SUB <Objects_YZ, X

	JSR Half_Value

	ADD <Objects_YZ,X
	STA <Debris_Y
	JSR Common_MakeChains
	LDA #$02
	STA Chomp_Charging, X

	JMP ChompAnimate

Chomp_ChargeSign:
	.byte $80, $00

Chomp_Aim:
	LDA RandomN
	AND #$07
	TAY
	LDA Chomp_ChargeXVel, Y
	STA <Objects_XVelZ, X

	LDA Chomp_ChargeYVel, Y
	STA <Objects_YVelZ, X

	JSR Object_XDistanceFromPlayer
	CPY #$00
	BNE Chomp_Aim1

	LDA <Objects_XVelZ, X
	EOR #$FF
	ADD #$01
	STA <Objects_XVelZ, X

Chomp_Aim1:
	RTS
	
Chomp_Charge:
	JSR Chomp_Aim
	
	LDA #$20
	STA Objects_Timer, X
	INC Chomp_Charging, X
	RTS

ChainOffset:
	.byte $F3, $0D

Chomp_MoveChains:
	LDA #$00
	STA Chomp_XChainMax, X
	STA Chomp_YChainMax, X

	LDA ChainChomp_ChainY4, X
	SUB <Vert_Scroll
	STA <Temp_Var1

	LDA ChainChomp_ChainY1, X
	SUB <Vert_Scroll
	SUB <Temp_Var1
	BPL Chain1OK
	
	INC ChainChomp_ChainY1, X
	INC ChainChomp_ChainY1, X

Chain1OK:
	LDA ChainChomp_ChainY2, X
	SUB <Vert_Scroll
	SUB <Temp_Var1
	BPL Chain2OK

	INC ChainChomp_ChainY2, X
	INC ChainChomp_ChainY2, X

Chain2OK:
	LDA ChainChomp_ChainY3, X
	SUB <Vert_Scroll
	SUB <Temp_Var1
	BPL Chain3OK


	INC ChainChomp_ChainY3, X
	INC ChainChomp_ChainY3, X

Chain3OK:	
	LDA <Objects_XZ, X
	ADD #$08
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainX1, X
	ADD #$04
	SUB <Temp_Var1
	BPL CMVC1

	INY

CMVC1:
	CMP ChainOffset + 1
	BCC SetChain_YJumpCC

	CMP ChainOffset
	BCS SetChain_YJumpCS

	ADD ChainOffset, Y
	EOR #$FF
	ADD #$01
	ADD ChainChomp_ChainX1, X
	STA ChainChomp_ChainX1, X
	ADD #$04
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainX2, X
	ADD #$04
	SUB <Temp_Var1
	BPL CMVC2

	INY

CMVC2:
	CMP ChainOffset + 1

SetChain_YJumpCC:
	BCC SetChain_Y

	CMP ChainOffset

SetChain_YJumpCS:
	BCS SetChain_Y
	
	ADD ChainOffset, Y
	EOR #$FF
	ADD #$01
	ADD ChainChomp_ChainX2, X
	STA ChainChomp_ChainX2, X
	ADD #$04
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainX3, X
	ADD #$04
	SUB <Temp_Var1
	BPL CMVC3

	INY

CMVC3:
	CMP ChainOffset + 1
	BCC SetChain_Y

	CMP ChainOffset
	BCS SetChain_Y
	
	ADD ChainOffset, Y
	EOR #$FF
	ADD #$01
	ADD ChainChomp_ChainX3, X
	STA ChainChomp_ChainX3, X
	ADD #$04
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainX4, X
	ADD #$04
	SUB <Temp_Var1
	BPL CMVCMaxX

	INY

CMVCMaxX:
	CMP ChainOffset + 1
	BCC SetChain_Y

	CMP ChainOffset
	BCS SetChain_Y

	ADD ChainOffset, Y

	BEQ SetChain_Y

	INC Chomp_XChainMax, X

SetChain_Y:
	LDA <Objects_YZ, X
	ADD #$08
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainY1, X
	ADD #$08
	SUB <Temp_Var1
	BPL CMVC4

	INY

CMVC4:
	CMP ChainOffset + 1
	BCC Chomp_MoveChains1CC

	CMP ChainOffset
	BCS Chomp_MoveChains1CS

	ADD ChainOffset, Y
	EOR #$FF
	ADD #$01
	ADD ChainChomp_ChainY1, X
	STA ChainChomp_ChainY1, X
	ADD #$08
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainY2, X
	ADD #$08
	SUB <Temp_Var1
	BPL CMVC5

	INY

CMVC5:

	CMP ChainOffset + 1
Chomp_MoveChains1CC:
	BCC Chomp_MoveChains1

	CMP ChainOffset
Chomp_MoveChains1CS:
	BCS Chomp_MoveChains1
	
	ADD ChainOffset, Y
	EOR #$FF
	ADD #$01
	ADD ChainChomp_ChainY2, X
	STA ChainChomp_ChainY2, X
	ADD #$08
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainY3, X
	ADD #$08
	SUB <Temp_Var1
	BPL CMVC6

	INY

CMVC6:
	CMP ChainOffset + 1
	BCC Chomp_MoveChains1

	CMP ChainOffset
	BCS Chomp_MoveChains1
	
	ADD ChainOffset, Y
	EOR #$FF
	ADD #$01
	ADD ChainChomp_ChainY3, X
	STA ChainChomp_ChainY3, X

	ADD #$08
	STA <Temp_Var1

	LDY #$00
	LDA ChainChomp_ChainY4, X
	ADD #$08
	SUB <Temp_Var1
	BPL CMVCMaxY

	INY

CMVCMaxY:
	CMP ChainOffset + 1
	BCC Chomp_MoveChains1

	CMP ChainOffset
	BCS Chomp_MoveChains1
	
	ADD ChainOffset, Y
	BEQ Chomp_MoveChains1

	INC Chomp_YChainMax, X

Chomp_MoveChains1:
	RTS

Chomp_DrawChains:
	LDY Object_SpriteRAMOffset, X
	STY <Temp_Var4

	LDA ChainChomp_ChainX1, X
	SUB <Horz_Scroll
	STA <Temp_Var2
	

	LDA ChainChomp_ChainY1, X
	SUB <Vert_Scroll
	STA <Temp_Var1

	JSR Object_ParticleVisibleTest
	BCS CDC1

	LDY <Temp_Var4
	LDA <Temp_Var2
	STA Sprite_RAMX + 8, Y
	LDA <Temp_Var1
	STA Sprite_RAMY + 8, Y

CDC1:
	LDA ChainChomp_ChainX2, X
	SUB <Horz_Scroll
	STA <Temp_Var2

	LDA ChainChomp_ChainY2, X
	SUB <Vert_Scroll
	STA <Temp_Var1

	JSR Object_ParticleVisibleTest
	BCS CDC2

	LDY <Temp_Var4
	LDA <Temp_Var2
	STA Sprite_RAMX + 12, Y
	LDA <Temp_Var1
	STA Sprite_RAMY + 12, Y

CDC2:
	LDA ChainChomp_ChainX3, X
	SUB <Horz_Scroll
	STA <Temp_Var2

	LDA ChainChomp_ChainY3, X
	SUB <Vert_Scroll
	STA <Temp_Var1

	JSR Object_ParticleVisibleTest
	BCS CDC3
	
	LDY <Temp_Var4
	LDA <Temp_Var2
	STA Sprite_RAMX + 16, Y
	LDA <Temp_Var1
	STA Sprite_RAMY + 16, Y
	
CDC3:
	LDA ChainChomp_ChainX4, X
	SUB <Horz_Scroll
	STA <Temp_Var2

	LDA ChainChomp_ChainY4, X
	SUB <Vert_Scroll
	STA <Temp_Var1

	JSR Object_ParticleVisibleTest
	BCS CDC4

	LDY <Temp_Var4
	LDA <Temp_Var2
	STA Sprite_RAMX + 20, Y
	LDA <Temp_Var1
	STA Sprite_RAMY + 20, Y

CDC4:
	LDY <Temp_Var4
	LDA #$BD
	STA Sprite_RAMTile + 8, Y
	STA Sprite_RAMTile + 12, Y
	STA Sprite_RAMTile + 16, Y
	STA Sprite_RAMTile + 20, Y

	LDA #SPR_PAL1
	STA Sprite_RAMAttr + 8, Y
	STA Sprite_RAMAttr + 12, Y
	STA Sprite_RAMAttr + 16, Y
	STA Sprite_RAMAttr + 20, Y
	RTS

Chomp_Free:
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat	 
	JSR Object_FaceDirectionMoving
	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

	

	LDA <Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ FreeNoBounce

	JSR Object_MoveTowardsPlayerFast

	LDA #$E8
	STA <Objects_YVelZ, X

	LDA #$10
	JSR Object_DetectTileAhead
	CMP #TILE_PROP_SOLID_ALL
	BCC FreeNoBounce

	LDA #$D0
	STA <Objects_YVelZ, X

FreeNoBounce:
	INC <Chomp_Frame, x
	LDA <Chomp_Frame, x
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X
	JMP Object_Draw

LakituMessage1:
	.byte "THANK YOU FOR FREEING ME. "

LakituMessage2:
	.byte "I WILL HELP YOU IN RETURN."

ObjInit_DeliveryLakitu:
	LDA #$9D
	STA Objects_Data8, X
	RTS

ObjNorm_DeliveryLakitu:
	LDA Objects_Data4, X
	JSR DynJump

	.word WaitForMario
	.word DisplayLakituText
	.word DeliveryLakituFlyAway
	.word DeliveryLakituTrack
	.word DeliveryLakituWait

WaitForMario:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	ORA #$02
	STA Objects_Frame, X
	JSR Object_DrawMirrored
	JSR Object_HitTest
	BCC WaitForMarioRTS
	JSR SpecialObject_FindEmptyAbort
	INC Objects_Data4, X
	LDA <Objects_XZ, X
	STA SpecialObj_X, Y
	LDA <Objects_YZ, X
	STA SpecialObj_Y, Y
	LDA <Objects_YHiZ,X
	STA SpecialObj_YHi,Y
	LDA #SOBJ_POOF
	STA SpecialObj_ID, Y
	LDA #$20	 
	STA SpecialObj_Data1, Y
	STA Objects_Timer, X
	LDA #$00
	STA Objects_Frame, X

	LDA #$40
	STA Objects_SlowTimer, X

	LDA #$80
	STA StatusBar_Mode

	LDX #$8C
	STX Status_Bar_Top
	INX
	STX Status_Bar_Top + 1
	LDX #$9C
	STX Status_Bar_Bottom
	INX
	STX Status_Bar_Bottom + 1
	LDX #$00

NextLakituLetter:
	LDA LakituMessage1, X
	STA Status_Bar_Top + 2, X
	LDA LakituMessage2, X
	STA Status_Bar_Bottom + 2, X
	INX
	CPX #26
	BNE NextLakituLetter

WaitForMarioRTS:
	RTS

DisplayLakituText:
	LDA Objects_SlowTimer, X
	BNE DisplayLakituText1

	LDA Last_StatusBar_Mode
	STA StatusBar_Mode
	LDA #$80
	STA Last_StatusBar_Mode
	INC Objects_Data4, X
	LDY Objects_Property, X
	LDA Effective_Suit
	CMP PowerUpChecks, Y
	BEQ DisplayLakituText1
	LDA #$03
	STA Objects_Data4, X

DisplayLakituText1:
	;JSR DrawLakitu
	LDA #$01
	STA Player_HaltTick
	RTS

DeliveryLakituFlyAway:
	LDA Objects_YHiZ, X
	BPL DeliveryLakituFlyAway1

	LDA #$04
	STA Objects_Data4, X
	LDA #$00
	STA <Objects_YVelZ, X
	RTS
	
DeliveryLakituFlyAway1:
	INC Reverse_Gravity
	JSR Object_Move
	;JSR DrawLakitu
	RTS

PowerUpChecks:
	.byte $02, $0B, $05, $04

PowerUpDeliveries:
	.byte OBJ_POWERUP_FIREFLOWER, OBJ_POWERUP, OBJ_POWERUP_STARMAN, OBJ_POWERUP_STARMAN

PowerUpDeliveriesFlash:
	.byte 00, 00, 02, 01

DeliveryLakituWait:
	LDY Objects_Property, X
	LDA Effective_Suit
	CMP PowerUpChecks, Y
	BEQ DeliveryLakituWait1
	LDA #$03
	STA Objects_Data4, X
	LDA <Player_X
	STA <Objects_XZ, X
	LDA <Player_XHi
	ADD #$01
	STA <Objects_XHiZ, X
	LDA <Player_Y
	STA <Objects_YZ, X
	LDA <Player_YHi
	STA <Objects_YHiZ, X

DeliveryLakituWait1:
	RTS

DeliveryLakituTrack:
	LDY Objects_Property, X
	LDA <Player_HaltGameZ
	BNE DeliveryLakituTrack1
	LDA Effective_Suit
	CMP PowerUpChecks, Y
	BEQ DeliveryLakituEscape

	LDA Objects_State + 5
	BNE DeliveryLakituEscape

	JSR Object_ChasePlayer
	JSR Object_HitTest
	BCC DeliveryLakituTrack1
	
	LDA Objects_State + 5
	BNE DeliveryLakituTrack1

	LDA #$01
	STA PowerUp_Reserve
	
	LDA #OBJSTATE_INIT
	STA Objects_State + 5
	
	LDY Objects_Property, X
	LDA PowerUpDeliveries, Y
	STA Objects_ID + 5
	STA PowerUp_NoRaise

	LDA PowerUpDeliveriesFlash, Y
	STA PUp_StarManFlash

	LDA <Objects_XZ, X
	STA <Objects_XZ + 5
	LDA <Objects_XHiZ, X
	STA <Objects_XHiZ + 5
	LDA <Objects_YZ, X
	SUB #$10
	STA <Objects_YZ + 5
	LDA <Objects_YHiZ, X
	SBC #$00
	STA <Objects_YHiZ + 5
	
DeliveryLakituEscape:
	LDA #$02
	STA Objects_Data4, X

DeliveryLakituTrack1:
	;JSR DrawLakitu
	RTS

BlueShellExplosionTimers:
	.byte $40, $80, $C0, $FF

ObjInit_BlueShell:
	LDA Objects_Property, X
	TAY
	LDA BlueShellExplosionTimers, Y
	STA Objects_SlowTimer, X
	RTS

ObjNorm_BlueShell:
	LDA <Player_HaltGameZ
	BNE DrawBlueShell

	JSR Object_HandleBumpUnderneath
	JSR Object_InteractWithPlayer
	INC Objects_Data4, X

	LDA Objects_SlowTimer, X
	BEQ ObjNorm_BlueShell0

ObjNorm_BlueShell_1:
	LDA Level_VertScroll
	ADD #$10
	STA ChaseTargetY
	LDA #$00
	ADC #$00
	STA ChaseTargetYHi
	JSR Object_ChasePlayer
	JSR Object_ApplyXVel
	JMP DrawBlueShell

ObjNorm_BlueShell0:
	LDA Objects_Data5, X
	BNE ObjNorm_BlueShellDive1

	JSR Object_XDistanceFromPlayer
	CMP #$01
	BNE ObjNorm_BlueShell_1

	CPY #$00
	BNE ObjNorm_BlueShell01

	LDY <Player_XVel
	BPL ObjNorm_BlueShell_1
	BMI ObjNorm_BlueShellDive

ObjNorm_BlueShell01:
	LDY <Player_XVel
	BMI ObjNorm_BlueShell_1 

ObjNorm_BlueShellDive:
	INC Objects_Data5, X

ObjNorm_BlueShellDive1:

	LDA Objects_YVelZ, X
	AND #$F0
	CMP #$70
	BEQ ObjNorm_BlueShell1
	LDA Objects_YVelZ, X
	ADD #$04
	STA Objects_YVelZ, X
	

ObjNorm_BlueShell1:
	LDA #$01
	STA Objects_Frame, X
	JSR Object_ApplyYVel_NoGravity
	JSR Object_DetectTiles
	LDA  <Objects_TilesDetectZ, X
	BEQ DrawBlueShell
	BNE BlueShell_Expload

DrawBlueShell:
	LDA Objects_Frame, X
	CMP #$01
	BNE DrawBlueShell0_1
	JMP Object_Draw

DrawBlueShell0_1:
	JSR Object_DrawMirrored
	
DrawBlueShell0_2:
	LDA Objects_Data5, X
	BNE ObjNorm_BlueShellDraw2

	LDA Objects_SlowTimer, X
	CMP #$10
	BCS DrawBlueShell0

	LDA Objects_Data4, X
	AND #$02
	BEQ ObjNorm_BlueShellDraw2

DrawBlueShell0:
	LDY Object_SpriteRAMOffset, X
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ ObjNorm_BlueShellDraw1	 ; If sprite was found to be vertically off-screen, jump to PRG004_B55D

	; The wing sprite is Y-8 from the body
	SUB #$08
	STA Sprite_RAM+08,Y

	; Temp_Var1 = $CD (pattern for wing up)
	LDA #$CD
	STA <Temp_Var1

	
	LDA Objects_Data4, X
	AND #$04
	BEQ ObjNorm_BlueShellDraw0	 ; 4 ticks on, 4 ticks off; jump to PRG004_B548

	; Temp_Var1 = $CF (pattern for wing down)
	LDA #$CF
	STA <Temp_Var1 

ObjNorm_BlueShellDraw0:

	; Set correct wing pattern
	LDA <Temp_Var1
	STA Sprite_RAM+9,Y

	; Copy Sprite X
	LDA #$0C
	STA <Temp_Var1

	LDA Objects_Orientation, X
	BEQ  ObjNorm_BlueShellDraw1

	LDA #$FC
	STA <Temp_Var1

ObjNorm_BlueShellDraw1:
	LDA Sprite_RAM+03,Y
	ADD <Temp_Var1
	STA Sprite_RAM+11,Y

	LDA #SPR_PAL1
	ORA Objects_Orientation, X
	STA Sprite_RAM+10,Y	 ; Set wing attribute

ObjNorm_BlueShellDraw2:
	RTS

BlueShell_Expload:
	INC Explosion_Timer, X
	RTS
	
