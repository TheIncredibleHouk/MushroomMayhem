; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-01-29 13:49:44.499306754 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; Indexed per top 2 bits of tile ($00, $40, $80, $C0)
	; Defines the shape of a slope tile for slope levels (Hills style and underground)
	; Values used for Player_Slopes:
	;	1) A tile is retrieved in Player_GetTileAndAttr
	;	2) Pick the proper table start by tile "quadrant" ($00, $40, $80, $C0)
	;	3) The relevant value from Tile_AttrTable (a series of values-per-quad
	;	   loaded by tileset) is grabbed; the tile retrieved in #1 is used as
	;	   a base value.  Hills/Underground style attr table: $25, $5F, $99, $E2
	;	4) If the tile is beneath the base this data is not used 
	;	   (e.g. using the above Hills Object_HitWall, if we got tile $16 -- this is 
	;	   quad $00, and the quad $00 base tile is $25, so this is not valid)
	;	5) If tile is in range, it is subtracted, so using the Hills example:
	;	   Tile $25 -- first table, index 0.  Tile $26 -- first table, index 1.
	;	   Tile $5F -- second table, index 0.  Etc...

	; Objects detect using a specific offset from this list
	; Which "group" they use is specified by the respective value in ObjectGroup_Attributes2
Object_TileDetectOffsets:

	; Y/X offset pairs

	; For groups:
	; Row 1: Object Y Velocity >= 0 (on ground or moving downward)
	; Row 2: Object Y Velocity < 0 (moving upward)
	; Row 3: Object X velocity < 0 (moving leftward) 
	; Row 4: Object X velocity >= 0 (moving rightward)

	; Group 0
	;       Y    X
	.byte $10, $03	; At feet
	.byte $00, $03	; At head
	.byte $0A, $01	; Wall to left
	.byte $0A, $07	; Wall to right

	; Group 1
	; NOTE! See "ONLY HAPPENS WITH GROUP 1 ROW 1 AND SLOPES ENABLED"
	; In a sloped level using this group, alternate offsets (below
	; Group 12) are used for left/right wall detection!
	;	        Y    X
OTDO_G1R1:
	.byte $10, $08	; At feet
	.byte $00, $08	; At head
	.byte $09, $00	; Wall to left
	.byte $09, $0F	; Wall to right

	; Group 2
	;       Y    X
	.byte $20, $08	; At feet
	.byte $00, $08	; At head
	.byte $15, $00	; Wall to left
	.byte $15, $0F	; Wall to right

	; Group 3
	;       Y    X
	.byte $0F, $08	; At feet
	.byte $00, $08	; At head
	.byte $08, $00	; Wall to left
	.byte $08, $0F	; Wall to right

	; Group 4
	;       Y    X
	.byte $10, $08	; At feet
	.byte $00, $08	; At head
	.byte $08, $01	; Wall to left
	.byte $08, $0E	; Wall to right

	; Group 5
	;       Y    X
	.byte $10, $0C	; At feet
	.byte $00, $0C	; At head
	.byte $0A, $01	; Wall to left
	.byte $0A, $17	; Wall to right

	; Group 6
	;       Y    X
	.byte $20, $0C	; At feet
	.byte $00, $0C	; At head
	.byte $11, $01	; Wall to left
	.byte $11, $17	; Wall to right

	; Group 7
	;       Y    X
	.byte $10, $08	; At feet
	.byte $00, $08	; At head
	.byte $08, $08	; Wall to left
	.byte $08, $08	; Wall to right

	; Group 8
	;       Y    X
	.byte $20, $08	; At feet
	.byte $10, $08	; At head
	.byte $18, $01	; Wall to left
	.byte $18, $0E	; Wall to right

	; Group 9
	;       Y    X
	.byte $10, $18	; At feet
	.byte $00, $03	; At head
Platform_Extended_Check:
	.byte $08, $00	; Wall to left
	.byte $08, $2F	; Wall to right

	; Group 10
	;       Y    X
	.byte $10, $08	; At feet
	.byte $00, $08	; At head
	.byte $0A, $00	; Wall to left
	.byte $0A, $1F	; Wall to right

	; Group 11
	;       Y    X
SuperGiantOffsets1:
	.byte $20, $08	; At feet
	.byte $20, $18	; At head
	.byte $00, $08	; At feet
	.byte $00, $18	; At head

	; Group 12
	;       Y    X
	.byte $30, $08	; At feet
	.byte $00, $08	; At head
	.byte $23, $01	; Wall to left
	.byte $23, $0E	; Wall to right

	; Alternate offsets used when object utilizes "Group 1" in sloped levels
	; See "ONLY HAPPENS WITH GROUP 1 ROW 1 AND SLOPES ENABLED"
	;       	Y    X
OTDO_G1Alt:	.byte $02, $01	; Wall to left
		.byte $02, $0E	; Wall to right

	; Offsets used for detection of water tiles
	;       	Y    X
OTDO_Water:	.byte $04, $08

OTDO_Explosion:
	.byte $00, $00
	.byte $00, $16
	.byte $16, $00
	.byte $16, $16

	; Defines the "bounding box" 
	; Selected by Object_AttrFlags lower 4 bits
Object_BoundBox:
	;    Left Right Top  Bot- offsets applied to sprite X/Y
	.byte  2,   4,   2,   8	; 0
	.byte  1,  13,   2,   8	; 1
	.byte  2,  12,   2,  24	; 2
	.byte 10,  27,  -2,  18	; 3
	.byte  8,  24,   8,  30	; (BOSS)
	.byte  8,  18,   8,  18	; 5 (UNUSED)
	.byte  2,  27,  -2,  34	; 6
	.byte  2,  20,   2,  12	; 7
	.byte  2,  43,  -2,  18	; 8
	.byte  2,  20,   2,  28	; 9
	.byte  2,  12,   2,  20	; A
	.byte  0,  31,  -1,  14	; B
	.byte  1,  14,  -2,  13	; C
	.byte  4,  17,  10,  19	; D
	.byte  4,   8,   5,  40	; E
	.byte  2,  43,   2,  12	; F

Object_AttrFlags:
	; Defines flags which set attributes of objects
	.byte OAT_BOUNDBOX00	; Object $00
	.byte OAT_BOUNDBOX02 | OAT_FIREIMMUNITY | OAT_HITNOTKILL | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $01
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $02
	.byte OAT_BOUNDBOX04 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $03
	.byte OAT_BOUNDBOX02 | OAT_FIREIMMUNITY | OAT_HITNOTKILL | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $04
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $05
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY	; Object $07 - OBJ_BRICK
	.byte OAT_BOUNDBOX00 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $08 - OBJ_COIN
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $09 - OBJ_BUBBLE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY| OAT_HITNOTKILL	; Object $0A
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY| OAT_HITNOTKILL	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY| OAT_HITNOTKILL	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY| OAT_HITNOTKILL	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY| OAT_HITNOTKILL	; Object $0E - OBJ_HARDICE
	.byte OAT_BOUNDBOX00	; Object $0F
	.byte OAT_BOUNDBOX01	; Object $10 OBJ_PIXIE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $11
	.byte OAT_BOUNDBOX01  | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $12
	.byte OAT_BOUNDBOX01  | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $13
	.byte OAT_BOUNDBOX04 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL 	; Object $14
	.byte OAT_BOUNDBOX09 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY	; Object $15
	.byte OAT_BOUNDBOX01  | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $16
	.byte  OAT_BOUNDBOX01  | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $17 - OBJ_WINGS
	.byte OAT_BOUNDBOX13	; Object $18 - OBJ_BOSS_BOWSER
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $1A
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OAT_BOUNDBOX01	; Object $1C
	.byte OAT_BOUNDBOX00 | OAT_HITNOTKILL	; Object $1D
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OAT_BOUNDBOX00 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $1F - OBJ_GROWINGVINE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $20
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY| OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $23 - OBJ_POWERUP_FOXLEAF
	.byte  OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $24 - OBJ_PLATFORMHORZ
	.byte OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $25
	.byte OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $27 - OBJ_OSCILLATING_H
	.byte OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $28 - OBJ_OSCILLATING_V
	.byte OAT_BOUNDBOX01	; Object $29 - OBJ_SPIKE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $2A - OBJ_SPARKRIGHT
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $2B - OBJ_RICOCHET_PODOBO
	.byte OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $2D - OBJ_BIGBERTHA
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL		; Object $2E - OBJ_PIRATEBOO
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY	; Object $2F - OBJ_BOO
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_FIREIMMUNITY	; Object $30 - OBJ_PACBOO
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	| OAT_ICEIMMUNITY | OAT_HITNOTKILL; Object $31 - OBJ_PHANTO
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	| OAT_ICEIMMUNITY ; Object $32 - OBJ_PHANTO_FLIP
	.byte OAT_BOUNDBOX01	; Object $33 - OBJ_NIPPER
	.byte OAT_BOUNDBOX02 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $34 - OBJ_TOAD
	.byte OAT_BOUNDBOX00	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OAT_BOUNDBOX08 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $36 - OBJ_WOODENPLATFORM
	.byte OAT_BOUNDBOX08 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $37 - OBJ_OSCILLATING_HS
	.byte OAT_BOUNDBOX08 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $38 - OBJ_OSCILLATING_VS
	.byte OAT_BOUNDBOX01	; Object $39 - OBJ_NIPPERHOPPING
	.byte OAT_BOUNDBOX03 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $3B - OBJ_SPECTERCHEEP
	.byte OAT_BOUNDBOX08 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OAT_BOUNDBOX01	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OAT_BOUNDBOX08 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS | OAT_FIREIMMUNITY	; Object $3F - OBJ_DRYBONES
	.byte OAT_BOUNDBOX01	; Object $40 - OBJ_GOLDENPIRANHAGROWER
	.byte OAT_BOUNDBOX01  	; Object $41 - OBJ_PIRANHAGROWER
	.byte OAT_BOUNDBOX01| OAT_FIREIMMUNITY	; Object $42 - OBJ_DRYCHEEP
	.byte OAT_BOUNDBOX01	; Object $43 - OBJ_BEACHEDCHEEP
	.byte OAT_BOUNDBOX08 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	 | OAT_HITNOTKILL; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $45 - OBJ_PWING
	.byte OAT_BOUNDBOX01	; Object $46 - OBJ_SNIFIT
	.byte OAT_BOUNDBOX10 | OAT_ICEIMMUNITY 	; Object $47 - OBJ_BIRDO
	.byte OAT_BOUNDBOX01	; Object $48 - OBJ_NINJI
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $4A - OBJ_MAGICSTAR
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $4B - OBJ_MAGICSTAR
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $4C - OBJ_MAGICSTAR
	.byte OAT_BOUNDBOX00	; Object $4D
	.byte OAT_BOUNDBOX00	; Object $4E
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY ; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL		; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $51 - OBJ_ROTODISCDUAL
	.byte OAT_BOUNDBOX01	; Object $52 - OBJ_SPINTULA
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $53 - OBJ_PODOBOOCEILING
	.byte OAT_BOUNDBOX12 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $54
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $55 - OBJ_BOBOMB
	.byte OAT_BOUNDBOX07	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OAT_BOUNDBOX07	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OAT_BOUNDBOX01	; Object $58 - OBJ_FIRECHOMP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $59 - OBJ_FIRESNAKE
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $5C - OBJ_ICEBLOCK
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	| OAT_ICEIMMUNITY | OAT_HITNOTKILL ; Object $5D - OBJ_STONEBLOCK
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OAT_BOUNDBOX01	; Object $61 - OBJ_SKULLBLOOPER
	.byte OAT_BOUNDBOX01	; Object $62 - OBJ_BLOOPER
	.byte OAT_BOUNDBOX13 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $63 - OBJ_FLOATMINE
	.byte OAT_BOUNDBOX01	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OAT_BOUNDBOX00 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $66 - OBJ_WATERCURRENTUPWARD
	.byte OAT_BOUNDBOX01	; Object $67 - OBJ_SNOWGUY
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OAT_BOUNDBOX01	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OAT_BOUNDBOX01	; Object $6A - OBJ_VEGGIEGUY
	.byte OAT_BOUNDBOX01	; Object $6B - OBJ_SHYGUY
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6C - OBJ_GREENTROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6D - OBJ_REDTROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS | OAT_FIREIMMUNITY	; Object $70 - OBJ_BUZZYBEATLE
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $71 - OBJ_SPINY
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $72 - OBJ_GOOMBA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $73 - OBJ_PARAGOOMBA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS 	; Object $74 - OBJ_ZOMBIEGOOMBA
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $75 - OBJ_WATERFILLER
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_BOUNCEOFFOTHERS	; Object $76 - OBJ_POISONMUSHROOM
	.byte OAT_BOUNDBOX01	; Object $77 - OBJ_GREENCHEEP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	| OAT_ICEIMMUNITY	; Object $78 - OBJ_BULLETBILL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $7A - OBJ_PURPLETROOPA
	.byte OAT_BOUNDBOX01	; Object $7B - OBJ_BLUESHELL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $7C - OBJ_HELPER
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS 	; Object $7D - OBJ_PARAZOMBIEGOOMBA
	.byte OAT_BOUNDBOX13 | OAT_BOUNCEOFFOTHERS	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OAT_BOUNDBOX13	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OAT_BOUNDBOX02	; Object $81 - OBJ_HAMMERBRO
	.byte OAT_BOUNDBOX02	; Object $82 - OBJ_NINJABRO
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY	; Object $83 - OBJ_LAKITU
	.byte OAT_BOUNDBOX01	; Object $84 - OBJ_SPINYEGG
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $85 - OBJ_BLUESPINY
	.byte OAT_BOUNDBOX02	; Object $86 - OBJ_ICEBRO
	.byte OAT_BOUNDBOX02	; Object $87 - OBJ_FIREBRO
	.byte OAT_BOUNDBOX02	; Object $88 - OBJ_PIRATEBRO
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY	; Object $89 - OBJ_CHAINCHOMP
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $8A - OBJ_THWOMP
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $8B - OBJ_HYPERTHWOMP
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $8D - OBJ_THWOMPUPDOWN
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $8F - OBJ_THWOMPDIAGONALDL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $90 - OBJ_FIREICEBAR
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_BOUNCEOFFOTHERS	; Object $91 - OBJ_FREEZIE
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY 	; Object $92 - OBJ_SWOOSH
	.byte OAT_BOUNDBOX01 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $93 - OBJ_INTRO
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $94 - OBJ_BIGQBLOCK_3UP
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $99 - OBJ_BIGQBLOCK_FROG
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.byte OAT_BOUNDBOX00	; Object $9B
	.byte OAT_BOUNDBOX00	; Object $9C
	.byte OAT_BOUNDBOX14 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $9E - OBJ_PODOBOO
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $9F - OBJ_PARABEETLE
	.byte OAT_BOUNDBOX01		; Object $A0 - OBJ_PUMPKINFREE
	.byte OAT_BOUNDBOX01		; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.byte OAT_BOUNDBOX10	; Object $A2 - OBJ_REDPIRANHA
	.byte OAT_BOUNDBOX10	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.byte OAT_BOUNDBOX10		; Object $A4 - OBJ_PUMPKINPLANT
	.byte OAT_BOUNDBOX01		; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.byte OAT_BOUNDBOX10	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OAT_BOUNDBOX10	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OAT_BOUNDBOX10	; Object $A8 - OBJ_UPARROW
	.byte OAT_BOUNDBOX10	; Object $A9 - OBJ_MANYARROW
	.byte OAT_BOUNDBOX00 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $AA - OBJ_AIRSHIPPROP
	.byte OAT_BOUNDBOX00 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $AB
	.byte OAT_BOUNDBOX15 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $AC - OBJ_FIREJET_LEFT
	.byte OAT_BOUNDBOX12	; Object $AD - OBJ_ROCKYWRENCH
	.byte OAT_BOUNDBOX11 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $AE - OBJ_BOLTLIFT
	.byte OAT_BOUNDBOX05 | OAT_FIREIMMUNITY	| OAT_ICEIMMUNITY | OAT_HITNOTKILL; Object $AF - OBJ_ENEMYSUN
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OAT_BOUNDBOX15 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OAT_BOUNDBOX14 | OAT_ICEIMMUNITY | OAT_HITNOTKILL	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OAT_BOUNDBOX01	; Object $B3


	; Index by Level_TilesetIdx
	; Sets the tile which is a pain in the ass (typically muncher, sometimes jelectro)

	; Velocities set to X/Y directly to Player for what might be a now-unused debug routine of sorts
PRG000_C3E7:
	.byte $00, $30, -$30

; FIXME: Anybody want to claim this?
; Looks like maybe a leftover debug routine for some kind of "float around" mode maybe!!
; $C3EA 
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	TAY		 ; Y = 1 or 2

	; Offsets into Sprite_RAM used by objects
SprRamOffsets:
	; The specified Sprite_RAM offset is calculated by object's index
	; added to Counter_7to0 (i.e. a value 0 to 7) so as to evenly
	; distribute the drawing of objects over available sprites and
	; help cope with the sprites-per-scanline drawing limits.
	;
	; Basically, on different frames, different objects will have 
	; different sprite priority, so while there may be flicker, at 
	; least everything is somewhat visible
	.byte $40, $E8, $58, $D0, $70, $B8, $88, $A0, $40, $E8, $58, $D0, $70, $B8, $88




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SpecialObj_FindEmptyAbort
; SpecialObj_FindEmptyAbortY
;
; Finds an empty special object slot (returned in 'Y') or "aborts" 
; if no slot is open OR if the object has any horizontal sprite visibility
; "abort" = will not return to caller...
;
; SpecialObj_FindEmptyAbortY just allows a specified range
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $C447
SpecialObj_FindEmptyAbort:
	LDY #$05
SpecialObj_FindEmptyAbortY:
	LDA SpecialObj_ID,Y
	BEQ PRG000_C454	 ; If object slot is dead/empty, jump to PRG000_C454 
	DEY		 ; Y--
	BPL SpecialObj_FindEmptyAbortY	 ; While Y >= 0, loop!

PRG000_C451:
	; Do not return to caller!!
	PLA
	PLA
	RTS

SpecialObj_FindEmpty:
	LDY #$05
	LDA SpecialObj_ID,Y
	BEQ PRG000_C456	 ; If object slot is dead/empty, jump to PRG000_C454 
	DEY		 ; Y--
	BPL SpecialObj_FindEmptyAbortY	 ; While Y >= 0, loop!
PRG000_C456:
	RTS

PRG000_C454:
	JSR Object_AnySprOffscreen

	BNE PRG000_C451	 ; If any sprites are off-screen, jump to PRG000_C451

	RTS		 ; Return


	; Checks for and handles object touching conveyor belt by carrying object
; $C4D6
Object_HandleConveyorBounceVel:
Object_HandleConveyorCarry:
	RTS		 ; Return


	; Checks for and handles object touching conveyor belt, storing result into LRBounce_Vel
; $CF46


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_HitGround
;
; When object hits the ground, this aligns it properly to a tile
; 
; X = index of on-screen object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $C515
Object_HitGround:
	LDA <Objects_YZ,X
	AND #$f0
	STA <Objects_YZ,X	 ; Align to tile and apply slope
	LDA #$00
	STA <Objects_YVelZ,X	 ; Halt vertical movement

	RTS		 ; Return

Object_HitCeiling:
	LDA <Objects_YZ,X
	ADD #$0F
	AND #$f0
	STA <Objects_YZ,X	 ; Align to tile and apply slope

	LDA <Objects_YHiZ, X
	ADC #$00
	STA <Objects_YHiZ, X

	LDA <Objects_YZ,X
	SUB #$02
	STA <Objects_YZ,X
	
	LDA <Objects_YHiZ,X
	SBC #$00
	STA <Objects_YHiZ,X
	
	LDA #$00
	STA <Objects_YVelZ,X	

Object_HitCeiling0:
	RTS
	; The only difference amongst the Object_WorldDetect[x] entries
	; are the input value, which specifies the limit that an object
	; should acknowledge a floor tile.  E.g., Object_DetectTiles
	; means the object will not detect a floor if it is more than
	; 4 pixels vertically down in to it.  "N1" (Negative one) is
	; thus basically to never use that limit because the object
	; can't be at a depth of "-1 pixels into the tile"

; $C542
Object_WorldDetectN1:
	LDA #$ff	; Use A = $FF
	BNE PRG000_C54C	; Jump (technically always) to PRG000_C54C

; $C546 
Object_WorldDetect8:
	LDA #$08	; Use A = 8
	BNE PRG000_C54C	; Jump (technically always) to PRG000_C54C

; $C54A
Object_DetectTiles:
	LDA #$04	; Use A = 4

PRG000_C54C:
	PHA		 ; Save input value (not used until PRG000_C649)

	CPX #$05
	BNE PRG000_C559	 ; If object slot is NOT 5, jump to PRG000_C559

	LDA ObjSplash_DisTimer,X
	BEQ PRG000_C559	 ; If ObjSplash_DisTimer = 0, jump to PRG000_C559

	DEC ObjSplash_DisTimer,X	 ; ObjSplash_DisTimer --

PRG000_C559:
	LDA <Objects_CollisionDetectionZ,X
	STA Temp_VarNP0	 ; Object's detection status -> Temp_VarNP0

	LDA <Objects_CollisionDetectionZ,X
	STA Objects_PreviousCollisionDetection,X
	LDA #$00
	STA <Objects_CollisionDetectionZ,X	; Clear Object's detection status
	STA LRBounce_Vel	; Clear left/right bounce power

	JSR Object_GetAttrAndMoveTiles	 ; Fill in values for Object_TileFeetProp/Quad and Object_TileWallProp/Quad

	PLA		 ; Restore input value
	STA <Temp_Var1	 ; Store into Temp_Var1

	LDA Object_TileWallProp	; A = detected tile index
	AND #TILE_PROP_SOLID_ALL
	CMP #TILE_PROP_SOLID_ALL
	BNE PRG000_C584	 	

	; Object is touching solid wall tile

	LDA #$01		; A = 1

	LDY <Objects_XVelZ,X
	BPL PRG000_C580	 ; If object's X velocity >= 0 (still or moving rightward), jump to PRG000_C580

	; Negative X vel...
	ASL A		 	; A = 2

PRG000_C580:
	ORA <Objects_CollisionDetectionZ,X	; Set bit 0 or 1
	STA <Objects_CollisionDetectionZ,X	 ; Update Objects_CollisionDetectionZ

PRG000_C584:

	LDA <Objects_YVelZ,X
	BPL PRG000_C5A9	 	; If object's Y velocity >= 0 (still or moving downward), jump to PRG000_C5A9

	; Object moving upwards... (ceiling detection)


PRG000_C59A:

	; Non-slope detection
	LDA Object_TileFeetProp
	AND #TILE_PROP_SOLID_BOTTOM
	BEQ PRG000_C5A8	 

PRG000_C5A2:
	; Flag ceiling impact
	LDA <Objects_CollisionDetectionZ,X
	ORA #$08
	STA <Objects_CollisionDetectionZ,X

PRG000_C5A8:
	RTS		 ; Return

PRG000_C5A9:

	; Object moving downwards (floor detection)
	LDA Object_TileFeetProp
	AND #TILE_PROP_SOLID_TOP
	BNE PRG000_C5B4	 ; If tile is within range of the starting solid tile, jump to PRG000_C5B4
	JMP PRG000_C65C	 ; Otherwise, jump to PRG000_C65D

PRG000_C5B4:
	LDA Player_PartDetEn
	BNE PRG000_C656	 ; If Player_PartDetEn is set (the object hit the visual ground), jump to PRG000_C656

	; The original input value finally winds up here.  This limits when an object will actually 
	; acknowledge "hitting ground."  Basically, if the object is more than [input value] pixels
	; down in to the tile, it will not count as having hit the floor.

	LDA <Objects_YZ,X
	AND #$0f	 ; Object's tile-relative vertical position
	CMP <Temp_Var1	
	BGE PRG000_C65C	 ; If object is too far down in to the tile, jump to PRG000_C65C (RTS)
 
PRG000_C656:

	; Flag object as "hit ground"
	LDA <Objects_CollisionDetectionZ,X
	ORA #$04
	STA <Objects_CollisionDetectionZ,X

PRG000_C65C:
	RTS		 ; Return

PRG000_C67F:

	; Flat ground tiles in a sloped world

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG000_C69C	 ; If object is killed, jump to PRG000_C69C (RTS)

	CMP #OBJSTATE_HELD
	BEQ PRG000_C69C	 ; If object is being held, jump to PRG000_C69C (RTS)

	LDA <Objects_YZ,X
	AND #$f0
	SUB #$01
	STA <Objects_YZ,X	; Align object to one pixel above the tile

	LDA <Objects_YHiZ,X
	SBC #$00
	STA <Objects_YHiZ,X	; Set the Y Hi

	JMP Object_WorldDetectN1	; Jump to Object_WorldDetectN1

PRG000_C69C:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_GetAttrAndMoveTiles
;
; Gets tiles for an object based on its attribute settings and
; current state of movement.  Handles entering/leaving water.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_GetAttrJustTile:
	LDA #$01
	STA JustTileFlag
	BNE Object_GetAttrAndMoveTiles1

Object_GetAttrAndMoveTiles:
	LDA #$00
	STA JustTileFlag

Object_GetAttrAndMoveTiles1:
	LDY #(OTDO_Water - Object_TileDetectOffsets)
	JSR Object_DetectTile	; Get tile here
	STA Object_TileWater
	STA Objects_LastProp, X
	JSR Object_Check_Water

	LDA ObjTile_DetXLo
	AND #$F0
	STA Objects_LastTileX

	LDA ObjTile_DetXHi
	STA Objects_LastTileXHi

	LDA ObjTile_DetYLo
	AND #$F0
	STA Objects_LastTileY

	LDA ObjTile_DetYHi
	STA Objects_LastTileYHi

	LDA JustTileFlag
	BEQ Object_GetAttrAndMoveTiles_NoWater
	RTS

Object_GetAttrAndMoveTiles_NoWater:
	LDA Object_LevelTile
	STA Objects_LastTile,X	 ; Set last tile this object detected

	LDY ObjGroupRel_Idx	 ; Y = object's group-relative index

	LDA ObjectGroup_Attributes2,Y	; Get attributes set 2 for this object
	AND #OA2_TDOGRPMASK	 
	LSR A		; Upper 4 bits of attributes set 2 shifted right 1 (value * 8)
	PHA		; Save it
	TAY		; -> 'Y' (use respective Object_TileDetectOffsets group Row 1)

	LDA <Objects_YVelZ,X
	BPL PRG000_C713	 ; If object Y velocity is >= 0 (stopped or moving downward), jump to PRG000_C713

	INY
	INY		 ; If object moving upward, Y += 2 (use respective Object_TileDetectOffsets group Row 2)

PRG000_C713:
	JSR Object_DetectTile	 ; Get tile
 
	; Store into tile index holders
	STA Object_TileFeetProp
	LDA Object_LevelTile
	STA Object_TileFeetValue


	LDA ObjTile_DetXLo
	STA <Temp_Var16	 ; Temp_Var16 = ObjTile_DetXLo

	LDA #$00
	STA Object_TileWallValue	 ; Object_TileWallValue = 0

	PLA		 ; Restore Object_TileDetectOffsets index

	TAY		 ; Object_TileDetectOffsets index -> 'Y'

	INY
	INY
	INY
	INY		 ; Y += 4 (move down two Rows in Object_TileDetectOffsets)

PRG000_C791:
	LDA <Objects_XVelZ,X
	BMI PRG000_C797	 ; If object's X velocity < 0 (moving leftward), jump to PRG000_C797

	INY
	INY		 ; Y += 2 (move down one Rows in Object_TileDetectOffsets)

PRG000_C797:
	JSR Object_DetectTile	 ; Get tile here

	; Store into tile index holders
	STA Object_TileWallProp

	LDA Object_LevelTile
	STA Object_TileWallValue

	JSR SetSpriteFG
	RTS		 ; Return




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DetectTile
;
; Gets tile based on offset of object; the offset is set by the
; 'Y' register which indexes Object_TileDetectOffsets for the
; Y/X offset pair.  Seems kind of a limited way to go, but hey..
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $C7A9
Object_DetectTile:
	LDA <Objects_YZ,X
	ADD Object_TileDetectOffsets,Y	; Adding tile detection Y offset to Object's Y
	AND #$f0		; Align to grid
	STA ObjTile_DetYLo 	; -> ObjTile_DetYLo (low)

	LDA <Objects_YHiZ,X
	ADC #$00	 	; Apply carry
	STA ObjTile_DetYHi 	; -> ObjTile_DetYHi (high)

	BEQ PRG000_C7FA	 	; If no carry, jump to PRG000_C7FA

	; In a non-vertical level, a high value of 2 or greater is way beyond the bottom
	CMP #$02
	BGE PRG000_C832	 ; If the Y Hi >= 2, jump to PRG000_C832

PRG000_C7F1:
	PHA		 ; Save high part

	LDA ObjTile_DetYLo
	CMP #$b0

	PLA		 ; Restore high part

	BGE PRG000_C832	 ; If the Y lo part is greater than $B0 (the bottom of the screen), jump to PRG000_C832

PRG000_C7FA:
	AND #$01
	STA <Temp_Var3	 ; Temp_Var3 = 0 or 1, depending if Y lo is on odd line or not

	LDA <Objects_XZ,X
	ADC Object_TileDetectOffsets+1,Y	; Adding tile detection X offset to Object's X
	STA ObjTile_DetXLo 	; -> ObjTile_DetXLo (low)

	LDA <Objects_XHiZ,X
	ADC #$00	 	; Apply carry
	STA ObjTile_DetXHi 	; -> ObjTile_DetXHi (high)

	CMP #$10
	BGE PRG000_C832	 ; If the high part is more than $10 (biggest possible within other limits), jump to PRG000_C832

IndependentBlockCheck:
	ASL A		 ; Change high part into 2 byte index to select the screen
	TAY		 ; -> 'Y'

	; Calculate Temp_Var2/1 (tile address)
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	ADC <Temp_Var3	
	STA <Temp_Var2	

	; Calculate tile offset within screen
	LDA ObjTile_DetXLo
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA ObjTile_DetYLo

	TAY		 	; -> 'Y'

PRG000_C82A:
	LDA [Temp_Var1],Y	; Get tile
	STA Object_LevelTile
	JSR PSwitch_SubstTileAndAttr	 ; Substitute tile if P-Switch is active
	TAY
	LDA TileProperties, Y
	STA Object_TileProp
	RTS	 ; Jump to PRG000_C834

PRG000_C832:
	LDA #$00	; No tile detected
	STA Object_LevelTile	; Store tile index detected

PRG000_C834:

	RTS		 ; Return



	; When Object hits water, splash!
Object_WaterSplash:
	LDA #$02

Podoboo_Splash:
	STA <Temp_Var1	 ; Temp_Var1 = 2

	LDA ObjSplash_DisTimer,X
	BNE PRG000_C914	 ; If splashes are disabled, jump to PRG000_C914 (RTS)

	LDA Objects_ID,X
	CMP #OBJ_GROWINGVINE
	BEQ PRG000_C914	 ; If object is a growing vine, jump to PRG000_C914 (RTS)

	LDA <Objects_YVelZ,X
	BMI PRG000_C8BE	 ; If Object's Y velocity is negative (moving upward), jump to PRG000_C8BE

	; If object is some kind of blooper, jump to PRG000_C914 (RTS)
	LDA Objects_ID,X
	CMP #OBJ_BLOOPER
	BEQ PRG000_C914
	CMP #OBJ_SKULLBLOOPER
	BEQ PRG000_C914

	LDA TempA
	BEQ PRG000_C8BE

	LDA #$00
	STA <Objects_YVelZ,X	; Object's Y velocity is zeroed at impact of water

PRG000_C8BE:

	; Basically looking not to do a splash effect if object is falling off-screen

	JSR Object_AnySprOffscreen
	BNE PRG000_C914	 ; If any sprites are off-screen, jump to PRG000_C914 (RTS)

	LDY #$02	 ; Y = 2 (this is immediately overwritten and thus not used)

	; Alternate between splash slot 1 and 2
	INC Object_SplashAlt	 ; Object_SplashAlt++
	LDA Object_SplashAlt
	AND #$01	 ; Keep just bit 0
	TAY		 ; -> 'Y'

	INY		 ; Y = 1 or 2

	LDA #$01	
	STA Splash_Counter,Y	 ; Splash counter = 1 (begin splash)

	LSR A		 
	STA Splash_NoScrollY,Y	 ; Splash_NoScrollY = 0 (splash is relative to vertical scroll)

	; Set appropriate splash Y
	LDA <Objects_YZ,X
	SUB #$04
	AND #$f0
	ADD <Temp_Var1
	STA Splash_Y,Y

	; Set appropriate splash X
	LDA <Objects_XZ,X
	STA Splash_X,Y

PRG000_C914:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Objects_HandleScrollAndUpdate
;
; THE function which spawns objects as they appear on screen and 
; calls updates on all objects based on their state etc.  Also
; updates the timers.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Objects_HandleScrollAndUpdate:
	LDX #$08
	LDA #$00

PRG000_C939:
	DEX
	BPL PRG000_C939

	LDA Splash_DisTimer
	BEQ PRG000_C93A	 ; If Splash_DisTimer > 0, jump to PRG000_C92F

	DEC Splash_DisTimer	 ; Splash_DisTimer--


PRG000_C93A:
	LDA Slow_Watch
	BEQ PRG000_C93A1
	LDA <Counter_1
	AND #$01
	STA Stop_Watch
	BNE PRG000_C93B
	DEC Slow_Watch

PRG000_C93A1:
	LDA Stop_Watch
	BEQ PRG000_C93B
	LDA <Counter_1
	AND #$01
	BEQ PRG000_C93B
	DEC Stop_Watch

PRG000_C93B:
	LDA <Player_IsDying
	CMP #$03
	BNE PRG000_C948	 ; If Player is NOT dying due to TIME UP, jump to PRG000_C948


PRG000_C948:
	
	LDA <Pad_Holding
	AND #PAD_B
	BNE PRG000_C949

	LDA #$00
	STA Player_IsHolding

PRG000_C949:
	LDA #$ff
	STA LRBounce_Y	 ; LRBounce_Y = $FF 

	; Set page @ A000 to 5
	LDA #$05
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR LevelEvent_Do 		; Perform event as set by Level_Event
	JSR Level_SpawnObjsAndBounce	; Handle if Player bounced off block and spawn new objects as screen scrolls

	DEC Counter_7to0 ; Counter_7to0--
	BPL PRG000_C973	 ; If Counter_7to0 >= 0, jump to PRG000_C973

	LDA #$07
	STA Counter_7to0 ; Otherwise, reset Counter_7to0 to 7

PRG000_C973:
	LDA #$00
	STA <CurrentObjectIndexZ

PRG000_C975:
	LDX <CurrentObjectIndexZ	 ; Backup current object index -> CurrentObjectIndexZ

	LDA <Player_HaltGameZ
	BNE PRG000_C9B6	 ; If gameplay is halted, jump to PRG000_C9B6

	LDA Objects_Timer,X
	BEQ PRG000_C983	 ; If this timer is already at zero, jump to PRG000_C983

	DEC Objects_Timer,X	 ; Otherwise, decrement it

PRG000_C983:

	LDA Objects_Timer2,X
	BEQ PRG000_C98B	 ; If this timer is already at zero, jump to PRG000_C98B

	DEC Objects_Timer2,X	; Otherwise, decrement it

PRG000_C98B:

	CPX #$05
	BGE PRG000_C9B6	 ; If object slot index >= 5, jump to PRG000_C9B6

	; Non-special objects in slots 0 to 4...

	LDA Objects_Timer4,X
	BEQ PRG000_C996	 ; If this timer is already at zero, jump to PRG000_C997

	DEC Objects_Timer4,X	; Otherwise, decrement it

PRG000_C996:
	LDA Objects_SlowTimer,X
	BEQ PRG000_C997	 ; If this timer is already at zero, jump to PRG000_C997

	LDA <Counter_1
	AND #$01
	BEQ PRG000_C997
	DEC Objects_SlowTimer,X	; Otherwise, decrement it

PRG000_C997:
	LDA Objects_Timer3,X
	BEQ PRG000_C9B6	 ; If timer is zero, jump to PRG000_C9B6

	CMP #$60	 
	BLT PRG000_C9B3	 ; If timer value is < $60, jump to PRG000_C9B3

	LDA #$01	 ; A = 1

	LDY Objects_State,X
	CPY #OBJSTATE_NORMAL
	BEQ PRG000_C9B3	 ; If object's state is Normal, jump to PRG000_C9B3

	CPY #$04	 
	BNE PRG000_C9AF	 ; If object's state is NOT 4 (being held), jump to PRG000_C9AF

	; Object being held...

	LDA #$03	 ; A = 3
PRG000_C9AF:
	AND <Counter_1
	BNE PRG000_C9B6	 ; Every A:A+1 ticks, jump to PRG000_C9B6

PRG000_C9B3:
	DEC Objects_Timer3,X	 ; Every 4 ticks, decrement Objects_Timer3

PRG000_C9B6:
	TXA		 ; Object index -> 'A'
	ADD Counter_7to0 ; Add current value of Counter_7to0
	TAY		 ; -> 'Y' (anywhere from 0 to 14)

	LDA SprRamOffsets,Y
	STA Object_SpriteRAM_Offset,X	 ; Store this object's Sprite_RAM offset

	JSR Object_DoStateAction 	; Do whatever's required by this object by its current state
	LDX <CurrentObjectIndexZ
	JSR Object_HitByTailOrBouncer	; Test and respond if object was hit by Player tail attack or left/right bouncer

	LDA Objects_State,X
	BNE PRG000_C9D2	 ; If object's state is not 0 (dead/empty), jump to PRG000_C9D2

	; Remove object's associated spawn index
	LDA #$ff
	STA Objects_SpawnIdx,X

PRG000_C9D2:
	INC <CurrentObjectIndexZ
	LDA <CurrentObjectIndexZ
	CMP #$08
	BNE PRG000_C975	 ; While X >= 0, loop!

PRG000_C9E5:
	LDA Player_Flip
	BEQ PRG000_C9FB	 ; If Player is NOT somersaulting, jump to PRG000_C9FB

	LDA Player_InWater
	ORA Player_SandSink
	BNE PRG000_C9F6	 ; If Player is in water or sinking in sand, jump to PRG000_C9F6

	LDA <Player_InAir
	BNE PRG000_C9FB	 ; If Player is mid-air, jump to PRG000_C9FB

PRG000_C9F6:
	; A would-be somersaulting Player is either in water or sand, 
	; or is not mid-air; disable it!
	LDA #$00
	STA Player_Flip

PRG000_C9FB:
	LDA Level_ChgTileEvent
	BNE PRG000_CA33	 ; If a change tile event is called for, jump to PRG000_CA33

	; Check each block bump slot to see if it needs to occur
	LDY #$00
	LDA Level_BlkBump,Y
	BNE PRG000_CA13

	INY	
	LDA Level_BlkBump,Y
	BNE PRG000_CA13

	INY	
	LDA Level_BlkBump,Y
	BEQ PRG000_CA33	

PRG000_CA13:
	STA Level_ChgTileValue
	INC Level_ChgTileEvent	 ; Set the block bump change event

	; Set relevant parameters
	LDA Level_BlkBump_XHi,Y
	STA Level_BlockChgXHi

	LDA Level_BlkBump_XLo,Y
	STA Level_BlockChgXLo

	LDA Level_BlkBump_YHi,Y
	STA Level_BlockChgYHi

	LDA Level_BlkBump_YLo,Y
	STA Level_BlockChgYLo

	; Clear this block bump!
	LDA #$00
	STA Level_BlkBump,Y

PRG000_CA33:
	LDA Level_JctCtl
	BEQ PRG000_CA40	 ; If no level junction is occurring, jump to PRG000_CA40

	STA LevelPartialInit	; Flag that we need a level partial initialization

	; Clear the "Get Wand" cinematic state
	LDA #$00
	STA Level_GetWandState

PRG000_CA40:
	RTS		 ; Return

	; Breaks up every 36 object IDs to make smaller jump tables
ObjectID_BaseVals:
	.byte $00, $24, $48, $6C, $90


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DoStateAction
;
; Do whatever is required by the current Objects_State value
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_DoStateAction:
	LDA Objects_State,X
	BEQ PRG000_CA40	 ; If this object is "dead/empty", jump to PRG000_CA40

	CMP #$08
	BEQ PRG000_CA81	 ; If this object's state = 8 ("Poof" Dying), jump to PRG000_CA81

	LDY #$04	 ; Y = 4

	; Try to locate the group that this object ID belongs to
	; Groups are defined by ObjectID_BaseVals, every 36 values.
PRG000_CA51:
	
	LDA Objects_ID,X	; Get object ID
	CMP ObjectID_BaseVals,Y	; Compare to this base value
	BGE PRG000_CA5C	 ; If this object ID >= the base value, jump to PRG000_CA5C

	; Object ID is smaller, thus not this group...

	DEY		 ; Y--
	BNE PRG000_CA51	 ; If Y > 0, loop!

PRG000_CA5C:

	; Y contains index to the base value for this group of object IDs
	; A contains the object's ID

	INY		 ; Y++
	SUB ObjectID_BaseVals-1,Y ; Subtract next group's ID to make this object's ID relative to group

	STA ObjGroupRel_Idx ; Set ObjGroupRel_Idx to this group-relative index value

	; Y is now a value of 1 to 5, and that value dictates the page 
	; where this object's code can be found...
	STY PAGE_A000	 ; Set new page
	TAY		; Object group-relative index -> 'Y'
		 
	JSR PRGROM_Change_A000	 ; Set page @ A000 to appropriate object page...

	; Object's can request a particular pattern set to be available to them.
	; They may set either the fifth or sixth bank of CHRROM, which is specified
	; by bit 7.  

	LDX #$00	 ; X = 0 (fifth CHRROM bank)
	STX BossBoundBox
	LDA ObjectGroup_PatTableSel,Y	 ; Load CHRROM bank request for this object, if any
	BEQ PRG000_CA7F	 ; If CHRROM bank request is zero, no change, jump to PRG000_CA7F
	BPL PRG000_CA7A	 ; If CHRROM bank request does not have bit 7 set, jump to PRG000_CA7A
	INX		 ; Otherwise, X = 1 (sixth CHRROM bank)

PRG000_CA7A:
	AND #$7f	 ; Bit 7 is used to specify which bank, so filter it here
	STA PatTable_BankSel+4,X	 ; Store pattern bank
	STX LastPatTab_Sel

PRG000_CA7F:
	LDX <CurrentObjectIndexZ		 ; Restore X as the object slot index

PRG000_CA81:
	JSR Object_DetermineVerticallyOffScreen	; Set flags based on which sprites of this object are vertically visible
	JSR Object_DetermineHorizontallyOffScreen	; Set flags based on which sprites of this object are horizontally visible

	LDA Objects_State,X	 ; Get object state...
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ObjState_DeadEmpty	; 0 - Dead/Empty
	.word ObjState_Initializing	; 1 - Initializing
	.word ObjState_Normal		; 2 - Normal operation
	.word ObjState_Shelled		; 3 - Shelled
	.word ObjState_Held		; 4 - Held by Player
	.word ObjState_Kicked		; 5 - Kicked
	.word ObjState_Killed		; 6 - Killed
	.word ObjState_Squashed		; 7 - Object was squashed (NOTE: Really only intended for Goomba/Giant Goomba)
	.word ObjState_PoofDying	; 8 - "Poof" Dying

	; Patterns selected by "poof" death frame
PoofDeath_Pats:
	.byte $47, $45, $41, $43

ObjState_PoofDying:
	LDA Objects_Timer,X
	BNE PRG000_CAAE	 ; If object timer is not expired, jump to PRG000_CAAE

	JMP PRG000_D068	 ; Jump to PRG000_D068 (Object_SetDeadEmpty)

PRG000_CAAE:
	JSR Object_AnySprOffscreen
	BNE PRG000_CAF0	 ; If any sprite is off-screen, jump to PRG000_CAF0 (RTS)

	; Set the "poof" pixel positions
	JSR Object_CalcSpriteXY_NoHi
	LDY Object_SpriteRAM_Offset,X
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y	
	STA Sprite_RAM+$04,Y	
	LDA <Objects_SpriteX,X	
	STA Sprite_RAM+$03,Y	
	ADD #$08	 
	STA Sprite_RAM+$07,Y

	LDA Objects_Timer,X
	LSR A
	LSR A
	LSR A
	TAX		 ; X = "poof" frame

	; Set "poof" death patterns
	LDA PoofDeath_Pats,X
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Set the attributes
	LDA Level_NoStopCnt
	LSR A
	LSR A
	ROR A
	AND #$80
	ORA #$01
	STA Sprite_RAM+$02,Y

	EOR #$c0
	STA Sprite_RAM+$06,Y

	LDX <CurrentObjectIndexZ	 ; X = object slot index

PRG000_CAF0:
	RTS		 ; Return

	; In units of $10 ticks by timer 3...
PRG000_CAF1:
	.byte %00000010, %00000010, %00000100, %00001000, %00010000, %00010000

	; Some objects have "feet" when they are waking up, 
	; this offsets their Y depending on whether v-flipped
ObjWakeUp_FeetYOff:	.byte 10, -10

Object_DampenVelocity:
	LDA <Objects_CollisionDetectionZ, X
	AND #HIT_GROUND
	BEQ Object_DampenVelocityRTS

	LDA <Objects_YVelZ,X 
	CMP #$10
	BCC Object_DampenStop

	LDA <Objects_YVelZ,X
	TAY
	JSR Object_HitGround

	TYA
	AND #$80
	STA TempA
	TYA
	LSR A
	ORA TempA
	EOR #$FF
	ADD #$01
	STA <Objects_YVelZ,X 

	LDA <Objects_CollisionDetectionZ, X
	AND #~HIT_GROUND
	STA <Objects_CollisionDetectionZ, X
	
	LDA <Objects_XVelZ,X 
	AND #$80
	STA TempA
	LDA <Objects_XVelZ,X 
	LSR A
	ORA TempA
	STA <Objects_XVelZ,X 
	RTS

Object_DampenStop:
	LDA #$00
	STA <Objects_XVelZ,X 

Object_DampenVelocityRTS:
	RTS


	; Called for an object in state 3 to do its "shelled" routine
ObjState_Shelled:
	LDY ObjGroupRel_Idx	; Y = object's group-relative index
	; Attribute set 3 bit 4 is NOT set... (object is "shelled" when stomped)

	LDA <Player_HaltGameZ	 
	BNE Object_DrawShelled	 ; If gameplay is halted, jump to PRG000_CB5B
	
	JSR Object_DeleteOffScreen
	JSR Object_Move	 
	JSR Object_DampenVelocity
	JSR Object_InteractWithTiles
	JSR Object_InteractWithOtherObjects
	JSR Object_TestTopBumpBlocks
	
	JSR Object_HandleBumpUnderneath	 ; Handle object getting hit from underside 
	JSR Object_AttackOrDefeat	 ; Bump off and turn away from other objects 
	JSR Object_ShellDoWakeUp	 

	JMP Object_DrawShelled


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DrawShelled
;
; Draw object in "shelled" state
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $CB61

Object_SetShakeAwakeTimer:

	; Set timer for object to wake up from

	LDA Objects_Timer3,X
	CMP #$60	 
	BGE PRG000_CB7A	 ; If timer 3 >= $60, jump to PRG000_CB7A

	AND #$07
	STA Objects_Timer4,X	; Timer 4 = 0-7, based on timer3

PRG000_CB7A:
	RTS		 ; Return

	LDA Objects_ID,X

	CMP #OBJ_BOBOMB
	;BNE PRG000_CB8E		; If this is not a Bob-omb of any sort, jump to PRG000_CB8E

	JSR Object_ShakeAndDraw
	LDA Objects_Data2, X
	CMP #$03
	BNE BobOmbDrawShelled2
	LDY Object_SpriteRAM_Offset, X
	LDA <Counter_1
	AND #$01
	BEQ BobOmbDrawShelled1
	TYA
	TAX
	DEC Sprite_RAM,X
	DEC Sprite_RAM+4,X

BobOmbDrawShelled1:
	LDX <CurrentObjectIndexZ
	LDA #$FF
	STA Objects_Timer, X

BobOmbDrawShelled2:
	RTS

PRG000_CB86:

	; Have object flip same way as Player
	JMP Object_ShakeAndDraw	 ; Draw object and never come back!

Object_DrawShelled:
	; Set object frame to 2
	LDA #$02	 
	STA Objects_Frame,X
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprit
	JSR Object_SetShakeAwakeTimer	 ; Set the "shake awake" timers
	JSR Object_Vibrate
	JSR Object_TestTopBumpBlocks

PRG000_CBB3:
	RTS		 ; Return

PRG000_CBB3_2:
	LDY Object_SpriteRAM_Offset,X	
	LDA Sprite_RAM + $06, Y
	ORA #SPR_VFLIP
	STA Sprite_RAM + $06, Y
	RTS

PRG000_CBB4:

	; NOT a Buzzy Beatle

	CMP #OBJ_SPINY
	BEQ PRG000_CBB3	 ; If Object is a Spiny, jump to PRG000_CBB3

	CMP #OBJ_BLUESPINY
	BEQ PRG000_CBB3	 

	CMP #OBJ_PURPLETROOPA
	BEQ RotatePaletteInstead

	; "Shake awake" speed

Object_Vibrate:
	LDA Objects_Timer3,X
	CMP #$50
	BGE PRG000_CC23	 ; If timer 3 >= $50, jump to PRG000_CC23

	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = index into PRG000_CAF1 (proper bit mask for shaking speed)

	; Various speed shake by timer 3
	LDA Objects_Timer3,X
	AND PRG000_CAF1,Y
	BEQ PRG000_CC23	 ; If not shaking on this bit, jump to PRG000_CC23

	LDA #$01	 ; A = 1 (object not vertically flipped)

	LDY Objects_Orientation,X	 
	BMI PRG000_CBD4	 ; If object is vertically flipped, jump to PRG000_CBD4

	LSR A		 ; A = 0 (object vertically flipped)

PRG000_CBD4:
	LDY Object_SpriteRAM_Offset,X	 ; Y = object's Sprite_RAM offset

	TAX		 ; X = 0 or 1 (proper Y offset for foot)

	; One foot
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG000_CBEA	 ; If sprite Y = $F8, jump to PRG000_CBEA

	ADD ObjWakeUp_FeetYOff,X ; Add the foot offset
	CMP #$c5
	BGE PRG000_CBF8	 ; If the offset >= $C5, jump to PRG000_CBF8

	STA Sprite_RAM+$08,Y	 ; Foot Y

PRG000_CBEA:

	; Other foot
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ PRG000_CBF8	 ; If sprite Y = $F8, jump to PRG000_CBF8

	ADD ObjWakeUp_FeetYOff,X ; Add the foot offset
	STA Sprite_RAM+$0C,Y	 ; Other foot Y

PRG000_CBF8:

	; Foot Xs
	LDA Sprite_RAM+$03,Y
	SUB #$03
	STA Sprite_RAM+$0B,Y

	LDA Sprite_RAM+$07,Y
	ADD #$03
	STA Sprite_RAM+$0F,Y

	; Foot attributes
	LDA Sprite_RAM+$02,Y
	AND #$80
	ORA #$03
	STA Sprite_RAM+$0A,Y

	; Flip the other foot
	ORA #$40
	STA Sprite_RAM+$0E,Y

	; Feet pattern
	LDA #$f9
	STA Sprite_RAM+$09,Y
	STA Sprite_RAM+$0D,Y

	LDX <CurrentObjectIndexZ ; Restore 'X' as object index

PRG000_CC23:
	RTS		 ; Return

RotatePaletteInstead:
	LDX <CurrentObjectIndexZ 
	LDA Objects_SpriteAttributes,X
	AND #$FC
	STA TempA
	LDA Objects_Timer3, X
	CMP #$01
	BEQ KoopaExpload0
	CMP #$60
	BCS DontSetColors
	CMP #$40
	BCS RotateColors1
	CMP #$20
	BCS RotateColors2
	LDA <Counter_1
	AND #$06
	LSR A
	JMP SetColors

RotateColors1:
	LDA <Counter_1
	AND #$18
	LSR A
	LSR A
	LSR A
	JMP SetColors

RotateColors2:
	LDA <Counter_1
	AND #$0C
	LSR A
	LSR A
	JMP SetColors

SetColors:
	ORA TempA
	STA Objects_SpriteAttributes,X

DontSetColors:
	RTS

KoopaExpload0:
	LDY Objects_SpawnIdx,X	
	LDA Level_ObjectsSpawned,Y
	AND #$7f
	STA Level_ObjectsSpawned,Y

KoopaExpload:
	LDA #OBJ_BOBOMBEXPLODE
	STA Objects_ID, X
	LDA #OBJSTATE_SHELLED
	STA Objects_State,X
	RTS

ObjState_Kicked:
	LDA <Player_HaltGameZ 
	BEQ ObjState_Kicked1	 ; If gameplay is NOT halted, jump to PRG000_CC75
 
	JMP DrawKickedShell	 ; Jump to PRG000_CD46 

ObjState_Kicked1:
	JSR Object_DeleteOffScreen
	JSR Object_Move	 
	JSR Object_TestTopBumpBlocks
	JSR Object_TestSideBumpBlocks
	JSR Object_InteractWithTiles
	JSR Object_HandleBumpUnderneath
	JSR Object_AttackOrDefeat
	JSR ObjectKill_Others
	
DrawKickedShell:
	LDA Level_NoStopCnt
	LSR A	
	AND #$03
	TAY		 ; Y = 0 to 3, by counter

	LDA Objects_Orientation,X
	AND #~SPR_HFLIP		; Keep all FlipBits except horizontal flips
	ORA ObjShell_AnimFlipBits,Y	 
	STA Objects_Orientation,X	 ; Apply flip as appropriate

	; Set animation frame as appropriate
	LDA ObjShell_AnimFrame,Y
	STA Objects_Frame,X
	TYA
	AND #$01
	BNE DrawKickedShell1	 ; Every other tick, jump to PRG000_CD74

	JMP Object_ShakeAndDrawMirrored	; Draw sprite and don't come back

DrawKickedShell1:
	JMP Object_ShakeAndDraw	 ; Update sprite data, draw sprite, and don't come back


ObjectKill_SetShellKillVars:
	JSR Reap_Coin

ObjectKill_NoScore:
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; Bounce up a bit
	LDA #-$30
	STA <Objects_YVelZ,X
	RTS		 ; Return

ObjectKill_Others:
	TXA 
	ADD <Counter_1 
	LSR A 
	BCC PRG000_CD46	 ; Semi-randomly jump to PRG000_CD46
 
	JSR ObjectToObject_HitTest 
	BCC PRG000_CD46	 ; If object has not hit another object, jump to PRG000_CD46

	; Play object-to-object collision sound 
	LDA Sound_QPlayer 
	ORA #SND_PLAYERKICK 
	STA Sound_QPlayer
 
	; Knock object in same general direction as the kicked shell object
	LDA <Objects_XVelZ,X 
	ASL A 
	LDA #$10	 ; A = $10
	BCC PRG000_CD17 
	LDA #-$10	 ; A = -$10

PRG000_CD17: 
	STA Objects_XVelZ,Y
 
	LDA Objects_State,Y 
	CMP #OBJSTATE_KICKED
	BNE PRG000_CD36	 ; If the impacted object's state is not Kicked, jump to PRG000_CD36

	; Another kicked object on the way... (slam and kill eachother)

	LDA Objects_KillTally,Y
	JSR ObjectKill_SetShellKillVars	 ; Kill our kicked object and set ShellKill variables

	; Set X Velocity of our kicked object in the direction of the impacted object
	LDA Objects_XVelZ,Y
	ASL A	
	LDA #$10
	BCS PRG000_CD34
	LDA #-$10	
PRG000_CD34:
	STA <Objects_XVelZ,X

PRG000_CD36:
	TYA
	TAX		 ; X = the other object we just hit
	JSR ObjectKill_SetShellKillVars	 ; Kill the impacted object and set ShellKill variables

	LDX <CurrentObjectIndexZ		 ; X = object slot index (our kicked object)
	INC Objects_KillTally,X		; Increase our kicked object's kill tally...
	LDA Objects_KillTally,X
	STA Exp_Earned

PRG000_CD46:
	RTS
	
	; Kicked shell object animation frames and flips
ObjShell_AnimFlipBits:	.byte $00, $00, $00, $40
ObjShell_AnimFrame:	.byte $04, $06, $05, $06

	; Copies all brick bust data over to the second bust slots
	; (So up to 2 bricks may be scattering debris at once)
BrickBust_MoveOver:
	LDA BrickBust_En
	STA BrickBust_En+1

	LDA BrickBust_YUpr
	STA BrickBust_YUpr+1

	LDA BrickBust_YLwr
	STA BrickBust_YLwr+1

	LDA BrickBust_X
	STA BrickBust_X+1

	LDA BrickBust_YVel
	STA BrickBust_YVel+1

	LDA BrickBust_XDist
	STA BrickBust_XDist+1

	LDA BrickBust_HEn
	STA BrickBust_HEn+1
	
	LDA BrickBust_Pal
	STA BrickBust_Pal+1

	LDA BrickBust_Tile
	STA BrickBust_Tile+1

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_BumpBlocks
;
; Provides an arbitrary object with the ability to hit objects
; with its "head"; used by Boom Boom, though Boom Boom never 
; gets a chance to employ that in the game...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $CDD2
Object_TopBumpBlocks:
	LDA Object_TileFeetValue
	STA <Level_Tile

	LDA Object_TileFeetProp
	STA <Level_Tile_Prop

	; Transfer tile detection 
	LDA <Objects_YZ, X
	SUB #$04
	STA <Temp_Var14	

	LDA <Objects_YHiZ, X
	SBC #$00
	STA <Temp_Var13	

	LDA <Objects_XZ, X
	ADD #$08
	STA <Temp_Var16	

	LDA <Objects_XHiZ, X
	ADC #$00
	STA <Temp_Var15	

	JMP Object_BumpBlocks

Object_SideBumpBlocks:
	LDA Object_TileWallValue
	STA <Level_Tile

	LDA Object_TileWallProp
	STA <Level_Tile_Prop

	; Transfer tile detection 
	LDA <Objects_YZ, X
	ADD #$09
	STA <Temp_Var14	

	LDA <Objects_YHiZ, X
	ADC #$00
	STA <Temp_Var13	

	LDA <Objects_XVelZ, X
	BMI Object_SideBumpBlocks1

	LDA <Objects_XZ, X
	ADD #$0F
	STA <Temp_Var16	

	LDA <Objects_XHiZ, X
	ADC #$00
	STA <Temp_Var15	
	JMP Object_BumpBlocks

Object_SideBumpBlocks1:
	LDA <Objects_XZ, X
	STA <Temp_Var16	

	LDA <Objects_XHiZ, X
	STA <Temp_Var15	

Object_BumpBlocks:
	; Backup current PAGE_A000 bank
	INC Object_BlockAttack
	LDA PAGE_A000
	PHA	

	; Change page @ A000 to 8
	LDA #$08
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Level_DoBumpBlocks

	LDX <CurrentObjectIndexZ	; X = object slot index

	; Restore page @ A000 to previous page
	PLA
	STA PAGE_A000
	JSR PRGROM_Change_A000

	RTS		 ; Return


	; X velocities depending on kick direction, added to by half of Player's X velocity
ObjectKickXVelMoving:	.byte -$30, $30

	; Set appropriate flip bits based on object's relative position to Player
PlayerKickFlipBits:	.byte $00, $40

	; X velocities depending on kick direction
BobombKickXVel:	.byte -$18, $18

	; Different X and X Hi offsets applied to object being held by Player
	; Changes whether not doing anything special, in pipe, etc.
ObjectHoldXOff:		.byte $0B, -$0B, $04, -$04, $04, $0B, -$13, $04, -$08, $04, $00
ObjectHoldXHiOff:	.byte $00,  $FF, $00,  $FF, $00, $00,  $FF, $00,  $FF, $00, $00

	; Object-to-object hit resultant X velocity
ObjectToObject_HitXVel:	.byte -$08, $08

ObjState_Held:

	LDA <Player_IsDying 
	BEQ PRG000_CE28	 ; If Player is NOT dying, jump to PRG000_CE28
 
	RTS

PRG000_CE28:

	BIT <Pad_Holding 
	BVC Player_KickObject	 ; If Player is NOT holding B button, jump to Player_KickObject  

PRG000_CE2F:
	LDA #$01
	STA Player_IsHolding

	JSR Object_HeldCollide
	JSR Object_PositionHeld
	JSR Object_ShellDoWakeUp
	JSR Object_DrawShelled

PRG000_CFA8:
	RTS	 ; Jump to PRG000_CEEF


Player_KickObject:
	LDA Level_PipeMove	 
	BNE PRG000_CE2F	 ; If Player is moving through pipes, jump to PRG000_CE2F (PRG000_CEEF)

	; Play kick sound


	;LDA Objects_ID,X
	;CMP #OBJ_BOBOMB	 
	;BNE PRG000_CE79	 ; If this is NOT a Bob-omb, jump to PRG000_CE79

PRG000_CE54:

	;; Bob-ombs only...
	;
	;; State remains "normal"
	;LDA Objects_LastProp, X
	;CMP #TILE_PROP_SOLID_ALL
	;BCC PRG000_CE55
	;JMP KillShell

PRG000_CE55:
	;LDA #OBJSTATE_NORMAL
	;STA Objects_State,X
	;
	;; Set Y vel to -$20 (bounce up)
	;LDA #-$20
	;STA <Objects_YVelZ,X
	;
	;; Set X Velocity appropriately based on kick direction
	;JSR Level_ObjCalcXDiffs
	;LDA BobombKickXVel,Y
	;STA <Objects_XVelZ,X
	;
	;EOR <Player_XVel
	;BMI PRG000_CE76	 ; If the Bob-omb's X velocity is the opposite sign of the Player's, jump to PRG000_CE76
	;
	;LDA <Player_XVel
	;STA <Temp_Var1		; -> Temp_Var1 (yyyy xxxx)
	;ASL <Temp_Var1		; Shift 1 bit left (bit 7 into carry) (y yyyx xxx0)
	;ROR A			; A is now arithmatically shifted to the right (yyyyy xxx) (signed division by 2)
	;ADD ObjectKickXVelMoving,Y	 ; Add base "moving" X velocity of Bob-omb
	;STA <Objects_XVelZ,X	 ; Set this as Bob-omb's X Velocity

PRG000_CE76:
	;LDA <Pad_Holding
	;AND #PAD_UP
	;BEQ PRG000_CE77
	;LDA #$C0
	;STA <Objects_YVelZ,X

PRG000_CE77:
	;JMP Object_ShakeAndDraw	 ; Draw Bob-omb and don't come back!

PRG000_CE79:

	; Anything besides a Bob-omb...

	; Clear Objects_KillTally 
	LDA #$00	
	STA Objects_KillTally,X

	LDY #1	 ; Y = 1

	LDA <Player_FlipBits
	BNE PRG000_CE94	 ; If Player is not turned around, jump to PRG000_CE94

	LDY #-1	 ; Y = -1

PRG000_CE94:
	STY <Objects_XVelZ,X	 ; Set minimum X velocity on object (to enable wall hit detection)

	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_CollisionDetectionZ,X
	AND #$03	
	BEQ Object_GetKicked	 ; If object has not hit a wall, jump to PRG000_CEB4


KillShell:
	; 1 EXP
	INC Exp_Earned
	JSR Reap_Coin

Dont_Coin_It4:

	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; Set object Y velocity to -$40 (fly up a bit)
	LDA #-$40
	STA <Objects_YVelZ,X

	; Remove that minimum X velocity
	LDA #$00
	STA <Objects_XVelZ,X

	JSR Object_DrawShelled
	RTS

Object_GetKicked:
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Have Player do kick frame
	LDA #$0c
	STA Player_Kick

	; Set object timer 2 to $10
	LDA #$10
	STA Objects_Timer2,X

	LDA #$00
	STA Player_IsHolding

	LDA <Pad_Holding
	AND #(PAD_UP)
	BEQ Object_GetKicked1

	LDA #$B0
	STA <Objects_YVelZ,X

Object_GetKicked1:
	LDA <Pad_Holding
	AND #PAD_UP
	BEQ Object_GetKicked3

	LDA <Player_XVel
	BEQ Object_GetKicked2_1

	LDA #OBJSTATE_KICKED
	STA Objects_State, X

	LDA <Player_XVel
	BPL Object_GetKicked2_0
	EOR #$FF
	ADD #$01

Object_GetKicked2_0:
	ADD #$08
	BNE Object_GetKicked6

Object_GetKicked2_1:
	LDA #OBJSTATE_SHELLED
	STA Objects_State, X

	LDA #$00
	STA <Objects_XVelZ, X
	RTS

Object_GetKicked2:
	LDA #OBJSTATE_KICKED
	STA Objects_State, X

	LDA <Objects_XVelZ, X
	BNE Object_GetKicked6

Object_GetKicked3:
	LDA <Pad_Holding
	AND #PAD_DOWN
	BEQ Object_GetKicked4

	LDA #OBJSTATE_SHELLED
	STA Objects_State, X
	BNE Object_GetKicked5

Object_GetKicked4:
	LDA #OBJSTATE_KICKED
	STA Objects_State, X

Object_GetKicked5:
	LDA #$30

Object_GetKicked6:
	
	LDY <Player_FlipBits
	BNE Object_GetKicked7

	EOR #$FF
	ADD #$01

Object_GetKicked7:
	STA <Objects_XVelZ,X	 ; Set as object's X velocity

	RTS

Object_HeldCollide:
	JSR ObjectToObject_HitTest	; Test if this object has collided with another object
	BCC Object_HeldCollideRTS		 ; If this object did not collide with any other objects, jump to PRG000_CF98

	LDA Objects_Timer2,X
	ORA Level_PipeMove
	BNE Object_HeldCollideRTS	 	; If timer 2 is not expired or Player is moving through pipes, jump to PRG000_CF98

	; Object colliding sound!
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Object which was held is dead!
	STA Debug_Snap
	JSR Object_GetKilled
	
	TYA
	TAX

	JSR Object_GetKilled

	LDX <CurrentObjectIndexZ
	LDA #$00
	STA Player_IsHolding
	
Object_HeldCollideRTS:
	RTS

Object_PositionHeld:
	LDA Level_PipeMove
	BEQ PRG000_CEFD	 ; If Player is NOT moving through pipes, jump to PRG000_CEFD

	LDY #$0a	 ; Y = 10
	BNE PRG000_CF1A	 ; Jump (technically always) to PRG000_CF1A

PRG000_CEFD:
	LDY #$00	 ; Y = 0

	LDA <Player_FlipBits
	BNE PRG000_CF04	 ; If Player is turned around, jump to PRG000_CF04

	INY		 ; Y = 1

PRG000_CF04:
	LDA Player_PipeFace
	BEQ PRG000_CF1F	 ; If Player is NOT "pipe facing" (facing forward in pipe), jump to PRG000_CF1F

	; Y += 2
	INY
	INY

	CMP #$05	
	BLT PRG000_CF1A	 ; If less than 5 ticks remaining on the "pipe face", jump to PRG000_CF1A

	INY		 ; Otherwise, Y++

PRG000_CF1A:

	; Set object to occupy Sprite_RAM offset $10
	LDA #$10
	STA Object_SpriteRAM_Offset,X

PRG000_CF1F:

	; Set held object's proper X position
	LDA <Player_X	
	ADD ObjectHoldXOff,Y
	STA <Objects_XZ,X	

	LDA <Player_XHi	
	ADC ObjectHoldXHiOff,Y
	STA <Objects_XHiZ,X	

	LDA #$0d	; A = $0D

	LDY <Player_Suit
	BNE PRG000_CF3D	 ; If Player is not small, jump to PRG000_CF3D

	LDA #$0f	; Otherwise, A = $0F

PRG000_CF3D:
	STA TempA		 ; Save 'A'

	; Set Y offset to object being held
	ADD <Player_Y
	STA <Objects_YZ,X

	LDY #$00	 ; Y = 0

	LDA TempA

	BPL PRG000_CF49	 ; If A >= 0 (negative when object was giant), jump to PRG000_CF49

	DEY		 ; Y = -1

PRG000_CF49:
	TYA		 ; A = 0 or -1

	; Apply carry
	ADC <Player_YHi
	STA <Objects_YHiZ,X

;	JSR Object_WorldDetectN1	; Detect against world
;	JSR Object_CalcSpriteXY_NoHi	; Calculate low parts of sprite X/Y (never off-screen when held by Player!)

PRG000_CF98:
	RTS		 ; Return


ObjState_Killed:
	JSR Object_FallAndDelete	; Have object fall and delete if it gets too low (at which point we don't return)

	LDY ObjGroupRel_Idx	 ; Y = object's group relative index

	LDA ObjectGroup_KillAction,Y
	AND #%00001111
	BEQ Object_DoKillAction	 ; If kill action is zero, jump to Object_DoKillAction (i.e. do NOT set frame 2)

	CPX #$05	 
	BGE Object_DoKillAction	 ; If object slot >= 5 (i.e. not a "general" objects), jump to Object_DoKillAction (i.e. do NOT set frame 2)

	PHA		 ; Save kill action

	LDA #$02	 
	STA Objects_Frame,X	 ; Set frame to 2

	PLA		 ; Restore kill action

	; Do the kill action
Object_DoKillAction:
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Object_StandardKill	; 0: Standard kill (does not set frame 2)
	.word Object_CalcAndDrawKilled	; 1: Standard sprite draw and kill
	.word Object_DrawMirroredKilled	; 2: Draw mirrored sprite
	.word Object_Draw16x32Killed	; 3: Draw tall sprite
	.word Object_DrawTallHFlipped	; 4: Draw tall object horizontally flipped
	.word Object_NormalAndKilled	; 5: Do "Normal" state and killed action (sinking/vert flip)
	.word Object_GiantKilled	; 6: Giant enemy death
	.word Object_PoofDie		; 7: Do "poof" dying state while killed
	.word Object_DrawAndMoveNotHalt	; 8: Draw and do movements unless gameplay halted
	.word Object_NormalWhileKilled	; 9: Just do "Normal" state while killed

Object_StandardKill:
	JSR Object_DoHaltedAction
	JMP Object_DoKilledAction

Object_NormalAndKilled:
	JSR Object_DoNormal
	JMP Object_DoKilledAction

Object_NormalWhileKilled:
	JMP Object_DoNormal

Object_GiantKilled:

Object_PoofDie:
	; Set object state to 8 ("Poof" Dying)

	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X

	; Set timer to $1F 
	LDA #$1f
	STA Objects_Timer,X

	LDA Objects_ID,X
	CMP #OBJ_POISONMUSHROOM
	BEQ End_The_Level
 
	RTS		 ; Return

End_The_Level:
	LDA #$80
	STA CompleteLevelTimer

End_The_Level1:
	RTS

Object_DrawAndMoveNotHalt:
	JSR Object_ShakeAndDraw	
	JMP Object_MoveNotHalted

Object_DrawTallHFlipped:
	JSR Object_DrawTallAndHFlip
	JMP Object_DoKilledAction

Object_Draw16x32Killed:
	JSR Object_Draw16x32Sprite
	JMP Object_DoKilledAction

Object_DrawMirroredKilled:
	JSR Object_ShakeAndDrawMirrored
	JMP Object_DoKilledAction

Object_CalcAndDrawKilled:
	JSR Object_ShakeAndDraw

	; If object was killed by sinking in quicksand or just killed, do this...
Object_DoKilledAction:
	; Dead object, not sinking in quicksand

	; Vertically flip
	LDA Objects_Orientation,X
	ORA #SPR_VFLIP
	STA Objects_Orientation,X

Object_MoveNotHalted:
	LDA <Player_HaltGameZ
	BNE PRG000_D054	 ; If gameplay halted, jump to PRG000_D054 (RTS)

	JSR Object_Move	 ; Perform standard object movements

PRG000_D054:
	RTS		 ; Return


	; If killed object falls too low, delete it
Object_FallAndDelete:
	LDA <Objects_YHiZ,X
	CMP #$02
	BLS PRG000_D054	 ; If object Y Hi < 2 (way low), jump to PRG000_D054

	; Do NOT return to caller!
	PLA
	PLA

PRG000_D068:
	JMP Object_SetDeadEmpty	 ; Jump to Object_SetDeadEmpty

ObjState_Squashed:
	JMP Object_SetDeadEmpty	
;	LDA Objects_Timer3,X 
;	BEQ PRG000_D090	 ; If timer 3 is expired, jump to PRG000_D090
;
;	JSR Object_Move	 ; Perform standard object movements
;
;	LDA <Objects_CollisionDetectionZ,X
;	AND #$04
;	BEQ PRG000_D07E	 ; If object did NOT hit ground, jump to PRG000_D07E
;
;	JSR Object_HitGround	 ; Align to ground
;	STA <Objects_XVelZ,X	 ; Clear X velocity
;
;PRG000_D07E:
;
;	; Set object frame to 3
;	LDA #$03
;	STA Objects_Frame,X
;
;	LDA Objects_ID,X
;	CMP #OBJ_ZOMBIEGOOMBA
;	BEQ PRG000_D08C
;	CMP #OBJ_GOOMBA
;	BNE PRG000_D08D	 ; If object is not a goomba, jump to PRG000_D08D (ObjectGroup_PatternSets, i.e. the "giant" enemy alternative)
;
;	JMP Object_ShakeAndDrawMirrored	 ; Draw goomba as mirrored sprite and don't come back
;
;PRG000_D08C:
;
;PRG000_D08D:
;	JMP ObjectGroup_PatternSets	 ; Do the giant enemy draw routine and don't come back
;
;PRG000_D090:
;	JMP Object_SetDeadEmpty	 ; Jump to Object_SetDeadEmpty (mark object as dead/empty)

Object_MaxFalls:
	.byte OBJECT_MAXFALL, OBJECT_MAXFALLINWATER

Object_MaxAntiGravity:
	.byte -OBJECT_MAXFALL, -OBJECT_MAXFALLINWATER
	; Gravity of object 
Object_Gravity:
	.byte OBJECT_FALLRATE, OBJECT_FALLRATEINWATER

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Move
;
; Links all code together to move an object with velocity
; including intersecting with the world etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D097
Object_Move:
	LDA <Objects_XVelZ,X	; Get Object's X velocity
	PHA		 	; Save it

	LDY Objects_InWater,X
	BEQ PRG000_D0A9	 	; If object is not in water, jump to PRG000_D0A9

	LDY Objects_State,X	
	CPY #OBJSTATE_NORMAL
	BEQ PRG000_D0A9	 	; If object's state is Normal, jump to PRG000_D0A9

	; This is basically an pseudo-ASR, a right shift preserving the sign
	ASL A			; Bit 7 pushed into carry
	ROR <Objects_XVelZ,X	; X velocity rotated right (divided by 2) and proper sign of bit 7 in place

PRG000_D0A9:
	JSR Object_ApplyXVel	 ; Applies object's X velocity

	PLA		 ; Restore Object's X velocity

	STA <Objects_XVelZ,X	 ; Undoes Object_ApplyXVel

Object_ApplyY_With_Gravity:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity without limit

	JSR Object_DetectTiles	 ; Detect against the world

	LDY Objects_InWater,X	; Y = whether in-water

	LDA <Objects_YVelZ,X
	BPL PRG000_D0CA	 	; If object is object is still or moving downward, jump to PRG000_D0CA

	; Object is moving upward...

	CPY #$00
	BEQ PRG000_D0CA	 ; If object is NOT in water, jump to PRG000_D0CA

	CMP #OBJECT_MAXWATERUPWARD
	BGE PRG000_D0CA	 ; If object's Y velocity is between OBJECT_MAXWATERUPWARD and 0, jump to PRG000_D0CA

	LDA #OBJECT_MAXWATERUPWARD	 
	STA <Objects_YVelZ,X ; Otherwise, cut off velocity at OBJECT_MAXWATERUPWARD

	BNE PRG000_D0CA	 ; Jump (technically always) to PRG000_D0CA (uhh... pointless, heh)

PRG000_D0CA:
	LDA NoGravity
	BNE PRG000_D0DE

	LDA ReverseGravity
	BNE PRG000_D0DF

	LDA <Objects_YVelZ,X
	ADD Object_Gravity,Y
	STA <Objects_YVelZ,X	; Apply gravity to object

	BMI PRG000_D0DE	 	; If Y velocity is negative, jump to PRG000_D0DE (RTS)

	CMP Object_MaxFalls,Y
	BLT PRG000_D0DE	 	; If object is not falling at the max rate, jump to PRG000_D0DE (RTS)

	LDA Object_MaxFalls,Y
	STA <Objects_YVelZ,X	; Cap fall at max rate

PRG000_D0DE:
	LDA #$00
	STA NoGravity
	RTS		 ; Return

PRG000_D0DF:
	LDA #$00
	STA ReverseGravity
	LDA <Objects_YVelZ,X
	SUB Object_Gravity,Y
	STA <Objects_YVelZ,X	; Apply gravity to object

	BPL PRG000_D0DE	 	; If Y velocity is negative, jump to PRG000_D0DE (RTS)

	CMP Object_MaxAntiGravity,Y
	BCS PRG000_D0DE	 	; If object is not falling at the max rate, jump to PRG000_D0DE (RTS)

	LDA Object_MaxAntiGravity,Y
	STA <Objects_YVelZ,X	; Cap fall at max rate
	RTS

ObjectHeld_WakeUpDir:	.byte $40, $00 

	; Handle shelled object "waking up" from a shelled state, if timer 3 expired...
Object_ShellDoWakeUp:

	; If object is a Bob-omb, jump to PRG000_D0EC, otherwise jump to PRG000_D101
	LDA Objects_ID,X	  
	CMP #OBJ_BOBOMB 
	BNE PRG000_D101

PRG000_D0EC: 

	; A Bob-omb only...

	LDA Objects_Timer,X 
	BNE PRG000_D0F9	 ; If timer is not expired, jump to PRG000_D0F9 

	; Timer expired, change to state 2 (Normal)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X 
	JMP BobOmb_Explode	 ; Jump to BobOmb_Explode and don't come back!

PRG000_D0F9:
	CMP #$40
	BGE PRG000_D100	 ; If timer ticks >= $40, jump to PRG000_D100 (RTS)
 
	STA Objects_ColorCycle,X	 ; In the last timer ticks, flash colors!

PRG000_D100:
	RTS		 ; Return

PRG000_D101:

	; Anything besides a Bob-omb...

	AND #$FE
	CMP #OBJ_ICEBLOCK ;
	BNE PRG000_D120	 ; If object is NOT an Ice Block, jump to PRG000_D120

	; Object is an ice block...  
	LDA #$01
	STA Objects_ColorCycle,X
	STA Objects_SpriteAttributes,X
	RTS		 ; Return


PRG000_D120:

	; Object is not a Bob-omb and not an Ice Block... 

	LDA Objects_Timer3,X 
	BNE PRG000_D15A	 ; If timer 3 is not expired, jump to PRG000_D15A (RTS) 

	LDA Objects_State,X 
	CMP #OBJSTATE_HELD
	BNE PRG000_D147	 ; If object is not currently being held, jump to PRG000_D147

	; Object is being held... 

	JSR Object_WorldDetectN1 
	LDA <Objects_CollisionDetectionZ,X 
	BEQ PRG000_D147	 ; If held object did not impact anything, jump to PRG000_D147 

	; Held object impacted...
 
	; 1 EXP for enemy defeated
	INC Exp_Earned

	JSR Reap_Coin

Dont_Coin_It6:
	LDA #OBJSTATE_KILLED
	STA Objects_State,X
 
	; Set object Y velocity to -$40 (fly up after death)
	LDA #-$40 
	STA <Objects_YVelZ,X
 
	; Halt horizontal movement
	LDA #$00 
	STA <Objects_XVelZ,X
 
	BEQ PRG000_D155	 ; Jump (technically always) to PRG000_D155

PRG000_D147: 

	; Held object did NOT impact... (time to wake up!)

	; Set object state to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	JSR ObjInit_TowardsPlayer
	PLA
	PLA

PRG000_D155:
PRG000_D15A:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Reverse
;
; Object reverses travel and facing direction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D15B 
Object_Reverse:
	LDA <Objects_XVelZ,X	 
	JSR Negate
	STA <Objects_XVelZ,X	 ; Negate object's X velocity

	LDA Objects_XVelFrac,X
	JSR Negate 
	STA Objects_XVelFrac,X

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_FlipFace
;
; Object reverses facing direction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D162
Object_FlipFace:
	LDA Objects_Orientation,X
	EOR #SPR_HFLIP
	STA Objects_Orientation,X	 ; Flip left/right flag

	RTS		 ; Return

PRG000_D16B:	.byte -$08, $08

Object_FaceMovement:
	LDA Objects_XVelZ, X
	BEQ Object_FaceMovement1
	LDA Objects_Orientation, X
	AND #~SPR_HFLIP
	STA Objects_Orientation, X
	LDA Objects_XVelZ, X
	BMI Object_FaceMovement1

	LDA Objects_Orientation, X
	ORA #SPR_HFLIP
	STA Objects_Orientation, X

Object_FaceMovement1:
	RTs

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_HandleBumpUnderneath
;
; Handles an object getting killed or shelled when hit from under
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D16D
Object_HandleBumpUnderneath:
	
	LDA Object_TileFeetValue 
	AND #$3F
	BEQ Object_HandleBumpUnderneath1
	RTS

	; Object detected a block bump tile (object got bumped)

Object_HandleBumpUnderneath1:
	; Set Y Vel to -$30 (bounce dead)
	LDA #-$30 
	STA <Objects_YVelZ,X
 
	JSR Level_ObjCalcXDiffs	; Detect which side object is on versus Player 

	; Store proper X velocity
	LDA PRG000_D16B,Y 
	STA <Objects_XVelZ,X

	; Vertically flip object 
	LDA #SPR_VFLIP
	STA Objects_Orientation,X
 
	LDY ObjGroupRel_Idx 
	LDA ObjectGroup_Attributes3,Y 
	AND #OA3_DIESHELLED
	BNE PRG000_D19E	 ; If OA3_DIESHELLED is SET (object may use special routine), jump to PRG000_D19E 

	; Object killed, get 100 pts

	INC Exp_Earned
	JSR Reap_Coin

	LDA #OBJSTATE_KILLED
	STA Objects_State,X 
	RTS

PRG000_D19E:
	LDA ObjGroupRel_Idx 
	ASL A 
	TAY		 ; Y = 2-byte index into CollideJumpTable
 

	LDA ObjectGroup_CollideJumpTable+1,Y	 ; Get the CollideJumpTable upper byte
	AND #%11111000
	CMP #%00001000
	BNE PRG000_D1B7	 ; If the upper byte is not ($08xx - $0Fxx), jump to PRG000_D1B7

	; SPECIAL JUMP TABLE VALUE ($08xx - $0Fxx): Change to alternate object

	; Change to alternate ObjectID in low byte
	LDA ObjectGroup_CollideJumpTable,Y
	STA Objects_ID,X
	; Get 100 pts

	INC Exp_Earned

PRG000_D1B7:
	JMP Object_SetShellState	 ; Jump to Object_SetShellState ("dies" into shelled state) 

PRG000_D1B8:
	RTS

IceBlockYRange: .byte $16, $16
IceBlockYOffset: .byte $0D, $1E
IceBlockStand:
;	RTS
;	LDA <Player_YVel
;	BMI Object_AttackOrDefeat1
;	JSR Level_ObjCalcXDiffs
;	LDA <Temp_Var16
;	BPL IceBlockStand1
;	JSR Negate
;
;IceBlockStand1:
;	CMP #$0D
;	BCS IceBlockStandRTS
;
;	JSR Level_ObjCalcYDiffs
;	CPY #$01
;	BNE IceBlockStandRTS
;
;	LDA <Player_Suit
;	BNE IceBlockStand23
;	DEY
;
;IceBlockStand23:
;	LDA <Temp_Var16
;	BPL IceBlockStand2
;	JSR Negate
;
;IceBlockStand2:
;	SUB IceBlockYRange, Y
;	CMP #$0A
;	BCS Object_AttackOrDefeat1
;
;	LDA Objects_YZ, X
;	SUB IceBlockYOffset, Y
;	STA <Player_Y
;	LDA <Objects_YHiZ, X
;	SBC #$00
;	STA <Player_YHi
;	LDA #$00
;	STA <Player_YVel
;	STA <Player_InAir
;
;IceBlockStandRTS:
;	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_AttackOrDefeat
;
; General routine for how the object responds to a Player 
; colliding with it (good and bad)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D1BA

Object_AttackOrDefeat:
	JSR Object_HitTest	; Check for collision

	; Clear hit status bits
	LDA #$00
	STA Objects_PlayerHitStat,X

	BCS PRG000_D1C5	 ; If collision occurred, jump to PRG000_D1C5

PRG000_D1C4:
	RTS		 ; Return

PRG000_D1C5:
	LDA Objects_Timer2,X
	BNE PRG000_D1C4	 ; If timer 2 hasn't expired, jump to PRG000_D1C4 (RTS)

	; Timer 2 has expired...


	; Player is not sliding...

	LDY ObjGroupRel_Idx	 ; Y = object group relative index
	LDA ObjectGroup_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_GNDPLAYERMOD
	BEQ PRG000_D218	 ; If OA2_GNDPLAYERMOD not set, jump to PRG000_D218

	; Object attribute set 2 bit 1 is set...

	; What does this do?
	; First off, Player must be on solid ground
	; Then, either the object is falling faster than $0A OR the object is on the ground
	; In those cases, we jump to Object_HoldKickOrHurtPlayer

	; The only real apparent function here is that a fast-falling or grounded object
	; will force into the "Hold, Kick, or Hurt Player" routine without doing the
	; the other checks, but with the Player being on the ground, it's hard for him
	; not to get hit anyway.  As such, I can't really for sure tell what the 
	; intention of this code was really supposed to be??

	; Otherwise it is PRG000_D218

	LDA <Player_InAir
	BNE PRG000_D218	 ; If Player is mid air, jump to PRG000_D218

	; Player is on solid ground...

	LDA <Objects_YVelZ,X
	CMP #$0a	 
	BLS PRG000_D212	 ; If Object's Y velocity < $0A, jump to PRG000_D212

PRG000_D20F:
	JMP Object_HoldKickOrHurtPlayer	 ; Otherwise, jump to Object_HoldKickOrHurtPlayer

PRG000_D212:

	; Object's Y velocity < $0A ...

	LDA <Objects_CollisionDetectionZ,X
	AND #$04	 
	BNE PRG000_D20F	 ; If object has hit ground, jump to PRG000_D20F (to Object_HoldKickOrHurtPlayer)

PRG000_D218:

	; Object attribute set 2 bit 1 not set...
	; OR Player is mid-air...
	; OR Player is sliding...

	; Remember, this is after the bounding boxes have already been used
	; to determine there's some kind of collision; we're just find tuning
	; if this is a successful "stomp" or not...
	;
	; 'Y' represents the "height" of the object for collision detection
	; The way to think about this is we're going to reference Objects_Y
	; which in SMB3 is generally the "top" of the enemy, or in any case
	; point at which "stomp" should occur.  (Of note, Koopa Troopa's 
	; "top" is their shell; the head is drawn as a negative coordinate 
	; from that point.)  The judgement is based on Player_Y, which is the
	; "top" of the Player (note for "Super" Mario, that's near the hat,
	; but for "small" Mario, that's roughly 16 pixels above.)
	;
possibl	; G = Goomba (for example)
	;
	; . <-- This would be 19 (for this example) pixels above 
	; |
	; G <-- top of 'Goomba' is Objects_Y
	;
	; .   m <-- Top of Player must be beneath the 19 pixel offset
	; |   M
	; G
	;
	; ... if the above is true, that's considered "stompable" range.
	LDY #19	 	; Y = 8 (not the first two, if object is giant set)

PRG000_D22E:
	STY <Temp_Var2		 ; -> Temp_Var2 (height above object considered "stompable" range)

	LDA <Objects_YZ,X	 ; Get object's Y
	SUB <Temp_Var2		 ; Subtract Temp_Var2 (height above object considered "stompable" range)
	ROL <Temp_Var1		 ; Stores the carry bit into Temp_Var1 bit 0
	CMP <Player_Y

	PHP		 ; Save CPU state (the comparison)

	LSR <Temp_Var1		; Restore the carry bit
	LDA <Objects_YHiZ,X	
	SBC #$00	 	; Apply the carry bit to the Objects_YHiZ as needed for the height subtraction

	PLP		 ; Restore CPU state (the comparison)

	SBC <Player_YHi		; Get the difference against the Player_YHi
	BMI PRG000_D20F	 	; If negative (Player_YHi > Objects_YHiZ, Player is lower), jump to PRG000_D20F (Object_HoldKickOrHurtPlayer)

	LDA <Player_YVel	
	BPL PRG000_D253	 	; If Player's Y Velocity >= 0 (stationary or moving downward), jump to PRG000_D253

	; Player moving upward, not flying...

	;LDA Kill_Tally	 
	;BEQ PRG000_D20F	 	; If Player hasn't killed anything yet, jump to PRG000_D20F (Object_HoldKickOrHurtPlayer)

PRG000_D253:
	LDA #$01
	STA Objects_PlayerHitStat,X

	LDA Objects_State, X
	CMP #OBJSTATE_SHELLED
	BEQ PRG000_D268

	LDA Player_InWater
	ORA Invincible_Enemies
	BNE PRG000_D267	 ; If Player is in water, jump to PRG000_D267

PRG000_D268:
	LDA Player_Equip
	CMP #BADGE_BOOTS
	BEQ PRG000_D272
	LDY ObjGroupRel_Idx	 ; Y = group relative index
	LDA ObjectGroup_Attributes3,Y	 ; Get object's attribute 3 setting
	AND #OA3_NOTSTOMPABLE	 
	BEQ PRG000_D272	 ; If OA3_NOTSTOMPABLE NOT set (Object is stompable), jump to PRG000_D272

PRG000_D267:

	; Player is in water (can't stomp in water) OR attribute 3 bit 5 is set (can't stomp anyway)...

	JMP PRG000_D355	 ; Jump to PRG000_D355 (hurt Player!)

PRG000_D272:

	LDY ObjGroupRel_Idx	 ; Y = group relative index
	LDA ObjectGroup_Attributes2,Y	 ; Get object attribute set 2
	AND #OA2_STOMPDONTCARE	 
	BNE PRG000_D2B3	 	; If OA2_STOMPDONTCARE is set (object is indifferent about stomping), jump to PRG000_D2B3 (RTS)

	; Attribute set 2 bit 2 NOT set... (object cares about being stomped)

	LDA #$00
	BEQ PRG000_D29B	 	; If Player is NOT a statue and NOT in a Kuribo's shoe, jump to PRG000_D29B

	; Player is a statue or in a Kuribo's shoe...

Object_FinishStompKill:
	JSR PRG000_D2B4	 ; Handle stomp!

	LDY ObjGroupRel_Idx	 ; Y = object group relative index
	LDA ObjectGroup_Attributes3,Y	 ; Get attribute set 3
	AND #OA3_SQUASH
	BEQ PRG000_D295	 ; If OA3_SQUASH NOT set, jump to PRG000_D295 (kill it)


	LDA #OBJSTATE_SHELLED	 ; Otherwise, state is Shelled
	BNE PRG000_D297	 ; Jump (technically always) to PRG000_D297

PRG000_D295:


	LDA #OBJSTATE_KILLED	 ; State is Killed

PRG000_D297:
	STA Objects_State,X	 ; Set appropriate object state
	LDA Kill_Tally
	STA Exp_Earned
	INC Kill_Tally
	LDA #$01
	STA Player_InAir

PRG000_D2B3
	RTS		 ; Return


PRG000_D29B:

	; Player NOT a statue and NOT in a Kuribo's shoe stomp code

	LDA Objects_State,X
	CMP #OBJSTATE_SHELLED
	BNE PRG000_D2B4	 ; If object state is not shelled, jump to PRG000_D2B4 (typical stomp)

PRG000_D2A2:
	JMP Object_GetKicked	 ; Player kicks the enemy


PRG000_D2B4:

	; Set timer 2 to 8
	LDA #$08	 
	STA Objects_Timer2,X

	; Set Player's Y velocity to -$40 (bounce!)
	LDA #-$40
	STA <Player_YVel
	STA Player_InAir

	; Play squish sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	DEC Objects_HitCount,X	; HitCount--
	BPL PRG000_D2B3	 ; If hits remain, jump to PRG000_D2B3 (RTS)

	LDA ObjGroupRel_Idx	 ; A = object group relative index
	ASL A		 ; Shift left 1 (2 byte index)
	PHA		 ; Save this

	TAY		 ; -> 'Y'

PRG000_D2E4:
	LDA Kill_Tally
	STA Exp_Earned
	INC Kill_Tally
	JSR Reap_Coin

	PLA		 ; Restore index into CollideJumpTable
	TAY		 ; -> 'Y'

	LDA ObjectGroup_CollideJumpTable+1,Y	 ; Get the CollideJumpTable upper byte
	AND #%11111000
	CMP #%00001000
	BNE PRG000_D301	 ; If the upper byte is not ($08xx - $0Fxx), jump to PRG000_D301

	; SPECIAL JUMP TABLE VALUE ($08xx - $0Fxx): Change to alternate object

	; Change to alternate ObjectID in low byte
	LDA ObjectGroup_CollideJumpTable,Y
	STA Objects_ID,X

	INC Objects_HitCount,X	 ; Give hit back (restore to zero)
	JMP PRG000_D31E	 ; Jump to PRG000_D31E

PRG000_D301:
	LDY ObjGroupRel_Idx	 ; Y = object group relative index
	LDA ObjectGroup_Attributes2,Y	 ; Get object attributes set 2
	AND #OA2_NOSHELLORSQUASH	 
	BEQ PRG000_D323	 	; If OA2_NOSHELLORSQUASH is NOT set (shelled enemy), jump to PRG000_D323

	; Cancel the "Squish" sound, use the "kick" sound instead!
	LDA Sound_QPlayer
	AND #~SND_PLAYERSWIM
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Set object state to 6 (killed)
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVelZ,X

PRG000_D31E:
	; Halt vertical movement
	LDA #$00
	STA <Objects_YVelZ,X

	RTS		 ; Return

PRG000_D323:
	INC Objects_HitCount,X	 ; Give hit back (restore to zero)

Object_SetShellState:
	; Set Objects_State to Shelled
	LDA #OBJSTATE_SHELLED
	STA Objects_State,X
	
	PHP
	LDA Objects_ID, X
	CMP #OBJ_PURPLETROOPA
	BEQ FuseTroopa

	; Set timer 3 = $FF (wake up timer)
	LDA #$ff
	STA Objects_Timer3,X

	PLP
	RTS		 ; Return

FuseTroopa:
	LDA #$80
	STA Objects_Timer3, X
	PLP
	RTS

Object_HoldKickOrHurtPlayer:
	LDA Objects_ID, X
	CMP #OBJ_ICEBLOCK
	BEQ PRG000_D343

	LDA Objects_State,X
	CMP #OBJSTATE_SHELLED
	BNE PRG000_D355	 ; If object state is not Shelled, jump to PRG000_D355 (hurt Player!)


PRG000_D343:
	LDA Player_ISHolding_OLD
	BNE PRG000_D39F	 ; If Player WAS holding something, jump to PRG000_D39F (RTS)

	BIT <Pad_Holding
	BVS PRG000_D34F	 	; If Player is holding B, jump to PRG000_D34F
	JMP Player_KickObject	 ; Kick away the object and don't come back!

PRG000_D34F:

	; Keep held object in state 4 (Held)
	LDA #OBJSTATE_HELD
	STA Objects_State,X

	RTS		 ; Return


PRG000_D355:

	; Player potentially gonna get hurt!
	LDA Player_FlashInv	; If Player is flashing from getting hit recently...
	ORA Objects_Timer2,X	; ... or this object's timer2 is not expired ...
	ORA Player_StarInv	; ... or Player is invincible by Star Man ...
	BNE PRG000_D39F	 	; ... then jump to PRG000_D39F (RTS)

	LDA Objects_State,X
	CMP #OBJSTATE_KICKED
	BNE PRG000_D382	 	; If object's state is not Kicked, jump to PRG000_D382

	LDY #$00	 ; Y = 0

	LDA <Player_XVel
	BEQ PRG000_D382	 ; If Player is not moving horizontally, jump to PRG000_D382
	BPL PRG000_D373	 ; If Player is moving to the right, jump to PRG000_D373

	INY		 ; Otherwise, Y = 1

PRG000_D373:
	STY <Temp_Var1		 ; Temp_Var1 = 0 (Player moving left) or 1 (Player moving right)

	EOR <Objects_XVelZ,X	 ; Check for X velocity sign difference between Player and object
	BMI PRG000_D382	 	; If there's a difference in sign, jump to PRG000_D382

	; Object and Player are moving in the same horizontal direction...

	JSR Level_ObjCalcXDiffs	
	CPY <Temp_Var1
	BNE PRG000_D39F	 ; If Player is moving away from object, jump to PRG000_D39F
	BEQ PRG000_D39C	 ; Otherwise, jump to PRG000_D39C

PRG000_D382:

PRG000_D39C:
	JMP Player_GetHurt	; Hurt Player and don't come back!

PRG000_D39F:
	RTS		 ; Return

	; A very popular RTS @ $D3A0
ObjState_DeadEmpty:
ObjInit_DoNothing:
ObjNorm_DoNothing:
ObjHit_DoNothing:
ObjHalt_DoNothing:
LevelEvent_DoNothing:
	RTS		 ; Return

	; Called for an object in state 1 to perform initialization logic
ObjState_Initializing:
	JSR Level_PrepareNewObject ; Prepare the object

	INC Objects_State,X	 	; Set object state to 2 (Normal run)
	JSR Object_SetPaletteFromAttr	; Set object's palette

	LDA ObjGroupRel_Idx	 ; Get object's group relative index
	ASL A		 ; Shift left 1 (2 byte index)
	TAY		 ; -> Y

	; Get jump address specific to this object
	LDA ObjectGroup_InitJumpTable,Y
	STA <Temp_Var1
	LDA ObjectGroup_InitJumpTable+1,Y
	STA <Temp_Var2
	JMP [Temp_Var1]	 ; Dynamically jump to object's init routine 

	; Set object's palette value
; $D3BC
Object_SetPaletteFromAttr:
	LDY ObjGroupRel_Idx	 	; Y = object's relative group index
	LDA ObjectGroup_Attributes,Y	; Get attributes
	AND #OA1_PALMASK 		; Keep only bits 0 and 1 (palette)
	STA Objects_SpriteAttributes,X	 	; Set this object's palette
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DeleteOffScreen
;
; The routine that removes objects if they go off-screen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Vertical level
PRG000_D3C8:	.byte $40, $B0	; Lo
PRG000_D3CA:	.byte $01, $FF	; Hi

	; Non-vertical level -- selectable remove sizes
PRG000_D3CC:	.byte $20, $D0, 	$80, $80, 	$40, $B0	; Lo
PRG000_D3D2:	.byte $01, $FF, 	$01, $FF, 	$01, $FF	; Hi

	; The different "N" varieties specify how wide before the deletion occurs

	; $D3D8
Object_DeleteOffScreen_N4:
	LDA #$04	 ; A = 4
	BNE PRG000_D3EF	 ; Jump (technically always) to PRG000_D3EF

	; $D3DC
Object_DeleteOffScreen_N2:
	LDA #$02	 ; A = 2
	BNE PRG000_D3EF	 ; Jump (technically always) to PRG000_D3EF

	; $D3E0
Object_DeleteOffScreen:
	LDA Objects_UseShortHTest,X	 
	BEQ PRG000_D3ED	 ; If object wants to use "short" horizontal test, jump to PRG000_D3ED

	LDA Objects_SpritesHorizontallyOffScreen,X
	BNE Object_DeleteOffScreen_N2	 ; If any sprites are horizontally off-screen, jump to Object_DeleteOffScreen_N2

	STA Objects_UseShortHTest,X	 ; Clear Objects_UseShortHTest

PRG000_D3ED:
	LDA #$00	 ; A = 0

PRG000_D3EF:
	STA <Temp_Var1	 ; Temp_Var1 = 0, 2, or 4 

	JSR Object_AnySprOffscreen
	BEQ PRG000_D463	 ; If any sprites are off-screen, jump to PRG000_D463


	; LEVEL NOT VERTICAL

	LDA <Objects_YHiZ,X
	CMP #$02	 
	BPL Object_Delete	 ; If object Y Hi >= 2 (way off screen), jump to Object_Delete

	; Semi-randomly jump to PRG000_D463 (RTS)
	; That is, only occasionally actually do the off-screen check
	; Keeps down on CPU cycles spent wondering about the object
	TXA		 
	ADD <Counter_1	
	LSR A		 ; A = (object index + Counter_1) >> 1
	BCS PRG000_D463	 ; If carry set, jump to PRG000_D463 (RTS)

	AND #$01
	STA <Temp_Var2	 ; Temp_Var2 stores bit 0 from above; thus 0 or 1

	ADC <Temp_Var1	 ; So value is now 0-5
	TAY		 ; -> 'Y'

	LDA <Horz_Scroll
	ADD PRG000_D3CC,Y	 ; Horizontal scroll plus offset

	ROL <Temp_Var1		 ; Temp_Var1 is 0/1, 4/5

	CMP <Objects_XZ,X	 ; Compare to object X
	PHP		 	; Save CPU state

	LDA <Horz_Scroll_Hi	 
	LSR <Temp_Var1		 
	ADC PRG000_D3D2,Y	 ; Add high part of offset

	PLP		 	; Restore CPU state

	SBC <Objects_XHiZ,X	 
	STA <Temp_Var1		 ; Temp_Var1 is X Hi difference               
      
	LDY <Temp_Var2		 ; Y = Temp_Var2
	BEQ PRG000_D42E	 	; If zero, jump to PRG000_D42E

	EOR #$80	 	
	STA <Temp_Var1		; Temp_Var1 ^= $80

PRG000_D42E:
	LDA <Temp_Var1	
	BPL PRG000_D463	 ; If positive, jump to PRG000_D463 (RTS)

	; Deletes object, marks it so it will reappear next time it comes on-screen
Object_Delete:
	LDA Objects_ID,X

	; If object ID is OBJ_FIRECHOMP, OBJ_CHAINCHOMPFREE, OBJ_VEGGIEGUY, 
	; OBJ_SKULLBLOOPER, or OBJ_FIRESNAKE, jump to PRG000_D449	
	; These objects are hardcoded to release their X/Y Buffer allocations!

	CMP #OBJ_CHAINCHOMPFREE	
	BEQ PRG000_D449	

	CMP #OBJ_FIRESNAKE
	BNE Object_SetDeadAndNotSpawned	 

PRG000_D449:

	; One of the above five objects ONLY!

	LDY Objects_Data6,X ; Y = Var6 (should be 0 or 1, the buffer slot the object occupies)

	; Clear the occupation of the X/Y Buffer
	LDA #$00
	STA Buffer_Occupied,Y

Object_SetDeadAndNotSpawned:
	LDY Objects_SpawnIdx,X	 ; Get the spawn index of this object
	BMI Object_SetDeadEmpty	 ; If object is spawned, jump to Object_SetDeadEmpty

	; Clear object spawn flag
	LDA Level_ObjectsSpawned,Y
	AND #$7f
	STA Level_ObjectsSpawned,Y

Object_SetDeadEmpty: 
	; Mark object as dead/empty
	LDA Objects_ID,X
	CMP #OBJ_SWOOSH
	BEQ Object_SetDeadEmpty0

	CMP #OBJ_PIXIE
	BNE Object_SetDeadEmpty1

Object_SetDeadEmpty0:
	LDY Objects_SpawnIdx,X
	LDA Level_ObjectsSpawned,Y
	AND #$7f
	STA Level_ObjectsSpawned,Y

Object_SetDeadEmpty1:
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X
	LDA #$00
	STA Objects_ID,X

PRG000_D463:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_PrepareNewObject
;
; Prepares a new object by initializing all of the many object
; variables to zero...
;
; X = index of on-screen object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D499
Level_PrepareNewObject:
	
	; Clear various object variables
	LDA #$00
	STA Objects_Data4,X
	STA Objects_Data5,X
	STA <Objects_SpriteX,X
	STA Objects_Timer,X
	STA Objects_Timer2,X
	STA <Objects_XVelZ,X
	STA <Objects_YVelZ,X
	STA Objects_Orientation,X
	STA Objects_Frame,X	
	STA Objects_ColorCycle,X
	STA <Objects_CollisionDetectionZ,X
	STA Objects_PreviousCollisionDetection,X


	CPX #$06
	BGE PRG000_D4C8	 ; If using slot index >= 6, jump to PRG000_D4C8 (skip variables available only to slots 0 to 5)

	; Clear some more variables (object slots 0 to 5 ONLY)
	STA Objects_DisPatChng,X
	STA ObjSplash_DisTimer,X
	STA Objects_QSandCtr,X
	STA Objects_InWater,X

PRG000_D4C8:
	STA Objects_IsGiant,X
	CPX #$05
	BGE PRG000_D506	 ; If using slot index >= 5, jump to PRG000_D506 (skip variables available only to slots 0 to 4)

	; Clear even more variables (object slots 0 to 4 [major objects] ONLY!!)
	STA Objects_PlayerHitStat,X
	STA Objects_Timer4,X
	STA Objects_Timer3,X
	STA Objects_Slope,X
	STA Objects_Data3,X
	STA <Objects_Data2,X
	STA <Objects_Data1,X
	STA Objects_Data3,X	
	STA Objects_Data6,X	 
	STA Objects_TargetingXVal,X
	STA Objects_TargetingYVal,X
	STA Objects_UseShortHTest,X
	STA Objects_HitCount,X
	STA Objects_DisPatChng,X
	STA Objects_Data8,X
	STA Objects_Data9,X
	STA Objects_Data10,X
	STA Objects_Data11,X
	STA Objects_Data12,X

PRG000_D506:
	RTS		 ; Return


	; Called for an object in state 2 to do its "normal" routine
ObjState_Normal:
	LDA <Player_HaltGameZ
	BEQ Object_DoNormal	 ; If gameplay is NOT halted by the Player, jump to Object_DoNormal

	JMP Object_DoHaltedAction	 ; Jump to Object_DoHaltedAction

Object_DoNormal:
	LDA ObjGroupRel_Idx
	ASL A		 
	TAY		 ; Y = object's group relative index * 2 (2 byte index for jump table)
	
	; Get jump address specific to this object
	LDA ObjectGroup_NormalJumpTable,Y
	STA <Temp_Var1
	LDA ObjectGroup_NormalJumpTable+1,Y
	STA <Temp_Var2
	JMP [Temp_Var1]	 ; Dynamically jump to object's "normal" routine 


Object_DoHaltedAction:

	; Gameplay is halted, determine what needs to happen with this object...

	LDY ObjGroupRel_Idx	 ; Y = group relative index 

	LDA ObjectGroup_Attributes3,Y	; Get attribute set 3 bits
	AND #OA3_HALT_MASK 		; Keep only the lowest 4
	JSR DynJump	 

	; WARNING: Read comment; some of these are specific to object banks!

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bank2_HotFootHaltAction		; 0: Bank2/Hotfoot ONLY
	.word Object_ShakeAndDraw		; 1: Standard draw
	.word Object_Draw16x32Sprite		; 2: Draw tall sprite
	.word ObjHalt_DoNothing		; 3: Bank2/Spike ONLY
	.word ObjHalt_DoNothing			; 4: Do nothing
	.word ObjHalt_DoNothingNotNormal	; 5: If object is in "normal" state, do its normal routine, otherwise do nothing (COMMON)
	.word Object_DrawWide			; 6: Draw wide sprite
	.word ObjHalt_DoNothing			; 7: Do nothing
	.word ObjHalt_DoNothing			; 8: Bank2/Kuribo's Shoe ONLY
	.word ObjHalt_DoNothing			; 9: Do nothing
	.word Object_ShakeAndDrawMirrored	; 10: Draw mirrored sprite
	.word ObjHalt_DoNothing			; 11: Bank2/End Level Card ONLY
	.word ObjHalt_DoNothing			; 12: Do nothing
	.word Buster_DrawHoldingIceBrick	; 13: Bank2/Buster Beatle ONLY
	.word Bank2_PiranhaSpikeHaltAction	; 14: Bank2/Piranha Spike Ball ONLY

ObjHalt_DoNothingNotNormal:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG000_D553	 ; If object's state is not Normal, jump to PRG000_D553

	JMP Object_DoNormal	 ; Otherwise, jump to Object_DoNormal (jump into object's "Normal" routine)

PRG000_D553:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcSpriteXY_NoHi
;
; Calculate SpriteX/Y without considering the "High" parts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D554
Object_CalcSpriteXY_NoHi:
	LDA <Objects_YZ,X
	SUB Level_VertScroll
	STA <Objects_SpriteY,X

	LDA <Objects_XZ,X
	SUB <Horz_Scroll
	STA <Objects_SpriteX,X

	RTS		 ; Return


; $D564
Fish_FixedY_ExceptHitFloor:
	LDA <Objects_CollisionDetectionZ,X
	AND #$04
	BNE PRG000_D588	 ; If object has hit floor, jump to PRG000_D588

; $D56A
Fish_FixedYIfAppro:
	LDA Level_AScrlConfig
	BEQ PRG000_D588	 ; If no auto scroll effect active (assuming fixed height water level), jump to PRG000_D588 (RTS)

	LDA Level_FreeVertScroll
	CMP #$01
	BEQ PRG000_D588	 ; If this level has free vertical scrolling, jump to PRG000_D588

	LDY #$00	 ; Y = 0 (16-bit carry)

	LDA Level_ScrollDiffV
	BPL PRG000_D57E	 ; If desired vertical scroll is not negative, jump to PRG000_D57E

	DEY 		; Y = $FF (16-bit carry)

PRG000_D57E:

	; In fixed-height, locked scrolling water levels, Big Bertha's
	; Object_Y position offsets from the scroll position
	ADD <Objects_YZ,X
	STA <Objects_YZ,X
	TYA
	ADC <Objects_YHiZ,X
	STA <Objects_YHiZ,X

PRG000_D588:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ShakeAndCalcSprite
;
; The routine for a held object to "shake awake" (shelled enemies)
; and calculates sprite related info
;
; X = index of on-screen object
;
; Returns lots of stuff:
; Temp_Var1 = Object sprite Y
; Temp_Var2 = Object sprite X
; Temp_Var3 = Object's LR flag
; Temp_Var4 = Object's attributes
; Temp_Var5 = Objects_SpritesVerticallyOffScreen
; Temp_Var6 = Object's starting tiles index (and -> 'X')
; Temp_Var7 = Object's Sprite_RAM offset (and -> 'Y')
; Temp_Var8 = Objects_SpritesHorizontallyOffScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D589
Object_ShakeAndCalcSprite:
	LDA <Objects_YZ,X	; Get object's Y
	SUB Level_VertScroll	; Make relative
	STA <Objects_SpriteY,X	; Store as sprite Y
	STA <Temp_Var1		; Also -> Temp_Var1

	; This is the object "shakin' awake" routine!  (Enemies in shell etc.)
 
	SEC		 ; Set carry (remember, this is the default for not applying carry to subtraction)

	LDA Objects_Timer4,X
	BEQ PRG000_D5A0	 ; If Timer4 = 0, jump to PRG000_D5A0

	CMP #$40
	BLT PRG000_D59F	 ; If Timer4 < $40, jump to PRG000_D59F

	LSR A
	LSR A

PRG000_D59F:
	LSR A	; Shift right 1 (if Timer4 < $40) or 3 (basically applies a carry sort of sporadically for "shakin' awake")

PRG000_D5A0:
	LDA <Objects_XZ,X	; Get object's X
	SBC <Horz_Scroll	; Make relative
	STA <Objects_SpriteX,X	; Store as sprite X
	STA <Temp_Var2		; Also -> Temp_Var2

	LDA Objects_Orientation,X
	STA <Temp_Var3		; Temp_Var3 = object's LR flag

	LDY ObjGroupRel_Idx	; Y = object's group relative index

	LDA Objects_ColorCycle,X
	BEQ PRG000_D5BC	 	; If Objects_ColorCycle = 0, jump to PRG000_D5BC

	DEC Objects_ColorCycle,X	; Objects_ColorCycle--
	AND #$03	 
	BPL PRG000_D5BF	 	; Jump (technically always) to PRG000_D5BF

PRG000_D5BC:
	LDA Objects_SpriteAttributes,X	; Otherwise, just get the normal attributes

PRG000_D5BF:
	STA <Temp_Var4		; Decided attributes -> Temp_Var4

	LDA Objects_SpritesVerticallyOffScreen,X
	STA <Temp_Var5		; Temp_Var5 = Objects_SpritesVerticallyOffScreen

	LDA Objects_SpritesHorizontallyOffScreen,X
	STA <Temp_Var8		; Temp_Var8 = Objects_SpritesVerticallyOffScreen

	; Each "frame" value moves up two bytes to the next pair
	LDA Objects_Frame,X
	ASL A	
	STA <Temp_Var6		; Temp_Var6 = Objects_Frame << 1

	LDA ObjectGroup_PatternStarts,Y
	ADD <Temp_Var6	
	STA <Temp_Var6		; Temp_Var6 += ObjectGroup_PatternStarts[Y] (set base tile index)

	TAX		 	; -> 'X' 

	LDY <CurrentObjectIndexZ	; Y = object slot index

	LDA Object_SpriteRAM_Offset,Y
	STA <Temp_Var7		; Temp_Var7 = Object_SpriteRAM_Offset[Y] 

	TAY		 	; -> 'Y' 

	RTS		 ; Return

PRG000_D5E3:
	.byte $08, $04, $02, $01

	; Object "shaking awake" and draw its sprite
; $D5E7

Object_ShakeAndDrawAligned:
	LDA #$01
	STA AlignSpriteFlag
	BNE Object_ShakeAndDraw1

Object_ShakeAndDraw:
	LDA #$00
	STA AlignSpriteFlag

Object_ShakeAndDraw1:
	JSR Object_ShakeAndCalcSprite
	JSR Object_Draw16x16Sprite

	LDA AlignSpriteFlag
	BEQ Object_ShakeAndDraw2

	TYA
	TAX
	DEC Sprite_RAM,X
	DEC Sprite_RAM+4,X

Object_ShakeAndDraw2:
	LDX <CurrentObjectIndexZ
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ShakeAndDrawMirrored
;
; Used to draw 16x16 mirrored object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D5F0
Object_ShakeAndDrawMirroredAligned:
	LDA #$01
	STA AlignSpriteFlag
	BNE Object_ShakeAndDrawMirrored0


Object_ShakeAndDrawMirrored:
	LDA #$00
	STA AlignSpriteFlag

Object_ShakeAndDrawMirrored0:
	JSR Object_ShakeAndDraw	; Draw object and "shake awake"
	LDA AlignSpriteFlag
	BEQ Object_ShakeAndDrawMirrored1

	TYA
	TAX
	DEC Sprite_RAM,X
	DEC Sprite_RAM+4,X
	LDX <CurrentObjectIndexZ

Object_ShakeAndDrawMirrored1:
	; Keep all attributes except horizontal flip
	LDA Sprite_RAM+$02,Y
	AND #%10111111	 
	STA Sprite_RAM+$02,Y

	; Flip opposite sprite
	ORA #$40
	STA Sprite_RAM+$06,Y

	RTS		 ; Return

; $D601
Object_DrawTallAndHFlip:
	JSR Object_Draw16x32Sprite	 ; Draw tall sprite

	; Reverse sprites
	LDA Sprite_RAM-$06,Y
	AND #%10111111
	STA Sprite_RAM-$06,Y

	STA Sprite_RAM+$02,Y
	ORA #$40
	STA Sprite_RAM-$02,Y

	STA Sprite_RAM+$06,Y

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Draw16x32Sprite
;
; Used to draw 16x32 object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D618
Object_Draw16x32Sprite:
	JSR Object_ShakeAndCalcSprite

	LDX <CurrentObjectIndexZ	; X = object slot index

	LDA Objects_Frame,X
	ASL A		 
	ADD <Temp_Var6	
	STA <Temp_Var6	 ; Temp_Var6 += object's frame
	TAX		 ; -> 'X'

	LDA <Temp_Var3	 ; Objects_Orientation
	BPL PRG000_D62D	 ; If Objects_Orientation bit 7 is NOT set, jump to PRG000_D62D

	; Otherwise...
	INX
	INX		 ; X += 2

PRG000_D62D:
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LSR <Temp_Var5	 ; Objects_SpritesVerticallyOffScreen

	; 'Y' += 8 (Sprite RAM 2 sprites over)
	TYA
	ADD #$08
	TAY	

	LDX <Temp_Var6	 ; X = Temp_Var6 (starting tile)

	LDA <Temp_Var3	 ; Objects_Orientation
	BMI PRG000_D63F	 ; If Objects_Orientation bit 7 set, jump to PRG000_D63F

	; Otherwise...
	INX
	INX		 ; X += 2

PRG000_D63F:
	LDA #16
	ADD <Temp_Var1	 ; Sprite Y
	STA <Temp_Var1	 ; Temp_Var1 += 16

	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LDX <CurrentObjectIndexZ		 ; X = object slot index

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DrawWide
;
; Draws a wide 48x16 object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_DrawWide:
	JSR Object_ShakeAndCalcSprite

	LDX <CurrentObjectIndexZ	; X = object's slot index

	; Calculate offset into the ObjectGroup_PatternSets table
 
	LDA Objects_Frame,X
	ADD <Temp_Var6	
	STA <Temp_Var6		; Temp_Var6 += object's frame
	TAX		 	; -> 'X'
	JSR Object_Draw24x16Sprite	; Draw wide sprite

	LDX <CurrentObjectIndexZ	 ; X = object's slot index
	RTS		 ; Return


VisMask:
	.byte $81, $41, $21, $11, $82, $42, $22, $12

SprRAMOffset:
	.byte $00, $04, $08, $0C, $10, $14, $80, $80

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Draw16x16Sprite
;
; Used to draw 16x16 object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D680
Object_Draw16x16Sprite:
; Temp_Var1 = Object sprite Y
; Temp_Var2 = Object sprite X
; Temp_Var3 = Object's LR flag
; Temp_Var4 = Object's attributes
; Temp_Var5 = Objects_SpritesVerticallyOffScreen
; Temp_Var6 = Object's starting tiles index (and -> 'X')
; Temp_Var7 = Object's Sprite_RAM offset (and -> 'Y')
; Temp_Var8 = Objects_SpritesHorizontallyOffScreen
	LDA <Temp_Var5	; Check sprite vertical visibility
	LSR A		; Shift right (checking lowest bit)
	BCS PRG000_D693	; If this bit is set, this sprite piece is invisible, jump to PRG000_D6C6 (RTS)

	LDA <Temp_Var1	; Get sprite Y

	BIT <Temp_Var8	; Testing bit 7 of horizontal sprite visibility
	BMI PRG000_D68E	; If bit 7 is set (this sprite is horizontally off-screen), jump to PRG000_D68E

	STA Sprite_RAM+$00,Y	 ; Otherwise, OK to set sprite Y

PRG000_D68E:
	BVS PRG000_D693	 ; If bit 6 is set, jump to PRG000_D693

	STA Sprite_RAM+$04,Y	 ; Otherwise, OK set second sprite Y

PRG000_D693:
	LDA <Temp_Var2		; Get sprite X
	STA Sprite_RAM+$03,Y	; Store into Sprite RAM

	ADD #$08	 	; +8 for next sprite over
	STA Sprite_RAM+$07,Y	; Store into second sprite

	LDA ObjectGroup_PatternSets,X	; Get first sprite pattern index
	STA Sprite_RAM+$01,Y	; -> Sprite RAM

	LDA ObjectGroup_PatternSets+1,X	; Get second sprite pattern index
	STA Sprite_RAM+$05,Y	; -> Sprite RAM

	LDA <Temp_Var3		 
	ORA <Temp_Var4		 ; Joins base attributes to H-flip flag
	STA Sprite_RAM+$02,Y	 ; Store into both sprite's attributes
	STA Sprite_RAM+$06,Y	 ; Store into both sprite's attributes

	BIT <Temp_Var3		
	BVC PRG000_D6C6	 ; If sprite is not horizontally flipped, jump to PRG000_D6C6 (RTS)

	; If flipped, swap sprite attributes
	LDA Sprite_RAM+$01,Y
	PHA		
	LDA Sprite_RAM+$05,Y
	STA Sprite_RAM+$01,Y
	PLA
	STA Sprite_RAM+$05,Y

PRG000_D6C6:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Draw24x16Sprite
;
; Used to draw 48x16 object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D6C7
Object_Draw24x16Sprite:
	LDY <Temp_Var7
	LDA <Temp_Var5	; Check sprite vertical visibility
	LSR A		
	BCS PRG000_D726	; If this sprite is off-screen, jump to PRG000_D726 (RTS)

	LDA <Temp_Var8	; Checking horizontal sprite visibility
	ASL A		; Left shift flags value
	STA <Temp_Var10	; -> Temp_Var10

	LDA <Temp_Var1	; Sprite Y
	BCS PRG000_D6D8	; If sprite is horizontally off-screen, jump to PRG000_D6D8

	STA Sprite_RAM+$00,Y	 ; Set sprite Y in RAM

PRG000_D6D8:
	BIT <Temp_Var10	 
	BMI PRG000_D6DF	 ; If this sprite is off-screen, jump to PRG000_D6DF

	STA Sprite_RAM+$04,Y	 ; Set sprite Y in RAM

PRG000_D6DF:
	BVS PRG000_D6E4	 ; If this sprite is off-screen, jump to PRG000_D6E4

	STA Sprite_RAM+$08,Y	 ; Set sprite Y in RAM

PRG000_D6E4:
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y	 ; Set sprite X in RAM
	ADD #$08
	STA Sprite_RAM+$07,Y	 ; Set sprite X in RAM (+8)
	ADD #$08
	STA Sprite_RAM+$0B,Y	 ; Set sprite X in RAM (+16)

	; Set each of the sprite's patterns
	LDA ObjectGroup_PatternSets,X
	STA Sprite_RAM+$01,Y
	LDA ObjectGroup_PatternSets+1,X
	STA Sprite_RAM+$05,Y
	LDA ObjectGroup_PatternSets+2,X
	STA Sprite_RAM+$09,Y

	; Set each sprite's attributes
	LDA <Temp_Var3
	ORA <Temp_Var4		 ; Combine attributes
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$0A,Y

	BIT <Temp_Var3
	BVC PRG000_D6C6	 ; If sprite is not horizontally flipped, jump to PRG000_D6C6 (RTS)

	; Swap end sprites patterns
	LDA Sprite_RAM+$01,Y
	PHA	
	LDA Sprite_RAM+$09,Y
	STA Sprite_RAM+$01,Y
	PLA	
	STA Sprite_RAM+$09,Y

PRG000_D726:
	RTS		 ; Return
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_GetRandNearUnusedSpr
;
; Gets a semi-random "near by" sprite as appropriate for an
; object; it's a "friendly" way of getting an additional sprite
; for an object that's going over the normal limit.
;
; X = index of on-screen object
;
; Returns:
;	Temp_Var7 = offset to the blank sprite (also in 'Y')
;	Temp_Var8 = 5 or 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Selection table for the 5/1... doesn't seem like the
	; values actually mean anything, it just checks > 5?
	; Kept in Temp_Var9 anyway...
PRG000_D727:
	.byte $00, $01, $02, $03, $04, $05, $03, $07, $00, $01, $02, $03, $04, $05, $02

; $D736
Object_GetRandNearUnusedSpr:
	TXA
	PHA		 ; Save object index

	LDY #$07	 ; Y = 7
PRG000_D73A:
	STY <Temp_Var7	 ; Update Temp_Var7

	LDX <CurrentObjectIndexZ	 ; X = object slot index

	LDA RandomN,X
	AND #$07	
	ADD <Temp_Var7	
	TAY		 ; Y = (Random 0-7) + Temp_Var7

	LDA PRG000_D727,Y
	TAY		
	STY <Temp_Var9	 ; Temp_Var9 = PRG000_D727[Y]

	LDA Objects_State,Y
	BEQ PRG000_D763	 ; If object state = 0 (dead/empty), jump to PRG000_D763

PRG000_D752:
	LDY <Temp_Var7	 ; Y = Temp_Var7
	DEY		 ; Y--
	BPL PRG000_D73A	 ; While Y > 0, loop!

	LDX #$20	 ; X = $20

	LDA RandomN
	BPL PRG000_D760	 ; 50/50, jump to PRG000_D760

	LDX #$24	 ; Otherwise, X = $24

PRG000_D760:
	JMP PRG000_D789	 ; Jump to PRG000_D789

PRG000_D763:

	; Object slot is dead/empty...

	TYA
	ADD Counter_7to0
	TAY		; Y = object slot + (0-7)

	LDX SprRamOffsets,Y	 ; X = Sprite_RAM offset

	LDY #$05	 ; Y = 5

	LDA <Temp_Var9
	CMP #$05	
	BLT PRG000_D776	 ; If Temp_Var9 < 5, jump to PRG000_D776

	LDY #$01	 ; Y = 1

PRG000_D776:
	STY <Temp_Var8	 ; Temp_Var8 = 5 or 1

	LDA Sprite_RAM+$00,X
	CMP #$f8
	BEQ PRG000_D789	 ; If this sprite Y is impossibly low (blank sprite), jump to PRG000_D789

	INX
	INX
	INX
	INX		 ; X += 4 (next sprite)

	DEY		 ; Y--
	BPL PRG000_D776	 ; While Y >= 0, loop!

	JMP PRG000_D752	 ; Jump to PRG000_D752

PRG000_D789:
	STX <Temp_Var7	 ; Temp_Var7 = offset to blank sprite

	TXA
	TAY		; Y = same offset

	PLA
	TAX		 ; Restore 'X'

	LDA <Temp_Var8	 ; A = 5 or 1

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DetermineHorizontallyOffScreen
; Object_DetermineHorizontallyOffScreenY
;
; Determines how many of each horizontal sprite of an object are
; invisible (off-screen), based on size of object
;
; X = index of on-screen object
; Y = width of object; 0-5 or 8, 16, 24, 32, 40, 48 respectively (Object_DetermineHorizontallyOffScreenY only)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Pixel width minus 8 of objects
Object_Widths:
	.byte  0	; 0
	.byte  8	; 1
	.byte 16	; 2
	.byte 24	; 3
	.byte 32	; 4
	.byte 48	; 5
	.byte 64	; 6

	; Respective bit to set per width checked
Object_WidthFlags:
	.byte %10000000	; 0
	.byte %01000000	; 1
	.byte %00100000	; 2
	.byte %00010000	; 3
	.byte %00001000	; 4
	.byte %00000100	; 5
	.byte %00000010	; 5

; $D79E
Object_DetermineHorizontallyOffScreen:
	LDY ObjGroupRel_Idx	 	; Y = object group relative index
	LDA ObjectGroup_Attributes,Y	; Get object's attributes
	AND #OA1_WIDTHMASK	 ; Keep only bits 4-6
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 ; shift right 4
	TAY		 ; Y = Width of object (0-5 or 0, 8, 16, 24, 32, or 40, -8)

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BGS PRG000_D7B8	 ; If this object's state >= OBJSTATE_NORMAL (not dead or initializing), jump to PRG000_D7B8

	; If object is dead/empty or initializing, mark all sprites as invisible
	LDA #%11111100
	STA Objects_SpritesHorizontallyOffScreen,X

	RTS		 ; Return

PRG000_D7B8:
	LDA #$00
	STA Objects_SpritesHorizontallyOffScreen,X	 ; Clear until determined

PRG000_D7BD:
	LDA <Objects_XZ,X
	ADD Object_Widths,Y
	STA <Temp_Var15		; Temp_Var15 = object's X + ??

	LDA <Objects_XHiZ,X
	ADC #$00	 
	STA <Temp_Var16		; Temp_Var16 = Object's X Hi with carry applied

	LDA <Temp_Var15
	CMP <Horz_Scroll
	LDA <Temp_Var16	
	SBC <Horz_Scroll_Hi
	BEQ PRG000_D7DE	 ; If sprite is not horizontally off-screen, jump to PRG000_D7DE

	; This sprite is off left/right of screen...
	LDA Objects_SpritesHorizontallyOffScreen,X	 ; Get appropriate invisibility bit
	ORA Object_WidthFlags,Y	 ; OR it
	STA Objects_SpritesHorizontallyOffScreen,X	 ; Store it

PRG000_D7DE:
	DEY		 ; Y--
	BPL PRG000_D7BD	 ; While Y >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DetermineVerticallyOffScreen
; Object_DetermineVerticallyOffScreenY
;
; Determines how many of each vertical sprite of an object are
; invisible (off-screen), based on size of object
;
; X = index of on-screen object
; Y = height of object; 0-3 or 16, 32, 48, 64 respectively (Object_DetermineVerticallyOffScreenY only)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D7E2
Object_DetermineVerticallyOffScreen:
	LDY ObjGroupRel_Idx	 	; Y = object group relative index
	LDA ObjectGroup_Attributes,Y	; Get object's attributes
	AND #OA1_HEIGHTMASK	 ; keep only bits 2 and 3
	LSR A		 
	LSR A		 ; shift right 2
	TAY		 ; Y = size of object (0-3 or 16, 32, 48, 64)

	LDA #$01
	STA <Temp_Var3	 ; Temp_Var3 = 1

	LDA #$00
	STA Objects_SpritesVerticallyOffScreen,X	 ; Clear until determined

	; Copy object's Y Hi/Lo -> Temp_Var1/2
	LDA <Objects_YHiZ,X
	STA <Temp_Var1	
	LDA <Objects_YZ,X
	STA <Temp_Var2	

PRG000_D7FE:

	; Add 16 to copy of object's Y (bottom of this sprite)
	LDA <Temp_Var2
	ADD #16
	STA <Temp_Var2

	BCC PRG000_D809	 ; If no carry, jump to Objects_SpritesVerticallyOffScreen

	INC <Temp_Var1		 ; Otherwise, apply carry

PRG000_D809:
	LDA <Temp_Var2		
	SUB Level_VertScroll
	STA <Temp_Var4		 ; Temp_Var4 = screen-relative Y

	LDA <Temp_Var1		
	SBC Level_VertScrollH	
	BNE PRG000_D81E	 ; If relative position is off-screen, jump to PRG000_D81E

	; Otherwise...
	LDA <Temp_Var4
	CMP #240
	BLT PRG000_D826	 ; If object sprite is higher than 240 (not off bottom of screen), jump to PRG000_D826

PRG000_D81E:

	; This sprite is off top/bottom of screen...
	LDA <Temp_Var3		 ; Get current set bit
	ORA Objects_SpritesVerticallyOffScreen,X	 
	STA Objects_SpritesVerticallyOffScreen,X	 ; Mark this part as invisible

PRG000_D826:
	ASL <Temp_Var3	 ; Temp_Var3 <<= 1
	DEY		 ; Y--
	BPL PRG000_D7FE	 ; While Y >= 0, loop!

PRG000_D82B:
	RTS		 ; Return

	; Defines the "bounding box" around the Player
	; Temp_Var1 - upper left of bounding box
	; Temp_Var2 - offset to right bounding box (width)
	; Temp_Var5 - top of bounding box
	; Temp_Var6 - offset to bottom bounding box (height)
Player_BoundBox:
	;    Left Right  Bot Top - offsets applied to sprite X/Y
	.byte 4,  8, 17, 13	; small/ducking
	.byte 3, 10,  5, 25	; otherwise


PRG000_D834:
	.byte -8, 8
	


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_HitTest
; Object_InteractWithPlayer
;
; Tests if Player has collided with another object
; If using "Object_InteractWithPlayer", then if the Player has touched
; the object, it will call appropriate ObjectGroup_CollideJumpTable
; routine after a successful intersection.
;
; In any case, carry is set if there was a collision, or clear
; if the Player did not collide with the object!
;
; X is object's slot
; Y is group relative object index
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D836
Object_HitTest:
	LDA #$01	 ; Test only, do NOT perform "collide" routine
	JMP PRG000_D83D	 ; Jump to PRG000_D83D

; $D83B
Object_InteractWithPlayer:
	LDA #$00	; Test and do "collide" routine

PRG000_D83D:
	STA <Temp_Var16	 ; Temp_Var16 = 0 or 1, depending on entry point

	; Clear the Player hit status bits
	LDA Objects_PlayerHitStat,X
	AND #%11111100
	STA Objects_PlayerHitStat,X

	CLC	; Carry flag will be used as a result

	LDA <Player_IsDying	; If Player is dying...
	ORA Player_OffScreen	; ... off-screen ...
	BNE PRG000_D82B	 	; ... jump to PRG000_D82B (RTS)

	JSR Object_CalcBoundBox	; Calculate object's bounding box

	LDA <Player_Suit
	BEQ PRG000_D862	 ; If Player is small, jump to PRG000_D862

	LDA #$00	 ; A = 0 when small or ducking

	LDY Player_IsDucking	 
	BNE PRG000_D862	 ; If Player is ducking, jump to PRG000_D862

	LDA #$01	 ; A = 1 otherwise

PRG000_D862:
	ASL A
	ASL A		 ; Multiply by 4
	TAY		 ; Y = 0 (small/ducking) or 4 (otherwise)

	; Calculate upper left of bounding box and lower right offsets of Player
	LDA <Player_SpriteX
	ADD Player_BoundBox,Y
	STA <Temp_Var3	

	LDA <Player_SpriteY
	ADD Player_BoundBox+2,Y
	STA <Temp_Var7	

	LDA Player_BoundBox+1,Y
	STA <Temp_Var4	

	LDA Player_BoundBox+3,Y
	STA <Temp_Var8	

	JSR ObjectObject_Intersect	; Returns carry SET if object and Player intersected
	BCC PRG000_D82B	 	; If carry clear, object and Player did not intersect, jump to PRG000_D82B (RTS)

	; Intersection occurred by 8-bit values that represent "screen relative" positions,
	; but this is not a complete check as Player or object may be at different "High/Low"
	; positions (full 16-bit coordinate check)

	STA <Temp_Var1		 ; Store Player's bounding box top offset -> Temp_Var1

	; Calculate full 16-bit X difference of object -> Temp_Var14/15

	LDA <Player_X
	SUB <Objects_XZ,X
	STA <Temp_Var15	

	LDA <Player_XHi
	SBC <Objects_XHiZ,X

	STA <Temp_Var14	

	BPL PRG000_D8A9	 ; If overall result is positive, jump to PRG000_D8A9

	; Otherwise, 16-bit negate Temp_Var14/15
	LDA <Temp_Var15
	JSR Negate	
	STA <Temp_Var15	

	LDA <Temp_Var14
	EOR #$ff	
	ADC #$00	
	STA <Temp_Var14	

PRG000_D8A9:
	LDA <Temp_Var14
	BNE PRG000_D8CF2	 ; If Temp_Var14 is not zero, there's a difference in the "High" component of the Player/Object, so no intersect!  Jump to PRG000_D920

	LDA <Temp_Var15
	BMI PRG000_D8CF3	 ; If Temp_Var15 is negative, no intersect, jump to PRG000_D920

PRG000_D8B1:

	; The above check is not needed on a vertical level...
	; no chance of being on horizontally different screens!

	; Calculate full 16-bit Y difference of object -> Temp_Var14/15
	LDA <Player_Y
	SUB <Objects_YZ,X
	STA <Temp_Var15	

	LDA <Player_YHi	
	SBC <Objects_YHiZ,X
	STA <Temp_Var14	

	BPL PRG000_D8CF	 ; If overall result is positive, jump to PRG000_D8CF

	; Otherwise, 16-bit negate Temp_Var14/15
	LDA <Temp_Var15
	JSR Negate
	STA <Temp_Var15

	LDA <Temp_Var14
	EOR #$ff	
	ADC #$00	
	STA <Temp_Var14	

PRG000_D8CF:
	LDA <Temp_Var14
PRG000_D8CF2:
	BNE PRG000_D920	 ; If Temp_Var14 is not zero, there's a difference in the "High" component of the Player/Object, so no intersect!  Jump to PRG000_D920

	LDA <Temp_Var15
PRG000_D8CF3:
	BMI PRG000_D920	 ; If Temp_Var15 is negative, no intersect, jump to PRG000_D920

	; Temp_Var12 holds specific info:
	;	Bit 0 - Set if Player's bbox bottom is HIGHER than object's bbox bottom
	;	Bit 1 - Set if Player's bbox left edge is to the LEFT of object's bbox left edge

	LDA <Temp_Var12
	LSR A		
	BCC PRG000_D8EB	 ; If Player's bbox bottom is NOT higher than object's, jump to PRG000_D8EB

	LDA <Temp_Var1	 ; Get Player's bounding box top offset
	SUB <Temp_Var11	 ; Get vertical difference between Player and Object's bounding box bottoms
	CMP #$08	 
	BLS PRG000_D8EB	 ; If the result < 8, jump to PRG000_D8EB

	; Otherwise, flip the remaining bit of Temp_Var12
	LDA <Temp_Var12	
	EOR #$01	
	STA <Temp_Var12	

PRG000_D8EB:

	; Set into status bits for this objcet
	LDA <Temp_Var12	
	ORA Objects_PlayerHitStat,X
	STA Objects_PlayerHitStat,X

	LDA Invincible_Enemies
	BNE PRG000_D922

	LDA Player_StarInv
	ORA Player_Shell
	ORA Player_FireDash
	BEQ PRG000_D922	 ; If Player is NOT invincible, jump to PRG000_D922

	; Player is invincible...

	LDY Objects_ID,X	 ; Get object's ID -> Y
	LDA Object_AttrFlags,Y	 ; Get this object's attribute flags
	AND #OAT_HITNOTKILL	 
	BNE PRG000_D922	 	 ; If OAT_HITNOTKILL is set, jump to PRG000_D922

	; For all objects where bit 7 is not set in their attributes...

	INC Exp_Earned
	JSR Reap_Coin

	LDA #OBJSTATE_KILLED
	STA Objects_State,X	 ; Set object state to Killed

	LDA #-$38	
	STA <Objects_YVelZ,X	 ; Set Y Velocity to -$38

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; 100 points pop up
	INC Exp_Earned

	JSR Level_ObjCalcXDiffs	 ; 'Y' is set to 0 if Player is to the right of object, 1 if to the left

	LDA PRG000_D834,Y
	STA <Objects_XVelZ,X	 ; Set X velocity

PRG000_D920:
	CLC		 ; Clear carry
	RTS		 ; Return


PRG000_D922:

	; For all objects where bit 7 is set in their attributes...
	LDA Player_Shell
	BNE Do_Hit_Stuff

	LDA <Temp_Var16	 ; Returns 0 or 1, depending on original entry point
	BNE PRG000_D929	 ; If it was 1 (do not respond to hit), jump to PRG000_D929

Do_Hit_Stuff:
	; Do hit routine
	JSR Object_DoCollision ; Otherwise...

PRG000_D929:
	SEC		 ; Set carry
	RTS		 ; Return


; FIXME: Anybody want to claim this?
; $D92B
	.byte $F0, $00, $10, $20


	; Calculates the upper-left and returns the lower-right offsets
	; of this object's bounding box...
	; Temp_Var1 - upper left of bounding box
	; Temp_Var2 - offset to right bounding box
	; Temp_Var5 - bottom of bounding box
	; Temp_Var6 - offset to top bounding box
; $D92F
Object_CalcBoundBox:
	; X is object's slot
	; Y is group relative object index

	LDA BossBoundBox
	BNE CustomBoundBox
	LDY Objects_ID,X	 ; Get this object's ID -> Y
	LDA Object_AttrFlags,Y	 ; Get this object's attribute flags

CustomBoundBox:
	AND #OAT_BOUNDBOXMASK	; Mask off the bounding box
	ASL A		 
	ASL A		 ; Shift left 2
	TAY		 ; -> Y (selected bounding box for this object)

	; Calculate upper left of bounding box and lower right offsets
	LDA <Objects_SpriteX,X
	ADD Object_BoundBox,Y	
	STA <Temp_Var1		 ; Temp_Var1 object's sprite X with offset

	LDA <Objects_SpriteY,X
	ADD Object_BoundBox+2,Y	
	STA <Temp_Var5		 ; Temp_Var5 object's sprite Y with offset

	LDA Object_BoundBox+1,Y
	STA <Temp_Var2		 ; Temp_Var2 has the right offset

	LDA Object_BoundBox+3,Y	
	STA <Temp_Var6		 ; Temp_Var6 has the bottom offset

	RTS		 ; Return


	; Calculates the upper-left and returns the lower-right offsets
	; of this object's bounding box...
	; Temp_Var3 - upper left of bounding box
	; Temp_Var4 - offset to right bounding box
	; Temp_Var7 - bottom of bounding box
	; Temp_Var8 - offset to top bounding box
; $D955
Object_CalcBoundBox2:	; Same as Object_CalcBoundBox in spirit, just different outputs, used for object-to-object collision
	; X is object's slot
	; Y is group relative object index

	LDY Objects_ID,X	 ; Get this object's ID -> Y
	LDA Object_AttrFlags,Y	 ; Get this object's attribute flags
	AND #OAT_BOUNDBOXMASK	 ; Mask off the bounding box
	ASL A		 
	ASL A		 ; Shift left 2
	TAY		 ; -> Y (selected bounding box for this object)

	; Calculate upper left of bounding box and lower right offsets
	LDA <Objects_SpriteX,X
	ADD Object_BoundBox,Y	
	STA <Temp_Var3		 ; Temp_Var3 object's sprite X with offset

	LDA <Objects_SpriteY,X
	ADD Object_BoundBox+2,Y	
	STA <Temp_Var7		 ; Temp_Var7 object's sprite Y with offset

	LDA Object_BoundBox+1,Y
	STA <Temp_Var4		 ; Temp_Var4 has the right offset

	LDA Object_BoundBox+3,Y	
	STA <Temp_Var8		 ; Temp_Var8 has the bottom offset

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ObjectObject_Intersect
;
; Determines if the Player/Object and the OTHER Object indexed
; by 'X' have intersected according to the bounding box data
;
; X = index of on-screen object
;
; Returns carry SET if Player/Object and Object intersected
; Temp_Var12 holds specific info:
;	Bit 0 - Set if Player/Object's bbox bottom is HIGHER than 
;	        object's bbox bottom
;	Bit 1 - Set if Player/Object's bbox left edge is to the LEFT of
;	        object's bbox left edge
;
; Note that this is performed by the "sprite" (or screen-relative)
; positions of the Player/Object and the OTHER Object, and may not 
; be accurate (because it's not a full 16-bit coordinate check) and 
; more logic is needed after this to determine completely if there 
; should be an actual collision.  See use of ObjectObject_Intersect 
; to get an idea what else needs to be done...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D97B
ObjectObject_Intersect:
	LDY #$00	 ; Y = 0
	STY <Temp_Var12	 ; Temp_Var12 = 0 (Player's bbox is to the RIGHT of the object's left edge, until determined otherwise)


	; Right now we're considering the left edges of the Player and Object
	; we're detecting against

	LDA <Temp_Var3		 ; Left of Player's bounding box
	SUB <Temp_Var1		 ; Left of object's bound box
	STA <Temp_Var11		 ; Difference between the two -> Temp_Var11

	ASL A			 ; Sets carry if it was a negative result
 
	LDA <Temp_Var2		 ; Get the object's right edge bounding box offset

	BCC PRG000_D997	 	 ; If the calculated difference was NOT negative (Player's bbox left edge is to the RIGHT of object's bbox left edge), jump to PRG000_D997

	; Player's box left edge is to the LEFT of the object's left edge

	; Negate Temp_Var11 (the difference), making it positive
	LDA <Temp_Var11
	EOR #$ff
	STA <Temp_Var11		 
	INC <Temp_Var11	

	INC <Temp_Var12		 ; Temp_Var12 = 1 (Player's bbox is to the LEFT of object's left edge)

	LDA <Temp_Var4		 ; Get the Player's right edge bounding box offset

PRG000_D997:
	CMP <Temp_Var11
	BLT PRG000_D9B7	 	 ; If the left edge offset is less than the right edge offset (CARRY CLEAR), jump to PRG000_D9B7 (RTS)


	; That didn't happen...

	ASL <Temp_Var12		 ; Push result bit up

	LDA <Temp_Var7		 ; Player's bounding box bottom
	SUB <Temp_Var5		 ; Object's bouncing box bottom
	STA <Temp_Var11		 ; Store difference -> Temp_Var11

	ASL A		 	 ; Sets carry if it was a negative result

	LDA <Temp_Var6		 ; Get object's bounding box top edge offset

	BCC PRG000_D9B5	 	 ; If the calculated difference was NOT negative (Player's bbox bottom is LOWER than object's bbox bottom), jump to PRG000_D9B5

	; Negate Temp_Var11 (the difference), making it positive
	LDA <Temp_Var11
	EOR #$ff	
	STA <Temp_Var11	
	INC <Temp_Var11	

	INC <Temp_Var12		 ; Set bit 0 of Temp_Var12

	LDA <Temp_Var8		 ; Get Player's bounding box top edge offset

PRG000_D9B5:
	CMP <Temp_Var11		 ; Set final carry bit to determine if we intersected or not

PRG000_D9B7:

	; Most importantly, status of the carry flag is returned
	; If carry is CLEAR, we did not intersect Player to Object

	; Temp_Var12 holds specific info:
	;	Bit 0 - Set if Player's bbox bottom is HIGHER than object's bbox bottom
	;	Bit 1 - Set if Player's bbox left edge is to the LEFT of object's bbox left edge

	RTS		 ; Return


	; Proper Collision routine for this object
; $D9BB
Object_DoCollision:
	LDX <CurrentObjectIndexZ	; X = the current object slot

	LDA ObjGroupRel_Idx	; Get the object's group relative index
	ASL A		 	; Shift left 1 (2 byte index)
	TAY		 	; -> Y

	; Get address from ObjectGroup_CollideJumpTable...
	LDA ObjectGroup_CollideJumpTable,Y
	STA <Temp_Var1	
	LDA ObjectGroup_CollideJumpTable+1,Y
	STA <Temp_Var2	
	JMP [Temp_Var1]	 ; Jump to the acquired address!

	; RAS: Dead data: Specified frame of "suit lost" object
	; to display when the cooresponding suit was lost (not
	; used for any of the "regular" power ups)
SMB3J_SuitLossFrame:	.byte $00, $00, $00, $00, $01, $02, $03

; $D9D3
Player_GetHurt:

	; If Player is...
	LDA Player_FlashInv		; ... flashing invincible ...
	ORA Boo_Mode_Timer		; ... or boo mode ...
	ORA Player_StarInv		; ... invincible by star ...
	ORA Player_SuitLost		; ... just lost a power-up suit ...
	ORA <Player_HaltGameZ		; ... gameplay halted ...
	ORA Player_HaltTick		; ... Player halted ...
	ORA Player_FireDash		;
	BNE PRG000_D9B7	 ; ... then jump to PRG000_D9B7 (RTS)

	JMP PRG000_DA15	 ; Jump to PRG000_DA15 (skips lost/dead Japanese version code)


; $D9EC

PRG000_DA15:
	LDA <Player_Suit
	CMP #PLAYERSUIT_FIRE		; RAS: Change this to "PLAYERSUIT_SUPERSUITBEGIN" and you restore Japanese version's "always shrink" code!!
	BLS PRG000_DA4E	 ; If Player is Big or small, jump to PRG000_DA4E

	LDA Player_Equip
	CMP #BADGE_DAMAGE
	BNE PRG000_DA4E
	LDA #$17
	STA Player_SuitLost	 ; Player_SuitLost = $17

	; Play Power up lost sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	LDA #$02
	STA Player_QueueSuit	 ; Queue power-up change

	LDA #$80
	STA Player_FlyTime

PRG000_DA47:
	LDA #$00	 
	BEQ PRG000_DA6D	 ; Jump (technically always) to PRG000_DA6D

PRG000_DA4E:

	; Player is only big or small...

	LDA <Player_Suit
	BEQ PRG000_DA7A	 ; If Player is small, jump to PRG000_DA7A (gonna die!!)

	LDA Player_Equip
	SUB #ITEM_HEART1
	BMI PRG000_DA4F
	CMP #$03
	BCS PRG000_DA4F
	CMP #$00
	BEQ PRG000_DA4F1
	DEC Player_Equip
	JMP PRG000_DA50
	
PRG000_DA4F1:
	LDA #$00
	STA Player_Equip
	BEQ PRG000_DA50

PRG000_DA4F:
	LDA #$02
	STA Player_QueueSuit	 ; Return to Big

PRG000_DA50:
	; Play shrinking sound!!
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA #$2f	
	STA Player_Grow	 	; Player_Grow = $2f (shrinking!)
	DEC Player_QueueSuit	; Get small!

PRG000_DA6D: 
	LDA #$71
	STA Player_FlashInv	 ; Player_FlashInv = $71

	LDA #$00
	STA Player_Flip	 ; Player not somersaulting

	BEQ PRG000_DAAE	 ; Jump (technically always) to PRG000_DAAE (cosmetic bugfix?)

	RTS		 ; Return

PRG000_DA7A:
	LDX <CurrentObjectIndexZ	 ; X = CurrentObjectIndexZ


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Die
;
; Simple and to the point: Starts the death song,
; resets a bunch of variables that get in the way,
; changes to small, etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Die:
	; Queue death song
	LDA Sound_QMusic1
	ORA #MUS1_PLAYERDEATH
	STA Sound_QMusic1

	; Clear a bunch of stuff at time of death
	LDA #$00
	STA <Player_XVel
	STA <Obj01_Flag	
	STA Player_Flip	
	STA Player_FlashInv
	STA Player_StarInv
	STA Player_Shell
	STA Player_FireDash
	STA Boo_Mode_Timer
	STA Boo_Mode_KillTimer
	STA Level_PSwitchCnt
	STA Frozen_Frame
	STA Frozen_State
	
	LDA #$01
	STA Player_QueueSuit	 ; Queue change to "small"

	LDA #-64
	STA <Player_YVel ; Player_YVel = -64

	LDA #$30	 
	STA Event_Countdown ; Event_Countdown = $30 (ticks until dropped back to map)

	LDA #$01
	STA <Player_IsDying	 ; Player_IsDying = 1

PRG000_DAAE:

	RTS		 ; Return


	; X velocities as appropriate based on which direction 
	; Player was when he killed the enemy
EnemyKill_XVels:	.byte -$08, $08

	; Tail attack X offset, based on Player's facing direction
Player_TailAttackXOff:	.byte $11, -$0A

PRG000_DAF0:
	.byte -$0A, $11


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_HitByTailOrBouncer
;
; Test if object is getting hit by Player's tail attack
; or a left/right bouncing block
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_HitByTailOrBouncer:
	; Clear the "Tail Attacked" bit
	LDA Objects_PlayerHitStat,X
	AND #%11110111
	STA Objects_PlayerHitStat,X

	JSR Object_RespondToTailAttack	; Get hit by tail attack if appropriate

	; Handle a left/right bouncer if it impacts an object
	LDA LRBounce_Y
	CMP #$ff
	BEQ PRG000_DB16	 ; If LRBounce_Y = $FF, jump to PRG000_DB16 (RTS)
	STA <Temp_Var7	 ; Temp_Var7 = LRBounce_Y

	LDA #$0f
	STA <Temp_Var8	 ; Temp_Var8 = $0F

	LDA LRBounce_X
	STA <Temp_Var3	 ; Temp_Var3 = LRBounce_X

	LDA #$0f
	STA <Temp_Var4	 ; Temp_Var4 = $0F

	JSR Player_TailAttackDo	; Perform tail attack type action

PRG000_DB16:
	RTS		 ; Return


PRG000_DB17:	.byte $10, -$10


Object_RespondToTailAttack:

	LDA Player_TailAttack
	BEQ PRG000_DB16	 ; If Player is not tail attacking, jump to PRG000_DB16 (RTS)

	; Tail attack only kicks at counter values $09 and $0C
	CMP #$0c
	BEQ PRG000_DB26	 ; If tail attack counter = $0C, jump to PRG000_DB26
	CMP #$09
	BNE PRG000_DB16	 ; If tail attack counter <> $09, jump to PRG000_DB16 (RTS)

PRG000_DB26:
	LDA <Player_FlipBits
	AND #$40
	TAY		 ; Y = $00 or $40, whether Player is flipped
	BEQ PRG000_DB2F	 ; If 'Y' = 0, jump to PRG000_DB2F

	LDY #$01	 ; Y = 1

PRG000_DB2F:
	LDA Player_TailAttackXOff,Y
	ADD <Player_SpriteX
	STA <Temp_Var3	 ; Temp_Var3 = appropriate X offset for tail attack

	LDA #$0a
	STA <Temp_Var4	 ; Temp_Var4 = $0A

	LDA <Player_SpriteY
	ADD #$10
	STA <Temp_Var7	 ; Temp_Var7 = tail attack offset

	LDA #$0f
	STA <Temp_Var8	 ; Temp_Var8 = $0F

Player_TailAttackDo:
	LDY Objects_State,X	; Y = object's current state

	LDA Obj2Obj_EnByState,Y
	BNE PRG000_DB16	 ; If object is not hit tested in this state, jump to PRG000_DB16 (RTS)

	JSR Object_AnySprOffscreen
	BNE PRG000_DB16	 ; If any sprite of the object is off-screen, jump to PRG000_DB16 (RTS)

	JSR Object_CalcBoundBox
	JSR ObjectObject_Intersect
	BCC PRG000_DB16	 ; If Player and object are not intersecting, jump to PRG000_DB16 (RTS)

	; Set "Tail Attacked" bit
	LDA Objects_PlayerHitStat,X
	ORA #%00001000
	STA Objects_PlayerHitStat,X

	LDY ObjGroupRel_Idx	 ; Y = object's group-relative index

	LDA Invincible_Enemies
	BNE PRG000_DB16
	LDA ObjectGroup_Attributes3,Y
	AND #OA3_TAILATKIMMUNE
	BNE PRG000_DB16	 ; If OA3_TAILATKIMMUNE is SET (Object cannot be tail-attacked), jump to PRG000_DB16 (RTS)

	LDA <Temp_Var4
	CMP #$0f
	BEQ Enemy_Kill

	LDY #$00	 ; Y = 0

	LDA <Player_FlipBits
	BEQ PRG000_DB7A	 ; If Player is not turned around, jump to PRG000_DB7A

	INY		 ; Y = 1

PRG000_DB7A:

	JSR Reap_Coin


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Enemy_Kill
;
; Kills an enemy; flips them over, plays the "kick" sound
; If attribute 3, bit 6 is SET, there's some special
; behavior described below (using CollideJumpTable as a
; value rather than address, alternate dead state 3, etc.)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Enemy_Kill:

	; Set timer 2 to 12
	LDA #12
	STA Objects_Timer2,X

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	LDY ObjGroupRel_Idx	 	; Y = object group relative index
	LDA ObjectGroup_Attributes3,Y	; Get this object's attribute set 3
	AND #OA3_DIESHELLED
	BNE PRG000_DBB6	 		; If OA3_DIESHELLED is set, jump to PRG000_DBB6

	; OA3_DIESHELLED is not set...

	LDA Player_Slide
	BNE PRG000_DBB2	 	; If Player is sliding, jump to PRG000_DBB2

	LDA Kill_Tally	 	; Get current kill tally
	STA Exp_Earned	; Get appropriate score based on kill tally

PRG000_DBB2:
	LDA #$06	 ; A = 6 (object state 6, killed)
	BNE PRG000_DBCF	 ; Jump (technically always) to PRG000_DBCF


PRG000_DBB6:

	; Attribute set 3 bit 6 is set...

	; Y *= 2 (2 byte index)
	TYA	
	ASL A	
	TAY	

	LDA ObjectGroup_CollideJumpTable+1,Y	; Get upper byte of collision jump entry
	AND #%11111000
	CMP #%00001000	; If only bit 3 is set and 4-7 are clear, this is a new object ID to change to
	BNE PRG000_DBC8	 ; If the above is not the case, jump to PRG000_DBC8

	; SPECIAL CASE: Collide Jump table lower byte specifies a new object ID

	LDA ObjectGroup_CollideJumpTable,Y 	; Get the new ID
	STA Objects_ID,X			; Set the new ID

PRG000_DBC8:
	; Timer 3 set to $FF
	LDA #$ff
	STA Objects_Timer3,X

	LDA #OBJSTATE_SHELLED	 ; A = Shelled

PRG000_DBCF:
	STA Objects_State,X	 ; Set new object state

	LDA #-$30	 ; A = -$30

	LDY <Temp_Var4

	CPY #$0f	
	BEQ PRG000_DBDC	 ; If Temp_Var4 = $0F, jump to PRG000_DBDC

	LDA #-$50	 ; A = -$50

PRG000_DBDC:
	STA <Objects_YVelZ,X	 ; Set Y velocity appropriately

	; Set appropriate X Velocity based on facing direction of 
	; Player when he killed the enemy
	JSR Level_ObjCalcXDiffs
	LDA EnemyKill_XVels,Y
	STA <Objects_XVelZ,X

	; Set vertical flip on the object
	LDA Objects_Orientation,X
	ORA #SPR_VFLIP
	STA Objects_Orientation,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ObjectToObject_HitTest
;
; Determines if the object specified in 'X' has collided
; with any of the other active objects not including
; Player (see Object_HitTest/Object_InteractWithPlayer)
;
; If the object has collided with another object:
;  Carry flag is SET
;  'Y' = index of the collided-with object 
;  'A' = ObjectID of the collided-with object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Enable object-to-object by state (0 = Enabled, 1 = Disabled)
Obj2Obj_EnByState:
	.byte $01	; State 0: Dead/Empty
	.byte $01	; State 1: Initializing
	.byte $00	; State 2: Normal
	.byte $00	; State 3: Shelled
	.byte $00	; State 4: Held
	.byte $00	; State 5: Kicked
	.byte $01	; State 6: Killed
	.byte $01	; State 7: Squashed
	.byte $01	; State 8: Dying

	; $DBF8
ObjectToObject_HitTest:
	LDA #$00
	STA HitTestOnly
	LDA Objects_SpritesVerticallyOffScreen,X
	BNE PRG000_DC54	 ; If any sprites are vertically off-screen, jump to PRG000_DC54

	; No sprites are vertically off-screen...

	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG000_DC54	 ; If both of the end sprite are horizontally off-screen, jump to PRG000_DC54

	JSR Object_CalcBoundBox2	; Calculate THIS object's bounding box

PRG000_DC09:
	LDX #$04	 ; X = 4

PRG000_DC0B:
	CPX <CurrentObjectIndexZ
	BEQ PRG000_DC51	 ; If this object slot is the current object, jump to PRG000_DC51 (don't do anything to self)

	LDY Objects_State,X
	LDA Obj2Obj_EnByState,Y
	BNE PRG000_DC51	 ; If the state this object is in does not do object-to-object detection, jump to PRG000_DC51 (do nothing)

	LDA Objects_SpritesVerticallyOffScreen,X
	BNE PRG000_DC51	 ; If sprites are vertically off-screen, jump to PRG000_DC51 (do nothing)

	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #%11000000	
	CMP #%11000000	
	BEQ PRG000_DC51	 ; If two sprites are horizontally off-screen, jump to PRG000_DC51 (do nothing)

	JSR Object_CalcBoundBox	 ; Calculate OTHER object's bounding box
	JSR ObjectObject_Intersect	 ; Returns carry SET if object and OTHER object intersected
	BCC PRG000_DC51	 	; If object did NOT intersect the OTHER object, jump to PRG000_DC51 (do nothing)

	LDA HitTestOnly
	BEQ PRG000_DC0C
	TXA
	TAY
	RTS

PRG000_DC0C:
	; These two objects have collided...!

	LDY <CurrentObjectIndexZ	 ; Y = object slot index

	LDA <Objects_XZ,X
	SUB Objects_XZ,Y		; Difference between the object and the OTHER object's X
	PHA		 	; Save the difference

	LDA <Objects_XHiZ,X
	SBC Objects_XHiZ,Y	 ; Difference between the object and the OTHER object's X Hi
	STA <Temp_Var1		 ; -> Temp_Var1

	PLA		 ; Restore the lower X difference

	; Don't quite understand the logic, but this determines if the 
	; objects are actually on the same screen instead of just
	; seeming to due to the low accuracy of sprite coordinates
	ADC #$80	
	LDA <Temp_Var1	
	ADC #$00	
	BNE PRG000_DC51	 ; If the objects did not actually collide, jump to PRG000_DC51 (do nothing)

	SEC		 ; Object's collided!  Set carry!

	LDY Objects_ID,X	 ; Y = OTHER object's ID

	LDA Object_AttrFlags,Y
	AND #OAT_HITNOTKILL
	BEQ PRG000_DC57	 ; If this object is NOT a "Hit-Not-Kill" type, jump to PRG000_DC57

PRG000_DC51:
	DEX		 ; X--
	BPL PRG000_DC0B	 ; While X >= 0, loop!

PRG000_DC54:
	CLC		 ; Clear carry (collided with no other object)
	BCC PRG000_DC5C	 ; Jump (technically always) to PRG000_DC5C

PRG000_DC57:
	TXA		 
	TAY		 ; Index of the OTHER object that this object collided with -> 'Y'
	LDA Objects_ID,Y	 ; A = the ID of the OTHER object

PRG000_DC5C:
	LDX <CurrentObjectIndexZ	 ; Restore 'X' as the object slot index
	RTS		 ; Return


	; This changes a tile based on Temp_Var13-16 coordinates:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo
Level_ChangeTile_ByTempVars:

	PHA		 ; Save 'A'
	
PRG000_DC7B:
	LDA <Temp_Var15
	ASL A		
	TAY		 ; Y = Temp_Var15 (X Hi) shifted left 1 (2 bytes index per screen for Tile_Mem_Addr)

	; Set tile grid modify address
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1	
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var2

	LDA <Temp_Var13	
	BEQ PRG000_DC8F	 ; If Y Hi = 0, jump to PRG000_DC8F

	INC <Temp_Var2	 ; Otherwise, offset to lower screen area

PRG000_DC8F:
	LDA <Temp_Var14	 ; A = Y lo

PRG000_DC91:
	AND #$f0
	STA <Temp_Var3	; Tile aligned "low" (makes row)

	LDA <Temp_Var16
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var3	; Makes column

	TAY		 ; Y = offset to specific tile

	PLA		 ; Restore 'A' (tile index)

	STA [Temp_Var1],Y ; Change tile as appropriate

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcCoarseXDiff
;
; Calculates a "coarse" X difference with the Player,
; returning a one byte value that determines the
; difference in X/XHi coordinates in units of 4 pixels
; in Temp_Var15.  Temp_Var16 is set to $40 and the
; carry flag is set if the difference was negative.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCA2 
Object_CalcCoarseXDiff:
	LDA <Objects_XZ,X	 
	SUB <Player_X	
	STA <Temp_Var15		; Temp_Var15 = difference between Object and Player X

	LDA <Objects_XHiZ,X
	SBC <Player_XHi		; Calc diff between X His

	LSR A			; Push low bit of "hi" difference -> carry
	ROR <Temp_Var15		; Cycle carry into Temp_Var15 at high bit; will be discarding low bit
	LSR A			; Push low bit of "hi" difference -> carry
	ROR <Temp_Var15		; Cycle carry into Temp_Var15 at high bit; will be discarding low bit

	; Temp_Var15 now holds a difference between the Object and Player
	;  X coordinates in units of 4 pixels (works up to two screen
	; widths; anything greater and object was probably removed anyway)

	; Note the following only works because there is no way that bit 5 and 7
	; could be a part of the actual difference, just the sign factor, since
	; a level cannot be more than 10 screens in width.
	ASL A			; Shift remaining difference left 1; carry set means negative difference
	AND #$40
	STA <Temp_Var16		; Temp_Var16 being $40 also means negative difference

	RTS		 ; Return

Object_CalcCoarseYDiff:
	LDA <Player_Y
	STA ChaseTargetY
	LDA <Player_YHi
	STA ChaseTargetYHi
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcCoarseYDiff
;
; Calculates a "coarse" Y difference with the Player,
; returning a one byte value that determines the
; difference in Y/YHi coordinates in units of 8 pixels.
; Returns Temp_Var15 in the format of a crude signed
; value for Y Hi in bit 6 and 7 
; [00 -> Y Hi = 0, 01 -> Y Hi = 1, 11 -> Y Hi = negative]
; and the base Y difference in the bits 0 - 5 (so units 
; of 8 pixels.)
; Temp_Var16 holds the raw difference in "Y Hi"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCB9

Object_CalcCoarseTargetYDiff:
	LDA <Objects_YZ,X
	SUB ChaseTargetY
	
	STA <Temp_Var15		 ; Temp_Var15 = difference between object's Y and Player's Y

	LDA <Objects_YHiZ,X
	SBC ChaseTargetYHi
	STA <Temp_Var16		 ; Temp_Var16 = difference between object's Y Hi and Player's Y Hi

	LDA <Temp_Var16
	ADC #$00
	STA <Temp_Var16

	LSR A		 	; least significant bit of Y Hi -> carry

	ROR <Temp_Var15		; Temp_Var15 takes on the "Hi" value in its most significant bit

	LSR A			; next least significant bit of Y Hi -> carry
	ROR <Temp_Var15		; The new Temp_Var15's least significant bit is pushed into its bit 7

	; So now Temp_Var15 holds the main Y difference in its first 5 bits
	; Bit 6 and 7 form a signed portion of the "hi" value -- 00 -> Y Hi = 0, 01 -> Y Hi = 1, 11 -> Y Hi = negative

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ApplyYVel
; Object_ApplyYVel_NoLimit
;
; Adds the 4.4FP Y velocity to object and prevents object
; from falling faster than OBJECT_MAXFALL (unless using
; Object_ApplyYVel_NoLimit which does not enforce this)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCCD
Object_ApplyYVel:
	LDA <Objects_YVelZ,X	 
	BMI Object_ApplyYVel_NoLimit	 ; If Object's Y Vel < 0 (moving upward), jump to Object_ApplyYVel_NoLimit

	CMP #OBJECT_MAXFALL	 
	BLS Object_ApplyYVel_NoLimit	 ; If Object's Y Vel < OBJECT_MAXFALL, jump to Object_ApplyYVel_NoLimit

	LDA #OBJECT_MAXFALL	 
	STA <Objects_YVelZ,X	 ; Cap Y Velocity to OBJECT_MAXFALL

; $DCD9
Object_ApplyYVel_NoLimit:
	TXA		 
	ADD #(Objects_YVelZ - Objects_XVelZ)
	TAX		 ; Offset to Y velocities

	LDA Stop_Watch
	BNE Object_ApplyYVel_NoLimit1
	JSR Object_AddVelFrac	 ; Apply the velocity to the object's position

		 ; Restore X as Object slot index
Object_ApplyYVel_NoLimit1:
	LDX <CurrentObjectIndexZ
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ApplyXVel
;
; Adds the 4.4FP X velocity to object and will disable
; X Hi's application if the object wants it that way..
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCE4
Object_ApplyXVel:
	LDA Stop_Watch
	BNE Object_ApplyXVel1
	JSR Object_AddVelFrac
Object_ApplyXVel1:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_AddVelFrac
;
; Adds the 4.4FP velocity to X or Y of object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_AddVelFrac:
	LDA <Objects_XVelZ,X	; Get Velocity
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 	; Fractional part shifted up
	ADD Objects_XVelFrac,X	 
	STA Objects_XVelFrac,X	; Add to object's vel fractional accumulator

	PHP		 ; Save CPU state
	PHP		 ; Save CPU state

	LDY #$00	 ; Y = 0 (positive high part)

	LDA <Objects_XVelZ,X	; Get Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG000_DD19	 ; If the value was not negatively signed, jump to PRG000_DD19
	ORA #%11110000	 ; Otherwise, apply a sign extension
	DEY		 ; Y = $FF (negative high part)
PRG000_DD19:
	PLP		 ; Restore CPU state

	PHA		 ; Save integer of velocity

	ADC <Objects_XZ,X 
	STA <Objects_XZ,X ; Add with carry

	TYA		 ; A = $00 or $FF as appropriate

	ADC <Objects_XHiZ,X
	STA <Objects_XHiZ,X ; Add to the high part

	PLA		 ; Restore integer of Velocity

	PLP		 ; Restore CPU state

	ADC #$00
	STA Object_VelCarry ; Set to '1' if fractional part rolled over

	RTS		 ; Return


Level_ObjCalcXBlockDiffs:
	LSR A
	LSR A
	LSR A
	LSR A
	PHA
	LDA <Objects_XZ,X
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var15
	LDA <Objects_XHiZ, X
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var15
	STA <Temp_Var15
	LDA <Player_X
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16
	LDA <Player_XHi
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var16
	STA <Temp_Var16
	CMP <Temp_Var15
	BCS ToTheRight

	PLA
	INC <Temp_Var16
	LDA <Temp_Var15
	SUB <Temp_Var16
	BPL XDiffRTS
	LDA #$00

XDiffRTS:
	LDY #$00
	RTS

ToTheRight:
	PLA
	ADD <Temp_Var15
	STA <Temp_Var15
	LDA <Temp_Var16
	SUB <Temp_Var15
	BPL ToTheRightRTS
	LDA #$00

ToTheRightRTS:
	LDY #$01
	RTS

Level_ObjCalcYBlockDiffs:

	LSR A
	LSR A
	LSR A
	LSR A
	PHA
	LDA <Objects_YZ,X
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var15
	LDA <Objects_YHiZ, X
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var15
	STA <Temp_Var15
	LDA <Player_Y
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16
	LDA <Player_YHi
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var16
	STA <Temp_Var16
	INC <Temp_Var16
	LDA <Temp_Var16
	CMP <Temp_Var15
	BCC EnemyIsBelow

	PLA
	ADD <Temp_Var16
	STA <Temp_Var16

	LDA <Player_Suit
	BEQ PlayerTall
	DEC <Temp_Var16

PlayerTall:
	LDA <Temp_Var16
	SUB <Temp_Var15
	BPL PlayerTallRTS
	LDA #$00

PlayerTallRTS:
	LDY #$00
	RTS

EnemyIsBelow:
	PLA

	INC <Temp_Var16
	LDA <Temp_Var15
	SUB <Temp_Var16
	BPL ToTheBottomRTS
	LDA #$00

ToTheBottomRTS:
	LDY #$01
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_ObjCalcXDiffs
;
; For a given object slot in 'X'...
; Returns: Temp_Var16 as pixel difference between Player and object X coordinates
; 	   And 'Y' is set to 0 if Player is to the right of object, 1 if to the left
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD2C
Level_ObjCalcXDiffs:
	LDA <Player_X
	SUB <Objects_XZ,X
	STA <Temp_Var16	 ; Temp_Var16 = difference between Player's X and object's X

	LDY #$00	 ; Y = 0
	LDA <Player_XHi	 
	SBC <Objects_XHiZ,X
	BPL PRG000_DD3C	 ; If Player's X Hi >= Object's X Hi, jump to PRG000_DD3C (RTS)

	INY		 ; Otherwise Y = 1

PRG000_DD3C:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_ObjCalcYDiffs
;
; For a given object slot in 'X'...
; Returns: Temp_Var16 as pixel difference between Player and object Y coordinates
; 	   And 'Y' is set to 0 if Player is lower than object, 1 if higher
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD3D
Level_ObjCalcYDiffs:
	LDA <Player_Y
	SUB <Objects_YZ,X
	STA <Temp_Var16		 ; Temp_Var16 = difference between Player's Y and object's Y

	LDY #$00	 ; Y = 0
	LDA <Player_YHi	
	SBC <Objects_YHiZ,X
	BPL PRG000_DD4D	 ; If Player's Y Hi >= Object's Y Hi, jump to PRG000_DD4D (RTS)

	INY		 ; Ohterwise Y = 1

PRG000_DD4D:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Negate
;
; "NEG" is not REALLY an opcode of its own
; This makes it a subroutine, though...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD4E
Negate:
	NEG
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_AnySprOffscreen
;
; Returns non-zero if any flags are set on Objects_SpritesHorizontallyOffScreen or Objects_SpritesVerticallyOffScreen
; (i.e. if any sprites are off-screen)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD54
Object_AnySprOffscreen:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	RTS		 ; Return


	; Initializes a "block bump" effect, if one of the 2 slots is open...
BlockBump_Init:
	LDY #$00	 ; Y = 0
	LDA Level_BlkBump,Y
	BEQ PRG000_DDB2	 ; If block bump slot 1 is empty, jump to PRG000_DDB2

	INY		 ; Y = 1
	LDA Level_BlkBump,Y	 
	BNE PRG000_DDCB	 ; If block bump slot 2 is not empty, jump to PRG000_DDCB (RTS)

PRG000_DDB2:
	LDA <Temp_Var12	
	STA Level_BlkBump,Y	 ; Store tile-behind effect
	AND #$C0
	ORA #$3F
	STA Level_BlkFinish

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	LDA <Temp_Var15	
	STA Level_BlkBump_XHi,Y

	LDA <Temp_Var16
	STA Level_BlkBump_XLo,Y

	LDA <Temp_Var13
	STA Level_BlkBump_YHi,Y

	LDA <Temp_Var14
	STA Level_BlkBump_YLo,Y

PRG000_DDCB:
	RTS		 ; Return

	; This sets up the "pop out" item you get when you open a treasure box
ToadHouse_GiveItem:

	RTS		 ; Return


ASHIM .func \1-AScroll_Movement-1
	; This is the initial movement table for horizontal auto scroll levels, minus 1
	; Level_AScrlLimitSel selects which entry to use, which sets Level_AScrlVar (the actual index value)
AScroll_HorizontalInitMove:
	.byte ASHIM(ASM_World_36_14)	;  0 World 3-6 / 1-4
	.byte ASHIM(ASM_W3_Airship)	;  1 World 3 Airship
	.byte ASHIM(ASM_World_62)	;  2 World 6-2
	.byte ASHIM(ASM_W5_Airship)	;  3 World 5 Airship
	.byte ASHIM(ASM_UNK4)		;  4
	.byte ASHIM(ASM_W4Airship)	;  5 World 4 Airship
	.byte ASHIM(ASM_W6Airship)	;  6 World 6 Airship
	.byte ASHIM(ASM_World_56)	;  7 World 5-6
	.byte ASHIM(ASM_UNK8)		;  8
	.byte ASHIM(ASM_UNK9)		;  9 
	.byte ASHIM(ASM_World_67)	;  A World 6-7
	.byte ASHIM(ASM_W1Airship)	;  B World 1 Airship
	.byte ASHIM(ASM_W7Airship)	;  C World 7 Airship
	.byte ASHIM(ASM_W8Airship)	;  D World 8 Airship
	.byte ASHIM(ASM_W8Battleship)	;  E World 8 Battleship
	.byte ASHIM(ASM_World_74)	;  F World 7-4
	.byte ASHIM(ASM_W1CoinHeaven)		; 10
	.byte ASHIM(ASM_CoinShip)	; 11 Coin Ship
	.byte ASHIM(ASM_UNK12)		; 12 
	.byte ASHIM(ASM_World8Tank1)	; 13 World 8 Tank 1
	.byte ASHIM(ASM_World8Tank2)	; 14 World 8 Tank 2
	.byte ASHIM(ASM_Terminator)	; 15 ** Terminator Only (because it seeks ahead to see the terminating movement index)


	; This routine is a much more simplified version of the water check. It basically checks the tile based on
	; the water flag for the tile rather than all these range comparisons
Object_Check_Water:
	STY TempY
	STA TempA
	LDY Objects_ID,X	 
	LDA Object_AttrFlags,Y	
	AND #OAT_FIREIMMUNITY
	BNE Object_Check_Water1

	LDA TempA
	CMP #(TILE_PROP_FOREGROUND | TILE_PROP_WATER | TILE_PROP_HARMFUL)
	BEQ Object_Check_Water0
	CMP #(TILE_PROP_WATER | TILE_PROP_HARMFUL)
	BNE Object_Check_Water1

Object_Check_Water0:
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State, X
	LDA #$1f
	STA Objects_Timer,X
	RTS


Object_Check_Water1:
	LDY #$00
	LDA TempA
	AND #TILE_PROP_ITEM
	CMP #TILE_PROP_ITEM
	BEQ Not_Water
	AND #TILE_PROP_WATER
	BEQ Not_Water
	INY

Not_Water:
	TYA
	STA TempA
	CMP Objects_InWater,X	
	BEQ PRG000_C6FA	 	; If object is either still in water / out of water (hasn't changed), jump to PRG000_C6FA

	JSR Object_WaterSplash	 ; Hit water; splash!

	LDA TempA		 ; Restore underwater flag

PRG000_C6FA:
	STA Objects_InWater,X	 ; Set object's in-water flag
	LDY TempY
	RTS

Object_TestTopBumpBlocks:
	LDA <Objects_CollisionDetectionZ,X
	AND #HIT_CEILING
	BEQ Object_TestTopBumpBlocks1

	LDA Object_TileFeetProp
	CMP #TILE_PROP_ITEM
	BCC Object_TestTopBumpBlocks1

	JSR Object_TopBumpBlocks

Object_TestTopBumpBlocks1:
	RTS

Object_TestSideBumpBlocks:
	LDA Object_TileWallProp
	CMP #TILE_PROP_ITEM
	BCC Object_TestSideBumpBlocks1

	JSR Object_SideBumpBlocks

Object_TestSideBumpBlocks1:
	RTS

SetObjectTileCoordAlignObj:
	SEC
	BCS SOTC

SetObjectTileCoord:
	CLC

SOTC:
	LDX <CurrentObjectIndexZ
	LDA Objects_LastTileYHi
	STA Level_BlockChgYHi
	BCC SOTC2
	STA <Objects_YHiZ,X

SOTC2:
	LDA Objects_LastTileY
	AND #$f0
	STA Level_BlockChgYLo
	BCC SOTC3
	STA <Objects_YZ,X

SOTC3:
	LDA Objects_LastTileXHi
	STA Level_BlockChgXHi
	BCC SOTC4
	STA <Objects_XHiZ,X

SOTC4:
	LDA Objects_LastTileX
	AND #$f0
	STA Level_BlockChgXLo
	BCC SOTC5
	STA <Objects_XZ,X

SOTC5:
	RTS

DrawEnemyTempBlock:
	STA TempA
	STX TempX
	LDX #$09

FindFreeSpinnerE:
	LDA SpinnerBlockTimers, X
	BEQ DoSpinnerE
	DEX
	BPL FindFreeSpinnerE
	LDX TempX
	LDA #$00
	RTS

DoSpinnerE:
	LDA TempA
	STA SpinnerBlocksReplace, X
	LDA #$FF
	STA SpinnerBlockTimers, X

	LDA Objects_LastTileY
	STA SpinnerBlocksY,X	 ; Store into object slot

	LDA Objects_LastTileYHi
	STA SpinnerBlocksYHi,X ; Store Y Hi into object slot

	LDA Objects_LastTileXHi
	STA SpinnerBlocksXHi,X ; Store X Hi into object slot

	LDA Objects_LastTileX
	STA SpinnerBlocksX,X ; Store X Hi into object slot

	LDX TempX
	LDA TempY
	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_InteractWithTiles
;
; Calls Object_Move and handles the object responding to hitting
; the floor/ceiling, or bump blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $A966
Object_InteractWithTiles:
	LDA <Objects_CollisionDetectionZ,X

	TAY		 ; Object detection status -> 'Y'
	AND #$04	 
	BEQ PRG001_A973	 ; If object did NOT hit floor, jump to PRG001_A973

	JSR Object_HitGround ; Object hit ground, align

PRG001_A973:
	TYA		 ; Object detection status -> 'A'
	AND #$08
	BEQ PRG001_A97C	 ; If object did NOT hit ceiling, jump to PRG001_A97C
	
	JSR Object_HitCeiling

PRG001_A97C:
	LDA Object_TileFeetValue
	BEQ PRG001_A993
	AND #$3F
	BNE PRG001_A993	 ; If object did not hit the TILEA_BLOCKBUMP_CLEAR tile, jump to PRG001_A993

	; Hit the blockbump tile... (i.e. this kills an enemy who was unlucky enough to be on a bumped block)

	LDA #-$30
	STA <Objects_YVelZ,X	 ; Object Y velocity = -$30

	LDA <Objects_XZ,X
	ASL A	
	ASL A	
	ASL A	
	ASL A			; Shift X left 4 (sort of makes it a 4.4FP)
	EOR <Objects_XVelZ,X	; Flip against the "whole" part of the X velocity
	AND #$80	 	
	BNE PRG001_A9B1	 	; If object is on the left half of the tile with a right going velocity or vice versa, jump to PRG001_A9B1

PRG001_A993:

	; Object didn't hit the bump tile 

	TYA		 ; Object detection status -> 'A'
	AND #$03
	BEQ PRG001_A9B7	 ; If object did NOT hit a wall, jump to PRG001_A9B7 (RTS)

	CPX #$05
	BNE PRG001_A9B1	 ; If object slot is NOT 5, jump to PRG001_A9B1

	; Object slot 5 only...

	LSR A		 ; Shifts detection bits right 1
 
	LDA <Objects_XZ,X
	AND #$0f	 ; Tile-relative X

	LDY #$03	 ; Y = 3

	BCS PRG001_A9A7	 ; If object hit wall on the right, jump to PRG001_A9A7

	LDY #$03	 ; Otherwise, Y = 3 (oops?)

PRG001_A9A7:
	STY <Temp_Var1	 ; Temp_Var1 = 3 (because the above does nothing, heh)
	ADD <Temp_Var1	 ; Temp_Var1 = 6
	CMP #$08	 
	BGE PRG001_A9B1	 ; If Temp_Var1 >= 8 (never gonna happen), jump to PRG001_A9B1

	RTS		 ; Return

PRG001_A9B1:

	; Combined, this just reverses the X velocity
	JSR Object_Reverse

PRG001_A9B7:
	RTS		 ; Return

SetSpriteFG:
	LDA Objects_SpriteAttributes, X
	AND #$DF
	STA Objects_SpriteAttributes, X

	LDY #$02

SetSpriteFG1:
	LDA Object_TileFeetProp, Y
	CMP #TILE_ITEM_COIN
	BCS SetSpriteFG2
	
	AND #TILE_PROP_FOREGROUND
	BNE SetSpriteFG3

SetSpriteFG2:
	DEY
	BPL SetSpriteFG1
	BMI SetSpriteFG4

SetSpriteFG3:
	LDA Objects_SpriteAttributes, X
	ORA #SPR_BEHINDBG
	STA  Objects_SpriteAttributes, X

SetSpriteFG4:
	RTS


FindEmptyEnemySlot:
	LDX #$04

FindEmptyEnemySlot1:
	LDA Objects_State,X
	BEQ FindEmptyEnemySlot2	 ; If this object slot's state is Dead/Empty, jump to PRG002_A5AE

	DEX		 ; X--
	BPL FindEmptyEnemySlot1	 ; While X >= 0, loop!
	PLA
	PLA

FindEmptyEnemySlot2:
	RTS

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcHomingVels
;
; How an 8-bit CPU can calculate aiming projectiles
; towards the Player!  Returns values in respective
; Objects_TargetingXVal and Objects_TargetingYVal
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_CalcHomingVels:
	
	LDA #$14
	STA <Temp_Var2	 ; Temp_Var2 = $14
	
	; Backup 'X' and 'Y'
	TXA
	PHA
	TYA
	PHA

	; Backup Player_Y
	LDA <Player_Y
	PHA

	;CMP #$50
	;BGE PRG001_B08F	 ; If Player_Y >= $50, jump to PRG001_B08F
	;
	;; Otherwise, force Player_Y = $50
	;LDA #$50
	;STA <Player_Y

PRG001_B08F:
	JSR Level_ObjCalcYDiffs
	STY <Temp_Var3		 ; Store above/below flag -> Temp_Var3

	; Get absolute value of Temp_Var16 (Y difference between Player and Koopaling)
	LDA <Temp_Var16	
	BPL PRG001_B09B	 
	JSR Negate	 
PRG001_B09B:
	STA <Temp_Var13		 ; -> Temp_Var13

	JSR Level_ObjCalcXDiffs
	STY <Temp_Var4		 ; Store left/right of flag -> Temp_Var4

	; Get absolute value of Temp_Var16 (X difference between Player and Koopaling)
	LDA <Temp_Var16	
	BPL PRG001_B0A9	
	JSR Negate
PRG001_B0A9:
	STA <Temp_Var14		 ; -> Temp_Var14

	LDY #$00	 ; Y = 0

	LDA <Temp_Var14
	CMP <Temp_Var13
	BGE PRG001_B0BC	 ; If Temp_Var14 (Player vs Koopaling X diff) >= Temp_Var13 (Player vs Koopaling Y diff), jump to PRG001_B0BC

	INY		 ; Y = 1

	; Swap Temp_Var13 and Temp_Var14
	PHA
	LDA <Temp_Var13
	STA <Temp_Var14
	PLA
	STA <Temp_Var13

PRG001_B0BC:

	; At this point, Temp_Var13 >= Temp_Var14, guaranteed

	; What follows is some kind of algorithm that can "aim" a projectile
	; towards a Player (e.g., Koopaling wand shots) but I'm not going to
	; research the "why" at this time... it "just works"

	LDA #$00
	STA <Temp_Var12		; Temp_Var12 = 0
	STA <Temp_Var1		; Temp_Var1 = 0
	LDX <Temp_Var2		; X = Temp_Var2 (starts at $14)

PRG001_B0C4:
	LDA <Temp_Var12
	ADD <Temp_Var13
	CMP <Temp_Var14
	BLT PRG001_B0D1		; If (Temp_Var12 + Temp_Var13) < Temp_Var14, jump to PRG001_B0D1

	; Otherwise...
	SBC <Temp_Var14		; Subtract Temp_Var14 from Temp_Var12
	INC <Temp_Var1		; Temp_Var1++

PRG001_B0D1:
	STA <Temp_Var12 	; Update Temp_Var12
	DEX		 	; X--
	BNE PRG001_B0C4	 	; While X > 0, loop!

	TYA
	BEQ PRG001_B0E3	 ; If Y = 0, jump to PRG001_B0E3

	; Swap Temp_Var1 and Temp_Var2
	LDA <Temp_Var1
	PHA		
	LDA <Temp_Var2	
	STA <Temp_Var1	
	PLA		
	STA <Temp_Var2	

PRG001_B0E3:
	LDA <Temp_Var1	
	LDY <Temp_Var3	
	BEQ PRG001_B0EE	

	JSR Negate	
	STA <Temp_Var1	

PRG001_B0EE:
	LDA <Temp_Var2	
	LDY <Temp_Var4	
	BEQ PRG001_B0F9	

	JSR Negate	
	STA <Temp_Var2	

PRG001_B0F9:

	; Restore Player_Y
	PLA
	STA <Player_Y

	; Restore 'Y' and 'X'
	PLA
	TAY
	PLA
	TAX


	; Temp_Var1 contains the "homing in" Y velocity
	LDA <Temp_Var1
	STA Objects_TargetingYVal,X

	; Temp_Var2 contains the "homing in" X velocity
	LDA <Temp_Var2
	STA Objects_TargetingXVal,X

	RTS		 ; Returns

DoBossFights:
	LDA PAGE_A000
	PHA
	LDA #$13
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR BossFight
	PLA 
	STA PAGE_A000
	JSR PRGROM_Change_A000 
	RTS

GiantXFrame:
	.byte $00, $08, $10, $18, $00, $08, $10, $18

GiantYFrame:
	.byte $00, $00, $00, $00, $10, $10, $10, $10

GiantFlipOffset:
	.byte $03, $01, $FF, $FD, $03, $01, $FF, $FD

DrawGiantObjectMirrored:
	LDA #$01
	BNE DrawGiantObject1

DrawGiantObject:
	LDA #$00

DrawGiantObject1
	STA <Temp_Var12

	JSR Object_CalcSpriteXY_NoHi
	LDA Objects_Frame, X
	ASL A
	ASL A
	ASL A
	STA <Temp_Var6

	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #$F0
	ORA Objects_SpritesVerticallyOffScreen, X
	STA <Temp_Var1

	LDA Objects_Orientation, X
	AND #SPR_HFLIP
	STA <Temp_Var16

	LDA #$00
	STA <Temp_Var2
	
DrawNextGiant:
	JSR DrawGiantSprite
	INC <Temp_Var6
	INC <Temp_Var2
	LDA Object_SpriteRAM_Offset, X
	ADD #$04
	STA Object_SpriteRAM_Offset, X
	LDA <Temp_Var2
	CMP #$08
	BNE DrawNextGiant

	RTS

DrawGiantSprite:
	LDY <Temp_Var6
	LDA <Temp_Var16
	BEQ DrawGiantSprite1

	LDY <Temp_Var2
	LDA GiantFlipOffset, Y
	ADD <Temp_Var6
	TAY

DrawGiantSprite1:
	LDA [Temp_Var10], Y
	STA <Temp_Var3
	LDY <Temp_Var2
	LDX <CurrentObjectIndexZ

	
	LDA GiantXFrame, Y
	ADD Objects_SpriteX,X
	STA <Temp_Var4

	LDA GiantYFrame, Y
	ADD Objects_SpriteY,X
	STA <Temp_Var5


	LDA VisMask, Y
	AND <Temp_Var1
	BNE DontDrawGiant

	LDA <Temp_Var2
	CMP #$06
	BCS GetExtendedSprite
	LDY Object_SpriteRAM_Offset, X
	JMP LetsDrawGiant

GetExtendedSprite:
	JSR Object_GetRandNearUnusedSpr
	
LetsDrawGiant:
	LDA <Temp_Var5
	STA Sprite_RAM, Y
	LDA <Temp_Var3
	STA Sprite_RAM + 1, Y
	LDA Objects_SpriteAttributes,X
	ORA Objects_Orientation,X
	STA Sprite_RAM + 2, Y
	LDA <Temp_Var4
	STA Sprite_RAM + 3, Y

	LDA <Temp_Var12
	BEQ DontDrawGiant

	LDA <Temp_Var2
	AND #$03
	CMP #$02
	BCC DontDrawGiant

	LDA Sprite_RAM + 2, Y
	ORA #SPR_HFLIP
	STA Sprite_RAM + 2, Y
	
DontDrawGiant:
	RTS

; Only works with 16x16 wide objects, nothing taller

Object_InteractWithOtherObjects:

	LDA <Objects_XZ, X
	STA <Temp_Var6		; original object's X
	LDA <Objects_XHiZ, X
	STA <Temp_Var7		; original object's XHi
	LDA <Objects_YZ, X
	ADD #$10
	STA <Temp_Var8		; original object's Y 'bottom'
	LDA <Objects_YHiZ, X
	ADC #$00
	STA <Temp_Var9
	LDX #$04

DetectNextSprite:
	CPX <CurrentObjectIndexZ
	BEQ GoNextSprite

	LDA Objects_State, X
	AND #$FE
	CMP #OBJSTATE_NORMAL
	BNE GoNextSprite

	LDY Objects_ID,X	 ; Y = this object's ID
	LDA Object_AttrFlags,Y
	AND #OAT_BOUNCEOFFOTHERS
	BEQ GoNextSprite
	LDA <Objects_XZ, X
	SUB <Temp_Var6			; original object's X
	STA <Temp_Var10			; object difference
	LDA <Objects_XHiZ, X		; original object's XHi
	SBC <Temp_Var7
	BEQ KeepCalcingX
	CMP #$FF
	BNE GoNextSprite

	LDA <Temp_Var10
	CMP #$F2
	BCS TrySpriteCarry
	BCC GoNextSprite

KeepCalcingX:
	LDA <Temp_Var10
	CMP #$0E
	BCS GoNextSprite

TrySpriteCarry:
	STX TempX
	LDA <Temp_Var8		; original object's Y 'bottom'
	SUB <Objects_YZ, X
	STA <Temp_Var10		
	LDA <Temp_Var9
	SBC <Objects_YHiZ, X
	BMI KeepCalcingY
	BNE GoNextSprite

KeepCalcingY:
	LDA <Temp_Var10
	CMP #$04 
	BCS TryBumpOff

DoSpriteCarry:
	STX TempX
	LDY TempX
	LDX <CurrentObjectIndexZ
	LDA Objects_XVelZ, Y
	STA <Objects_XVelZ, X
	LDA #$00
	STA <Objects_YVelZ, X
	LDA Objects_YZ, Y
	SUB #$10
	STA <Objects_YZ, X
	LDA Objects_YHiZ, Y
	SBC #$00
	STA <Objects_YHiZ, X
	SEC
	RTS


GoNextSprite:
	DEX
	BMI GoNextSprite1
	JMP DetectNextSprite
	 
GoNextSprite1:
	LDX <CurrentObjectIndexZ
	CLC
	RTS

TryBumpOff:
	CMP #$1E
	BCS GoNextSprite

	JSR Object_Reverse
	JSR Object_ApplyXVel

	LDX <CurrentObjectIndexZ
	JSR Object_Reverse
	JSR Object_ApplyXVel
	CLC
	RTS

PatrolAccel_Limit: .byte $01, $FF
PatrolVel_Limit: .byte $10, $F0
ChaseVel_Limit: .byte $18, $E8


InitPatrol:
	LDA #$01
	STA Objects_Data3,X
	LDA Objects_Property, X
	JSR DynJump

	.word InitPatrolRTS
	.word InitPatrolRTS
	.word InitPatrolRTS
	.word InitDiagonal2
	.word InitCircleCCW
	.word InitCircleCW
	.word InitPatrolRTS

InitCircleCCW:
	LDA Objects_Data8, X
	LSR A
	STA Objects_Timer2, X
	LDA #$F0
	STA Objects_YVelZ, X
	RTS

InitCircleCW:
	LDA Objects_Data8, X
	LSR A
	STA Objects_Timer2, X
	LDA #$10
	STA Objects_YVelZ, X

InitDiagonal2:
	LDA #$01
	STA Objects_Data3, X

InitPatrolRTS:
	RTS

DoPatrol:
	LDA Objects_Property, X

	JSR DynJump
	.word PatrolBackForth
	.word PatrolUpDown
	.word PatrolDiagonal
	.word PatrolDiagonal
	.word PatrolDiagonal
	.word PatrolDiagonal
	.word Chase

PatrolDiagonal:
	JSR PatrolUpDown

PatrolBackForth:
	LDY #SPR_HFLIP	 ; Y = SPR_HFLIP (paratroopa moving to the right)

	LDA <Objects_XVelZ,X
	BPL PRG004_B2BD	 ; If paratroopa is moving to the right, jump to PRG004_B2BD

	LDY #$00	 ; Y = 0 (paratroopa moving to the left)

PRG004_B2BD:
	TYA		 
	STA Objects_Orientation,X	 ; Set appropriate flip

	LDA Objects_Timer,X
	BNE PRG004_B2FB	 ; If timer is not expired, jump to PRG004_B2FB

	INC <Objects_Data1,X	 ; Var4++

	LDA <Objects_Data1,X
	AND #$03
	BNE PRG004_B2FB	 ; 1:4 ticks proceed, otherwise jump to PRG004_B2FB

	LDA Objects_Data3,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate!
	LDA <Objects_XVelZ,X
	ADD PatrolAccel_Limit,Y
	STA <Objects_XVelZ,X

	CMP PatrolVel_Limit,Y
	BNE PRG004_B2FB	 ; If Paratroopa is not at his velocity limit, jump to PRG004_B2FB
 
	INC Objects_Data3,X	 ; Var3++

	; Reset timer to $30
	
	LDA Objects_Data8, X
	STA Objects_Timer,X

PRG004_B2FB:
	JSR Object_ApplyXVel	 ; Apply X velocity
	RTS

PatrolUpDown:
	
	LDA Objects_Timer2,X
	BNE PRG004_B2FB_2	 ; If timer is not expired, jump to PRG004_B2FB

	INC Objects_Data6,X	 ; Var4++

	LDA Objects_Data6,X
	AND #$03
	BNE PRG004_B2FB_2	 ; 1:4 ticks proceed, otherwise jump to PRG004_B2FB

	LDA Objects_Data3,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate!
	LDA <Objects_YVelZ,X
	ADD PatrolAccel_Limit,Y
	STA <Objects_YVelZ,X

	CMP PatrolVel_Limit,Y
	BNE PRG004_B2FB_2	 ; If Paratroopa is not at his velocity limit, jump to PRG004_B2FB
 
	INC Objects_Data3,X	 ; Var3++

	; Reset timer to $30
	LDA Objects_Data9, X
	STA Objects_Timer2,X

PRG004_B2FB_2:
	JSR Object_ApplyYVel_NoLimit	 ; Apply X velocity
	RTS

Chase:
	LDA <Player_Y
	STA ChaseTargetY
	LDA <Player_YHi
	STA ChaseTargetYHi

ChaseTargeted:
	LDA Objects_InWater, X
	BEQ PRG002_A8ED
	INC Objects_Data5, X
	LDA Objects_Data5, X
	AND #$03
	BEQ PRG002_A84F

PRG002_A8ED:	
	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVelZ,X
	CMP ChaseVel_Limit,Y	
	BEQ PRG002_A8EE	 ; If Boo is at his acceleration limit, jump to PRG002_A8EE

	ADD PatrolAccel_Limit,Y	 ; Boo accelerates!
	STA <Objects_XVelZ,X	 ; Update Boo's X velocity

PRG002_A8EE:

	; Set flip bit as appropriate
	LDY #SPR_HFLIP
	LDA Objects_XVelZ, X
	BPL SetChaseFlip
	LDY #$00

SetChaseFlip:
	TYA
	STA Objects_Orientation,X	

	JSR Object_CalcCoarseTargetYDiff

	LDY #$00	 ; Y = 0 (Player is lower, move down!)

	LDA <Temp_Var15
	SUB #$0C
	BMI PRG002_A841

	INY		 ; Y = 1 (Player is higher, move up!)

PRG002_A841:
	LDA <Objects_YVelZ,X
	CMP ChaseVel_Limit,Y
	BEQ PRG002_A84E	 ; If Boo is at his acceleration limit, jump to PRG002_A84E

	ADD PatrolAccel_Limit,Y	 ; Boo accelerates!
	STA <Objects_YVelZ,X	 ; Update Boo's Y velocity

PRG002_A84E:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity

PRG002_A84F:
	RTS



FaceDirection: .byte SPR_HFLIP, $00

Object_FaceDirectionMoving:
	LDY #$00
	LDA <Objects_XVelZ, X
	BPL Object_FaceDirectionMoving1

	INY

Object_FaceDirectionMoving1:
	LDA Objects_Orientation, X
	AND #~SPR_HFLIP
	ORA FaceDirection, Y
	STA Objects_Orientation, X
	RTS

Object_FacePlayer:
	JSR Level_ObjCalcXDiffs
	LDA Objects_Orientation, X
	AND #~SPR_HFLIP
	ORA FaceDirection, Y
	STA Objects_Orientation, X
	RTS

Reap_Coin:
	LDA Player_Equip
	CMP #BADGE_COIN
	BNE Reap_Coin1

	INC Coins_Earned ; One more coin earned
	LDA Objects_YZ, X
	CLC
	ADC #$08
	STA <Temp_Var1
	LDA Objects_XZ, X
	STA <Temp_Var2
	JSR Produce_Coin

Reap_Coin1:
	RTS

Reap_CoinY:
	LDA Player_Equip
	CMP #BADGE_COIN
	BNE Reap_CoinY1

	INC Coins_Earned ; One more coin earned
	LDA Objects_YZ, Y
	CLC
	ADC #$08
	STA <Temp_Var1
	LDA Objects_XZ, Y
	STA <Temp_Var2
	JSR Produce_Coin

Reap_CoinY1:
	RTS

Object_HitWall:
	LDA <Objects_XVelZ, X
	BPL Object_HitWall1

	LDA <Objects_XZ, X
	ADD #$08
	AND #$F0
	STA <Objects_XZ, X
	LDA <Objects_XHiZ, X
	ADC #$00
	STA <Objects_XHiZ, X
	LDA #$00
	STA <Objects_XVelZ, X
	STA Objects_XVelFrac,X	 
	RTS

Object_HitWall1:
	LDA <Objects_XZ, X
	AND #$F0
	STA <Objects_XZ, X
	LDA #$00
	STA <Objects_XVelZ, X
	STA Objects_XVelFrac,X	 
	RTS

CheckBlockAbove:
	LDA <Objects_YZ, X
	STA <Temp_Var14
	SUB #$10
	STA <Objects_YZ, X
	LDA <Objects_YHiZ, X
	STA <Temp_Var15
	SBC #$00
	STA <Objects_YHiZ, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_YZ, X
	LDA <Temp_Var15
	STA <Objects_YHiZ, X
	PLA
	RTS

CheckBlockBelow:
	LDA <Objects_YZ, X
	STA <Temp_Var14
	ADD #$10
	STA <Objects_YZ, X
	LDA <Objects_YHiZ, X
	STA <Temp_Var15
	ADC #$00
	STA <Objects_YHiZ, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_YZ, X
	LDA <Temp_Var15
	STA <Objects_YHiZ, X
	PLA
	RTS

CheckBlockRight:
	LDA <Objects_XZ, X
	STA <Temp_Var14
	ADD #$10
	STA <Objects_XZ, X
	LDA <Objects_XHiZ, X
	STA <Temp_Var15
	ADC #$00
	STA <Objects_XHiZ, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_XZ, X
	LDA <Temp_Var15
	STA <Objects_XHiZ, X
	PLA
	RTS

CheckBlockLeft:
	LDA <Objects_XZ, X
	STA <Temp_Var14
	SUB #$10
	STA <Objects_XZ, X
	LDA <Objects_XHiZ, X
	STA <Temp_Var15
	SBC #$00
	STA <Objects_XHiZ, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_XZ, X
	LDA <Temp_Var15
	STA <Objects_XHiZ, X
	PLA
	RTS

GetBlock:
	LDY #(OTDO_Water - Object_TileDetectOffsets)
	JSR Object_DetectTile
	RTS

Object_GetKilled:
	INC Exp_Earned
	JSR Reap_Coin

	LDA #OBJSTATE_KILLED
	STA Objects_State,X
 
	; Set object Y velocity to -$40 (fly up after death)
	LDA #-$40 
	STA <Objects_YVelZ,X
 
	RTS

EnemyEnterXVel:	.byte $08, -$08



ObjInit_TowardsPlayer:

	; Get last scroll direction so we know which way to face
	JSR Object_FacePlayer

	; Enemy charges at Player the same
	LDA EnemyEnterXVel,Y
	STA <Objects_XVelZ,X

	RTS		 ; Return


Object_Hold:
	LDA Objects_Timer2, X
	BNE Object_HoldRTS

	LDA <Pad_Holding
	AND #PAD_B
	BEQ Object_Kick

	LDA Objects_Data4, X
	BNE Object_HoldRTS0

	LDA Player_IsHolding
	BNE Object_HoldRTS

	LDA #$01
	STA Player_IsHolding
	STA Objects_Data4, X

	LDA Player_FlipBits
	STA Objects_Orientation,X
	LDA Player_XVel, X
	STA Objects_XVelZ, X

	LDA Player_YVel, X
	STA Objects_YVelZ, X

Object_HoldRTS0:
	JSR Object_PositionHeld

Object_HoldRTS:
	RTS

Object_Kick:
	LDA Objects_Data4, X
	BEQ Object_KickRTS

	LDA #$00
	STA Objects_Data4, X
	STA Player_IsHolding
	JSR Object_GetKicked
	
	LDA #OBJSTATE_NORMAL
	STA Objects_State, X

	JSR Object_DetectTiles

	LDA <Objects_CollisionDetectionZ,X
	AND #(HIT_LEFTWALL | HIT_RIGHTWALL)
	BNE Object_ReverseXVel

	LDA Objects_LastProp, X
	AND #$F0
	CMP #TILE_PROP_SOLID_ALL
	BEQ Object_ReverseXVel

	CMP #TILE_PROP_ITEM
	BNE Object_KickNotWall

Object_ReverseXVel:
	LDA <Objects_XVelZ, X
	EOR #$FF
	ADD #$01
	STA <Objects_XVelZ, X

Object_KickNotWall:
	LDA <Objects_CollisionDetectionZ,X
	AND #HIT_GROUND
	BEQ Object_KickRTS

	LDA #$F0
	STA <Objects_YVelZ, X

Object_KickRTS:
	RTS
