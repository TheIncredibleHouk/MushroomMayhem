; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-02-13 22:44:39.225983982 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ColorRotation_Do
;
; Performs the palette color rotation effects per RotatingColor_Cnt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; The palette color forcefully applied in a color rotation
Rotation_Colors:
	.byte $26, $2A, $22, $36

ColorRotation_Do:
	
	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	LDA RotatingColor_Cnt
	BEQ PRG007_A1EA	 ; If RotatingColor_Cnt = 0 (No color rotation active), jump to PRG007_A1EA (RTS)

	PHA		 ; Save rotation value

	AND #$03
	TAY		 ; Y = 0 to 3, based on rotation value

	DEC RotatingColor_Cnt	 ; RotatingColor_Cnt--

	PLA		 ; Restore rotation value
	BPL PRG007_A1EB	 ; If bit 7 not set on rotation value, jump to PRG007_A1EB

	; Bit 7 set on RotatingColor_Cnt

	AND #%01111111	 ; Ignore bit 7
	BNE PRG007_A1A8	 ; If does not amount to zero, jump to PRG007_A1A8

	STA RotatingColor_Cnt	 ; Otherwise, clear RotatingColor_Cnt

PRG007_A1A8:

	; Address of palette to modify
	LDA #$3f
	STA Graphics_Buffer+$00,X
	LDA #$04
	STA Graphics_Buffer+$01,X

	; 8 bytes to go
	LDA #$08
	STA Graphics_Buffer+$02,X

	; Set the rotation colors into the buffer
	LDA Rotation_Colors,Y
	STA Graphics_Buffer+$04,X
	STA Graphics_Buffer+$05,X
	STA Graphics_Buffer+$06,X
	STA Graphics_Buffer+$08,X

	LDA Palette_Buffer+$4
	STA Graphics_Buffer+$03,X

	LDA Palette_Buffer+$8
	STA Graphics_Buffer+$07,X

	LDA Palette_Buffer+$A
	STA Graphics_Buffer+$09,X

	LDA Palette_Buffer+$B
	STA Graphics_Buffer+$0A,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$0B,X

	; Add to the graphics buffer counter
	TXA
	ADD #$0b
	STA Graphics_BufCnt

PRG007_A1EA:
	RTS		 ; Return


PRG007_A1EB:

	; Bit 7 not set on RotatingColor_Cnt

	LDA RotatingColor_Cnt
	BEQ PRG007_A1F5	 ; If RotatingColor_Cnt = 0, jump to PRG007_A1F5

	; Set the rotation colors into the buffer
	LDA Rotation_Colors,Y
	BNE PRG007_A1F8	 ; Jump (technically always) to PRG007_A1F8

PRG007_A1F5:
	LDA Palette_Buffer+$10

PRG007_A1F8:
	STA Graphics_Buffer+$03,X

	LDA #$10
	STA Graphics_Buffer+$01,X

	LDA Palette_Buffer+$11
	STA Graphics_Buffer+$04,X

	LDA Palette_Buffer+$12
	STA Graphics_Buffer+$05,X

	LDA Palette_Buffer+$13
	STA Graphics_Buffer+$06,X

	; Address of palette to modify
	LDA #$3f
	STA Graphics_Buffer+$00,X
	LDA #$04
	STA Graphics_Buffer+$02,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$07,X

	; Add to the graphics buffer counter
	TXA
	ADD #$07
	STA Graphics_BufCnt

	RTS		 ; Return

PlayerXVel: .byte 03, 02
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gameplay_UpdateAndDrawMisc
;
; Color rotation effects, lava, donut lifts, arrow platforms,
; brick busts, water/waterfall visual effects, bubbles, splashes,
; pop-up coins, Special Objects, Cannon Fires, Player Projectiles,
; and, last but not least (well, maybe least), "shell kill flashes"!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Gameplay_UpdateAndDrawMisc:
	JSR ColorRotation_Do	 	 ; Do color rotation effects, if any
	JSR BrickBusts_DrawAndUpdate	 ; Draw and update brick bust effects
	JSR CoinPUps_DrawAndUpdate	 ; Update and draw coins that have popped out of boxes
	JSR SpecialObjs_UpdateAndDraw	 ; Update and draw Special objects
	JSR CannonFire_UpdateAndDraw	 ; Update and draw the Cannon Fires
	JSR PlayerProjs_UpdateAndDraw	 ; Update and draw Player's weapon projectiles
	
	LDA Player_HaltTick	; If Player is not halted ...
	ORA Player_IsDucking	; ... Player is ducking ...
	ORA Player_Kick	 	; ... Player is kicking ...
	ORA Player_InPipe	; ... Player is in a pipe ...
	ORA <Player_HaltGameZ	; ... gameplay is halted ...
	BNE PRG007_A268	 	; ... then jump to PRG007_A268

	BIT <Pad_Input
	BVC PRG007_A268	 ; If Player is NOT pressing B, jump to PRG007_A268

	JSR PlayerProj_ThrowWeapon	 ; Player throws weapon, whatever's appropriate

PRG007_A268:
	RTS		 ; Return

Player_Projectiles:
	.byte $00, $00, PLAYER_FIREBALL, $00, $00, $00, PLAYER_HAMMER, PLAYER_ICEBALL, $00, $00, $00, PLAYER_NINJASTAR

PlayerProj_ThrowWeapon:
	LDY Effective_Suit
	LDA Player_Projectiles, Y
	BNE PlayerProj_ThrowWeapon1

	RTS
PlayerProj_ThrowWeapon1:
	TAY
	LDX #$09

PlayerProj_ThrowWeapon2:
	LDA SpecialObj_ID, X
	BEQ PlayerProj_ThrowWeapon3

	DEX
	LDA SpecialObj_ID, X
	BEQ PlayerProj_ThrowWeapon3
	RTS

PlayerProj_ThrowWeapon3:
	LDA Sound_QPlayer
	ORA #SND_PLAYERFIRE
	STA Sound_QPlayer

	LDA #$0B
	STA Player_FireCount

	TYA
	STA SpecialObj_ID, X

	JSR DynJump

	.word Throw_FireBall
	.word Throw_FireBall
	.word Throw_IceBall
	.word Throw_Hammer
	.word Throw_NinjaStar

IceFire_XVel:
	.byte $D0, $30, $E8, $18

IceFire_YVel:
	.byte $10, $C0

Throw_FireBall:
	JSR SetProjectilePosition8x16
	
	LDA IceFire_XVel, Y
	STA SpecialObj_XVel, X

	LDY #$00
	LDA <Pad_Holding
	AND #PAD_UP
	BEQ Throw_FireBall1
	
	INY

Throw_FireBall1:
	LDA IceFire_YVel, Y
	STA SpecialObj_YVel, X

	LDA #$00
	STA SpecialObj_Data2, X
	RTS

Throw_IceBall:
	JSR SetProjectilePosition8x16

	LDA IceFire_XVel + 2, Y
	STA SpecialObj_XVel, X

	LDA #$00
	STA SpecialObj_Data2, X
	STA SpecialObj_YVel, X
	RTS

Hammer_Vel:
	.byte $F0, $10

Throw_Hammer:
	JSR SetProjectilePosition16x16
	
	LDA <Player_XVel
	ADC Hammer_Vel, Y
	STA SpecialObj_XVel, X

	LDA #$C0
	STA SpecialObj_YVel, X
	RTS

PlayerNinja_YVel:
	.byte $00, $30, $D0, $D0

PlayerNinja_XVel:
	.byte $D0, $30, $00

Throw_NinjaStar:
	
	JSR SetProjectilePosition16x16

	LDA <Pad_Holding
	AND #$0C
	LSR A
	LSR A
	TAY

	LDA PlayerNinja_YVel, Y
	STA SpecialObj_YVel, X
	BEQ Throw_NinjaStar1

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE Throw_NinjaStar1

	LDA SpecialObj_YVel, X
	BPL Throw_NinjaStar1
	
	LDA #$00
	STA SpecialObj_XVel, X
	RTS

Throw_NinjaStar1:
	LDY Player_Direction
	LDA PlayerNinja_XVel, Y
	STA SpecialObj_XVel, X
	RTS		 ; Return

Proj_BallPos:
	.byte $04, $0C, $FE, $04
	.byte $00, $00, $FF, $00

SetProjectilePosition16x16:
	LDY Player_Direction

	LDA <Player_X
	ADD Proj_BallPos + 2, Y
	STA SpecialObj_X, X

	LDA <Player_XHi
	ADC Proj_BallPos + 6, Y
	STA SpecialObj_XHi,X
	JMP SetProjectileYPos

SetProjectilePosition8x16:
	LDY Player_Direction

	LDA <Player_X
	ADD Proj_BallPos, Y
	STA SpecialObj_X,X

	LDA <Player_XHi
	ADC #$00
	STA SpecialObj_XHi,X

SetProjectileYPos:
	LDA <Player_Y
	ADD #$08
	STA SpecialObj_Y,X

	LDA <Player_YHi
	ADC #$00
	STA SpecialObj_YHi,X
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PlayerProjs_UpdateAndDraw
;
; Update and draw Player Projectiles 
; (weapons, i.e. fireballs/hammers/fireball poofs)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PlayerProjs_UpdateAndDraw:
	LDX #$09
	STX <CurrentObjectIndexZ
	JSR Player_ProjDoState

	LDX #$08
	STX <CurrentObjectIndexZ
	
Player_ProjDoState:
	LDA SpecialObj_ID, X
	
	JSR DynJump

	.word Player_Nothing
	.word Player_FireBall
	.word Player_IceBall
	.word Player_Hammer
	.word Player_NinjaStar
	.word SpecialObj_Poof

Player_Nothing
	RTS

SpecialObj_ObjectAttributes = Temp_Var16

Player_FireBall:
	LDA <Player_HaltGameZ
	BNE Player_FireBall5

	JSR SObj_ApplyXYVelsWithGravity
	INC SpecialObj_YVel, X
	INC SpecialObj_YVel, X

	JSR SpecialObj_CalcBounds8x16
	JSR PlayerProj_HitEnemies
	BCC Player_FireBallTiles

Player_HitFire:
	LDA #HIT_FIREBALL
	STA Objects_PlayerProjHit, Y

	LDA <SpecialObj_ObjectAttributes
	AND #OAT_FIREPROOF
	BNE Player_FireBallNoKill

	JSR SpecialObj_AttackEnemy
	JMP SpecialObj_ToPoofNoSound

Player_FireBallNoKill:
	LDA <SpecialObj_ObjectAttributes
	AND #OAT_WEAPONSHELLPROOF
	BNE Player_FireBallTiles

	JMP SpecialObj_ToPoof

Player_FireBallTiles:
	JSR SpecialObj_DetectWorld8x16
	JSR SpecialObj_FireTiles

	LDA SpecialObj_YVel, X
	BPL Player_FireBall1

	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_ALL
	BCC Player_FireBall4
	BCS Player_FireBall2

Player_FireBall1:
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCC Player_FireBall4

Player_FireBall2:
	INC SpecialObj_Data2, X
	LDA SpecialObj_Data2, X
	CMP #$02
	BNE Player_FireBall3

	LDA SpecialObj_X, X
	SUB #$08
	STA SpecialObj_X, X

	JMP SpecialObj_ToPoof

Player_FireBall3:
	LDA SpecialObj_YVel, X
	BMI Player_FireBall5

	LDA #-$38
	STA SpecialObj_YVel, X
	BNE Player_FireBall5

Player_FireBall4:
	LDA #$00
	STA SpecialObj_Data2, X

Player_FireBall5:
	LDA #$65
	STA <SpecialObj_Tile

	LDA #SPR_PAL0
	STA <SpecialObj_Attributes
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_CheckDirection
	JSR SpecialObj_Draw8x16
	RTS

SpecialObj_FireTiles:
	LDA Block_NeedsUpdate
	BNE SpecialObj_FireTiles1

	LDY #$07

SpecialObj_FireTiles0:
	LDA FireBallTransitions, Y
	BEQ Fire_Empty

	CMP Tile_LastValue
	BEQ Player_FireTiles2

Fire_Empty:
	DEY
	BPL SpecialObj_FireTiles0

SpecialObj_FireTiles1:
	RTS

Player_FireTiles2:
	ADD #$01
	JSR Object_ChangeBlock
	LDA Tile_DetectionX
	AND #$F0
	STA SpecialObj_X, X

	LDA Tile_DetectionY
	AND #$F0
	STA SpecialObj_Y, X
	JMP SpecialObj_ToPoofNoSound

Player_IceBall:
	LDA <Player_HaltGameZ
	BEQ Player_IceBall0

	JMP Player_IceBall5

Player_IceBall0:

	JSR SObj_ApplyXYVelsWithGravity
	INC SpecialObj_YVel, X
	INC SpecialObj_YVel, X

	JSR SpecialObj_CalcBounds8x16

	JSR PlayerProj_HitEnemies
	BCC Player_IceBallTiles

Player_HitIce:
	LDA #HIT_ICEBALL
	STA Objects_PlayerProjHit, Y

	LDA <SpecialObj_ObjectAttributes
	AND #OAT_ICEPROOF
	BNE Player_IceBallNoKill

	JSR SpecialObj_AttackEnemy
	LDA Objects_State, Y
	CMP #OBJSTATE_KILLED
	BNE Player_IceBallNoKill

	LDA Objects_NoIce, Y
	BEQ Make_Ice
	JMP SpecialObj_ToPoofNoSound

Make_Ice:
	LDA #OBJ_ICEBLOCK
	STA Objects_ID, Y

	LDA #OBJSTATE_NORMAL
	STA Objects_State, Y

	LDA #$00
	STA Objects_Frame, Y
	STA Objects_Orientation, Y

	LDA #SPR_PAL2
	STA Objects_SpriteAttributes, Y

Ice_NoReverse:

	LDA #SPR_PAL2
	STA Objects_SpriteAttributes, Y
	JMP SpecialObj_ToPoofNoSound

Player_IceBallNoKill:
	
	LDA <SpecialObj_ObjectAttributes
	AND #OAT_WEAPONSHELLPROOF
	BNE Player_IceBallTiles

	JMP SpecialObj_ToPoof

Player_IceBallTiles:
	JSR SpecialObj_DetectWorld8x16
	JSR SpecialObj_IceTiles

	LDA SpecialObj_YVel, X
	BPL Player_IceBall1

	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_ALL
	BCC Player_IceBall4
	BCS Player_IceBall2

Player_IceBall1:
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCC Player_IceBall4

Player_IceBall2:
	INC SpecialObj_Data2, X
	LDA SpecialObj_Data2, X
	CMP #$02
	BNE Player_IceBall3

	LDA SpecialObj_X, X
	SUB #$08
	STA SpecialObj_X, X

	JMP SpecialObj_ToPoof

Player_IceBall3:
	LDA SpecialObj_YVel, X
	BMI Player_IceBall5

	LDA #-$50
	STA SpecialObj_YVel, X
	BNE Player_IceBall5

Player_IceBall4:
	LDA #$00
	STA SpecialObj_Data2, X

Player_IceBall5:
	LDA #$59
	STA <SpecialObj_Tile

	LDA #SPR_PAL2
	STA <SpecialObj_Attributes
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_CheckDirection
	JSR SpecialObj_Draw8x16
	RTS

SpecialObj_IceTiles:
	LDA Block_NeedsUpdate
	BNE SpecialObj_IceTiles1

	LDY #$07

SpecialObj_IceTiles0:
	LDA IceBallTransitions, Y
	BEQ Ice_Empty

	CMP Tile_LastValue
	BEQ SpecialObj_IceTiles2

Ice_Empty:
	DEY
	BPL SpecialObj_IceTiles0

SpecialObj_IceTiles1:
	RTS

SpecialObj_IceTiles2:
	SUB #$01
	JSR Object_ChangeBlock
	LDA Tile_DetectionX
	AND #$F0
	STA SpecialObj_X, X

	LDA Tile_DetectionY
	AND #$F0
	STA SpecialObj_Y, X
	JMP SpecialObj_ToPoofNoSound

SpecialObj_ToPoof:
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

SpecialObj_ToPoofNoSound:
	LDA Player_StarInv
	BNE SpecialObj_ToPoofNoSound1

	LDA #PLAYER_POOF
	STA SpecialObj_ID, X

	LDA #$10
	STA SpecialObj_Timer, X

	LDA #$00
	STA SpecialObj_Data1, X

SpecialObj_ToPoofNoSound1:
	RTS

Player_Hammer:
	LDA <Player_HaltGameZ
	BNE Player_HammerDraw

	JSR SObj_ApplyXYVelsWithGravity
	JSR SpecialObj_CalcBounds16x16
	JSR PlayerProj_HitEnemies
	BCC Player_HammerNoKill

	LDA <SpecialObj_ObjectAttributes
	AND #OAT_WEAPONSHELLPROOF
	BNE Player_HammerNoKill

	LDA #HIT_HAMMER
	STA Objects_PlayerProjHit, Y

	JSR SpecialObj_AttackEnemy

Player_HammerNoKill:
	JSR SpecialObj_DetectWorld16x16
	JSR Player_HammerTilesInteraction

Player_HammerDraw:
	LDA #$6D
	STA <SpecialObj_Tile

	LDA #$6F
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL3
	STA <SpecialObj_Attributes
	STA <SpecialObj_Attributes + 1
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_CheckDirection16x6
	JSR SpecialObj_Draw16x16
	RTS

Hammer_Tiles:
	.byte (TILE_PROP_SOLID_TOP | TILE_PROP_STONE), (TILE_PROP_SOLID_ALL | TILE_PROP_STONE), (TILE_ITEM_BRICK)

Player_HammerTilesInteraction:
	LDA Block_NeedsUpdate
	BNE Player_HammerTilesInteraction1

	LDY #$02

Player_HammerTilesInteraction0:
	LDA Hammer_Tiles, Y
	BEQ Hammer_Empty

	CMP Tile_LastProp
	BEQ Player_HammerTilesInteraction2

Hammer_Empty:
	DEY
	BPL Player_HammerTilesInteraction0

Player_HammerTilesInteraction1:
	RTS

Player_HammerTilesInteraction2:
	LDA Tile_LastValue
	AND #$C0
	ORA #$01
	JSR Object_ChangeBlock
	LDA Tile_DetectionX
	AND #$F0
	STA SpecialObj_X, X

	LDA Tile_DetectionY
	AND #$F0
	STA SpecialObj_Y, X

	LDA SpecialObj_X, X
	STA Debris_X

	LDA SpecialObj_Y, X
	STA Debris_Y
	JSR Common_MakeBricks

	JMP SpecialObj_ToPoofNoSound

Player_NinjaStar:
	LDA <Player_HaltGameZ
	BNE Player_StarNoKill

	JSR SObj_ApplyXYVels
	JSR SpecialObj_CalcBounds16x16
	JSR PlayerProj_HitEnemies
	BCC Player_StarNoKill

	LDA <SpecialObj_ObjectAttributes
	AND #OAT_WEAPONSHELLPROOF
	BNE Player_StarNoKill

	LDA #HIT_NINJASTAR
	STA Objects_PlayerProjHit, Y

	JSR SpecialObj_AttackEnemy

Player_StarNoKill:

	LDA #$4D
	STA <SpecialObj_Tile
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL3
	STA <SpecialObj_Attributes
	STA <SpecialObj_Attributes + 1
	JSR SpecialObj_SetMirrorFlipped
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_Draw16x16
	RTS

SpecialObj_SetMirrorFlipped:
	LDA SpecialObj_XVel, X
	BPL SpecialObj_SetMirrorFlipped1

	LDA #(SPR_VFLIP | SPR_HFLIP)
	ORA <SpecialObj_Attributes
	STA <SpecialObj_Attributes + 1
	BNE SpecialObj_SetMirrorFlipped2

SpecialObj_SetMirrorFlipped1:
	LDA <SpecialObj_Attributes + 1
	ORA #(SPR_HFLIP)
	STA <SpecialObj_Attributes + 1

	LDA <SpecialObj_Attributes
	ORA #(SPR_VFLIP)
	STA <SpecialObj_Attributes

SpecialObj_SetMirrorFlipped2:
	RTS

SpecialObj_Poof:
	LDA <Player_HaltGameZ
	BNE Poof_DoDraw

	DEC SpecialObj_Timer, X
	BEQ SpecialObj_Poof1

Poof_DoDraw:
	LDA SpecialObj_Data1, X
	BEQ Poof_DrawNorm

	LDA SpecialObj_Timer, X
	LSR A
	LSR A
	LSR A
	AND #$03
	TAY
	JMP Poof_DrawTiles 

Poof_DrawNorm:
	LDA SpecialObj_Timer, X
	LSR A
	LSR A
	AND #$03
	TAY

Poof_DrawTiles:

	LDA Poof_Patterns, Y
	STA <SpecialObj_Tile
	STA <SpecialObj_Tile2

	LDA SpecialObj_Timer, X
	LSR A
	LSR A
	AND #$01
	BNE SpecialObj_PoofMirrored

	LDA #(SPR_PAL1)
	STA SpecialObj_Attributes

	LDA #(SPR_PAL1 | SPR_VFLIP | SPR_HFLIP)
	STA SpecialObj_Attributes + 1
	BNE SpecialObj_Poof0

SpecialObj_PoofMirrored:
	LDA #(SPR_PAL1 | SPR_VFLIP)
	STA SpecialObj_Attributes

	LDA #(SPR_PAL1 | SPR_HFLIP)
	STA SpecialObj_Attributes + 1

SpecialObj_Poof0:
	JSR SpecialObj_Draw16x16
	RTS


SpecialObj_Poof1:
	JMP SpecialObj_Delete

Detect16x16:
	.byte $02, $0E

SpecialObj_DetectWorld16x16:
	LDA GameCounter
	AND #$01
	TAY

	LDA SpecialObj_Y,X
	ADD Detect16x16, Y
	STA Tile_DetectionY

	LDA SpecialObj_YHi,X
	ADC #$00
	STA Tile_DetectionYHi

	LDA GameCounter
	LSR A
	AND #$01
	TAY

	LDA SpecialObj_X,X
	ADD Detect16x16, Y
	STA Tile_DetectionX

	LDA SpecialObj_XHi,X
	ADC #$00
	STA Tile_DetectionXHi

	JMP Object_DetectTile

Detect8x8:
	.byte $00, $08, $04, $0C

SpecialObj_DetectWorld8x16:
	LDY #$00
	LDA SpecialObj_YVel,X
	BMI DW81

	INY

DW81:
	LDA SpecialObj_Y,X
	ADD Detect8x8 + 2, Y
	STA Tile_DetectionY

	LDA SpecialObj_YHi,X
	ADC #$00
	STA Tile_DetectionYHi

	LDY #$00
	LDA SpecialObj_XVel,X
	BMI DW82

	INY

DW82:
	LDA SpecialObj_X,X
	ADD Detect8x8, Y
	STA Tile_DetectionX

	LDA SpecialObj_XHi,X
	ADC #$00
	STA Tile_DetectionXHi

	JMP Object_DetectTile

SpecialObj_Delete:
	
	LDA #$00
	STA SpecialObj_ID, X
	RTS

SpecialObj_CheckForeground:
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCS SpecialObj_CheckForeground1

	AND #TILE_PROP_FOREGROUND
	BEQ SpecialObj_CheckForeground1

	LDA <SpecialObj_Attributes
	ORA #SPR_BEHINDBG
	STA <SpecialObj_Attributes 

	LDA <SpecialObj_Attributes + 1
	ORA #SPR_BEHINDBG
	STA <SpecialObj_Attributes + 1

SpecialObj_CheckForeground1:
	RTS

SpecialObj_CheckDirection16x6:
	LDA SpecialObj_XVel, X
	BMI SpecialObj_CheckDirection16x61

	LDA <SpecialObj_Attributes
	EOR #SPR_HFLIP
	STA <SpecialObj_Attributes

	LDA <SpecialObj_Attributes + 1
	EOR #SPR_HFLIP
	STA <SpecialObj_Attributes + 1

	LDA <SpecialObj_Tile
	PHA

	LDA <SpecialObj_Tile + 1
	STA <SpecialObj_Tile

	PLA
	STA  <SpecialObj_Tile + 1

SpecialObj_CheckDirection16x61:
	RTS

SpecialObj_CheckDirection:
	LDA SpecialObj_XVel, X
	BMI SpecialObj_CheckDirection1

	LDA <SpecialObj_Attributes
	ORA #SPR_HFLIP
	STA <SpecialObj_Attributes

SpecialObj_CheckDirection1:
	RTS


SpecialObj_Tile = Temp_Var9
SpecialObj_Tile2 = Temp_Var10
SpecialObj_Attributes = Temp_Var11
SpecialObj_Attributes2 = Temp_Var12

SpecialObj_Draw8x16:
	JSR Object_GetUnusedSprite

	LDA SpecialObj_Y,X
	SUB Level_VertScroll
	CMP #$F8
	BCS SpecialObj_Draw8x161

	STA Sprite_RAM+$00,Y

	LDA SpecialObj_X,X
	SUB <Horz_Scroll
	CMP #$08

	BCC SpecialObj_Draw8x161
	CMP #$F8

	BCS SpecialObj_Draw8x161
	STA Sprite_RAM+$03,Y

	LDA <SpecialObj_Attributes
	STA Sprite_RAM + 2, Y

	LDA <SpecialObj_Tile
	STA Sprite_RAM + 1, Y
	RTS

SpecialObj_Draw8x161
	LDA #$F8
	STA Sprite_RAM, Y
	JMP SpecialObj_Delete

SpecialObj_Draw16x16:
	JSR Object_GetUnusedSprite

	LDA SpecialObj_Y,X
	SUB Level_VertScroll
	CMP #$C0
	BCC SpecialObj_NotDelete
	CMP #$D0
	BCC SpecialObj_Draw16x16Delete

SpecialObj_NotDelete:
	STA <Temp_Var1
	STA Sprite_RAM+$00,Y

	LDA SpecialObj_X,X
	SUB <Horz_Scroll
	CMP #$08

	BCC SpecialObj_Draw16x16Delete
	CMP #$F8

	BCS SpecialObj_Draw16x16Delete
	STA <Temp_Var2
	STA Sprite_RAM+$03,Y
	
	LDA <SpecialObj_Attributes
	STA Sprite_RAM + 2, Y

	LDA <SpecialObj_Tile
	STA Sprite_RAM + 1, Y

	JSR Object_GetUnusedSprite

	LDA <SpecialObj_Attributes2
	STA Sprite_RAM + 2, Y

	LDA <SpecialObj_Tile + 1
	STA Sprite_RAM + 1, Y

	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	LDA <Temp_Var2
	ADD #$08
	STA Sprite_RAM+$03,Y
	
	RTS

SpecialObj_Draw16x16Delete:
	LDA #$F8
	STA Sprite_RAM, Y
	JMP SpecialObj_Delete
	
ProjXBound:
	.byte $00, $07

SpecialObj_CalcBounds8x16:
	LDA SpecialObj_X, X
	STA SpecialObj_BoundLeft

	LDA SpecialObj_XHi, X
	STA SpecialObj_BoundLeftHi

	LDA SpecialObj_BoundLeft
	ADD #$08
	STA SpecialObj_BoundRight

	LDA SpecialObj_BoundLeftHi
	ADC #$00
	STA SpecialObj_BoundRightHi

	LDA SpecialObj_Y, X
	ADD #$04
	STA SpecialObj_BoundTop

	LDA SpecialObj_YHi, X
	ADC #$00
	STA SpecialObj_BoundTopHi

	LDA SpecialObj_BoundTop
	ADD #$08
	STA SpecialObj_BoundBottom

	LDA SpecialObj_BoundTopHi
	ADC #$00
	STA SpecialObj_BoundBottomHi
	RTS

SpecialObj_CalcBounds16x16:
	LDA SpecialObj_X, X
	ADD #$02
	STA SpecialObj_BoundLeft

	LDA SpecialObj_XHi, X
	ADC #$00
	STA SpecialObj_BoundLeftHi

	LDA SpecialObj_BoundLeft
	ADD #$0D
	STA SpecialObj_BoundRight

	LDA SpecialObj_BoundLeftHi
	ADC #$00
	STA SpecialObj_BoundRightHi

	LDA SpecialObj_Y, X
	ADD #$02
	STA SpecialObj_BoundTop

	LDA SpecialObj_YHi, X
	ADC #$00
	STA SpecialObj_BoundTopHi

	LDA SpecialObj_BoundTop
	ADD #$0D
	STA SpecialObj_BoundBottom

	LDA SpecialObj_BoundTopHi
	ADC #$00
	STA SpecialObj_BoundBottomHi
	RTS

PlayerProj_HitEnemies:
	LDY #$04	 ; Y = 4 (enemies only exist in the lower slots)

PlayerProj_HitEnemies1:
	LDA Objects_SpritesHorizontallyOffScreen,Y
	ORA Objects_SpritesVerticallyOffScreen,Y
	BNE PlayerProj_HitEnemies2	 ; If object has sprites horizontally or vertically off-screen, jump to PRG007_A667 (Forget it!)

	LDX Objects_State,Y	; X = object's state
	LDA Obj2Obj_EnByState,X
	BNE PlayerProj_HitEnemies2	 ; If this state does not support object-to-object (object-to-Projectile), jump to PRG007_A667 (Forget it!)

	LDX Objects_ID,Y	; X = object's ID
	LDA Object_AttrFlags,X	
	STA <SpecialObj_ObjectAttributes		; Object attribute flags -> Temp_Var1

	JSR SpecialObj_DetectObject	 ; See if Player Project hit an object and respond!
	BCC PlayerProj_HitEnemies2
	LDX <CurrentObjectIndexZ
	RTS

PlayerProj_HitEnemies2:
	DEY		 ; Y--
	BPL PlayerProj_HitEnemies1	; While Y >= 0, loop

	LDX <CurrentObjectIndexZ	 ; X = Player Projectile slot index
	CLC
	RTS		 ; Return

	; A Y range per bounding box index

SpecialObj_AttackEnemy:

	LDA Objects_Health,Y
	SUB #$01
	STA Objects_Health,Y
	BMI ProjEnemyDead	 ; If enemy has no hits left, jump to PRG007_A6DD
	
	RTS		 ; Return


ProjEnemyDead:
	
	TYA
	TAX
	JSR Object_GetKilled
	JSR Object_FlipFallAwayFromHit

	LDX <CurrentObjectIndexZ

	; Set object's velocity based on Player's velocity (sort of works)
	LDA SpecialObj_XVel,X
	BMI ProjEnemyDead_Left

	LDA #$0C
	BNE ProjEnemyDead_XVel

ProjEnemyDead_Left:
	LDA #-$0C

ProjEnemyDead_XVel:
	STA Objects_XVelZ,Y

	LDA #SND_PLAYERKICK
	STA Sound_QPlayer
	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_WaterOrWaterfallVizFX
;
; Visual effects for standing in a waterfall (splashing on head)
; or the periodic bubbles underwater...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Y offsets for periodic bubble generated by the Player while underwater
SwimBubble_YOff:
	.byte $04, $04	; Not a frog swimming frame
	.byte $08, $08	; Idle or left/right frog swimming
	.byte $0D, $0D	; Down frog swim
	.byte $00, $00	; Up frog swim

	; X offsets for periodic bubble generated by the Player while underwater (left is not horizontally flipped, right is h-flipped)
SwimBubble_XOff:
	.byte $00, $0B	; Not a frog swimming frame
	.byte $00, $0B	; Idle or left/right frog swimming
	.byte $05, $05	; Down frog swim
	.byte $05, $05	; Up frog swim

Player_WaterOrWaterfallVizFX:
PRG007_A783:
	LDY <Player_HaltGameZ
	BNE PRG007_A7F0	 ; If gameplay halted, jump to PRG007_A7F0 (RTS)

	LDA Player_InWater
	BEQ PRG007_A7F0	 ; If Player is not underwater, jump to PRG007_A7F0 (RTS)

	; Otherwise, clear kill tally (Being underwater also resets your chain stomping)
	STY Kill_Tally

	CMP #$01
	BEQ PRG007_A7F1	 ; If Player_InWater = 1 (water, not waterfall), jump to PRG007_A7F1

	; Player's in a waterfall!

	LDA <Player_YVel
	CMP #$3c
	BGS PRG007_A7A2	 ; If Player's Y velocity >= $3C, jump to PRG007_A7A2

	INC <Player_YVel ; Player_YVel++

	LDA <Counter_1
	LSR A	
	BCC PRG007_A7A2	 ; Every other tick, jump to PRG007_A7A2

	INC <Player_YVel ; Player_YVel++

PRG007_A7A2:
	JSR Object_GetUnusedSprite
	BEQ PRG007_A7F0	 ; If no free sprite, jump to PRG007_A7F0 (RTS)

	LDA Player_OffScreen
	BNE PRG007_A7F0	 ; If Player is off-screen, jump to PRG007_A7F0 (RTS)

	; Patterns for "splashing" effect seen above Player's head
	LDA #$47
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDA <Counter_1
	LSR A
	AND #$03
	ADD #$05	; Value of 5 to 8

	LDX Player_IsDucking
	BNE PRG007_A7C6	 ; If Player is ducking, jump to PRG007_A7C6

	LDX Player_Suit
	BNE PRG007_A7C9	 ; If Player is not small, jump to PRG007_A7C9

PRG007_A7C6:
	ADD #10		 ; Small or ducking, +10 (15 to 18)

PRG007_A7C9:
	STA <Temp_Var1	 ; -> Temp_Var1

	LDX <CurrentObjectIndexZ	 ; Restore 'X' as slot index

	; Sprite "splashing" effect Y
	LDA <Player_SpriteY
	ADD <Temp_Var1
	SUB #10
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Sprite "splashing" effect X
	LDA <Player_SpriteX
	STA Sprite_RAM+$03,Y
	ADD #$08
	STA Sprite_RAM+$07,Y

	LDA <Counter_1
	AND #$03
	SUB #$02	 ; A = -2 to 1 (spread value)

	JSR Draw_SpreadAndColorful	 ; Spreads out the two sprites and rotates the color palette

PRG007_A7F0:
	RTS		 ; Return


PRG007_A7F1:

	; Player's in regular old water

	LDY #$7f	 ; Y = $7F ("slow" mask value for idle underwater player)

	LDA <Pad_Holding
	AND #(PAD_A | PAD_LEFT | PAD_RIGHT)
	BEQ PRG007_A7FB	 ; If Player is not pressing A, LEFT, or RIGHT (swim controls), jump to PRG007_A7FB

	LDY #$3f	 ; Y = $3F ("fast" mask value for idle underwater player)

PRG007_A7FB:
	TYA		 ; Mask -> 'Y'
	AND <Counter_1
	BNE PRG007_A80C	 ; Periodically jump to PRG007_A80C (RTS)

	; CurrentObjectIndexZ = 2
	LDX #$02
PRG007_A802:
	STX <CurrentObjectIndexZ

	LDA Bubble_Cnt,X
	BEQ PRG007_A80D	 ; If this bubble slot is empty, jump to PRG007_A80D

	DEX		 ; X--
	BPL PRG007_A802	 ; While X >= 0, loop!

PRG007_A80C:
	RTS		 ; Return


PRG007_A80D:
	LDA RandomN
	ORA #$10
	STA Bubble_Cnt,X ; Set random value -> Bubble_Cnt

	LDY #$00	 ; Y = 0

	LDA <Player_Frame
	CMP #PF_FROGSWIM_UPBASE
	BLT PRG007_A835	 ; If Player is not within the low end range of frog suit swim frames, jump to PRG007_A835

	LDY #$03	 ; Otherwise, Y = 3 (pending this might be the "up" frame)

	CMP #PF_FROGHOP_BASE
	BLT PRG007_A835	 ; If frame < PF_FROGHOP_BASE (if true, then absolutely the "up" swim frame), jump to PRG007_A835

	LDY #$00	 ; Otherwise, Y = 0

	CMP #PF_FROGSWIM_IDLEBASE
	BLT PRG007_A835	 ; If not possibly just the "idling" frog frames, jump to PRG007_A835

	INY		 ; Otherwise, Y = 1 (idle or left/right frog swim)

	CMP #PF_FROGSWIM_LRBASE+2
	BLT PRG007_A835	 ; Not a down swimming frame, jump to PRG007_A835

	INY		 ; Otherwise, Y = 2 (down frog swim)

	CMP #(PF_FROGSWIM_DOWNBASE+3)	; This is actually 1 passed the end of frog suit swim frames
	BLT PRG007_A835	 ; If within range of the last frog suit swim frame, jump to PRG007_A835

	LDY #$00	 ; Otherwise, Y = 0

PRG007_A835:

	; Y *= 2
	TYA
	ASL A
	TAY

	BIT <Player_FlipBits
	BVC PRG007_A83D	 ; If Player is not horizontally flipped, jump to PRG007_A83D

	INY		 ; Otherwise, Y++

PRG007_A83D:
	LDA #$00	; A = 0

	LDX <Player_Suit
	BNE PRG007_A845	 ; If Player is not small, jump to PRG007_A845
 
	LDA #$08	 ; Otherwise, A = 8

PRG007_A845:
	LDX <CurrentObjectIndexZ	 ; X = slot backup

	; Set Bubble Y
	ADD <Player_Y
	ADC SwimBubble_YOff,Y
	STA Bubble_Y,X
	LDA <Player_YHi
	ADC #$00
	STA Bubble_YHi,X

	; Set Bubble X
	LDA <Player_X
	ADD SwimBubble_XOff,Y
	STA Bubble_X,X
	LDA <Player_XHi
	ADC #$00
	STA Bubble_XHi,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bubbles_UpdateAndDraw
;
; Update and draw bubbles that appear underwater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Bubbles_UpdateAndDraw:
	LDX #$03	 ; X = 3
PRG007_A86A:
	STX <CurrentObjectIndexZ	 ; -> Slot index backup

	LDA Bubble_Cnt,X
	BEQ PRG007_A874	 ; If this bubble slot is not in use, jump to PRG007_A874

	JSR Bubble_UpdateAndDraw	 ; Update and draw this bubble

PRG007_A874:
	DEX		; X--
	BPL PRG007_A86A	; While X >= 0, loop!

	RTS		 ; Return


Bubble_UpdateAndDraw:
	LDA <Player_HaltGameZ		 
	BEQ PRG007_A87F	 ; If gameplay is not halted, juimp to PRG007_A89A

	JMP PRG007_A89A	 ; Otherwise, jump to PRG007_A89A

PRG007_A87F:
	INC Bubble_Cnt,X ; Bubble counter increment

	; Fix bit 7 on bubble counter
	LDA Bubble_Cnt,X
	ORA #$80
	STA Bubble_Cnt,X

	AND #%00110000
	BEQ PRG007_A89A	 ; Periodically jump to PRG007_A89A

	DEC Bubble_Y,X	 ; Bubble Y --

	LDY Bubble_Y,X
	INY	
	BNE PRG007_A89A	 ; If no carry, jump to PRG007_A89A
	DEC Bubble_YHi,X ; Apply carry

PRG007_A89A:
	LDA Level_7Vertical
	BEQ PRG007_A8BF	 ; If this level is not vertical, jump to PRG007_A8F0

	; Vertical level...

	LDA Bubble_Y,X
	ADD #10		; Bubble Y + 10
	AND #$f0
	STA <Temp_Var3	; Temp_Var3 = bubble row (offset into tile memory)

	LDA Bubble_YHi,X
	ADC #HIGH(Tile_Mem)
	STA <Temp_Var2	; Temp_Var2 = bubble high offset into tile memory

	; Create row/column offset into tile memory for current screen of bubble -> Temp_var1
	LDA Bubble_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	STA <Temp_Var1

	LDY #$00	 ; Y = 0 (not using the offset like non-vertical does)
	BEQ PRG007_A8F0	 ; Jump (technically always) to PRG007_A8F0

PRG007_A8BF:
	LDA Bubble_Y,X
	ADD #10		 ; Bubble Y + 10
	AND #$f0
	STA <Temp_Var3	 ; Temp_Var3 = bubble row (offset into tile memory)

	LDA Bubble_YHi,X
	ADC #$00	 ; Apply carry
	PHA		 ; Save it

	; Temp_Var5 = bubble X
	LDA Bubble_X,X
	STA <Temp_Var5

	LDA Bubble_XHi,X
	ASL A		 ; 2 bytes per screen
	TAY		 ; Y = offset into Tile_Mem_Addr

	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1	 ; Temp_Var1 = low byte of this screen's tile memory address

	PLA		 ; Restore Bubble's Y Hi
	AND #$01	 ; Only 0/1 valid for non-vertical
	ADD Tile_Mem_Addr+1,Y	 ; Add to high byte of address
	STA <Temp_Var2	 ; -> Temp_Var2

	; Create row/column offset -> Temp_Var3
	LDA <Temp_Var5
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var3

	TAY		 ; Y = this offset

PRG007_A8F0:
	LDA [Temp_Var1],Y ; Get the tile the bubble detects
	STA <Temp_Var2	 ; -> Temp_Var2
	AND #TILE_PROP_ITEM
	CMP #TILE_PROP_ITEM
	BNE PRG007_A91E
	AND #TILE_PROP_WATER
	BNE Bubble_Draw	 ; If this tile is still considered underwater, jump to Bubble_Draw 

PRG007_A91E:

	; Remove this bubble
	LDA #$00
	STA Bubble_Cnt,X

	RTS		 ; Return

Bubble_XOff:		.byte $00, $01, $00, -$01
Bubble_SprRAMOff:	.byte $10, $14, $0C, $FF, $10, $14, $0C

Bubble_Draw:
	LDA GameCounter
	AND #%00001100
	LSR A	
	LSR A	
	TAY		 ; Y = 0 to 3

	; Temp_Var1 = bubble's X offset
	LDA Bubble_XOff,Y
	STA <Temp_Var1

	LDA <Counter_1
	AND #%00000011
	ADC <CurrentObjectIndexZ 	
	TAY		 ; Y = (0 to 3) + bubble's index

	LDA Bubble_SprRAMOff,Y
	BMI PRG007_A978	 ; If we hit the $FF value in Bubble_SprRAMOff, jump to PRG007_A978 (RTS)

	TAY		 ; -> 'Y'

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BNE PRG007_A978	 ; If this sprite is not free, jump to PRG007_A978 (RTS)

	; Bubble Y
	LDA Bubble_Y,X
	SUB Level_VertScroll
	STA Sprite_RAM+$00,Y

	CMP #200
	BGE PRG007_A91E	 ; If this bubble's sprite Y >= 200, jump to PRG007_A91E (destroy bubble)

	; Bubble X
	LDA Bubble_X,X
	ADD <Temp_Var1
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	CMP #248
	BCS PRG007_A91E	 ; If this bubble's X >= 248, jump  to PRG007_A91E (destroy bubble)

	; Bubble's pattern
	LDA #$17
	STA Sprite_RAM+$01,Y

	; Bubble's attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

PRG007_A978:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Splash_UpdateAndDraw
;
; Update and draw water surface splashes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Splash_UpdateAndDraw:
	RTS
	LDX #$02	 ; X = 2

PRG007_A97B:
	STX <CurrentObjectIndexZ	 ; -> Slot Index backup

	LDA Splash_Counter,X
	BEQ PRG007_A9A0	 ; If no splash is active here, jump to PRG007_A9A0

	LDA <Player_HaltGameZ
	INC Splash_Counter,X	 ; Splash counter++

	LDA <Counter_1
	LSR A
	BCC PRG007_A991	 ; Every other tick, jump to PRG007_A991

	INC Splash_Counter,X	 ; Splash counter++

PRG007_A991:
	LDA Splash_Counter,X
	CMP #$30
	BLT PRG007_A99D	 ; If splash counter < $30, jump to PRG007_A99D

	JSR Splash_Remove ; Remove this splash
	BEQ PRG007_A9A0	 ; Jump (technically always) to PRG007_A9A0

PRG007_A99D:
	JSR Splash_Draw	 ; Draw this splash

PRG007_A9A0:
	DEX		 ; X--
	BPL PRG007_A97B	 ; While X >= 0, loop!

	RTS		 ; Return

Splash_Patterns:
	.byte $11, $13, $15, $47, $47, $47

Splash_Remove:

	; Remove this splash
	LDA #$00	 
	STA Splash_Counter,X

PRG007_A9AF:
	RTS		 ; Return

Splash_Draw:
	JSR Object_GetUnusedSprite	 
	BEQ PRG007_A9AF	 ; If no sprite available, jump to PRG007_A9AF (RTS)

	STY <Temp_Var1	 ; Sprite RAM offset -> Temp_Var1

	LDA Splash_X,X
	SUB <Horz_Scroll	; Make scroll relative X for splash

	CMP #240
	BGE Splash_Remove	; If splash X >= 240, jump to Splash_Remove

	STA Sprite_RAM+$03,Y	 ; Set left splash sprite X

	ADC #$08	 ; +8
	STA Sprite_RAM+$07,Y	; Set right splash sprite X

	LDA Splash_Y,X		; Get splash Y

	LDY Splash_NoScrollY,X
	BNE PRG007_A9D5	 	; If Splash_NoScrollY is set, do not make splash Y scroll relative

	SUB Level_VertScroll	 ; Make scroll relative Y for splash

PRG007_A9D5:
	LDY <Temp_Var1		 ; Y = sprite RAM offset

	CMP #$ae
	BGE Splash_Remove	 ; If splash sprite RAM offset >= $AE (?), jump to Splash_Remove (remove it!)

	; Set splash sprites Y
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Set left splash sprite attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	; Set right splash sprite attributes
	LDA #(SPR_PAL1 | SPR_HFLIP)
	STA Sprite_RAM+$06,Y

	LDA Splash_Counter,X
	LSR A
	LSR A
	LSR A
	TAX		; X = splash counter / 8
	STX <Temp_Var1	; -> Temp_Var1

	; Set splash sprite patterns
	LDA Splash_Patterns,X
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDX <CurrentObjectIndexZ	 ; X = splash index

	LDA <Temp_Var1
	CMP #$03
	BLT PRG007_AA4C	 ; If (splash counter / 8) < 3, jump to PRG007_AA4C (RTS)

	LDA <Counter_1
	AND #$01
	ORA <Player_HaltGameZ
	BNE PRG007_AA10	 ; Every other tick or gameplay halted, jump to 

	INC Splash_Y,X	 ; Splash_Y++

PRG007_AA10:
	LDA Splash_Counter,X
	SUB #24
	LSR A	
	LSR A	
	LSR A	
	AND #$03	 ; A = (splash counter - 24) / 8

Draw_SpreadAndColorful:
	STA <Temp_Var1		 

	; Subtract from sprite X
	LDA Sprite_RAM+$03,Y
	SUB <Temp_Var1	
	STA Sprite_RAM+$03,Y

	; Add to other sprite X
	LDA Sprite_RAM+$07,Y
	ADD <Temp_Var1
	STA Sprite_RAM+$07,Y

	; Set attributes of two sprites
	LDA #SPR_PAL1
	STA Sprite_RAM+$06,Y

	ORA #SPR_HFLIP
	STA Sprite_RAM+$02,Y

	LDA GameCounter
	AND #$02
	BNE PRG007_AA4C	 ; 2 ticks on, 2 ticks off; jump to PRG007_AA4C (RTS)

	; Mess with attributes for a little sparkly fun
	LDA <Temp_Var1
	ORA #SPR_VFLIP
	STA Sprite_RAM+$02,Y

	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

PRG007_AA4C:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BrickBusts_DrawAndUpdate
;
; Draws and updates the brick bust debris/poof effects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BrickBusts_DrawAndUpdate:
	LDX #$01	 ; X = 1

PRG007_ABC7:
	STX <CurrentObjectIndexZ	; -> CurrentObjectIndexZ

	JSR BrickBust_DrawAndUpdate	 ; Draw and update this brick bust

	DEX		 ; X--
	BPL PRG007_ABC7	 ; While X >= 0, loop

PRG007_ABCF:
	RTS		 ; Return

BrickBust_SprRAMOff:	.byte $08, $18	; Four sprites required here
BrickPoof_SprRAMOff:	.byte $08, $10	; Only two sprites required here

	; Draw and update the specific brick bust
BrickBust_DrawAndUpdate:
	LDA BrickBust_En,X
	BEQ PRG007_ABCF	 ; If this brick bust slot is not active, jump to PRG007_ABCF

	CMP #$02
	BEQ PRG007_ABE0	 ; If the bust type is 2 (typical), jump to PRG007_ABE0

	JMP PRG007_AD27	 ; Otherwise, jump to PRG007_AD27

PRG007_ABE0:
	LDA <Player_HaltGameZ
	BNE PRG007_ABED	 ; If gameplay halted, jump to PRG007_ABED

	LDA <Counter_1
	AND #$03
	BNE PRG007_ABED	 ; 1:4 proceed, otherwise jump to PRG007_ABED

	INC BrickBust_YVel,X	 ; BrickBust_YVel++ (gravity)

PRG007_ABED:
	LDA Brick_DebrisYHi,X
	PHA		 ; Save upper chunk Y

	CLC		 ; Clear carry (no point?)
	SUB Level_ScrollDiffV	 ; Adjust Y based on vertical screen scroll

	LDY <Player_HaltGameZ
	BNE PRG007_ABFE	 ; If gameplay is halted, jump to PRG007_ABFE

	ADD BrickBust_YVel,X	 ; Apply brick bust Y velocity

PRG007_ABFE:
	STA Brick_DebrisYHi,X	 ; -> upper chunk Y

	PLA		 ; Restore original Y
	EOR Brick_DebrisYHi,X
	BPL PRG007_AC1F	 ; If the sign hasn't changed, jump to PRG007_AC1F

	; Sign changed; need to make sure the block bust debris didn't wrap

	LDA Level_ScrollDiffV

	LDY <Player_HaltGameZ
	BNE PRG007_AC12	 ; If gameplay halted, jump to PRG007_AC12

	SUB BrickBust_YVel,X	 ; Apply velocity in reverse

PRG007_AC12:
	EOR Brick_DebrisYHi,X
	BPL PRG007_AC1F	 ; If the sign didn't change, jump to PRG007_AC1F

	; Otherwise, toggle the upper chunk disable
	LDA BrickBust_HEn,X
	EOR #$08
	STA BrickBust_HEn,X

PRG007_AC1F:
	LDA Brick_DebrisY,X
	PHA		 ; Save lower chunk Y

	CLC		 ; Clear carry (no point?)
	SUB Level_ScrollDiffV	 ; Adjust Y based on vertical screens croll

	LDY <Player_HaltGameZ
	BNE PRG007_AC36	 ; If gameplay is halted, jump to PRG007_AC36

	INC Brick_DebrisXDist,X	 ; Increase the chunk separation

	ADD BrickBust_YVel,X	 ; Apply Y velocity

	ADD #$02		; More impact on lower chunk
PRG007_AC36:
	STA Brick_DebrisY,X

	PLA		 ; Restore lower chunk Y

	EOR Brick_DebrisY,X
	BPL PRG007_AC5A	 ; If the sign hasn't changed, jump to PRG007_AC5A

	; Sign changed; need to make sure the block bust debris didn't wrap

	LDA Level_ScrollDiffV

	LDY <Player_HaltGameZ
	BNE PRG007_AC4D	 ; If gameplay halted, jump to PRG007_AC4D

	SUB BrickBust_YVel,X	 ; Apply velocity in reverse
	SUB #$02	 ; With the greater impact

PRG007_AC4D:
	EOR Brick_DebrisY,X
	BPL PRG007_AC5A	 ; If sign didn't change, jump to PRG007_AC5A

	; Otherwise, toggle the lower chunk disable
	LDA BrickBust_HEn,X
	EOR #$04
	STA BrickBust_HEn,X

PRG007_AC5A:

	; Scroll brick bust debris horizontally with screen
	LDA Brick_DebrisX,X
	SUB Level_ScrollDiffH
	STA Brick_DebrisX,X

	TXA		 ; Keeps things interesting
	EOR <Counter_1
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA BrickBust_SprRAMOff,Y
	TAY		 ; Y = sprite RAM offset
	CPY #$08	 
	BNE PRG007_AC7A	 ; If NOT using the offset $08, jump to PRG007_AC7A

	LDA Sprite_RAM+$08
	CMP #$f8
	BEQ PRG007_AC7A	 ; If this sprite is not in use, jump to PRG007_AC7A

	RTS		 ; Return

PRG007_AC7A:
	LDA BrickBust_HEn,X
	STA <Temp_Var4	 ; Horizontal enable flag -> Var4

	CMP #$0c
	BLT PRG007_AC91	 ; If at least one of upper or lower are enabled, jump to PRG007_AC91

	; Upper and lower are both disabled!

	LDA <Player_HaltGameZ
	BNE PRG007_AC8E	 ; If gameplay halted, jump to PRG007_AC8E

	LDA BrickBust_YVel,X
	CMP #$08
	BLS PRG007_AC91	 ; If brick bust Y velocity < $08, jump to PRG007_AC91

PRG007_AC8E:
	JMP PRG007_AD21	 ; Otherwise, jump to PRG007_AD21 (disable this brick bust)

PRG007_AC91:
	LDA <Temp_Var4
	AND #$08
	BNE PRG007_ACA0	 ; If upper bust chunks are disabled, jump to PRG007_ACA0

	; Otherwise set sprite Y for left and right uppers
	LDA Brick_DebrisYHi,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

PRG007_ACA0:
	LDA <Temp_Var4
	AND #$04
	BNE PRG007_ACAF	 ; If lower bust chunks are disabled, jump to PRG007_ACAF

	; Otherwise set sprite Y for left and right lowers
	LDA Brick_DebrisY,X
	STA Sprite_RAM+$08,Y
	STA Sprite_RAM+$0C,Y

PRG007_ACAF:
	LSR <Temp_Var4
	BCC PRG007_ACBB	 ; If right bust chunks are NOT disabled, jump to PRG007_ACBB

	; Hide right-hand bust chunks
	LDA #$f8
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$08,Y

PRG007_ACBB:
	LSR <Temp_Var4
	BCC PRG007_ACC7	 ; If left bust chunks are NOT disabled, jump to PRG007_ACC7

	; Hide left-hand bust chunks
	LDA #$f8
	STA Sprite_RAM+$04,Y
	STA Sprite_RAM+$0C,Y

PRG007_ACC7:

	; Pattern for bust chunks
	LDA BrickBust_Tile, X
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y
	STA Sprite_RAM+$09,Y
	STA Sprite_RAM+$0D,Y

	LDA Brick_DebrisX,X
	PHA		 ; Save chunk X
	ADD Brick_DebrisXDist,X	; Add the distance
	ADD #$08	 	; +8
	STA Sprite_RAM+$03,Y	; Set right upper chunk X
	STA Sprite_RAM+$0B,Y	; Set right lower chunk X

	CMP #248
	BLT PRG007_ACF2	 ; If bust chunk X < 248, jump to PRG007_ACF2

	; Otherwise, disable right chunks
	LDA BrickBust_HEn,X
	ORA #$01
	STA BrickBust_HEn,X

PRG007_ACF2:
	PLA		 ; Restore chunk X
	SUB Brick_DebrisXDist,X	 ; Subtract the distance
	STA Sprite_RAM+$07,Y	 ; Set left upper chunk X
	STA Sprite_RAM+$0F,Y	 ; Set left lower chunk X

	; Seems like this should be a >= 8 check??
	CMP #244
	BLT PRG007_AD09	 ; If bust chunk X < 244 (??), jump to PRG007_AD09

	; Otherwise, disable left chunks
	LDA BrickBust_HEn,X
	ORA #$02
	STA BrickBust_HEn,X

PRG007_AD09:

	; Rotate the horizontal / vertical flips
	LDA BrickBust_Pal, X
	STA Sprite_RAM+$06,Y

	ORA #SPR_VFLIP
	STA Sprite_RAM+$0E,Y

	ORA #SPR_HFLIP
	STA Sprite_RAM+$0A,Y

	LDA BrickBust_Pal, X
	ORA #SPR_HFLIP
	STA Sprite_RAM+$02,Y

	RTS		 ; Return

PRG007_AD21:

	; Disable this brick bust
	LDA #$00
	STA BrickBust_En,X
	LDA #$4B
	STA BrickBust_Tile, X
	LDA #SPR_PAL3
	STA BrickBust_Pal, X

	RTS		 ; Return

PRG007_AD27:

	; Brick bust type non-2 ("poof" away the tile)

	LDA BrickBust_HEn,X
	BEQ PRG007_AD21	 ; If BrickBust_HEn = 0 (poof expired), jump to PRG007_AD21 (disable this brick bust)

	LDA <Player_HaltGameZ
	BNE PRG007_AD33	 ; If gameplay is halted, jump to PRG007_AD33

	DEC BrickBust_HEn,X	 ; BrickBust_HEn-- (used as a counter here)

PRG007_AD33:
	LDA Brick_DebrisYHi,X

	LDY Level_AScrlConfig
	BNE PRG007_AD42	 ; If raster enabled, jump to PRG007_AD42

	; Otherwise, just be screen-scroll relative
	SUB Level_ScrollDiffV
	STA Brick_DebrisYHi,X

PRG007_AD42:
	CMP #208
	BGE PRG007_AD21	 ; If the poof effect Y >= 208 (too low), jump to PRG007_AD21 (disable this brick bust)

	CPY #$00
	BNE PRG007_AD54	 ; If raster effects enabled, jump to PRG007_AD54

	; Scroll poof horizontally
	LDA Brick_DebrisX,X
	SUB Level_ScrollDiffH
	STA Brick_DebrisX,X

PRG007_AD54:
	CMP #240
	BGE PRG007_AD21	 ; If the poof effect X >= 24, jump to PRG007_AD21 (disable this brick bust)

	TXA		 ; Keep it interesting
	EOR <Counter_1	 
	AND #$01	 
	TAY		 ; Y = 0 or 1

	LDA BrickPoof_SprRAMOff,Y
	TAY		 ; Y = Sprite RAM offset

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BNE PRG007_ADA7	 ; If this sprite is not free, jump to PRG007_ADA7 (RTS)

	; Set left sprite X
	LDA Brick_DebrisX,X
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08	 ; +8
	STA Sprite_RAM+$07,Y

	; Set left/right sprite Y
	LDA Brick_DebrisYHi,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA GameCounter
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP
	STA <Temp_Var1	 ; Periodically vertically flip

	; Form attribute with sprite palette 1 for left half
	LDA #SPR_PAL1
	ORA <Temp_Var1
	STA Sprite_RAM+$02,Y

	; Right half uses opposite flips
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y

	LDA BrickBust_HEn,X
	LSR A
	LSR A
	LSR A
	TAX	; X = 0 to 3

	LDA Poof_Patterns,X	 ; Get appropriate "poof" pattern
	STA Sprite_RAM+$01,Y	 ; Left
	STA Sprite_RAM+$05,Y	 ; Right

	LDX <CurrentObjectIndexZ	 ; X = restore slot index

PRG007_ADA7:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CoinPUp_DrawAndUpdate
;
; Draws and updates the coins which have popped out of blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CoinPUp_Patterns:	.byte $49, $49, $49, $49
CoinPUp_Attributes:	.byte SPR_PAL3, SPR_PAL3, SPR_PAL3, SPR_PAL3

CoinPUps_DrawAndUpdate:
	LDX #$03	 ; X = 3 (all "power up" coin slots)
PRG007_ADB2: 
	STX <CurrentObjectIndexZ	 ; -> slot index backup

	LDA CoinPUp_State,X
	BEQ PRG007_ADBC	 ; If there's no active "powerup coin" here, jump to PRG007_ADBC

	JSR CoinPUp_UpdateAndDraw	 ; Update and draw powerup coin

PRG007_ADBC:
	DEX		 ; X--
	BPL PRG007_ADB2	 ; While X >= 0, loop!

	RTS		 ; Return

CoinPUp_UpdateAndDraw:
	LDA <Player_HaltGameZ		 
	BNE PRG007_ADF0	 ; If gameplay is halted, jump to PRG007_ADF0

	INC CoinPUp_Counter,X	 ; counter++

	; Apply coin's Y velocity
	LDA CoinPUp_Y,X
	ADD CoinPUp_YVel,X
	STA CoinPUp_Y,X

	LDA CoinPUp_Counter,X
	AND #$03
	BNE PRG007_ADE2	 ; 1:4 ticks proceed, otherwise jump to PRG007_ADE2

	INC CoinPUp_YVel,X	 ; coin YVel ++

	LDA CoinPUp_YVel,X
	CMP #$05
	BEQ PRG007_AE28	 ; If coin's Y velocity = 5, jump to PRG007_AE28

PRG007_ADE2:
	LDA CoinPUp_X,X
	SUB Level_ScrollDiffH	; Make relative coin X

	CMP #248
	BGE PRG007_AE4A	 ; If coin X >= 248, jump to PRG007_AE4A (remove coin)

	STA CoinPUp_X,X	 ; Update coin X

PRG007_ADF0:
	LDA <Player_HaltGameZ
	BEQ PRG007_AE02	 ; If gameplay is not halted, jump to PRG007_AE02

	; Move coin Y with vertical scroll
	LDA CoinPUp_Y,X	 
	SUB Level_ScrollDiffV
	STA CoinPUp_Y,X	 

	CMP #197
	BGE PRG007_AE4A	 ; If coin Y >= 197, jump to PRG007_AE4A (remove coin)

PRG007_AE02:
	JSR Object_GetUnusedSprite

	; Set coin Y
	LDA CoinPUp_Y,X
	STA Sprite_RAM+$00,Y

	; Set coin X
	LDA CoinPUp_X,X
	STA Sprite_RAM+$03,Y

	LDA CoinPUp_Counter,X
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3 by coin counter

	; Set pattern
	LDA CoinPUp_Patterns,X
	STA Sprite_RAM+$01,Y

	; Set attribute
	LDA CoinPUp_Attributes,X
	STA Sprite_RAM+$02,Y

	LDX <CurrentObjectIndexZ	; X = power up coin slot index

	RTS		 ; Return

PRG007_AE28:

	LDA CoinPUp_Y,X
	CMP #192
	BLT PRG007_AE3E	 ; If the coin is not too low, jump to PRG007_AE3E

	LDA #$05	 ; Otherwise use top of screen

PRG007_AE3E:


PRG007_AE4A:

	; Remove coin
	LDA #$00
	STA CoinPUp_State,X

	RTS		 ; Return


	; Sets carry if solid was hit
SObj_CheckHitSolid:

	; Flag Blooper Kid as out of water until determined otherwise

	; Temp_Var6 = special object Y + 12
	JSR SpecialObj_DetectWorld8x16
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SpecialObjs_UpdateAndDraw
;
; Updates Special Objects and they draw as they will
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SpecialObjs_UpdateAndDraw:


	LDX #$07	 ; X = 7
PRG007_AF1B:
	STX <CurrentObjectIndexZ ; Store current checked index -> CurrentObjectIndexZ

	JSR SpecialObj_UpdateAndDraw	 ; Does the update and draw routines of Special OBjects

	LDX <CurrentObjectIndexZ
	DEX		 ; X--
	BPL PRG007_AF1B	 ; While X >= 0, loop!

SObj_DoNothing:
PRG007_AF23:
	RTS		 ; Return

SpecialObj_UpdateAndDraw:
	
	LDA SpecialObj_ID,X

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word SObj_DoNothing	; 00: EMPTY / NOT USED (should never get here anyway)
	.word Enemy_Hammer	; 01: Hammer Bro hammer
	.word Enemy_Veggie	; 02: Boomerangs
	.word Enemy_Acid	; 03: 
	.word Enemy_FireBall	; 04: Nipper fireball
	.word SpecialObj_Poof	; 05: Piranha fireball
	.word Enemy_IceBall	; 06: Micro goombas
	.word Enemy_NinjaStar	; 07: Spike/Patooie's spike ball
	.word SObj_Egg	; 08: Koopaling wand blast
	.word Enemy_AcidPool	; 09: Lost Kuribo shoe
	.word SObj_Wrench	; 0A: Rocky's Wrench
	.word Enemy_Cannonball	; 0B: Cannonball
	.word SObj_DoNothing	; 0C: Fire bro bouncing fireball
	.word SObj_ExplodeStar	; 0D: Explosion star
	.word SOBJ_BUBBLE	; 0E: Bubble
	.word SObj_LavaLotusFire; 0F: Lava Lotus fire
	.word SObj_Wand		; 10: Recovered wand
	.word SObj_CoinOrDebris	; 11: Popped out coin
	.word SObj_DoNothing	; 12: Fire Chomp's fire
	.word SObj_CoinOrDebris	; 13: Brick debris (e.g. from Piledriver Microgoomba)
	.word SObj_BlooperKid	; 14: Blooper kid
	.word SObj_DoNothing	; 15: Laser
	.word SpecialObj_Poof		; 16: Poof

PUpCoin_Patterns:	.byte $49, $4F, $4D, $4F
PUpCoin_Attributes:	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP, SPR_PAL3, SPR_PAL3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - LASER code removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG007_B058:
	RTS		 ; Return

SObj_BlooperKid:
	
	RTS		 ; Return

PRG007_B0F7:
	JMP SpecialObj_Remove	 ; Remove Blooper kid

DebrisPattern:
	.byte $4B, $59, $55

DebrisPalette:
	.byte SPR_PAL3, SPR_PAL1, SPR_PAL1

SObj_CoinOrDebris:
	LDA <Player_HaltGameZ
	BNE PRG007_B11F	 ; If gameplay halted, jump to PRG007_B11F

	INC SpecialObj_Data2,X	 ; Var1++

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity

	LDA SpecialObj_ID,X
	CMP #SOBJ_BRICKDEBRIS
	BNE PRG007_B11F	 ; If this is not brick debris, jump to PRG007_B11F

	; Brick debris only...

	LDA SpecialObj_YVel,X
	BMI PRG007_B114	 ; If brick debris is moving upward, jump to PRG007_B114

	CMP #$70
	BGE PRG007_B11F	 ; If brick debris is falling >= $70, jump to PRG007_B11F

PRG007_B114:
	LDA SpecialObj_Data1,X
	BNE PRG007_B11C	 ; If data <> 0, jump to PRG007_B11C (fall slower)

	INC SpecialObj_YVel,X	 ; YVel++

PRG007_B11C:
	INC SpecialObj_YVel,X	 ; YVel++

PRG007_B11F:
	JSR SObj_GetSprRAMOffChkVScreen

	LDA SpecialObj_ID,X
	CMP #SOBJ_BRICKDEBRIS
	BNE PRG007_B169	 ; If this is not brick debris, jump to PRG007_B169

	; Brick debris only...

	LDA SpecialObj_Data1,X
	BEQ PRG007_B153	 ; If data = 0 (full giant world style brick rather than chunks), jump to PRG007_B153

	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Brick debris chunk pattern
	LDA SpecialObj_Data3,X
	STA TempA
	TAX
	LDA DebrisPattern, X
	STA Sprite_RAM+$01,Y
	LDX TempA
	LDA DebrisPalette, X
	STA <Temp_Var1
	LDX <CurrentObjectIndexZ
	

	; Temp_Var1 = SPR_PAL3

	; Rotating effect
	LDA GameCounter
	ASL A
	ASL A
	ASL A
	ASL A
	AND #(SPR_HFLIP | SPR_VFLIP)

	; Set attributes
	ORA <Temp_Var1		 ; OR'd with palette

KeepDrawingDebris:
	STA Sprite_RAM+$02,Y
	RTS		 ; Return

PRG007_B153:
	JSR SObj_Draw16x16	 ; Draw full brick

	; Set petterns
	LDA #$75
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Set attributes on left sprite
	LDA #SPR_PAL3
	STA Sprite_RAM+$02,Y

	; Set attributes on right sprite
	LDA #(SPR_PAL3 | SPR_HFLIP)
	STA Sprite_RAM+$06,Y

	RTS		 ; Return

PRG007_B169:

	; Popped out coin only

	LDA SpecialObj_YVel,X
	CMP #$20
	BMI PRG007_B17E	 ; If Y Velocity < $20, jump to PRG007_B17E

	; Coin fell far enough..

	JSR SpecialObj_Remove	 ; Remove it
	INC Coins_Earned	 ; You get a coin



PRG007_B17E:
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Set coin sprite Y
	LDA Sprite_RAM+$03,Y
	ADD #$04
	STA Sprite_RAM+$03,Y

	LDA SpecialObj_Data2,X
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	; Set pattern
	LDA PUpCoin_Patterns,X
	STA Sprite_RAM+$01,Y	

	; Set attributes
	LDA PUpCoin_Attributes,X
	STA Sprite_RAM+$02,Y	

	LDX <CurrentObjectIndexZ	 ; X = special object slot index

	RTS		 ; Return

	; Velocity gets applied at different rates (slower as timer decreases)
ExplodeStar_VelMask:
	.byte $07, $03, $01, $00


SObj_ExplodeStar:
	LDA SpecialObj_Data1,X
	BNE PRG007_B1DD	 ; If star's data <> 0, jump to PRG007_B1DD (RTS)

	LDA SpecialObj_Timer,X
	BEQ PRG007_B1DE	 ; If timer expired, jump to PRG007_B1DE (RTS)

	LSR A
	LSR A
	LSR A
	LSR A
	AND #$03
	TAY		 ; Y = 0 to 3, by timer

	; Apply velocities at lower rates as timer decreases
	LDA <Counter_1
	AND ExplodeStar_VelMask,Y
	BNE PRG007_B1C3

	JSR SObj_AddXVelFrac	 ; Apply X velocity
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

PRG007_B1C3:
	JSR SObj_GetSprRAMOffChkVScreen
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Set Explosion Star pattern
	LDA #$73
	STA Sprite_RAM+$01,Y

	; Apply cycling palette attribute
	LDA GameCounter
	LSR A
	LSR A
	NOP
	ADD <CurrentObjectIndexZ
	AND #$03	 ; A = 0 to 3 (palette select)
	STA Sprite_RAM+$02,Y

	RTS		 ; Return


PRG007_B1DD:
	RTS		 ; Return

PRG007_B1DE:
	JMP SpecialObj_Remove	 ; Remove special object and don't come back!

SObj_Wand:
	RTS		 ; Return

SObj_LavaLotusFire:

	JSR SObj_AddXVelFrac	 ; Apply X Velocity
	JSR SObj_AddYVelFrac	 ; Apply Y Velocity

PRG007_B2EE:
	LDA SpecialObj_Data3,X
	BNE PRG007_B2F6	 ; If Var2 <> 0 (fire still has life), jump to PRG007_B2F6

	JMP SpecialObj_Remove	 ; Otherwise, remove it and don't come back!

PRG007_B2F6:
	CMP #$30
	BGE PRG007_B303	 ; If Var2 >= 30, jump to PRG007_B303

	TXA		; A = special object slot index
	ASL A		; * 2
	ADC SpecialObj_Data3,X	; Add life counter
	AND #$02		; 0 or 2
	BNE PRG007_B320	 ; 2 ticks on, 2 ticks off; jump to PRG007_B320 (fire flickers away) (RTS)

PRG007_B303:
	JSR SObj_GetSprRAMOffChkVScreen	

	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	LDA GameCounter
	LSR A
	LSR A
	LSR A	; 8 ticks on/off

	LDA #$d9	 ; A = $D9
	BCC PRG007_B315	 ; 8 ticks on, 8 ticks off; jump to PRG007_B315
	LDA #$db	 ; A = $DB
PRG007_B315:

	; Store pattern
	STA Sprite_RAM+$01,Y

	; Set attribute
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	JMP SObj_PlayerCollide	 ; Do Player-to-fire collision and don't come back!

PRG007_B320:
	RTS		 ; Return


	LDA <Player_HaltGameZ
	BNE PRG007_B364	 ; If gameplay is halted, jump to PRG007_B364

	LDA SpecialObj_Timer,X
	BNE PRG007_B32D	 ; If timer not expired, jump to PRG007_B32D

	JMP SpecialObj_Remove	 ; Otherwise, remove the bubble

PRG007_B32D
	LDA SpecialObj_Data1,X
	BNE PRG007_B352	 ; If data <> 0, jump to PRG007_B352

	JSR SObj_AddYVelFrac	 ; Apply Y velocity

	LDA SpecialObj_YVel,X
	BMI PRG007_B344	 ; If bubble is moving upward, jump to  PRG007_B344

	SUB #$07	; Slow down (downward bubble)
	STA SpecialObj_YVel,X
	BPL PRG007_B34F	 ; If bubble is still moving downward, jump to PRG007_B34F
	BMI PRG007_B34C	 ; Otherwise, jump to PRG007_B34C

PRG007_B344:
	ADD #$07	 ; Slow down (upward bubble)
	STA SpecialObj_YVel,X
	BMI PRG007_B34F	 ; If bubble is still moving upward, jump to PRG007_B34F

PRG007_B34C:
	INC SpecialObj_Data1,X	 ; Otherwise, set SpecialObj_Data1

PRG007_B34F:
	JMP PRG007_B364	 ; Jump to PRG007_B364

PRG007_B352:
	INC SpecialObj_Data2,X	 ; SpecialObj_Data2++

	LDA SpecialObj_Data2,X
	AND #%00110000
	BEQ PRG007_B364	 ; 48 ticks on, 48 ticks off; jump to PRG007_B364

	DEC SpecialObj_Y,X	 ; Bubble Y --
	BNE PRG007_B364
	DEC SpecialObj_YHi,X	 ; Apply carry
PRG007_B364:

	LDA GameCounter
	AND #%00001100
	LSR A
	LSR A
	TAY		 ; Y = 0 or 3

	; Bubble_XOff -> Temp_Var1
	LDA Bubble_XOff,Y
	STA <Temp_Var1

	JSR SObj_GetSprRAMOffChkVScreen
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Set bubble X
	LDA SpecialObj_X,X
	ADD <Temp_Var1	
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	; Set bubble pattern
	LDA #$17
	STA Sprite_RAM+$01,Y

	; Set bubble attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_ApplyXYVelsWithGravity
;
; Apply the special object X and Y velocity with gravity
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_ApplyXYVels:
	JSR SObj_AddXVelFrac
	JSR SObj_AddYVelFrac
	RTS

SObj_ApplyXYVelsWithGravity:
	JSR SObj_AddXVelFrac	 ; Apply X velocity
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

	LDA SpecialObj_YVel,X
	BMI PRG007_B39D	 ; If special object is moving upward, jump to PRG007_B39D

	CMP #$40
	BCS PRG007_B3A3	 ; If special object Y velocity >= $6E, jump to PRG007_B3A3 (RTS)

PRG007_B39D:

	; Apply gravity
	INC SpecialObj_YVel,X
	INC SpecialObj_YVel,X
	INC SpecialObj_YVel,X

PRG007_B3A3:
	RTS		 ; Return

Enemy_Cannonball:
	LDA <Player_HaltGameZ
	BNE Enemy_CannonDraw

	LDA SpecialObj_Data3, X
	BNE Cannonball_Norm

	JSR SObj_ApplyXYVelsWithGravity
	JMP Enemy_CannonDraw

Cannonball_Norm:
	JSR SObj_ApplyXYVels
	JSR SpecialObj_CalcBounds16x16
	JSR EnemyProj_HitPlayer
	
	JSR SpecialObj_DetectWorld16x16
	JSR CannonBall_TilesInteraction

Enemy_CannonDraw:
	LDA #$5B
	STA <SpecialObj_Tile

	LDA #$5B
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL3
	STA <SpecialObj_Attributes

	LDA #(SPR_PAL3 | SPR_VFLIP | SPR_HFLIP)
	STA <SpecialObj_Attributes + 1

	JSR SpecialObj_CheckForeground
	JSR SpecialObj_Draw16x16
	RTS


CannonBall_TilesInteraction:
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_ALL
	BCC CannonBall_NotSolid

	DEC SpecialObj_Data3, X
	BNE CannonBall_NotSolid

	LDA SpecialObj_XVel, X
	JSR Half_Value
	EOR #$FF
	ADD #$01
	STA SpecialObj_XVel, X

	LDA #$00
	STA SpecialObj_YVel, X

	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer
	RTS

CannonBall_NotSolid:
	LDA Block_NeedsUpdate
	BNE CannonBall_TilesInteraction1

	LDY #$02

CannonBall_TilesInteraction0:
	LDA Cannon_Tiles, Y
	BEQ Cannon_Empty

	CMP Tile_LastProp
	BEQ CannonBall_TilesInteraction2

Cannon_Empty:
	DEY
	BPL CannonBall_TilesInteraction0

CannonBall_TilesInteraction1:
	RTS

Cannon_Tiles:
	.byte (TILE_PROP_SOLID_TOP | TILE_PROP_STONE), (TILE_PROP_SOLID_ALL | TILE_PROP_STONE), (TILE_ITEM_BRICK)

CannonBall_TilesInteraction2:
	LDA #$02
	STA SpecialObj_Data3, X
	LDA Tile_LastValue
	AND #$C0
	ORA #$01
	JSR Object_ChangeBlock

	LDA SpecialObj_X, X
	AND #$F0
	STA Debris_X

	LDA SpecialObj_Y, X
	AND #$F0
	STA Debris_Y
	JMP Common_MakeBricks

SObj_OffsetYForRaster:
	LDA Level_AScrlConfig
	BEQ PRG007_B491	 ; If there's no raster effect going on, jump to PRG007_B491 (RTS)

	LDY #$00	 ; Y = $00 (16-bit sign extension)

	LDA Level_ScrollDiffV
	BPL PRG007_B483	 ; If vertical scroll difference is not negative, jump to PRG007_B483

	DEY		 ; Otherwise, Y = $FF (16-bit sign extension)

PRG007_B483:
	ADD SpecialObj_Y,X
	STA SpecialObj_Y,X	; Apply raster offset to Special Object Y

	TYA

	ADC SpecialObj_YHi,X
	STA SpecialObj_YHi,X	; Apply sign extension/carry

PRG007_B491:
	RTS		 ; Return

Wrench_Patterns:	.byte $A1, $95, $9F, $95
Wrench_Attributes:	.byte SPR_PAL2, SPR_PAL2 | SPR_VFLIP, SPR_PAL2, SPR_PAL2
	
SObj_Wrench:
	LDA <Player_HaltGameZ		 
	BNE PRG007_B4AF	 ; If gameplay halted, jump to PRG007_B4AF

	JSR SObj_OffsetYForRaster	; Offset Y with raster effects (if any)
	JSR SObj_AddXVelFrac	 	; Apply X velocity

	LDA SpecialObj_YVel,X
	BEQ PRG007_B4AC	 ; If wrench Y velocity = 0, jump to PRG007_B4AC

	INC SpecialObj_YVel,X	 ; Otherwise, Y Vel++ (fall?)

PRG007_B4AC:
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

PRG007_B4AF:
	JSR SObj_PlayerCollide	 ; Do Player-to-wrench collision

	JSR SObj_GetSprRAMOffChkVScreen
	BNE PRG007_B4EB	 ; If wrench is not vertically on-screen, jump to PRG007_B4EB (RTS)

	; Set Temp_Var1 = $00 or $80, depending on sign bit of X velocity
	LDA SpecialObj_XVel,X
	AND #$80
	STA <Temp_Var1

	LDA GameCounter
	LSR A
	ADD <CurrentObjectIndexZ
	AND #$03
	TAX		 ; X = 0 to 3

	; Set wrench pattern
	LDA Wrench_Patterns,X
	STA Sprite_RAM+$01,Y

	; Set wrench attributes
	LDA Wrench_Attributes,X
	EOR <Temp_Var1	
	STA Sprite_RAM+$02,Y

	LDX <CurrentObjectIndexZ	; X = special object slot index

SObj_SetSpriteXYRelative:
	LDA SpecialObj_Y,X
	SUB Level_VertScroll
	STA Sprite_RAM+$00,Y

	LDA SpecialObj_X,X
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

PRG007_B4EB:
	RTS		 ; Return


	; In the Japanese original, there were other power ups that "flew off"
	; when you lost them, and those are the additional values.  None of
	; them display correctly anymore, however, because:
	;
	; The graphics for the fly-off sprite only exist with small Mario, 
	; meaning when they added the "American" rule of returning to "super"
	; state, it didn't have the suit sprite graphics available!

LostShoe_Pattern:	.byte $A9, $AB	; 0
			.byte $39, $39	; 1
			.byte $3B, $3B	; 2
			.byte $3D, $3D	; 3
LostShoe_Attribute:	.byte $02, $01, $01, $01
	
SObj_Egg:
	LDA Player_HaltGameZ
	BNE SObj_Egg0

	JSR SObj_AddXVelFrac
	JSR SObj_PlayerCollide 

SObj_Egg0:
	JSR SObj_GetSprRAMOffChkVScreen
	JSR SObj_SetSpriteXYRelative	

	LDX <CurrentObjectIndexZ
	LDA #$97
	STA Sprite_RAM + 1, Y
	LDA #$99
	STA Sprite_RAM + 5, Y

	LDA Sprite_RAM , Y
	STA Sprite_RAM + 4, Y

	LDA Sprite_RAM +3 , Y
	ADD #$08
	BCS SObj_Egg1
	STA Sprite_RAM + 7, Y

SObj_Egg1:
	LDA #SPR_PAL1
	STA Sprite_RAM + 2, Y
	STA Sprite_RAM + 6, Y

	LDA SpecialObj_XVel, X
	BMI SObj_Egg2

	LDA #$99
	STA Sprite_RAM + 1, Y
	LDA #$97
	STA Sprite_RAM + 5, Y
	LDA #(SPR_PAL1 | SPR_HFLIP)
	STA Sprite_RAM + 2, Y
	STA Sprite_RAM + 6, Y

SObj_Egg2:
	LDA SpecialObj_Timer,X
	BNE SObj_EggRTS

SObj_Egg3:
	LDX #$04
	LDA Sprite_RAM + 3, Y
	ADD Object_BoundBox,X
	STA <Temp_Var3		 ; Temp_Var3 object's sprite X with offset

	LDA Sprite_RAM, Y
	ADD Object_BoundBox+2,X
	STA <Temp_Var7		 ; Temp_Var7 object's sprite Y with offset

	LDA Object_BoundBox+1,X
	STA <Temp_Var4		 ; Temp_Var4 has the right offset

	LDA Object_BoundBox+3,X	
	STA <Temp_Var8		 ; Temp_Var8 has the bottom offset
	
	LDX <CurrentObjectIndexZ
	STX TempX
	LDA #$FF
	STA <CurrentObjectIndexZ
	
	INC HitTestOnly

	;JSR PRG000_DC09
	LDX TempX
	STX <CurrentObjectIndexZ
	BCC SObj_EggRTS	 ; If object has not hit another object, jump to PRG000_CD46

	LDA #SOBJ_POOF
	STA SpecialObj_ID,X

	; SpecialObj_Data1 = $1F
	LDA #$1f
	STA SpecialObj_Data1,X

	TYA
	TAX
	DEC Objects_Health,X
	DEC Objects_Health,X
	DEC Objects_Health,X
	BPL SObj_EggRTS

	LDX <CurrentObjectIndexZ
	; Play object-to-object collision sound 
	LDA Sound_QPlayer 
	ORA #SND_PLAYERKICK 
	STA Sound_QPlayer
 
	; Knock object in same general direction as the kicked shell object
	LDA SpecialObj_XVel,X 
	ASL A 
	LDA #$10	 ; A = $10
	BCC SObj_Egg4 
	LDA #$F0	 ; A = -$10

SObj_Egg4: 
	STA Objects_XVelZ,Y

	LDA #OBJSTATE_KILLED
	STA  Objects_State,Y
	LDA #$F0
	STA Objects_YVelZ,Y

SObj_EggRTS:
	RTS


SObj_KuriboShoe:
	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity

	JSR SObj_GetSprRAMOffChkVScreen

	LDA SpecialObj_Data1,X
	TAX		 ; SpecialObj_Data1 -> 'X' (NOTE: Will always be zero in US version, see notes at LostShoe_Pattern)

	; Set left sprite attribute
	LDA LostShoe_Attribute,X
	STA Sprite_RAM+$02,Y

	CPX #$00
	BEQ PRG007_B54F	 ; For the lost Kuribo's shoe only: Do not mirror sprite, jump to PRG007_B54F

	ORA #SPR_HFLIP	 ; Mirror sprite (NOTE: Used only in Japanese version for the "fly off" super suits!)

PRG007_B54F:
	STA Sprite_RAM+$06,Y	 ; Set attributes on right sprite

	; X *= 2 (two patterns per suit, again generally unused in US version)
	TXA
	ASL A
	TAX

	; Pattern for left fly off sprite
	LDA LostShoe_Pattern,X
	STA Sprite_RAM+$01,Y

	; Pattern for right fly off sprite
	LDA LostShoe_Pattern+1,X
	STA Sprite_RAM+$05,Y

	LDX <CurrentObjectIndexZ	; X = special object slot index

SObj_Draw16x16:
	JSR SObj_SetSpriteXYRelative	 

	; Copy sprite Y into right sprite
	LDA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Right sprite is X + 8
	LDA Sprite_RAM+$03,Y
	ADD #$08
	STA Sprite_RAM+$07,Y

	RTS		 ; Return


Enemy_NinjaStar:
	LDA <Player_HaltGameZ
	BNE Enemy_NinjaStarDraw

	JSR SObj_ApplyXYVels
	JSR SpecialObj_CalcBounds16x16
	JSR EnemyProj_HitPlayer
	

Enemy_NinjaStarDraw:

	LDA #$4D
	STA <SpecialObj_Tile
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL3
	STA <SpecialObj_Attributes
	STA <SpecialObj_Attributes + 1
	JSR SpecialObj_SetMirrorFlipped
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_Draw16x16
	RTS


SObj_PlayerCollide:
	; Player to Special Object collision logic...

	TXA		 ; object slot index -> 'A'
	ADD <Counter_1	 ; Keep it interesting
	LSR A
	BCC PRG007_B826	 ; Every other tick, jump to PRG007_B826 (RTS)

	LDY #$00	 ; Y = 0 (small/ducking)

	LDA <Player_Suit
	BEQ PRG007_B7E4	 ; If Player is small, jump to PRG007_B7E4

	LDA Player_IsDucking
	BNE PRG007_B7E4	 ; If Player is ducking, jump to PRG007_B7E4

	INY		 ; Y = 1 (otherwise)

PRG007_B7E4:
	LDA SpecialObj_Y,X		; Special object Y
	ADD #$08			; +8
	SUB <Player_Y			; Subtract Player Y
	;SUB SObjYOff_PlayerSize,Y	; Subtract Player height offset
	;CMP SObj_VLimit,Y
	BGE PRG007_B843	 	; If result >= SObj_VLimit, jump to PRG007_B843 (RTS)

	LDA SpecialObj_X,X		; Special object X
	ADD #$06			; +6
	SUB <Player_X			; Subtract Player X
	SBC #$00			; Carry?
	CMP #16
	BGE PRG007_B843	 	; If result >= 16, jump to PRG007_B843 (RTS)

PRG007_B805:
	LDA Player_FlashInv	; If Player is flashing from being hit ...
	ORA <Player_HaltGameZ	; ... if gameplay is halted ...
	ORA Player_IsDying	; ... Player is dying ...
	ORA Player_OffScreen	; ... Player is off-screen ...
	ORA <Temp_Var14		; ... or special object is not vertically on-screen ...
	BNE PRG007_B843	 	; ... jump to Player_Behind_En (RTS)
	BEQ PRG007_B827

PRG007_B826:
	RTS		 ; Return


PRG007_B827:	
	LDA SpecialObj_ID, X
	CMP #SOBJ_ICEBALL
	BNE PRG007_B836
	JSR CheckTailSpin
	JSR Enemy_FreezePlayer
	LDA SpecialObj_XVel,X
	STA <Player_XVel
	JMP SpecialObj_Remove

PRG007_B836:
	LDA Player_StarInv
	BNE PRG007_B844	 ; If Player is Star Man invincible, jump to PRG007_B844
	
	JSR CheckTailSpin
	LDA SpecialObj_ID, X
	CMP #SOBJ_EGG
	BEQ YolkPlayer
	
PRG007_B837:
	JMP Player_GetHurt	 ; Hurt Player and don't come back!

YolkPlayer:
	LDA #SOBJ_POOF
	STA SpecialObj_ID,X

	; SpecialObj_Data1 = $1F
	LDA #$1f
	STA SpecialObj_Data1,X

	LDA Yolked
	BNE PRG007_B837
	LDA #$17
	STA Player_SuitLost
	LDA #$80
	STA Player_QueueSuit

	LDA #$FF
	STA Yolked

YolkPlayer1:
	RTS

SpecialObj_Remove:

	; Remove special object
	LDA #$00
	STA SpecialObj_ID,X

PRG007_B843:
	RTS		 ; Return

PRG007_B844:

	; Player is invincible; destroy the special object!

	; Play "kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

PRG007_B84C:
	; Change to a "poof"
	LDA #SOBJ_POOF
	STA SpecialObj_ID,X

	; SpecialObj_Data1 = $1F
	LDA #$1f
	STA SpecialObj_Data1,X

	RTS		 ; Return

Enemy_Veggie:
	LDA <Player_HaltGameZ
	BNE Enemy_VeggieDraw

	JSR SObj_ApplyXYVelsWithGravity
	JSR SpecialObj_CalcBounds16x16
	JSR EnemyProj_HitPlayer

Enemy_VeggieDraw:
	LDA #$B3
	STA <SpecialObj_Tile
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL2
	STA <SpecialObj_Attributes

	ORA #SPR_HFLIP
	STA <SpecialObj_Attributes + 1
	
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_Draw16x16
	RTS		 ; Return
	
Enemy_Acid:
	LDA <Player_HaltGameZ
	BEQ Enemy_AcidNorm

	JMP Enemy_AcidDraw

Enemy_AcidNorm:
	LDA SpecialObj_Data2, X
	BEQ Normal_Acid

	LDA SpecialObj_X, X
	ADD #$07
	STA Tile_DetectionX

	LDA SpecialObj_XHi, X
	ADC #$00
	STA Tile_DetectionXHi

	LDA SpecialObj_Y, X
	ADD #$0F
	STA Tile_DetectionY

	LDA SpecialObj_YHi, X
	ADC #$00
	STA Tile_DetectionYHi

	JSR Object_DetectTile
	AND #TILE_PROP_SOLID_TOP
	BNE ToAcidPool

	LDA Tile_LastProp
	AND #TILE_PROP_SOLID_ALL
	BEQ ToAcidPoof

ToAcidPool:
	LDA #SOBJ_ACIDPOOL
	STA SpecialObj_ID, X

	LDA SpecialObj_Y, X
	AND #$F0
	ADD #$06
	STA SpecialObj_Y, X

	LDA SpecialObj_YHi, X
	ADC #$00
	STA SpecialObj_YHi, X

	LDA #$60
	STA SpecialObj_Data1, X
	RTS

ToAcidPoof:
	JMP SpecialObj_ToPoofNoSound

Normal_Acid:
	LDA SpecialObj_Data1, X
	BNE Enemy_AcidNoGravity

	JSR SObj_ApplyXYVelsWithGravity
	JMP Enemy_AcidCalcBounds

Enemy_AcidNoGravity:
	JSR SObj_ApplyXYVels

Enemy_AcidCalcBounds:
	JSR SpecialObj_CalcBounds16x16
	JSR EnemyProj_HitPlayer
	JSR SpecialObj_DetectWorld16x16
	
	LDA Tile_LastProp
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_ENEMYSOLID)
	BNE Enemy_NotInteract

	LDA Block_NeedsUpdate
	BNE Enemy_NotInteract

	LDA Tile_LastValue
	AND #$C0
	ORA #$01
	JSR Object_ChangeBlock

	LDA Block_DetectX
	AND #$F0
	STA SpecialObj_X, X

	LDA Block_DetectXHi
	STA SpecialObj_XHi, X

	LDA Block_DetectY
	AND #$F0
	STA SpecialObj_Y, X

	LDA Block_DetectYHi
	STA SpecialObj_YHi, X
	JMP SpecialObj_ToPoofNoSound

Enemy_NotInteract:
	LDA SpecialObj_YVel, X
	BMI Enemy_AcidNotTop

	LDA Tile_LastProp
	AND #TILE_PROP_SOLID_TOP
	BNE Enemy_AcidToPool

Enemy_AcidNotTop:
	LDA Tile_LastProp
	AND #TILE_PROP_SOLID_ALL
	BEQ Enemy_AcidDraw

Enemy_AcidToPool:
	INC SpecialObj_Data2, X

Enemy_AcidDraw:
	LDA #$4F
	STA <SpecialObj_Tile
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL2
	STA <SpecialObj_Attributes
	STA <SpecialObj_Attributes + 1

	JSR SpecialObj_SetMirrorFlipped
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_Draw16x16
	RTS

Enemy_AcidPool:
	DEC SpecialObj_Data1, X
	BNE Enemy_AcidPoolNorm

	JMP SpecialObj_ToPoofNoSound

Enemy_AcidPoolNorm:
	JSR SpecialObj_CalcBounds16x16
	LDA SpecialObj_BoundTop
	ADD #$08
	STA SpecialObj_BoundTop

	LDA SpecialObj_BoundTopHi
	ADC #$00
	STA SpecialObj_BoundTopHi

	JSR EnemyProj_HitPlayer

	LDA #$63
	STA <SpecialObj_Tile
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL2
	STA <SpecialObj_Attributes
	STA <SpecialObj_Attributes + 1
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_Draw16x16
	RTS

Enemy_FireBall:
	LDA <Player_HaltGameZ
	BNE Enemy_FireBall5

	LDA SpecialObj_Data1, X
	BNE Enemy_FireBallNoGravity

	JSR SObj_ApplyXYVelsWithGravity
	INC SpecialObj_YVel, X
	INC SpecialObj_YVel, X
	JMP Enemy_FireBallCalcBounds

Enemy_FireBallNoGravity:
	JSR SObj_ApplyXYVels

Enemy_FireBallCalcBounds:
	JSR SpecialObj_CalcBounds8x16
	JSR EnemyProj_HitPlayer

Enemy_FireBallTiles:
	JSR SpecialObj_DetectWorld8x16
	JSR SpecialObj_FireTiles

	LDA SpecialObj_YVel, X
	BPL Enemy_FireBall1

	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_ALL
	BCC Enemy_FireBall4
	BCS Enemy_FireBall2

Enemy_FireBall1:
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCC Enemy_FireBall4

Enemy_FireBall2:
	INC SpecialObj_Data2, X
	LDA SpecialObj_Data2, X
	CMP #$02
	BNE Enemy_FireBall3

	LDA SpecialObj_X, X
	SUB #$08
	STA SpecialObj_X, X

	JMP SpecialObj_ToPoof

Enemy_FireBall3:
	LDA SpecialObj_Data1, X
	BNE Enemy_FireBall5

	LDA SpecialObj_YVel, X
	BMI Enemy_FireBall5

	LDA #-$38
	STA SpecialObj_YVel, X
	BNE Enemy_FireBall5

Enemy_FireBall4:
	LDA #$00
	STA SpecialObj_Data2, X

Enemy_FireBall5:
	LDA #$65
	STA <SpecialObj_Tile

	LDA #SPR_PAL1
	STA <SpecialObj_Attributes
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_CheckDirection
	JSR SpecialObj_Draw8x16
	RTS


Enemy_IceBall:
	LDA <Player_HaltGameZ
	BNE Enemy_IceBall5

	LDA SpecialObj_Data1, X
	BNE Enemy_IceBallNoGravity

	JSR SObj_ApplyXYVelsWithGravity
	INC SpecialObj_YVel, X
	INC SpecialObj_YVel, X
	JMP Enemy_IceBallCalcBounds

Enemy_IceBallNoGravity:
	JSR SObj_ApplyXYVels

Enemy_IceBallCalcBounds
	JSR SpecialObj_CalcBounds8x16
	JSR EnemeyProj_Enemy_FreezePlayer

Enemy_IceBallTiles:
	JSR SpecialObj_DetectWorld8x16
	JSR SpecialObj_IceTiles

	LDA SpecialObj_YVel, X
	BPL Enemy_IceBall1

	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_ALL
	BCC Enemy_IceBall4
	BCS Enemy_IceBall2

Enemy_IceBall1:
	LDA Tile_LastProp
	CMP #TILE_PROP_SOLID_TOP
	BCC Enemy_IceBall4

Enemy_IceBall2:
	INC SpecialObj_Data2, X
	LDA SpecialObj_Data2, X
	CMP #$02
	BNE Enemy_IceBall3

	LDA SpecialObj_X, X
	SUB #$08
	STA SpecialObj_X, X

	JMP SpecialObj_ToPoof

Enemy_IceBall3:
	LDA SpecialObj_Data1, X
	BNE Enemy_IceBall5

	LDA SpecialObj_YVel, X
	BMI Enemy_IceBall5

	LDA #-$50
	STA SpecialObj_YVel, X
	BNE Enemy_IceBall5

Enemy_IceBall4:
	LDA #$00
	STA SpecialObj_Data2, X

Enemy_IceBall5:
	LDA #$59
	STA <SpecialObj_Tile

	LDA #SPR_PAL2
	STA <SpecialObj_Attributes

	JSR SpecialObj_CheckForeground
	JSR SpecialObj_CheckDirection
	JSR SpecialObj_Draw8x16
	RTS

Poof_Patterns:	.byte $47, $45, $43, $41

Enemy_Hammer:
	LDA <Player_HaltGameZ
	BNE Enemy_HammerDraw

	JSR SObj_ApplyXYVelsWithGravity
	JSR SpecialObj_CalcBounds16x16
	JSR EnemyProj_HitPlayer
	
	JSR SpecialObj_DetectWorld16x16
	JSR Player_HammerTilesInteraction

Enemy_HammerDraw:
	LDA #$6D
	STA <SpecialObj_Tile

	LDA #$6F
	STA <SpecialObj_Tile + 1

	LDA #SPR_PAL3
	STA <SpecialObj_Attributes
	STA <SpecialObj_Attributes + 1
	JSR SpecialObj_CheckForeground
	JSR SpecialObj_CheckDirection16x6
	JSR SpecialObj_Draw16x16
	RTS


Enemy_HammerTilesInteraction2:
	LDA Tile_LastValue
	AND #$C0
	ORA #$01
	JSR Object_ChangeBlock
	LDA Tile_DetectionX
	AND #$F0
	STA SpecialObj_X, X

	LDA Tile_DetectionY
	AND #$F0
	STA SpecialObj_Y, X

	LDA SpecialObj_X, X
	STA Debris_X

	LDA SpecialObj_Y, X
	STA Debris_Y
	JSR Common_MakeBricks

	JMP SpecialObj_ToPoofNoSound

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_GetSprRAMOffChkVScreen
;
; Gets an appropriate sprite RAM offset and also returns zero if
; the object is on the same vertical screen as the Player
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_SprRAMBase:
	.byte $08, $10, $00, $08, $10, $04, $0C, $14, $0C

SObj_GetSprRAMOffChkVScreen:
	LDY #$07	 ; Y = 7

	CPX #$09
	BEQ PRG007_BAED	 ; If special object slot = 9, jump to PRG007_BAED

	CPX #$03
	BLT PRG007_BAED	 ; If special object slot < 3, jump to PRG007_BAED

	LDY #$08	 ; Y = 8

PRG007_BAED:
	LDA SObj_SprRAMBase-1,X
	ADD Object_SpriteRAMOffset-1,Y
	TAY		 ; Y = Sprite RAM offset

	CPX #$00
	BNE PRG007_BB1A	 ; If special object slot 0, jump to PRG007_BB1A

	JSR Object_GetUnusedSprite
	BNE PRG007_BB1A	 ; If sprite available, jump to PRG007_BB1A

	LDA SpecialObj_ID,X

	; If this special object is empty, or is a Nipper fireball/Piranha Fireball/Microgoomba, jump to PRG007_BB1A

	CMP #SOBJ_FIREBALL
	BEQ PRG007_BB1A

	CMP #SOBJ_ICEBALL
	BEQ PRG007_BB1A

	CMP #$00
	BEQ PRG007_BB1A

	LDA RandomN,X
	AND #$03	; 0 to 3
	ASL A	
	ASL A	
	ASL A		; Multiply by 8
	TAY		; Y = 0, 8, 16, 24

PRG007_BB1A:
	LDA <Temp_Var14	; Return the relative Y Hi value

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_AddXVelFrac
;
; Adds the 4.4FP X velocity to X of special object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_AddXVelFrac:
	LDA SpecialObj_XVel,X		; Get Y Velocity
	ASL A
	ASL A
	ASL A
	ASL A		 		; Fractional part shifted up
	ADD SpecialObj_XVelFrac,X
	STA SpecialObj_XVelFrac,X	; Add to special object's X vel fractional accumulator

	PHP		 ; Save CPU status

	; Basically amounts to an arithmetic shift right 4 places
	LDA SpecialObj_XVel,X	; Get Y Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 	; Whole part shifted down (integer)
	CMP #%00001000	; Check the sign bit
	LDY #$00	 ; Y = $00 (16-bit sign extension)
	BLT SObj_AddXVelFrac1	 ; If the value was not negatively signed, jump to PRG007_BB60
	ORA #%11110000	; Otherwise, apply a sign extension

	DEY		 ; Y = $FF (16-bit sign extension)

SObj_AddXVelFrac1:
	PLP		 ; Restore CPU status

	ADC SpecialObj_X,X
	STA SpecialObj_X,X ; Add with carry

	TYA		 ; Sign extension

	; Apply sign extension
	ADC SpecialObj_XHi,X
	STA SpecialObj_XHi,X
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_AddYVelFrac
;
; Adds the 4.4FP Y velocity to Y of special object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_AddYVelFrac:
	LDA SpecialObj_YVel,X		; Get Y Velocity
	ASL A
	ASL A
	ASL A
	ASL A		 		; Fractional part shifted up
	ADD SpecialObj_YVelFrac,X
	STA SpecialObj_YVelFrac,X	; Add to special object's X vel fractional accumulator

	PHP		 ; Save CPU status

	; Basically amounts to an arithmetic shift right 4 places
	LDA SpecialObj_YVel,X	; Get Y Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 	; Whole part shifted down (integer)
	CMP #%00001000	; Check the sign bit
	LDY #$00	 ; Y = $00 (16-bit sign extension)
	BLT PRG007_BB60	 ; If the value was not negatively signed, jump to PRG007_BB60
	ORA #%11110000	; Otherwise, apply a sign extension

	DEY		 ; Y = $FF (16-bit sign extension)

PRG007_BB60:
	PLP		 ; Restore CPU status

	ADC SpecialObj_Y,X
	STA SpecialObj_Y,X ; Add with carry

	TYA		 ; Sign extension

	; Apply sign extension
	ADC SpecialObj_YHi,X
	STA SpecialObj_YHi,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CannonFire_UpdateAndDraw
;
; Updates and draws the Cannon Fires
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CannonFire_UpdateAndDraw:
	LDA <Player_HaltGameZ		 
	ORA EndCard_Flag
	BNE PRG007_BB80	 ; If gameplay halted or end level card grabbed, jump to PRG007_BB80 (RTS)

	LDX #$07	 ; X = 7
PRG007_BB78:
	STX <CurrentObjectIndexZ	 ; Update index backup

	JSR CannonFire_DrawAndUpdate	; Draw and Update Cannon Fire

	DEX		 ; X--
	BPL PRG007_BB78	; While X >= 0, loop!

PRG007_BB80:
	RTS		 ; Return


CannonFire_DrawAndUpdate:
	LDA CannonFire_ID,X
	BEQ PRG007_BB80	 ; If this slot is unused/empty, jump to PRG007_BB80 (RTS)

	PHA		 ; Save ID

	; Update CannonFire_Timer
	LDA CannonFire_Timer,X
	BEQ PRG007_BB8F	 ; If CannonFire_Timer = 0, jump to CannonFire_Timer
	DEC CannonFire_Timer,X	 ; CannonFire_Timer--
	BNE PRG007_BB8F

	LDA MiscValue1
	AND #$80
	BEQ PRG007_BB8F
	LDA TrapSet
	BNE PRG007_BB8F
	INC CannonFire_Timer,X

PRG007_BB8F:

	; Update CannonFire_Timer2
	LDA CannonFire_Timer2,X
	BEQ PRG007_BB97
	DEC CannonFire_Timer2,X

PRG007_BB97:
	PLA		 ; Restore ID
	STA TempA
	JSR DetermineCannonVisibilty
	LDA TempA
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG007_BB80	; 00: Unused (would never get here anyway)
	.word CFire_BulletBill	; 01: Bullet Bill cannon
	.word CFire_BulletBill	; 02: Missile Bill (homing Bullet Bill)
	.word Cfire_Bobombs	; 03: Creates Rocky Wrench
	.word CFire_Platform	; 04: 4-way cannon
	.word CFire_GoombaPipe	; 05: Goomba pipe (left output)
	.word CFire_ShellCannon	; 06: Goomba pipe (right output)
	.word CFire_Cannonball 	; 07: Fires cannonballs horizontally left
	.word CFire_Cannonball	; 08: Fires BIG cannonballs horizontally left
	.word CFire_Cannonball	; 09: Fires cannonballs diagonally, upper left
	.word CFire_Cannonball	; 0A: Fires cannonballs diagonally, upper right
	.word CFire_Cannonball	; 0B: Fires cannonballs diagonally, lower left
	.word CFire_Cannonball	; 0C: Fires cannonballs diagonally, lower right
	.word CFire_Cannonball	; 0D:
	.word CFire_Cannonball	; 0E: 
	.word CFire_Cannonball 	; 0F: 
	.word CFire_Cannonball	; 10:
	.word CFire_Cannonball	; 11: Fires cannonballs horizontally right
	.word CFire_Cannonball	; 12: Fires BIG cannonballs horizontally right
	.word CFire_Cannonball	; 13: Launches fused Bob-ombs to the left
	.word CFire_Cannonball	; 14: Launches fused Bob-ombs to the right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Laser code removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CFire_Cannonball:

	LDA CannonFire_Timer,X
	BNE PRG007_BC5B	 ; If timer not expired, jump to PRG007_BC5B (RTS)

	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BC5B	 ; If Cannon Fire is off-screen left, jump to PRG007_BC5B (RTS)

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	CMP #240
	BGE PRG007_BC5B	 ; If Cannon Fire is off-screen right, jump to PRG007_BC5B (RTS)

	; Reload timer = $87
	LDA #$87
	STA CannonFire_Timer,X

	; Temp_Var1 = this particular Cannon Fire ID
	LDA CannonFire_ID,X
	STA <Temp_Var1

	CMP #CFIRE_HRBIGCANNON
	BEQ PRG007_BC4B	 ; If this is the right-shooting BIG Cannon, jump to PRG007_BC4B

	CMP #CFIRE_HLBIGCANNON
	BNE PRG007_BC4E	 ; If this is NOT the left-shooting BIG Cannon, jump to PRG007_BC4E

PRG007_BC4B:
	JMP PRG007_BC5C	 ; For all BIG Cannons, jump to PRG007_BC5C

PRG007_BC4E:
	CMP #CFIRE_LBOBOMBS
	BLT PRG007_BC55	 ; If this is not one of the Bob-omb cannons, jump to PRG007_BC55

	JMP Cfire_Bobombs	 ; For all Bob-omb cannons, jump to PRG007_BCB4

PRG007_BC55: 
	ADD #(Cannons_CPXOff - CannonPoof_XOffs - CFIRE_HLCANNON)	; Offset to proper array index for this Cannon Fire
	JMP PRG007_BE59	 ; Jump to PRG007_BE59 (fire cannonball!)

PRG007_BC5B:
	RTS		 ; Return


PRG007_BC5C:

	; Left/right BIG Cannons

	JSR PrepareNewObjectOrAbort	; Get me an object slot or don't come back!

	; This is a BIG Cannon Ball!
	LDA #OBJ_BIGCANNONBALL
	STA Objects_ID,X

	LDY <CurrentObjectIndexZ	; Y = Cannon Fire slot index

	; Set BIG Cannon Ball Y
	LDA CannonFire_Y,Y
	STA <Objects_YZ,X
	LDA CannonFire_YHi,Y
	STA <Objects_YHiZ,X

	LDA <Temp_Var1
	CMP #CFIRE_HRCANNON

	LDA #$30	 ; A = $30
	LDY #$12	 ; Y = $12

	BGE PRG007_BC81	 ; Basically if this is the right-shooting BIG Cannon, jump to PRG007_BC81

	LDY #$09	 ; Y = $09
	LDA #-$30	 ; A = -$30

PRG007_BC81:
	STY <Temp_Var1	 ; Temp_Var1 = $12 (if right-shooting) or $09 (if left-shooting)

	STA <Objects_XVelZ,X	 ; X velocity = -$30 or $30, depending on direction

	EOR #$80	 ; Invert the sign bit

	LDY <CurrentObjectIndexZ	 ; Y = Cannon Fire slot index

	ASL A		 ; Inverted sign bit -> carry

	; Set BIG Cannon Ball X
	LDA CannonFire_X,Y
	BCS PRG007_BC92	 ; If right-shooting, jump to PRG007_BC92
	SUB #16		; -16 for left-shooting

PRG007_BC92:
	STA <Objects_XZ,X
	LDA CannonFire_XHi,Y
	SBC #$00
	STA <Objects_XHiZ,X

	;JSR PRG007_BD09		; Set attribute and make noise and smoke!
	JSR CannonFire_NoiseAndSmoke	 ; make more smoke!!

	; +4 to this smoke though
	LDA CannonFire_Y,X
	SUB Level_VertScroll
	ADD #$04
	STA Brick_DebrisYHi

	; +8 to the other smoke
	ADC #$08
	STA Brick_DebrisYHi+1

	RTS		 ; Return

BobOmbXOffset:		.byte $00, $00, $08, $08
BobOmbYOffset:		.byte $F8, $F8, $00, $00
Cfire_Bobombs:
	JSR PrepareNewObjectOrAbort

	LDY <CurrentObjectIndexZ	

	LDA #OBJ_BOBOMB
	STA Objects_ID,X

	LDA #$28
	STA Objects_Timer, X

	LDA CannonFire_Property, Y
	AND #$03
	ADD #$01
	STA BobOmb_Action, X

	LDA #SPR_PAL1
	STA Objects_SpriteAttributes, X

	LDA CannonFire_Property, Y
	AND #$03
	TAY
	LDA BobOmbXOffset,Y
	STA <Temp_Var1

	LDA BobOmbYOffset,Y
	STA <Temp_Var2

	LDY <CurrentObjectIndexZ	

	
	LDA CannonFire_Y,Y
	ADD <Temp_Var2
	STA <Objects_YZ,X

	LDA CannonFire_YHi,Y
	STA <Objects_YHiZ,X

	LDA CannonFire_X,Y
	ADD <Temp_Var1
	STA <Objects_XZ,X

	LDA CannonFire_XHi,Y
	STA <Objects_XHiZ,X

	JSR Object_CalcBoundBox
	JSR Object_FacePlayer

	LDA CannonFire_Property, Y
	AND #$04
	LSR A
	LSR A
	STA Objects_Property, X

	LDA #$80
	STA CannonFire_Timer, Y
	LDY <CurrentObjectIndexZ	 ; X = Cannon Fire slot index
	RTS

Goomb_XVelocity:	.byte $E0, $20
Goomb_YVelocity:    .byte $C0, $C0

CanonPoofXOffset:
	.byte $FA, $06

EnemyCannonType:
	.byte OBJ_GOOMBA, OBJ_BEACHEDCHEEP

EnemyCannonDirection:
	.byte $00, SPR_HFLIP

EnemyCannonColor:
	.byte SPR_PAL3, SPR_PAL1

CFire_GoombaPipe:
	LDA CannonFire_Timer,X
	BNE PRG007_BD7A	 ; If timer not expired, jump to PRG007_BD7A (RTS)

	LDA Kill_Tally
	CMP #$03
	BCS PRG007_BD7A

	TXA
	TAY

	; Set timer to $70
	LDA #$70
	STA CannonFire_Timer,X	; (only used here, then it goes back to 'X' anyway)

	INC CannonFire_Var,X	 ; CannonFire_Var++

	LDA CannonFire_Var,X
	AND #$03
	BEQ PRG007_BD7A	 ; 1:4 ticks proceed, otherwise jump to PRG007_BD7A (RTS)

	JSR PrepareNewObjectOrAbort	 ; Prepare me a Goomba!

	; Set Goomba X
	LDA CannonFire_X,Y
	STA <Objects_XZ,X
	LDA CannonFire_XHi,Y
	STA <Objects_XHiZ,X
	LDA CannonFire_Y,Y
	STA <Objects_YZ,X
	LDA CannonFire_YHi,Y
	STA <Objects_YHiZ,X

PRG007_BD49:
	; set the motion of the goomba as it "pops" out of the pipe
	LDA CannonFire_Property, Y
	AND #$01
	TAY
	LDA EnemyCannonDirection, Y
	STA Objects_Orientation, X
	LDA Goomb_YVelocity, Y
	STA <Objects_YVelZ, X
	LDA Goomb_XVelocity, Y
	STA <Objects_XVelZ, X

	LDA CannonFire_Property, Y
	LSR A
	TAY
	; It's a Goomba
	LDA EnemyCannonType, Y
	STA Objects_ID,X

	LDA #$10
	STA Objects_Data4, X

	; Set Goomba's color
	LDA EnemyCannonColor, Y
	STA Objects_SpriteAttributes,X

	LDA #$00
	STA Objects_Property, X

	LDX <CurrentObjectIndexZ
	LDA CannonFire_Property, X
	AND #$01
	TAY
	
	
	JSR CannonFire_NoiseAndSmoke

PRG007_BD78:
	LDX <CurrentObjectIndexZ	 ; X = Cannon Fire slot index

PRG007_BD7A:
	RTS		 ; Return


CFire_ShellCannon:
	LDA CannonFire_Timer,X
	BNE CFire_ShellCannon1	 ; If timer not expired, jump to PRG007_BD7A (RTS)

	LDA Kill_Tally
	CMP #$03
	BCS CFire_ShellCannon1

	TXA
	TAY
	; Set timer to $70
	LDA #$70
	STA CannonFire_Timer,X	; (only used here, then it goes back to 'X' anyway)

	INC CannonFire_Var,X	 ; CannonFire_Var++

	LDA CannonFire_Var,X
	AND #$03
	BEQ CFire_ShellCannon1	 ; 1:4 ticks proceed, otherwise jump to PRG007_BD7A (RTS)

	JSR PrepareNewObjectOrAbort	 ; Prepare me a Goomba!

	; Set Goomba X
	LDA CannonFire_X,Y
	STA <Objects_XZ,X
	LDA CannonFire_XHi,Y
	STA <Objects_XHiZ,X
	LDA CannonFire_Y,Y
	STA <Objects_YZ,X
	LDA CannonFire_YHi,Y
	STA <Objects_YHiZ,X
	; set the motion of the goomba as it "pops" out of the pipe
	LDA CannonFire_Property, Y
	TAY
	LDA Goomb_YVelocity, Y
	STA <Objects_YVelZ, X
	LDA Goomb_XVelocity, Y
	STA <Objects_XVelZ, X

	; It's a Goomba
	LDA #OBJ_PURPLETROOPA
	STA Objects_ID,X

	LDA #OBJSTATE_KICKED
	STA Objects_State, X

	LDA #$60
	STA Objects_Timer3, X

	; Set Goomba's color
	LDA #SPR_PAL1
	STA Objects_SpriteAttributes,X

	LDX <CurrentObjectIndexZ
	LDA CannonFire_Property, X
	AND #$01
	TAY
	
	JSR CannonFire_NoiseAndSmoke

CFire_ShellCannon1:
	RTS		 ; Return

PRG007_BD82:
	.byte $00, $08, $10, $18, $20, $28, $30, $38

FourWay_CannonballXVel:	.byte $00, $0B, $10, $0B, $00, -$0B, -$10, -$0B

	.byte $F0, $F0, $F5, $0B, $F5, $0B, $F5, $0B, $F5, $0B, $10, $10

FourWay_CannonballYVel:	.byte -$10, -$0B, $00, $0B, $10, $0B, $00, -$0B

	.byte $00, $00, $F5, $F5, $0B, $0B, $F5, $F5, $0B, $0B, $00, $00

CannonPoof_XOffs:

FourWay_CPXOff:	.byte $08, $18, $1C, $18, $08, $F8, $F4, $F8

Cannons_CPXOff:
	.byte -$0C	; CFIRE_ULCANNON
	.byte -$0C	; CFIRE_URCANNON
	.byte -$08	; CFIRE_LLCANNON
	.byte  $08	; CFIRE_LRCANNON
	.byte -$08	; CFIRE_HLCANNON2
	.byte  $08	; CFIRE_ULCANNON2
	.byte  $00	; CFIRE_URCANNON2
	.byte  $00	; CFIRE_LLCANNON2
	.byte  $00	; CFIRE_HRCANNON
	.byte  $00	; Not used?
	.byte  $0C	; CFIRE_LBOBOMBS
	.byte  $0C	; CFIRE_RBOBOMBS


Bill_CPXOff:	.byte $0C, -$0C		; Bullet/Missile Bill
CannonPoof_YOffs:

FourWay_CPYOff:	.byte $F3, $F7, $07, $17, $1B, $17, $07, $F7

Cannons_CPYOff:
	.byte  $00	; CFIRE_ULCANNON
	.byte  $08	; CFIRE_URCANNON
	.byte -$08	; CFIRE_LLCANNON
	.byte -$08	; CFIRE_LRCANNON
	.byte  $08	; CFIRE_HLCANNON2
	.byte  $08	; CFIRE_ULCANNON2
	.byte  $00	; CFIRE_URCANNON2
	.byte  $00	; CFIRE_LLCANNON2
	.byte  $00	; CFIRE_HRCANNON
	.byte  $00	; Not used?
	.byte  $00	; CFIRE_LBOBOMBS
	.byte  $00	; CFIRE_RBOBOMBS

Bill_CPYOff:	.byte $00, $00		; Bullet/Missile Bill

CannonWidths: .byte $00, $08
DetermineCannonVisibilty:
	LDA #$01
	STA <Temp_Var1
	LDY #$01

DetermineCannonVisibilty1:
	LDA CannonFire_X,X
	ADD CannonWidths,Y
	STA <Temp_Var15		; Temp_Var15 = object's X + ??

	LDA CannonFire_XHi,X
	ADC #$00	 
	STA <Temp_Var16		; Temp_Var16 = Object's X Hi with carry applied

	LDA <Temp_Var15
	CMP <Horz_Scroll
	LDA <Temp_Var16	
	SBC <Horz_Scroll_Hi
	BEQ DetermineCannonVisibilty2	 ; If sprite is not horizontally off-screen, jump to PRG000_D7DE
	DEC <Temp_Var1
	BPL DetermineCannonVisibilty2
	PLA
	PLA
	RTS

DetermineCannonVisibilty2:
	DEY		 ; Y--
	BPL DetermineCannonVisibilty1	 ; While Y >= 0, loop

	RTS		 ; Return

CFire_Platform:
	LDA CannonFire_Timer, X
	BNE CFire_Platform1

	JSR Object_FindEmptyX
	LDY <CurrentObjectIndexZ

	LDA #OBJ_PLATFORMUNSTABLE
	STA Objects_ID,X

	LDA #$22
	STA Objects_Timer2, X

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA CannonFire_X,Y
	STA <Objects_XZ,X

	LDA CannonFire_XHi,Y
	STA <Objects_XHiZ,X

	LDA CannonFire_Y,Y
	STA <Objects_YZ,X

	LDA CannonFire_YHi,Y
	STA <Objects_YHiZ,X

	LDA #$F8
	STA <Objects_YVelZ, X

	LDA #SPR_PAL3
	STA Objects_SpriteAttributes,X

	TYA
	TAX

	LDY CannonFire_Property, X
	LDA PlatformGenTimer, Y
	STA CannonFire_Timer, X

CFire_Platform1:
	RTS
	
PlatformGenTimer:
	.byte $A0

PRG007_BE59:
	STA <Temp_Var1
	JMP FireCannonBall	 ; Fire the cannonball!

FireCannonBall:
	LDY #$05	 ; Y = 5

PRG007_BE60:
	LDA SpecialObj_ID,Y
	BEQ PRG007_BE69	 ; If this special object slot is free, jump to PRG007_BE69

	DEY		 ; Y--
	BPL PRG007_BE60	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG007_BE69:

	; Set this as a cannon ball!
	LDA #SOBJ_CANNONBALL
	STA SpecialObj_ID,Y

	; Set cannonball X
	LDA CannonFire_X,X
	CLC
	LDX <Temp_Var1		; X = 0 to 7
	ADC CannonPoof_XOffs,X
	STA SpecialObj_X,Y

	; Set cannonball Y velocity
	LDA FourWay_CannonballYVel,X
	ASL A
	STA SpecialObj_YVel,Y

	; Set cannonball X velocity
	LDA FourWay_CannonballXVel,X
	ASL A
	STA SpecialObj_XVel,Y

	; Temp_Var3 = 0 (16-bit sign extension)
	LDA #$00
	STA <Temp_Var3

	LDA CannonPoof_YOffs,X
	BPL PRG007_BE91	 ; If Y offset is not negative, jump to PRG007_BE91

	DEC <Temp_Var3	 ; Temp_Var3 = $FF (16-bit sign extension)

PRG007_BE91:
	CLC
	LDX <CurrentObjectIndexZ	 ; X = Cannon Fire slot index
	ADC CannonFire_Y,X
	STA SpecialObj_Y,Y
	LDA CannonFire_YHi,X
	ADC <Temp_Var3		; 16-bit sign extension
	STA SpecialObj_YHi,Y	

	; Data = 0
	LDA #$00
	STA SpecialObj_Data1,Y

	JMP CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke

PRG007_BEAA:
	RTS		 ; Return

	; Produces the smoke resulting from cannon fire; specify X/Y offset
	; from Cannon Fire's position by Temp_Var1 which indexes CannonPoof_X/YOffs 
CannonFire_NoiseAndSmoke:
	LDX <CurrentObjectIndexZ

	; Cannon firing noise
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA CannonFire_Y,X
	CMP Level_VertScroll
	LDA CannonFire_YHi,X
	SBC Level_VertScrollH
	BNE CannonPoofRTS		; If Cannon Fire has fallen off screen vertically, jump to PRG007_BF28 (RTS)

	JSR BrickBust_MoveOver	 ; Make room in first "brick bust" slot for poof

	; Brick bust, poof style
	LDA #$01
	STA BrickBust_En

	LDA CanonPoofXOffset, Y
	ADD CannonFire_X,X
	SUB <Horz_Scroll	; Make relative to horizontal scroll
	STA Brick_DebrisX		; Set X

	LDX <CurrentObjectIndexZ	 ; X = Cannon Fire slot index

	LDA CannonFire_Y,X	 ; + Cannon Fire Y
	SUB #$08
	SUB Level_VertScroll	 ; Make relative to vertical scroll
	STA Brick_DebrisYHi	 ; Set Y

	; Set poof counter
	LDA #$1f
	STA BrickBust_HEn

CannonPoofRTS:
	RTS		 ; Return


Rocky_InitAttr:	.byte SPR_HFLIP | SPR_BEHINDBG, SPR_BEHINDBG

CFire_RockyWrench:
	LDA CannonFire_Timer,X
	BNE PRG007_BF28	 ; If timer not expired, jump to PRG007_BF28 (RTS)

	; Reset cannon timer to $C0
	LDA #$c0
	STA CannonFire_Timer,X

	JSR PrepareNewObjectOrAbort	; Get me a slot for Rocky Wrench or don't come back!

	LDY <CurrentObjectIndexZ	; Y = Cannon Fire slot index

	; This is a Rocky Wrench
	LDA #OBJ_ROCKYWRENCH
	STA Objects_ID,X

	; Start at Cannon Fire Y - 6
	LDA CannonFire_Y,Y
	SUB #$06
	STA <Objects_YZ,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHiZ,X

	; Set Rocky's X to Cannon Fire's X
	LDA CannonFire_XHi,Y
	STA <Objects_XHiZ,X
	LDA CannonFire_X,Y
	STA <Objects_XZ,X

	; Var5 = 0
	LDA #$00
	STA Objects_Data2,X

	; Set Rocky's timer to $28
	LDA #$28
	STA Objects_Timer,X

	; Set Rocky's attributes
	LDA #SPR_PAL3
	STA Objects_SpriteAttributes,X

	; Set Rocky's initial attributes towards Player
	JSR Object_XDistanceFromPlayer
	LDA Rocky_InitAttr,Y
	STA Objects_Orientation,X

	LDX <CurrentObjectIndexZ	; X = Cannon Fire slot index

PRG007_BF28:
	RTS		 ; Return
				  
Bill_XVel:	.byte -$18, $18, $00, $18, $18, $00, -$18, -$18
Bill_YVel:	.byte $00, $00, $18, $18, -$18, -$18, -$18, $18
CanonTimers: .byte $20, $40, $60, $40, $20, $80, $40, $60
CFire_BulletBill:
	
	LDA CannonFire_Timer,X
	BNE PRG007_BF28	 ; If timer not expired, jump to PRG007_BF28 (RTS)

	; Reset Cannon Fire timer to $80-$9F, random
	LDA RandomN,X
	AND #$07
	TAY
	LDA CanonTimers, Y
	STA CannonFire_Timer,X

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	ADD #16
	CMP #32
	BLT PRG007_BF28		; If Cannon Fire X + 16 is less than 32 pixels from screen edge, jump to PRG007_BF28 (RTS)

	LDA <Player_X
	SBC CannonFire_X,X
	ADD #17
	CMP #34
	BLT PRG007_BF28		; If Player is standing on Bullet Bill cannon, jump to PRG007_BF28 (RTS)

	JSR PrepareNewObjectOrAbort

	LDY <CurrentObjectIndexZ	 ; Y = Cannon Fire object slot

	LDA CannonFire_Property, Y
	TAY
	LDA CannonFire_ID,Y
	LSR A		; Selects which Bill type

	LDA #OBJ_BULLETBILL

	BCS PRG007_BF80	 ; If carry set, jump to PRG007_BF80

	LDA #$50
	STA Objects_Timer, X
	LDA #OBJ_BULLETBILLHOMING

PRG007_BF80:
	STA Objects_ID,X	 ; Store Bill's ID

	; Set Bill's palette
	LDA #SPR_PAL3
	STA Objects_SpriteAttributes,X

	; Set Bill's Y
	LDA CannonFire_Y,Y
	SUB #$01
	STA <Objects_YZ,X

	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHiZ,X

	; Set Bill's X
	LDA CannonFire_XHi,Y
	STA <Objects_XHiZ,X

	LDA CannonFire_X,Y
	STA <Objects_XZ,X
	STA Objects_Data11,X	; original X hold

	LDA CannonFire_Property,Y
	TAY
	BNE PRG007_BF81

	LDA CannonFire_X, Y
	STA Objects_BoundLeft + 9
	ADD #$10
	STA Objects_BoundRight + 9

	LDA CannonFire_XHi, Y
	STA Objects_BoundLeftHi + 9
	ADC #$00
	STA Objects_BoundRightHi + 9

	STX TempX
	LDX #$09
	JSR Object_XDistanceFromPlayer

	LDX TempX
PRG007_BF81:
	; Bill fires towards Player
	LDA Bill_XVel,Y
	STA <Objects_XVelZ,X

	LDA Bill_YVel, Y
	STA <Objects_YVelZ, X

	LDY <CurrentObjectIndexZ	; X = Cannon Fire slot index

	JSR CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke

	RTS		 ; Return


	; Provides a newly prepared object or does not return to caller!
PrepareNewObjectOrAbort:
	LDX #$04	  ; X = 4

PRG007_BFCF:
	LDA Objects_State,X
	BEQ PRG007_BFDC	 ; If this object state = 0 (Dead/Empty), jump to PRG007_BFDC

	DEX		 ; X--
	BPL PRG007_BFCF	 ; While X >= 0, loop!

	; No object slots available; do not return to caller!!
	PLA
	PLA

	LDX <CurrentObjectIndexZ	 ; Restore 'X' to its slot index value

	RTS		 ; Return

PRG007_BFDC:
	JSR Object_New	 ; Prepare this new object

	; Set to normal state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	RTS		 ; Return

CheckTailSpin:
	LDA Effective_Suit
	CMP #$03
	BNE CheckTailSpin1

	LDA Player_TailAttack
	BEQ CheckTailSpin1

	
	JSR SObj_AddXVelFrac
	JSR SObj_AddYVelFrac
	PLA
	PLA

CheckTailSpin1:
	RTS	

EnemyProj_HitPlayer:
	LDA SpecialObj_HurtEnemies, X
	BEQ HitPlayer

	JSR PlayerProj_HitEnemies
	BCC Enemy_NoKill

	JMP Player_HitFire

Enemy_NoKill:
	RTS

HitPlayer:
	JSR SpecialObj_DetectPlayer
	BCC EnemyProj_HitPlayer1

	LDA SpecialObj_Data3, X
	BEQ SObj_CantStomp

	LDA <HitTest_Result
	AND #(HITTEST_BOTTOM)
	BEQ SObj_CantStomp

	LDA Player_BoundBottom
	SUB SpecialObj_BoundTop
	CMP #$08
	BCS SObj_CantStomp

	LDA #$00
	STA SpecialObj_Data3, X
	STA SpecialObj_YVel, X
	STA SpecialObj_XVel, X

	LDA #-$20
	STA <Player_YVel
	STA Player_InAir
	INC Exp_Earned

	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer
	RTS

SObj_CantStomp:
	LDA Effective_Suit
	CMP #$03
	BNE NotTailHit

	LDA Player_TailAttack
	BEQ NotTailHit

	LDA SpecialObj_XVel, X
	EOR #$FF
	ADD #$01
	STA SpecialObj_XVel, X

	LDA SpecialObj_YVel, X
	EOR #$FF
	ADD #$01
	STA SpecialObj_YVel, X
	INC SpecialObj_HurtEnemies, X
	RTS

NotTailHit:

	LDA Player_StarInv
	ORA Player_FireDash
	BEQ EnemyProj_HitPlayer2

	JMP SpecialObj_ToPoof
	
EnemyProj_HitPlayer2:
	JMP Player_GetHurt

EnemyProj_HitPlayer1:
	RTS

FreezeVel:
	.byte $10, $F0

EnemeyProj_Enemy_FreezePlayer:
	LDA SpecialObj_HurtEnemies, X
	BEQ Enemy_FreezePlayer

	JSR PlayerProj_HitEnemies
	BCC EnemeyProj_Enemy_FreezePlayer3

	JMP Player_HitIce

Enemy_FreezePlayer:
	JSR SpecialObj_DetectPlayer
	BCC EnemeyProj_Enemy_FreezePlayer3

	LDA Effective_Suit
	CMP #$03
	BNE Enemy_IceFreeze

	LDA Player_TailAttack
	BEQ Enemy_IceFreeze

	LDA SpecialObj_XVel, X
	EOR #$FF
	STA SpecialObj_XVel, X

	LDA SpecialObj_YVel, X
	EOR #$FF
	STA SpecialObj_YVel, X
	INC SpecialObj_HurtEnemies, X
	RTS

Enemy_IceFreeze:
	LDA Player_StarInv
	BEQ EnemeyProj_Enemy_FreezePlayer1

	JMP SpecialObj_ToPoof
	
EnemeyProj_Enemy_FreezePlayer1:
	LDY #$00
	LDA SpecialObj_XVel, X
	BPL EnemeyProj_Enemy_FreezePlayer2

	INY

EnemeyProj_Enemy_FreezePlayer2
	LDA FreezeVel, Y
	STA <Player_XVel

	LDA #$00
	STA SpecialObj_ID, X

	JMP Enemy_FreezePlayer
	
EnemeyProj_Enemy_FreezePlayer3:
	RTS


DrawStarsBackground:
	
	LDA WeatherActive
	BNE DrawStarsBackground01

	LDA DayNightActive
	BNE DrawParallaxBackground

DrawStarsBackground01:
	RTS

DrawParallaxBackground:
	LDA DayNight
	BNE DrawStarsBackground1


DrawSkyBackground1:
	LDA <Counter_1
	AND #$3F
	BNE DrawSkyBackground2
	INC Weather_XPos
	INC Weather_XPos + 1
	INC Weather_XPos + 2
	INC Weather_XPos + 3
	INC Weather_XPos + 4
	INC Weather_XPos + 5

DrawSkyBackground2:
	LDX #$05
	LDY #$F8
	LDA <Vert_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1
	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	STA <Temp_Var2
	LDA <Horz_Scroll_Hi
	ASL A
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var2
	STA <Temp_Var2

DrawClouds0:
	JSR FindUnusedSprite
	LDA #(SPR_PAL1 | SPR_BEHINDBG)
	STA Sprite_RAM + 2, Y
	LDA #$75
	STA Sprite_RAM + 1, Y
	
	LDA Weather_YPos, X
	SUB <Temp_Var1
	STA Sprite_RAM, Y
	
	LDA Weather_XPos, X
	SUB <Temp_Var2
	STA Sprite_RAM +3, Y
	DEX
	BPL DrawClouds0
	RTS

DrawStarsBackground1:
	LDY #$F8
	LDX #$05
	LDA <Vert_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1
	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	STA <Temp_Var2
	LDA <Horz_Scroll_Hi
	ASL A
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var2
	STA <Temp_Var2

DrawStars0:
	JSR FindUnusedSprite
	TXA
	AND #$03
	ORA #SPR_BEHINDBG
	STA Sprite_RAM + 2, Y
	LDA #$5D
	STA Sprite_RAM + 1, Y

	LDA StarYPositions, X
	SUB <Temp_Var1
	STA Sprite_RAM, Y
	
	LDA StarXPositions, X
	SUB <Temp_Var2
	STA Sprite_RAM +3, Y
	DEX
	BPL DrawStars0
	RTS

Projectile_TempChange:
	LDA ProjectileToSpinners
	BEQ Projectile_TempChangeRTS


Projectile_TempChangeRTS:
	RTS