; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup04 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $04 (i.e. objects starting at ID $90) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup04_InitJumpTable:
	.word ObjInit_ProjBar	; Object $90 - OBJ_FIREICEBAR
	.word ObjInit_Freezie	; Object $91 - OBJ_FREEZIE
	.word ObjInit_Swoosh	; Object $92 - OBJ_SWOOSH
	.word ObjInit_IntroSequence	; Object $93 - OBJ_INTRO
	.word ObjInit_Dimmer		; Object $94 - OBJ_DIMMER
	.word ObjInit_DoNothing		; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.word ObjInit_DoNothing		; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.word ObjInit_DoNothing		; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.word ObjInit_DoNothing		; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.word ObjInit_DoNothing		; Object $99 - OBJ_BIGQBLOCK_FROG
	.word ObjInit_DoNothing		; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.word ObjInit_DoNothing		; Object $9B
	.word ObjInit_DoNothing		; Object $9C
	.word ObjInit_FireJetUpward	; Object $9D - OBJ_FIREJET_UPWARD
	.word ObjInit_Podobo		; Object $9E - OBJ_Podobo
	.word ObjInit_ParaBeetle	; Object $9F - OBJ_PARABEETLE
	.word ObjInit_PumpkinFree	; Object $A0 - OBJ_PUMPKINFREE
	.word ObjInit_DoNothing	; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.word ObjInit_Piranha	; Object $A2 - OBJ_PIRANHA
	.word ObjInit_Piranha_TwoShot	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.word ObjInit_Pumpkin	; Object $A4 - OBJ_PUMPKINPLANT
	.word ObjInit_DoNothing	; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.word ObjInit_DoNothing	; Object $A6 - OBJ_VENUSFIRETRAP
	.word ObjInit_DoNothing	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.word ObjInit_DoNothing		; Object $A8 - OBJ_ACIDTRAP
	.word ObjInit_DoNothing		; Object $A9 - OBJ_ACIDTRAP_CEIL
	.word ObjInit_DoNothing		; Object $AA - OBJ_AIRSHIPPROP
	.word ObjInit_FireJetRight	; Object $AB (doesn't really work, and the "normal" routine is even weirder)
	.word ObjInit_FireJetLeft	; Object $AC - OBJ_FIREJET_LEFT
	.word ObjInit_RockyWrench	; Object $AD - OBJ_ROCKYWRENCH
	.word ObjInit_BoltLift		; Object $AE - OBJ_BOLTLIFT
	.word ObjInit_Sun		; Object $AF - OBJ_ENEMYSUN
	.word ObjInit_BigCannonBall	; Object $B0 - OBJ_BIGCANNONBALL
	.word ObjInit_FireJetRight	; Object $B1 - OBJ_FIREJET_RIGHT
	.word ObjInit_FireJetUpsideDown	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.word ObjInit_ObjB3		; Object $B3 


	; Object group $04 (i.e. objects starting at ID $90) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup04_NormalJumpTable:
	.word ObjNorm_ProjectileBarCW	; Object $90 - OBJ_FIREICEBAR
	.word ObjNorm_Freezie	; Object $91 - OBJ_FREEZIE
	.word ObjNorm_Swoosh	; Object $92 - OBJ_SWOOSH
	.word ObjNorm_IntroSequence	; Object $93 - OBJ_INTRO
	.word ObjNorm_Dimmer		; Object $94 - OBJ_DIMMER
	.word ObjNorm_DoNothing		; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.word ObjNorm_DoNothing		; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.word ObjNorm_DoNothing		; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.word ObjNorm_DoNothing		; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.word ObjNorm_DoNothing		; Object $99 - OBJ_BIGQBLOCK_FROG
	.word ObjNorm_DoNothing		; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.word ObjNorm_DoNothing		; Object $9B
	.word ObjNorm_DoNothing		; Object $9C
	.word ObjNorm_FireJet		; Object $9D - OBJ_FIREJET_UPWARD
	.word ObjNorm_Podobo		; Object $9E - OBJ_Podobo
	.word ObjNorm_ParaBeetle	; Object $9F - OBJ_PARABEETLE
	.word ObjNorm_PumpkinFree		; Object $A0 - OBJ_PUMPKINFREE
	.word ObjNorm_PumpkinFree		; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.word ObjNorm_Piranha		; Object $A2 - OBJ_REDPIRANHA
	.word ObjNorm_Piranha		; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.word ObjNorm_Pumpkin		; Object $A4 - OBJ_PUMPKINPLANT
	.word ObjNorm_DoNothing		; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.word ObjNorm_DoNothing		; Object $A6 - OBJ_VENUSFIRETRAP
	.word ObjNorm_DoNothing		; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.word ObjNorm_DoNothing	; Object $A8 - OBJ_ACIDTRAP
	.word ObjNorm_DoNothing	; Object $A9 - OBJ_ACIDTRAP_CEIL
	.word ObjNorm_DoNothing	; Object $AA - OBJ_AIRSHIPPROP
	.word FireJetLR_SpriteVisibleTest	; Object $AB (this call doesn't make any sense!!)
	.word ObjNorm_FireJet		; Object $AC - OBJ_FIREJET_LEFT
	.word ObjNorm_RockyWrench	; Object $AD - OBJ_ROCKYWRENCH
	.word ObjNorm_BoltLift		; Object $AE - OBJ_BOLTLIFT
	.word ObjNorm_Sun		; Object $AF - OBJ_ENEMYSUN
	.word ObjNorm_BigCannonBall	; Object $B0 - OBJ_BIGCANNONBALL
	.word ObjNorm_FireJet		; Object $B1 - OBJ_FIREJET_RIGHT
	.word ObjNorm_FireJet		; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.word ObjNorm_ObjB3		; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) Collision routine jump table (if calling Object_InteractWithPlayer;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup04_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $90 - OBJ_FIREICEBAR
	.word ObjHit_Freezie	; Object $91 - OBJ_FREEZIE
	.word ObjHit_DoNothing	; Object $92 - OBJ_SWOOSH
	.word ObjHit_DoNothing	; Object $93 - OBJ_INTRO
	.word ObjHit_DoNothing	; Object $94 - OBJ_BIGQBLOCK_3UP
	.word ObjHit_DoNothing	; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.word ObjHit_DoNothing	; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.word ObjHit_DoNothing	; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.word ObjHit_DoNothing	; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.word ObjHit_DoNothing	; Object $99 - OBJ_BIGQBLOCK_FROG
	.word ObjHit_DoNothing	; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.word ObjHit_DoNothing	; Object $9B
	.word ObjHit_DoNothing	; Object $9C
	.word ObjHit_DoNothing	; Object $9D - OBJ_FIREJET_UPWARD
	.word ObjHit_DoNothing	; Object $9E - OBJ_Podobo
	.word ObjHit_DoNothing	; Object $9F - OBJ_PARABEETLE
	.word Player_GetHurt	; Object $A0 - OBJ_PUMPKINFREE
	.word ObjHit_DoNothing	; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.word ObjHit_DoNothing	; Object $A2 - OBJ_REDPIRANHA
	.word ObjHit_DoNothing	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.word ObjHit_DoNothing	; Object $A4 - OBJ_PUMPKINPLANT
	.word ObjHit_DoNothing	; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.word ObjHit_DoNothing	; Object $A6 - OBJ_VENUSFIRETRAP
	.word ObjHit_DoNothing	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.word ObjHit_DoNothing	; Object $A8 - OBJ_ACIDTRAP
	.word ObjHit_DoNothing	; Object $A9 - OBJ_ACIDTRAP_CEIL
	.word ObjHit_DoNothing	; Object $AA - OBJ_AIRSHIPPROP
	.word ObjHit_DoNothing	; Object $AB
	.word ObjHit_DoNothing	; Object $AC - OBJ_FIREJET_LEFT
	.word ObjHit_DoNothing	; Object $AD - OBJ_ROCKYWRENCH
	.word ObjHit_DoNothing	; Object $AE - OBJ_BOLTLIFT
	.word Player_GetHurt	; Object $AF - OBJ_ENEMYSUN
	.word $0000	; Object $B0 - OBJ_BIGCANNONBALL
	.word $0000	; Object $B1 - OBJ_FIREJET_RIGHT
	.word $0000	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.word $0000	; Object $B3 

	
	; Object group $04 (i.e. objects starting at ID $90) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup04_Attributes:
	.byte OA1_PAL1 | OA1_WIDTH8 | OA1_WIDTH8	; Object $90 - OBJ_FIREICEBAR
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $91 - OBJ_FREEZIE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $92 - OBJ_SWOOSH
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $93 - OBJ_INTRO
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $94 - OBJ_BIGQBLOCK_3UP
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $99 - OBJ_BIGQBLOCK_FROG
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $9B
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $9C
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH16	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $9E - OBJ_Podobo
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $9F - OBJ_PARABEETLE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $A0 - OBJ_PUMPKINFREE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A2 - OBJ_REDPIRANHA
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A4 - OBJ_PUMPKINPLANT
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A8 - OBJ_ACIDTRAP
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A9 - OBJ_ACIDTRAP_CEIL
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $AA - OBJ_AIRSHIPPROP
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $AB
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $AC - OBJ_FIREJET_LEFT
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $AD - OBJ_ROCKYWRENCH
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $AE - OBJ_BOLTLIFT
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $AF - OBJ_ENEMYSUN
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH16	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $B3

	; Object group $04 (i.e. objects starting at ID $90) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup04_Attributes2:
	.byte OA2_TDOGRP0	; Object $90 - OBJ_FIREICEBAR
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $91 - OBJ_FREEZIE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $92 - OBJ_SWOOSH
	.byte OA2_TDOGRP0	; Object $93 - OBJ_INTRO
	.byte OA2_TDOGRP0	; Object $94 - OBJ_BIGQBLOCK_3UP
	.byte OA2_TDOGRP0	; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.byte OA2_TDOGRP0	; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.byte OA2_TDOGRP0	; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.byte OA2_TDOGRP0	; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.byte OA2_TDOGRP0	; Object $99 - OBJ_BIGQBLOCK_FROG
	.byte OA2_TDOGRP0	; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.byte OA2_TDOGRP0	; Object $9B
	.byte OA2_TDOGRP0	; Object $9C
	.byte OA2_TDOGRP0	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP0	; Object $9E - OBJ_Podobo
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $9F - OBJ_PARABEETLE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A0 - OBJ_PUMPKINFREE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A2 - OBJ_REDPIRANHA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A4 - OBJ_PUMPKINPLANT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A8 - OBJ_ACIDTRAP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A9 - OBJ_ACIDTRAP_CEIL
	.byte OA2_TDOGRP0	; Object $AA - OBJ_AIRSHIPPROP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AB
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AC - OBJ_FIREJET_LEFT
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AD - OBJ_ROCKYWRENCH
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP10	; Object $AE - OBJ_BOLTLIFT
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AF - OBJ_ENEMYSUN
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP0	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OA2_TDOGRP0	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OA2_TDOGRP0	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OA2_TDOGRP11	; Object $B3

	; Object group $04 (i.e. objects starting at ID $90) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup04_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $90 - OBJ_FIREICEBAR
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $91 - OBJ_FREEZIE
	.byte OA3_HALT_NORMALONLY	; Object $92 - OBJ_SWOOSH
	.byte OA3_HALT_NORMALONLY 	; Object $93 - OBJ_INTRO
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $94 - OBJ_BIGQBLOCK_3UP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $99 - OBJ_BIGQBLOCK_FROG
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $9B
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $9C
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $9E - OBJ_Podobo
	.byte OA3_HALT_NORMALONLY 	; Object $9F - OBJ_PARABEETLE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A0 - OBJ_PUMPKINFREE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE 	; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A2 - OBJ_REDPIRANHA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A4 - OBJ_PUMPKINPLANT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE	; Object $A8 - OBJ_ACIDTRAP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE	; Object $A9 - OBJ_ACIDTRAP_CEIL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $AA - OBJ_AIRSHIPPROP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $AB
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $AC - OBJ_FIREJET_LEFT
	.byte OA3_HALT_NORMALONLY 	; Object $AD - OBJ_ROCKYWRENCH
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $AE - OBJ_BOLTLIFT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $AF - OBJ_ENEMYSUN
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup04_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $90 - OBJ_FIREICEBAR
	.byte OPTS_SETPT5 | $33	; Object $91 - OBJ_FREEZIE
	.byte OPTS_SETPT5 | $33	; Object $92 - OBJ_SWOOSH
	.byte OPTS_SETPT5 | $36	; Object $93 - OBJ_INTRO
	.byte OPTS_NOCHANGE ; Object $94 - OBJ_BIGQBLOCK_3UP
	.byte OPTS_SETPT5 | $4C	; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.byte OPTS_SETPT5 | $4C	; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.byte OPTS_SETPT5 | $4C	; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.byte OPTS_SETPT5 | $4C	; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.byte OPTS_SETPT5 | $4C	; Object $99 - OBJ_BIGQBLOCK_FROG
	.byte OPTS_SETPT5 | $4C	; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.byte OPTS_NOCHANGE	; Object $9B
	.byte OPTS_NOCHANGE	; Object $9C
	.byte OPTS_SETPT6 | $37	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OPTS_NOCHANGE	; Object $9E - OBJ_Podobo
	.byte OPTS_SETPT5 | $0E	; Object $9F - OBJ_PARABEETLE
	.byte OPTS_SETPT6 | $13	; Object $A0 - OBJ_PUMPKINFREE
	.byte OPTS_SETPT5 | $13	; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.byte OPTS_SETPT6 | $4F	; Object $A2 - OBJ_REDPIRANHA
	.byte OPTS_SETPT6 | $4F	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.byte OPTS_SETPT6 | $13	; Object $A4 - OBJ_PUMPKINPLANT
	.byte OPTS_SETPT6 | $4F	; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.byte OPTS_SETPT6 | $4F	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OPTS_SETPT6 | $4F	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OPTS_SETPT6 | $4F	; Object $A8 - OBJ_ACIDTRAP
	.byte OPTS_SETPT6 | $4F	; Object $A9 - OBJ_ACIDTRAP_CEIL
	.byte OPTS_SETPT5 | $36	; Object $AA - OBJ_AIRSHIPPROP
	.byte OPTS_SETPT5 | $36	; Object $AB
	.byte OPTS_SETPT6 | $37	; Object $AC - OBJ_FIREJET_LEFT
	.byte OPTS_SETPT5 | $36	; Object $AD - OBJ_ROCKYWRENCH
	.byte OPTS_SETPT5 | $36	; Object $AE - OBJ_BOLTLIFT
	.byte OPTS_SETPT5 | $37	; Object $AF - OBJ_ENEMYSUN
	.byte OPTS_SETPT5 | $36	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OPTS_SETPT6 | $37	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OPTS_SETPT6 | $37	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OPTS_SETPT5 | $0B	; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup04_KillAction:
	.byte KILLACT_STANDARD	; Object $90 - OBJ_FIREICEBAR
	.byte KILLACT_NORMALSTATE	; Object $91 - OBJ_FREEZIE
	.byte KILLACT_POOFDEATH	; Object $92 - OBJ_SWOOSH
	.byte KILLACT_STANDARD	; Object $93 - OBJ_INTRO
	.byte KILLACT_STANDARD	; Object $94 - OBJ_BIGQBLOCK_3UP
	.byte KILLACT_STANDARD	; Object $95 - OBJ_BIGQBLOCK_MUSHROOM
	.byte KILLACT_STANDARD	; Object $96 - OBJ_BIGQBLOCK_FIREFLOWER
	.byte KILLACT_STANDARD	; Object $97 - OBJ_BIGQBLOCK_SUPERLEAF
	.byte KILLACT_STANDARD	; Object $98 - OBJ_BIGQBLOCK_TANOOKI
	.byte KILLACT_STANDARD	; Object $99 - OBJ_BIGQBLOCK_FROG
	.byte KILLACT_STANDARD	; Object $9A - OBJ_BIGQBLOCK_HAMMER
	.byte KILLACT_STANDARD	; Object $9B
	.byte KILLACT_STANDARD	; Object $9C
	.byte KILLACT_STANDARD	; Object $9D - OBJ_FIREJET_UPWARD
	.byte KILLACT_POOFDEATH	; Object $9E - OBJ_Podobo
	.byte KILLACT_JUSTDRAW16X16	; Object $9F - OBJ_PARABEETLE
	.byte KILLACT_JUSTDRAW16X16	; Object $A0 - OBJ_PUMPKINFREE
	.byte KILLACT_POOFDEATH	; Object $A1 - OBJ_PUMPKINFREE_FLIPPED
	.byte KILLACT_POOFDEATH	; Object $A2 - OBJ_REDPIRANHA
	.byte KILLACT_POOFDEATH	; Object $A3 - OBJ_PIRANHA_TWOSHOT
	.byte KILLACT_NORMALANDKILLED	; Object $A4 - OBJ_PUMPKINPLANT
	.byte KILLACT_POOFDEATH	; Object $A5 - OBJ_PUMPKINPLANT_HOPPER
	.byte KILLACT_POOFDEATH	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte KILLACT_POOFDEATH	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte KILLACT_POOFDEATH	; Object $A8 - OBJ_ACIDTRAP
	.byte KILLACT_POOFDEATH	; Object $A9 - OBJ_ACIDTRAP_CEIL
	.byte KILLACT_STANDARD	; Object $AA - OBJ_AIRSHIPPROP
	.byte KILLACT_STANDARD	; Object $AB
	.byte KILLACT_STANDARD	; Object $AC - OBJ_FIREJET_LEFT
	.byte KILLACT_NORMALANDKILLED	; Object $AD - OBJ_ROCKYWRENCH
	.byte KILLACT_STANDARD	; Object $AE - OBJ_BOLTLIFT
	.byte KILLACT_NORMALANDKILLED	; Object $AF - OBJ_ENEMYSUN
	.byte KILLACT_NORMALANDKILLED	; Object $B0 - OBJ_BIGCANNONBALL
	.byte KILLACT_STANDARD	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte KILLACT_STANDARD	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte KILLACT_NORMALANDKILLED	; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) pattern index starts
	; These are used for all states except "normal"

OG4_POff .func (\1 - ObjectGroup04_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup04_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG4_POff(ObjP90), OG4_POff(ObjP91), OG4_POff(ObjP92), OG4_POff(ObjP93)
	.byte OG4_POff(ObjP94), OG4_POff(ObjP95), OG4_POff(ObjP96), OG4_POff(ObjP97)
	.byte OG4_POff(ObjP98), OG4_POff(ObjP99), OG4_POff(ObjP9A), OG4_POff(ObjP9B)
	.byte OG4_POff(ObjP9C), OG4_POff(ObjP9D), OG4_POff(ObjP9E), OG4_POff(ObjP9F)
	.byte OG4_POff(ObjPA0), OG4_POff(ObjPA1), OG4_POff(ObjPA2), OG4_POff(ObjPA3)
	.byte OG4_POff(ObjPA4), OG4_POff(ObjPA5), OG4_POff(ObjPA6), OG4_POff(ObjPA7)
	.byte OG4_POff(ObjPA8), OG4_POff(ObjPA9), OG4_POff(ObjPAA), OG4_POff(ObjPAB)
	.byte OG4_POff(ObjPAC), OG4_POff(ObjPAD), OG4_POff(ObjPAE), OG4_POff(ObjPAF)
	.byte OG4_POff(ObjPB0), OG4_POff(ObjPB1), OG4_POff(ObjPB2), OG4_POff(ObjPB3)


	; Object group $04 (i.e. objects starting at ID $90) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup04_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup04_PatternSets:
	; (End restricted alignment space)

ObjP90:
ObjP91:
	.byte $AD, $AF, $B1, $AF, $B5, $B7, $AD, $B3
ObjP92:
	.byte $A1, $A3
	.byte $A5, $A7
	.byte $81, $83
	.byte $85, $87
	.byte $85, $87
	.byte $81, $83
	.byte $A1, $A3
	.byte $A9, $AB

ObjP93:
	.byte $81, $83, $A1, $A3, $85, $87, $A5, $A7

ObjP94:
ObjP95:
ObjP96:
ObjP97:
ObjP98:
ObjP99:
ObjP9A:
ObjP9B:
ObjP9C:
ObjP9E:
ObjPAC:
ObjPB1:
	.byte $8D, $8D, $8F, $8F, $95, $95
ObjPB3:
	.byte $BD, $BD, $BB, $BB, $BD, $BD, $99, $99
ObjPB0:
	.byte $A5, $A7, $A5, $A7
ObjP9D:
ObjPB2:
	.byte $DD, $71, $DF, $71, $D9, $71, $DB, $71, $CD, $D3, $CF, $D5, $71, $71, $71, $71, $CB, $D1

ObjPA0:
	.byte $F1, $F3, $F5, $F7, $E5, $E7, $E9, $EB

ObjPA1:
ObjPA2:
ObjPA3:
	.byte $E1, $E1, $E3, $E3, $E5, $E5, $E3, $E3
	.byte $F1, $F3, $E3, $E3, $F5, $F7, $E3, $E3

ObjPA4:
	.byte $E5, $E7, $E3, $E3, $E9, $EB, $E3, $E3, $E5, $E7, $71, $71, $E9, $EB, $71, $71
	.byte $F1, $F3, $E3, $E3, $F5, $F7, $E3, $E3, $F1, $F3, $71, $71, $F5, $F7, $71, $71

ObjPA5:
ObjPA6:
ObjPA7:
ObjPA8:
ObjPA9:
	
ObjP9F:
	.byte $B1, $B3, $B5, $B7, $B1, $B3

ObjPAF:
	.byte $81, $83, $83, $81, $A1, $A3, $A3, $A1
	.byte $85, $87, $87, $85, $A5, $A7, $A7, $A5

ObjPAE:
	.byte $81, $81, $83, $83, $85, $85, $87, $87

ObjPAD:
	.byte $91, $93, $8D, $8F, $89, $8B, $B3, $B5, $97, $9B, $99, $99, $9B, $97, $99, $99
ObjPAB:
	.byte $A5, $A7
ObjPAA:
; Note to self: Remember, until the label!
	.byte $A9, $71

Podobo_Limit = Objects_Data3
Podobo_LimitHi = Objects_Data4
Podobo_Frame = Objects_Data1
Podobo_Timer = Objects_Data5
Podobo_Hiding = Objects_Data6

ObjInit_Podobo:
	LDA Objects_Property, X
	BEQ ObjInit_Podobo1

	LDA #$0A
	STA PatTable_BankSel+4

ObjInit_Podobo1:
	LDA <Objects_YZ,X
	ADD #$2A
	STA Podobo_Limit,X

	LDA <Objects_YHiZ,X
	ADC #$00
	STA Podobo_LimitHi,X

	LDA #$01
	STA Objects_NoIce, X
	RTS		 ; Return

ObjNorm_Podobo:
	LDA <Player_HaltGameZ
	BEQ Podobo_Norm

	JMP Object_DrawMirrored

Podobo_Norm:
	
	JSR Object_DeleteOffScreen
	LDA Objects_Timer,X
	BEQ Podobo_Move	 ; If timer expired, jump to PRG005_A259

Podobo_Hide:
	RTS

Podobo_Move:	
	LDA <Objects_YVelZ, X
	BPL Podobo_MoveGravity

	LDA <Objects_YZ, X
	SUB Podobo_Limit, X

	LDA <Objects_YHiZ, X
	SBC Podobo_LimitHi, X
	BCC Podobo_MoveGravity

	LDA #$C0
	STA <Objects_YVelZ, X

Podobo_MoveGravity:
	JSR Object_Move

Podobo_MoveDone:
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	JSR Object_DetectTiles
	JSR Object_CheckForeground

	LDA <Objects_YZ, X
	AND #$0F
	CMP #$0B
	BCC Podobo_Animate

	LDA Object_BodyTileProp, X
	CMP #(TILE_PROP_WATER | TILE_PROP_HARMFUL)
	BEQ Podobo_Pause

	CMP #(TILE_PROP_FOREGROUND |TILE_PROP_WATER | TILE_PROP_HARMFUL)
	BNE Podobo_Animate

Podobo_Pause:

	LDA #$40
	STA Objects_Timer, X

	LDA #$C0
	STA <Objects_YVelZ, X

Podobo_Animate:
	; Frame loop 0-2
	INC Podobo_Frame, X
	LDA Podobo_Frame, X
	LSR A
	LSR A
	LSR A
	AND #$03
	CMP #$03
	BCC Podobo_StoreFrame

	LDA #$00
	STA Podobo_Frame, X

Podobo_StoreFrame:
	STA Objects_Frame, X


	LDA <Objects_YVelZ, X
	BPL Podobo_Flip

	LDA #$00
	STA Objects_Orientation, X
	BEQ Podobo_Draw

Podobo_Flip:

	LDA #SPR_VFLIP
	STA Objects_Orientation, X
	BNE Podobo_Draw
	
Podobo_Draw:
	JMP Object_DrawMirrored

SpinyEgg_TowardsPlayer:	.byte $0A, -$0A

ObjInit_ObjB3:

	RTS		 ; Return

ObjNorm_ObjB3:

ObjInit_BigCannonBall:
	RTS		 ; Return

ObjNorm_BigCannonBall:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR BigCannonBall_Draw	 	; Draw the big cannon ball

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE ObjInit_BigCannonBall	; If big cannon ball's state is not Normal, jump to ObjInit_BigCannonBall (RTS)

	LDA <Player_HaltGameZ
	BNE ObjInit_BigCannonBall	; If gameplay halted, jump to ObjInit_BigCannonBall (RTS)

	JSR Object_ApplyXVel	 ; Apply X velocity
	JMP Object_AttackOrDefeat	 ; Do Player to Big Cannon Ball collision and don't come back!

BigCannonBall_Draw:
	LDA #$00
	STA Objects_Frame,X	; Set frame to zero
	STA Objects_Orientation,X	; No flip

	; horizontal visibility bits -> Temp_VarNP0
	LDA Objects_SpritesHorizontallyOffScreen,X
	STA Temp_VarNP0

	LDA <Objects_XZ,X
	PHA		 ; Save big cannon ball's X
	ADD #$08	 
	STA <Objects_XZ,X ; +8 to big cannon ball's X

	LDA <Objects_XHiZ,X
	PHA		 ; Save big cannon ball's X Hi
	ADC #$00	 ; Apply carry
	STA <Objects_XHiZ,X	 ; Update big cannon ball's X Hi

	ASL Objects_SpritesHorizontallyOffScreen,X
	JSR Object_Draw16x32	 ; Draw center of big cannon ball

	; Restore X/Hi
	PLA
	STA <Objects_XHiZ,X
	PLA
	STA <Objects_XZ,X

	JSR Object_CalcSpriteXY_NoHi

	LDA Objects_SpritesVerticallyOffScreen,X
	BNE PRG005_A429	 	; If any sprite of the big cannon ball is vertically off-screen, jump to PRG005_A429 (RTS)

	; Temp_Var1 = big cannon ball's Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	LDY Object_SpriteRAMOffset,X	 ; Y = Sprite RAM offset

	LDA Temp_VarNP0
	BMI PRG005_A3F3	 ; If this sprite is horizontally off-screen, jump to PRG005_A3F3

	; Add 8 to Sprite Y for left edge sprite (vertically centered)
	LDA <Temp_Var1
	ADD #$08
	STA Sprite_RAM+$10,Y

PRG005_A3F3:
	LDA Temp_VarNP0
	AND #%00010000
	BNE PRG005_A402	 ; If this sprite is horizontally off-screen, jump to PRG005_A402

	; Add 8 to Sprite Y for right edge sprite (vertically centered)
	LDA <Temp_Var1
	ADD #$08
	STA Sprite_RAM+$14,Y

PRG005_A402:
	; Set palette select 3 and vertical flip for lower sprites
	LDA #(SPR_VFLIP | SPR_PAL3)
	STA Sprite_RAM+$0A,Y
	STA Sprite_RAM+$0E,Y

	; Left edge sprite pattern
	LDA #$a3
	STA Sprite_RAM+$11,Y

	; Right edge sprite pattern
	LDA #$b1
	STA Sprite_RAM+$15,Y

	; Set palette select 3 for edge sprites
	LDA #SPR_PAL3
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	LDX <CurrentObjectIndexZ	 ; X = object slot index

	; Set Sprite X for edge sprites
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$13,Y
	ADD #24
	STA Sprite_RAM+$17,Y

PRG005_A429:
	RTS		 ; Return

ObjInit_FireJetUpward:
	RTS		 ; Return

ObjInit_FireJetUpsideDown:
	RTS		 ; Return

ObjNorm_FireJet:
	RTS		 ; Return

PumpkinFreeXSpeeds:
	.byte $10, $F0

ObjInit_PumpkinFree:
	LDA <Objects_XZ, X
	ADD #$08
	STA <Objects_XZ, X
	RTS

ObjNorm_PumpkinFree:
	LDA <Player_HaltGameZ
	BEQ ObjNorm_PumpkinFree1
	LDA Objects_Data6, X
	BNE PumpkinFreeDraw1
	RTS
	JMP PumpkinFreeDraw1

ObjNorm_PumpkinFree1:
	JSR Object_DeleteOffScreen
	JSR Object_InteractWithPlayer
	LDA Objects_Data6, X
	JSR DynJump

	.word PumpkinFreeWait
	.word PumpkinFreeAttack

PumpkinFreeWait:
	JSR Object_XDistanceFromPlayer
	LDA <Temp_Var16
	BPL PumpkinFreeWait1
	JSR Negate

PumpkinFreeWait1:
	CMP #$28
	BCS PumpkinFreeWaitRTS

	LDA #$B0
	STA <Objects_YVelZ, X
	INC Objects_Data6, X

PumpkinFreeWaitRTS:
	RTS

PumpkinFreeAttack:
	JSR Object_Move
	JSR Object_InteractWithTiles

	LDA Objects_PreviousTilesDetect, X
	AND #HIT_GROUND
	BNE PumpkinFreeDraw

	LDA Objects_TilesDetectZ, X
	AND #HIT_GROUND
	BEQ PumpkinFreeDraw

	LDA <Objects_XVelZ, X
	BNE PumpkinFreeAttack1

	JSR Object_FacePlayer
	LDA PumpkinFreeXSpeeds, Y
	STA <Objects_XVelZ, X

PumpkinFreeAttack1:
	LDA #$C0
	STA <Objects_YVelZ, X
	
PumpkinFreeDraw:
	INC Objects_Data4, X
	LDA Objects_Data4, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

	LDA <Objects_XVelZ, X
	BNE PumpkinFreeDraw1

	LDA Objects_Frame, X
	ORA #$02
	STA Objects_Frame, X

PumpkinFreeDraw1:
	JMP Object_Draw
	
PiranhaPals:
	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1, SPR_PAL1, SPR_PAL2, SPR_PAL2, SPR_PAL1, SPR_PAL1


FireJetLR_SpriteVisibleTest:

	RTS		 ; Return

ObjInit_FireJetLeft:
ObjInit_FireJetRight:
	RTS		 ; Return

RockyWrench_FlipBits:	.byte $60, $20



Piranha_CurrentFrame = Objects_Data1
Piranha_CurrentState = Objects_Data3
Piranha_AttackCount	= Objects_Data4
Piranha_AttacksLeft	= Objects_Data5
Piranha_AttackData = Objects_Data6
Piranha_StateTimer = Objects_Timer

Piranha_YVel:
	.byte $F8, $08
	
Piranha_Orientation:
	.byte SPR_BEHINDBG, SPR_VFLIP | SPR_BEHINDBG

Piranha_Palettes:
	.byte SPR_PAL1, SPR_PAL1, SPR_PAL2, SPR_PAL1

Piranha_Facing:
	.byte $00, SPR_HFLIP

Piranha_Velocities:
	.byte $F0, $10

Piranha_AttackProjectiles:
	.byte $00, SOBJ_FIREBALL, SOBJ_ICEBALL, SOBJ_ACID

Piranah_AttackNumbers:
	.byte $00, $01, $01, $01

ObjInit_Pumpkin:
	LDA <Objects_XZ, X
	ADD #$08
	STA <Objects_XZ, X
	RTS

ObjInit_Piranha_TwoShot:
	JSR ObjInit_Piranha

	INC Piranha_AttackCount, X
	RTS

ObjInit_Piranha:
	LDA #$03
	STA Piranha_CurrentState, X

	LDA #$02
	STA Piranha_AttackData, X

	LDA Objects_Property, X
	LSR A
	TAY

	LDA Piranah_AttackNumbers, Y
	STA Piranha_AttackCount, X

	LDA Objects_Property, X
	AND #$01
	TAY
	LDA Piranha_Velocities, Y
	STA <Objects_YVelZ, X

	LDA Piranha_Orientation, Y
	STA Objects_Orientation, X

ObjInit_Piranha1:
	LDA Objects_Property, X
	LSR A
	TAY
	LDA Piranha_Palettes, Y
	STA Objects_SpriteAttributes, X

	LDA #$20
	STA Objects_Timer, X


	LDA <Objects_XZ, X
	ADD #$08
	STA <Objects_XZ, X

	LDA <Objects_YZ, X
	SUB #$01
	STA <Objects_YZ, X

	LDA <Objects_YHiZ, X
	SBC #$00
	STA <Objects_YHiZ, X

	INC Piranha_CurrentFrame, X
	RTS

ObjNorm_Pumpkin:
	JMP ObjNorm_Piranha

ObjNorm_Piranha:

	LDA <Player_HaltGameZ
	BEQ ObjNorm_Piranha1

	JMP Piranha_Draw

ObjNorm_Piranha1:
	JSR Object_DeleteOffScreen
	JSR Object_CalcBoundBox
	JSR Object_AttackOrDefeat
	
	JSR Object_YDistanceFromPlayer

	JSR Piranha_DoState

	LDA Objects_Property, X
	CMP #$02
	BCC Piranha_Animate

	JSR Object_XDistanceFromPlayer
	
	LDA Objects_Orientation, X
	AND #~SPR_HFLIP
	ORA Piranha_Facing, Y
	STA Objects_Orientation, X

	LDA Piranha_CurrentState, X
	CMP #$01
	BNE Piranha_Animate

	LDA #$03
	STA Piranha_CurrentFrame, X
	BNE Piranha_Draw1

Piranha_Animate:
	INC Piranha_CurrentFrame, X
	LDA Piranha_CurrentFrame, X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

Piranha_Draw:
	LDA Objects_Property, X
	CMP #$02
	BCC Piranha_Draw1

	LDA Objects_Frame,X
	ORA #$02
	STA Objects_Frame,X

Piranha_Draw1:
	JSR Object_Draw16x32
	
	LDY Object_SpriteRAMOffset, X

	LDA Sprite_RAM + 10, Y
	AND #(SPR_VFLIP | SPR_BEHINDBG)
	ORA #SPR_PAL2
	STA Sprite_RAM + 10, Y
	ORA #SPR_HFLIP
	STA Sprite_RAM + 14, Y
	
	LDA Objects_Property, X
	CMP #$02
	BCS Piranha_DrawUpsideDown

	LDA Sprite_RAM + 6, Y
	ORA #SPR_HFLIP
	STA Sprite_RAM + 6, Y
	RTS

Piranha_HeadFlips:
	.byte SPR_VFLIP, $00

Piranha_DrawUpsideDown:
	JSR Object_YDistanceFromPlayer
	LDA Piranha_HeadFlips, Y
	STA TempA

	LDY Object_SpriteRAMOffset, X

	LDA Sprite_RAM + 2, Y
	AND #~SPR_VFLIP
	ORA TempA
	STA Sprite_RAM + 2, Y

	LDA Sprite_RAM + 6, Y
	AND #~SPR_VFLIP
	ORA TempA
	STA Sprite_RAM + 6, Y

Piranha_DrawUpsideDown1:
	RTS

Piranha_DoState:
	LDA Piranha_CurrentState, X
	JSR DynJump

	.word Piranha_Move
	.word Piranha_Attack
	.word Piranha_Move
	.word Piranha_Wait

Piranha_Wait:
	LDA Objects_Timer, X
	BNE Piranha_Wait2

	LDA Objects_Property, X
	AND #$01
	BNE Piranha_Wait1  

	JSR Object_XDistanceFromPlayer
	CMP #$18
	BCC Piranha_Wait2

Piranha_Wait1:
	LDA #$00
	STA Piranha_CurrentState, X
	LDA #$20
	STA Objects_Timer, X

Piranha_Wait2:
	RTS

Piranha_Move:	
	JSR Object_ApplyYVel_NoGravity

	LDA Objects_Timer, X
	BNE Piranha_Move1

	INC Piranha_CurrentState, X

	LDA <Objects_YVelZ, X
	EOR #$FF
	ADD #$01
	STA <Objects_YVelZ, X

	LDA #$40
	STA Objects_Timer, X

	LDA Piranha_AttackCount, X
	STA Piranha_AttacksLeft, X

Piranha_Move1:
	RTS

Piranha_Attack:

	LDA Objects_Timer, X
	BEQ Piranha_Attack1

	CMP #$20
	BNE Piranha_Attack2

	STA Debug_Snap
	LDA Piranha_AttacksLeft, X
	BEQ Piranha_Attack2

	LDA Objects_Property, X
	LSR A
	STA <Temp_Var15
	TAY

	LDA Piranha_AttackProjectiles, Y
	BEQ Piranha_Attack1

	LDA Objects_SpritesVerticallyOffScreen, X
	ORA Objects_SpritesHorizontallyOffScreen, X
	BNE Piranha_Attack1

	LDA #$08
	STA <Proj_YOff

	LDA Objects_Orientation, X
	AND #SPR_VFLIP
	BEQ Piranha_NoYOff

	LDA #$18
	STA <Proj_YOff

Piranha_NoYOff:

	LDA #$08
	STA <Proj_XOff

	JSR Object_PrepProjectile
	BCC Piranha_Attack1

	JSR Piranha_Projectile
	DEC Piranha_AttacksLeft, X
	BEQ Piranha_NoMoreAttacks

	LDA #$50
	STA Objects_Timer, X
	RTS

Piranha_NoMoreAttacks:
	LDA #$20
	STA Objects_Timer, X
	RTS

Piranha_Attack1:
	LDA #$20
	STA Objects_Timer, X
	
	INC Piranha_CurrentState, X

Piranha_Attack2:
	RTS

Piranha_Projectile:
	LDX <Temp_Var15
	LDA Piranha_AttackProjectiles, X
	STA SpecialObj_ID,Y

	LDX <CurrentObjectIndexZ

	LDA Piranha_AttackData, X
	STA SpecialObj_Data1,Y

	LDA #SND_PLAYERFIRE
	ORA Sound_QPlayer
	STA Sound_QPlayer

	LDA Palette_Buffer + $10 
	CMP #$0F
	BEQ ShootProjectile1 ; if dark, we aim blindly

	JSR Object_AimProjectile
	JMP ShootProjectile2

ShootProjectile1:
	JSR Object_AimProjectileRandom

ShootProjectile2:
	RTS

ObjInit_RockyWrench:
	INC Objects_Data1,X	 ; Var4 = 1 (keeps Rocky alive)

Rocky_FacePlayer:
	JSR Object_XDistanceFromPlayer

	; Set flip towards Player
	LDA RockyWrench_FlipBits,Y
	STA Objects_Orientation,X	

	RTS		 ; Return

	; Timer reload values for Rocky by his internal state
Rocky_TimerReload:
	.byte $00, $20, $16, $20, $20, $10

ObjNorm_RockyWrench:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG005_A9B1	 ; If Rocky's state is Normal, jump to PRG005_A9B1

	JMP Rocky_Draw	 ; Draw Rocky and don't come back!

PRG005_A9B1:

	; Set Rocky's priority
	LDA Objects_Orientation,X
	ORA #SPR_BEHINDBG
	STA Objects_Orientation,X

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	; Sprite RAM +8 (Two sprites over)
	LDA Object_SpriteRAMOffset,X
	ADD #$08
	STA Object_SpriteRAMOffset,X

	JSR Object_Draw ; Draw Rocky

	LDA Objects_Frame,X
	CMP #$01
	BNE PRG005_A9F7	 ; If frame <> 1, jump to PRG005_A9F7

	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE PRG005_A9F7	 ; If any of Rocky's sprites are off-screen, jump to PRG005_A9F7

	; Set Rocky's held wrench Y
	LDA <Objects_SpriteY,X
	SUB #$08
	STA Sprite_RAM-$08,Y

	LDA Objects_Orientation,X
	ASL A
	ASL A

	LDA #$00	; A = 0

	BCS PRG005_A9E7	 ; If Rocky is horizontally flipped, jump to PRG005_A9E7

	LDA #$08	; A = 8

PRG005_A9E7:

	; Offset Rocky's Wrench X
	ADD <Objects_SpriteX,X
	STA Sprite_RAM-$05,Y

	; Rocky's Wrench pattern
	LDA #$a1
	STA Sprite_RAM-$07,Y

	; Palette select 1
	LDA #SPR_PAL1
	STA Sprite_RAM-$06,Y

PRG005_A9F7:
	LDA <Player_HaltGameZ
	BNE PRG005_AA38	 ; If gameplay is halted, jump to PRG005_AA38

	JSR Rocky_KillOrStandOn	 ; Kill Rocky or stand on top of him

	LDA Objects_Data2,X	 ; Var5 is internal state

	JSR DynJump
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!! 

	.word Rocky_FaceAndPopup	; 0: After timer, Rocky pops up and faces Player
	.word Rocky_WaitTimer		; 1: Just waiting for timer to expire
	.word Rocky_RiseUp		; 2: Rocky rises up
	.word Rocky_ReadyThrowWrench	; 3: Gets ready to throw wrench
	.word Rocky_WrenchToss		; 4: Toss the wrench
	.word Rocky_DieOrWaitRevive	; 5: Rocky is dead if Var4 = 0, otherwise delay until revive
	.word Rocky_Killed		; 6: Rocky's killed state

Rocky_FaceAndPopup:
	LDA Objects_Timer,X	 
	BNE PRG005_AA38	 ; If timer not expired, jump to PRG005_AA38 (RTS)

	JSR Rocky_FacePlayer	 ; Rocky faces Player
 
	; Rocky "pops up" to look for Player
	LDA <Objects_YZ,X
	ADD #$08
	AND #$f0
	SUB #$06
	STA <Objects_YZ,X
	BCS Rocky_WaitTimer
	DEC <Objects_YHiZ,X	 ; Apply carry

	; Wait for timer to expire, go to next state, reload timer
Rocky_WaitTimer: 

	LDA Objects_Timer,X
	BNE PRG005_AA38	 ; If timer not expired, jump to PRG005_AA38 (RTS)

	INC Objects_Data2,X	 ; Var5++ (next internal state)

	LDY Objects_Data2,X	 
	LDA Rocky_TimerReload,Y	 ; Load timer value by internal state
	STA Objects_Timer,X	 ; Set timer

PRG005_AA38:
	RTS		 ; Return

Rocky_RiseUp:
	; Set frame 0 and advance state after timer expires
	LDA #$00	 
	JSR Rocky_UpdFrameAdvIntState

	LDA Objects_Timer,X
	LSR A
	BCS PRG005_AA4D	 ; Every other tick, jump to PRG005_AA4D (RTS)

	; Move up one pixel
	DEC <Objects_YZ,X
	LDY <Objects_YZ,X
	INY	
	BNE PRG005_AA4D
	DEC <Objects_YHiZ,X
PRG005_AA4D:

	RTS		 ; Return


Rocky_ReadyThrowWrench:
	LDA #$01 	; Ready to throw frame

Rocky_UpdFrameAdvIntState:
	STA Objects_Frame,X	  ; Update frame
	JMP Rocky_WaitTimer	 ; Wait for timer to expire and advance state afterward

Rocky_WrenchToss:

	; Set frame 2 (thrown wrench) and advance state after timer expires
	LDA #$02
	JSR Rocky_UpdFrameAdvIntState

	LDA Objects_Timer,X
	CMP #$1f
	BNE PRG005_AA65	 ; 1:32 ticks proceed, otherwise jump to PRG005_AA65

	JSR Rocky_ThrowWrench	 ; Throw Wrench 

PRG005_AA65:
	RTS		 ; Return

Rocky_DieOrWaitRevive:
	LDA Objects_Timer,X	  
	BNE PRG005_AA7F	 ; If timer not expired, jump to PRG005_AA7F

	LDA Objects_Data1,X
	BNE PRG005_AA75	 ; If Var4 <> 0 (Rocky will come back, otherwise he's gone forever), jump to PRG005_AA75

	; Set Rocky's state to Dead/Empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

PRG005_AA75:
	; Go back to initial internal state
	LDA #$00
	STA Objects_Data2,X

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

	RTS		 ; Return

PRG005_AA7F:

	; +1 to Rocky's Y
	INC <Objects_YZ,X
	BNE PRG005_AA85	
	INC <Objects_YHiZ,X
PRG005_AA85:

	; Frame = 0
	LDA #$00
	STA Objects_Frame,X

	RTS		 ; Return

Rocky_Killed:
	LDA Objects_Timer,X	  
	BNE PRG005_AA96	 ; If timer not expired, jump to PRG005_AA96

	
	LDA Player_Equip
	CMP #$09
	BNE Dont_Coin_It10
	INC Coins_Earned ; One more coin earned
	LDA Objects_YZ, X
	CLC
	ADC #$08
	STA <Temp_Var1
	LDA Objects_XZ, X
	STA <Temp_Var2
	JSR Produce_Coin

Dont_Coin_It10:
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	RTS		 ; Return

PRG005_AA96:

	; Set frame to 3
	LDA #$03
	STA Objects_Frame,X

	RTS		 ; Return

Rocky_KillOrStandOn:
	LDA Objects_Data2,X
	CMP #$06
	BEQ PRG005_AAE8	 ; If Var5 = 6, jump to PRG005_AAE8 (RTS)

	JSR Object_InteractWithPlayer

	LDA Objects_PlayerHitStat,X
	BEQ PRG005_AAE8	; If Player has not collided with Rocky, jump to PRG005_AAE8

	LDA <Player_YVel
	BMI PRG005_AAE8	 ; If Player is moving upward, jump to PRG005_AAE8 (RTS)

	CMP #$10
	BGE PRG005_AACA	 ; If Player is falling faster than $10, jump to PRG005_AACA

	; Player not falling fast enough; stand on top of Rocky

	; Flag Player as not mid-air
	LDA #$00
	STA <Player_InAir

	; Set Player at Rocky's Y - 31
	LDA <Objects_YZ,X
	SUB #31
	STA <Player_Y
	LDA <Objects_YHiZ,X
	SBC #$00
	STA <Player_YHi

	RTS		 ; Return

PRG005_AACA:

	; Rocky got stepped on!

	; Var5 = 6
	LDA #$06
	STA Objects_Data2,X

	; Timer = $0C
	LDA #$0c
	STA Objects_Timer,X

	; Bounce Rocky a bit
	LDA #-$30
	STA <Player_YVel

	; Kill sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer


PRG005_AAE8:
	RTS		 ; Return

Rocky_WrenchYVel:	.byte $00, -$10, -$20, -$10, $00, -$10, -$20, -$10

Rocky_ThrowWrench:

	; Rocky's wrench throw

	JSR SpecialObject_FindEmptyAbort	 ; Find an empty special object slot or don't come back!

	; Set Wrench at Rocky's Y - 8
	LDA <Objects_YZ,X
	SUB #$08
	STA SpecialObj_Y,Y
	LDA <Objects_YHiZ,X
	SBC #$00
	STA SpecialObj_YHi,Y

	LDA <Objects_XZ,X
	STA SpecialObj_X,Y

	LDA Level_AScrlHVel
	CMP #$0e

	LDA #$10	; A = $10 (horizontal velocity < $0E)

	BLT PRG005_AB13		; If autoscroll horizontal velocity < $0E, jump to PRG005_AB13

	LDA #$18	; A = $18 (otherwise)

PRG005_AB13:
	STA <Temp_Var3		 ; -> Temp_Var3

	LDA Objects_Orientation,X
	ASL A
	ASL A

	STY <Temp_Var1	 ; Special object slot index -> Temp_Var1

	LDA <Temp_Var3
	BCS PRG005_AB22	 ; If Rocky is horizontally flipped, jump to PRG005_AB22

	LDA #-$10

PRG005_AB22:
	STA SpecialObj_XVel,Y	 ; Set appropriate X velocity of wrench

	LDA RandomN,X
	AND #$07
	TAY		 ; Y = 0 to 7, random

	; Set Rocky's Wrench Y Velocity
	LDA Rocky_WrenchYVel,Y
	LDY <Temp_Var1	
	STA SpecialObj_YVel,Y

	; Rocky's Wrench ID
	LDA #SOBJ_WRENCH
	STA SpecialObj_ID,Y

	RTS		 ; Return

Rocky_Draw:
	LDY #$02	 ; Y = 2

	LDA Game_Counter
	AND #$10
	BEQ PRG005_AB43	 ; 16 ticks on, 16 ticks off; jump to PRG005_AB43

	INY		 ; Y = 3

PRG005_AB43:
	TYA		 ; A = 2 or 3

	STA Objects_Frame,X	 ; Set frame to 2 or 3

	; Set Rocky's priority
	LDA #SPR_BEHINDBG
	STA Objects_Orientation,X

	JMP Object_DrawTallAndHFlip	 ; Draw Rocky and don't come back!

ObjInit_BoltLift:

	; Set at Y - 1
	LDA <Objects_YZ,X
	SUB #$01
	STA <Objects_YZ,X
	LDA <Objects_YHiZ,X
	SBC #$00
	STA <Objects_YHiZ,X

PRG005_AB5C:
	RTS		 ; Return

PRG005_AB5D:	.byte $60, $70, $80, $90, $A0, $B0, $C0, $D0

ObjNorm_BoltLift:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR Object_Draw 	; Draw left half of bolt lift

	LDA Objects_SpritesHorizontallyOffScreen,X
	PHA		 ; Save horizontal visibility bits

	; Shift over visibility to draw second half
	ASL A
	ASL A
	STA Objects_SpritesHorizontallyOffScreen,X

	LDA <Objects_XZ,X
	PHA		 	; Save object X
	ADD #16
	STA <Objects_XZ,X 	; Add 16 to bolt lift's X

	LDA <Objects_XHiZ,X
	PHA			; Save object X Hi
	ADC #$00
	STA <Objects_XHiZ,X 	; Apply carry

	; Two sprites over
	LDA Object_SpriteRAMOffset,X
	ADD #$08
	STA Object_SpriteRAMOffset,X

	JSR Object_Draw ; Draw right half of bolt lift

	; Restore XHi / X / horizontal visibility bits
	PLA
	STA <Objects_XHiZ,X
	PLA
	STA <Objects_XZ,X
	PLA
	STA Objects_SpritesHorizontallyOffScreen,X

	JSR Object_CalcSpriteXY_NoHi

	LDA <Player_HaltGameZ
	BNE PRG005_AB5C	 ; If gameplay is halted, jump to PRG005_AB5C

	LDA <Objects_XVelZ,X
	BEQ PRG005_ABC9	 ; If bolt lift is not moving horizontally, jump to PRG005_ABC9
	BPL PRG005_ABA9	 ; If bolt lift is moving to the right, jump to PRG005_ABA9

	JSR Negate	 ; Otherwise, negate the X velocity (absolute velocity)

PRG005_ABA9:
	ASL A
	ASL A
	ASL A
	ASL A		 	; Divide absolute value of X velocity by 16
	ADC #$60	 	; A = $60 to $6F
	ADC Objects_Data3,X	; Add Var7
	STA Objects_Data3,X	; -> Var7

	BCC PRG005_ABC9	 	; If no overflow, jump to PRG005_ABC9

	LDA <Objects_XVelZ,X
	ASL A

	LDA #$01	 ; A = 1
	BCC PRG005_ABC0	 ; If X velocity is not negative, jump to PRG005_ABC0
	LDA #-$01	 ; A = -1 

PRG005_ABC0:
	ADD Objects_Frame,X	; Add current frame value
	AND #$03	 	; Modulus 3 (frame capped into 0 to 3)
	STA Objects_Frame,X	; -> Frame

PRG005_ABC9:
	LDA Objects_Data2,X
	BEQ PRG005_ABD0	 ; If Var5 = 0, jump to PRG005_ABD0

	JMP PRG005_AC57	 ; Jump to PRG005_AC57 (indirect to Object_Move)

PRG005_ABD0:
	LDA <Counter_1
	AND #$07
	BNE PRG005_ABE2	 ; 1:8 ticks proceed, otherwise jump to PRG005_ABE2

	LDA <Objects_XVelZ,X
	BEQ PRG005_ABE2	 ; If bolt is not moving horizontally, jump to PRG005_ABE2
	BPL PRG005_ABE0	 ; If bolt is moving to the right, jump to PRG005_ABE0

	; Bolt moving to the left; slow down
	INC <Objects_XVelZ,X
	INC <Objects_XVelZ,X	; This is just to overcome the DEC that follows, so really only one INC

PRG005_ABE0:

	; Bolt moving to the right; slow down
	DEC <Objects_XVelZ,X

PRG005_ABE2:
	JSR Bolt_CheckOnThread	 ; Checks if bolt is on thread tile; if not, Var5 = 1

	JSR Object_WorldDetectN1
	;LDA Object_TileWallValue
	CMP #TILE10_BOLT_H
	BNE PRG005_ABF5	 	; If bolt has not hit thread end tile, jump to PRG005_ABF5

	; Bolt hit thread end, halt horizontal movement
	LDA #$00
	STA <Objects_XVelZ,X

	INC <Objects_TilesDetectZ,X	 ; DetStat++ (bad use of this var :P)

PRG005_ABF5:
	JSR Bolt_ToBoltCollide	; Bolt-to-bolt intersection response

	JSR Object_ApplyXVel	; Apply X velocity

	LDA <Objects_XVelZ,X
	BEQ PRG005_AC04	 	; If bolt is not moving horizontally, jump to PRG005_AC04

	LDA Objects_Timer,X
	BNE PRG005_AC56	 	; If timer not expired, jump to PRG005_AC56 (RTS)

PRG005_AC04:
	JSR Object_CalcSpriteXY_NoHi

	JSR Object_HitTest
	BCC PRG005_AC56	 	; If Player isn't touching bolt, jump to PRG005_AC56 (RTS)

	LDA <Player_SpriteY
	ADC #23
	CMP <Objects_SpriteY,X
	BGE PRG005_AC36	 	; If Player is lower than the top of bolt, jump to PRG005_AC36

	LDA <Player_YVel
	BMI PRG005_AC35		; If Player is moving upward, jump to PRG005_AC35 (RTS)

	LDA <Objects_TilesDetectZ,X	; Bad use of this var
	BNE PRG005_AC20	 	; If bolt hit end of thread, jump to PRG005_AC20

	; Bolt moves to the right
	LDA #$05
	STA <Objects_XVelZ,X

PRG005_AC20:

	LDA #$10
	STA Objects_Timer,X	; Set timer to $10
	STA Player_AllowAirJump	; Lets Player jump off bolt

	LDA #$00
	STA <Player_YVel	; Halt Player's vertical movement
	STA <Player_InAir	; Flag Player as not mid-air

	; Set Player to top of bolt
	LDA <Objects_YZ,X
	SUB #30
	STA <Player_Y

PRG005_AC35:
	RTS		 ; Return

PRG005_AC36:
	LDA #-4		; A = -4

	LDY <Player_Suit
	BNE PRG005_AC3E	 ; If Player is not small, jump to PRG005_AC3E

	LDA #12	 	; A = 12

PRG005_AC3E:
	ADD <Player_SpriteY	; Offset Player Y
	CMP <Objects_SpriteY,X
	BLT PRG005_AC52		; If Player is not hitting head off bolt, jump to PRG005_AC52

	LDA <Player_YVel
	BPL PRG005_AC51	 ; If Player is moving downard, jump to PRG005_AC51 (RTS)
	
	; Move bolt backward
	LDA #-$05
	STA <Objects_XVelZ,X

	; Player bumped head off bolt!
	LDA #$10
	STA <Player_YVel

PRG005_AC51:
	RTS		 ; Return

PRG005_AC52:

	; Halt horizontal movement
	LDA #$00
	STA <Player_XVel

PRG005_AC56:
	RTS		 ; Return

PRG005_AC57:
	JMP Object_Move	; Do standard movements and don't come back!

Bolt_CheckOnThread:
	LDA #-30	 ; A = -30 (X offset for bolt moving to the right)

	LDY <Objects_XVelZ,X
	BEQ PRG005_AC93	 ; If bolt is not moving horizontally, jump to PRG005_AC93
	BPL PRG005_AC64	 ; If bolt is moving to the right, jump to PRG005_AC64

	LDA #30		 ; A = 30 (X offset for bolt moving to the left)

PRG005_AC64:
	LDY #$00	 ; Y = $00 (16-bit sign extension)
	CMP #$00
	BGS PRG005_AC6B	 ; If decided value is non-negative ($1E), jump to PRG005_AC6B
	DEY		 ; Y = $FF (16-bit sign extension)

PRG005_AC6B:
	STA <Temp_Var1	 ; A = -30 or 30

	LDA <Objects_XZ,X
	PHA		 ; Save bolt's X
	ADD <Temp_Var1	 ; Add decided value
	STA <Objects_XZ,X ; -> bolt's X

	LDA <Objects_XHiZ,X
	PHA		 ; Save bolt's X Hi
	TYA		 ; sign extension -> 'A'
	ADC <Objects_XHiZ,X	 ; Apply sign
	STA <Objects_XHiZ,X	 ; -> X Hi

	JSR Object_WorldDetectN1

	; Restore X/Hi
	PLA
	STA <Objects_XHiZ,X
	PLA
	STA <Objects_XZ,X

	;LDA Object_TileWallValue
	CMP #TILE10_BOLT_H
	BEQ PRG005_AC93	 ; If bolt lift has hit a thread end tile, jump to PRG005_AC93

	CMP #TILE10_THREAD_H
	BEQ PRG005_AC93	 ; If bolt lift is running along the thread, jump to PRG005_AC93

	; Bolt is run into the end
	INC Objects_Data2,X	 ; Var5 = 1

PRG005_AC93:
	RTS		 ; Return

Bolt_ToBoltCollide:
	LDA Objects_SpritesVerticallyOffScreen,X 
	BNE PRG005_AD06	 ; If any sprite of the bolt is vertically off-screen, jump to PRG005_AD06 (RTS)

	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG005_AD06	 ; If left two sprites are off-screen, jump to PRG005_AD06 (RTS)

	;JSR Object_CalcBoundBox2
	TXA
	BEQ PRG005_AD06	 ; If this is object slot 0, jump to PRG005_AD06 (RTS)

	DEX		 ; X-- (consider previous object)

PRG005_ACA9:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG005_AD01	 ; If state is not Normal, jump to PRG005_AD01 (skip this object)

	LDA Objects_ID,X
	CMP #OBJ_BOLTLIFT
	BNE PRG005_AD01	 ; If this is not another bolt lift, jump to PRG005_AD01 (skip this object)

	LDA Objects_SpritesVerticallyOffScreen,X
	BNE PRG005_AD01	 ; If this other bolt is vertically off-screen, jump to PRG005_AD01 (skip this object)

	LDA Objects_SpritesHorizontallyOffScreen,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG005_AD01	 ; If this other bolt is horizontally off-screen, jump to PRG005_AD01 (skip this object)

	JSR Object_CalcSpriteXY_NoHi
	;JSR Object_CalcBoundBox
	JSR ObjectObject_Intersect
	BCC PRG005_AD01	 ; If the two bolts are colliding with eachother, jump to PRG005_AD01 (skip this object)

	LDY <CurrentObjectIndexZ	 ; Y = current bolt's object slot index

	LDA <Objects_XZ,X
	SUB Objects_XZ,Y
	PHA		 ; Save X difference of two bolts

	LDA <Objects_XHiZ,X
	SBC Objects_XHiZ,Y
	STA <Temp_Var1	 ; Temp_Var1 = difference of X His

	ROL <Temp_Var2	 ; Pushes sign bit

	PLA		 ; Restore X difference

	ADC #$80
	LDA <Temp_Var1
	ADC #$00
	BNE PRG005_AD01	 ; If bolts haven't hit, jump to PRG005_AD01 (skip this object)

	LSR <Temp_Var2

	LDA #-$01	 ; A = -$01
	BCS PRG005_ACF3	 

	LDA #$01	 ; A = $01

PRG005_ACF3:

	STX <Temp_Var16		 ; Backup this other bolt's index

	LDX <CurrentObjectIndexZ	 ; X = original bolt object slot index
	STA <Objects_XVelZ,X	 ; Set this bolt's X velocity

	PHA		 ; ?? doesn't do anything useful (see immediately below)

	LDX <Temp_Var16	 ; Restore this other bolt's index 

	PLA		 ; ?? doesn't do anything useful (see immediately above)

	EOR #$ff	 ; The opposite value 

	STA <Objects_XVelZ,X	 ; Store opposing value into the other bolt

PRG005_AD01:
	DEX		 ; X-- (previous object)
	BPL PRG005_ACA9	 ; While X >= 0, loop!

	LDX <CurrentObjectIndexZ		 ; X = object slot index

PRG005_AD06:
ObjInit_Sun:
	LDA DayNight
	EOR #$FF
	STA Objects_Data4, X
	RTS		 ; Return

SunMoonPalette:
	.byte SPR_PAL3, SPR_PAL1

SunMoonDayEnemies:
	.byte OBJ_GOOMBA, OBJ_PARAGOOMBA, OBJ_PIRANHA, OBJ_GREENTROOPA,  OBJ_BEACHEDCHEEP, OBJ_PUMPKINFREE

SunMoonDayEnemyPals:
	.byte SPR_PAL3, SPR_PAL3, SPR_PAL1, SPR_PAL2, SPR_PAL1, SPR_PAL2

SunMoonDayEnemyStates:
	.byte OBJSTATE_INIT, OBJSTATE_NORMAL, OBJSTATE_NORMAL, OBJSTATE_INIT, OBJSTATE_INIT,  OBJSTATE_POOFDEATH

SunMoonNightEnemies:
	.byte OBJ_ZOMBIEGOOMBA, OBJ_PARAZOMBIEGOOMBA, OBJ_PUMPKINPLANT, OBJ_DRYBONES, OBJ_SPECTERCHEEP, OBJ_PUMPKINFREE

SunMoonNightEnemyPals:
	.byte SPR_PAL2, SPR_PAL3, SPR_PAL3, SPR_PAL2, SPR_PAL2, SPR_PAL2

SunMoonNightEnemyStates:
	.byte OBJSTATE_NORMAL, OBJSTATE_NORMAL, OBJSTATE_NORMAL, OBJSTATE_INIT, OBJSTATE_NORMAL, OBJSTATE_POOFDEATH

SunMoonGraphics:
	.byte $7C, $00, $7E
	
ObjNorm_Sun:
	
	LDA <Player_HaltGameZ
	BEQ ObjNorm_Sun0
	JMP DrawSunMoon

ObjNorm_Sun0:
	LDA DayNight
	BMI ObjNorm_Sun0_1

	JSR ToDayEnemies
	JMP ObjNorm_Sun0_2

ObjNorm_Sun0_1:
	JSR ToNightEnemies

ObjNorm_Sun0_2:
	JSR Object_InteractWithPlayer
	INC Game_Timer_Tick
	INC Game_Timer_Tick
	INC Game_Timer_Tick
	INC Game_Timer_Tick
	INC Game_Timer_Tick
	CLC
	LDA #$00
	STA TempA
	LDY DayNightTicker
	BEQ ObjNorm_Sun3

ObjNorm_Sun2:
	LDA #$14
	ADC TempA
	STA TempA
	DEY
	BNE ObjNorm_Sun2

ObjNorm_Sun3:
	LDY DayNightMicroTicker
	BEQ ObjNorm_Sun5

ObjNorm_Sun4:
	LDA #$02
	ADC TempA
	STA TempA
	DEY
	BNE ObjNorm_Sun4

ObjNorm_Sun5:
	LDA Game_Timer_Tick
	CMP #$1E
	BCC ObjNorm_Sun6

	INC TempA

ObjNorm_Sun6:
	LDA <Horz_Scroll
	SUB #$04
	STA <Temp_Var1
	LDA <Horz_Scroll_Hi
	SBC #$00
	STA <Temp_Var2
	LDA <Temp_Var1
	ADC TempA
	STA <Objects_XZ,X
	LDA #$00
	ADC <Temp_Var2
	STA <Objects_XHiZ, X

	LDA <Vert_Scroll
	ADD #$00
	STA <Objects_YZ, X
	LDA <Vert_Scroll_Hi
	ADC #$00
	STA <Objects_YHiZ, X

DrawSunMoon:
	LDY #$00
	LDA DayNight
	BEQ DrawSunMoon1

	INY

DrawSunMoon1:
	LDA SunMoonPalette, Y
	ORA #SPR_BEHINDBG
	STA Objects_SpriteAttributes, X
	TYA
	STA Objects_Frame, X

	LDA #LOW(ObjPAF)
	STA <Temp_Var10
	LDA #HIGH(ObjPAF)
	STA <Temp_Var11

	JMP DrawGiantObjectMirrored

ToNightEnemies:
	LDX #$04

ToNightEnemies1:
	LDA Objects_State, X
	BEQ ToNightEnemies4

	CMP #OBJSTATE_NORMAL
	BCC ToNightEnemies2

	CMP #OBJSTATE_KILLED
	BCS ToNightEnemies4

	CMP #OBJSTATE_HELD
	BCC ToNightEnemies3

ToNightEnemies2:
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State, X

	LDA #$1f
	STA Objects_Timer,X
	BNE ToNightEnemies4

ToNightEnemies3:
	LDY #$04

ToNightEnemies3_0:
	LDA Objects_ID, X
	CMP SunMoonDayEnemies, Y
	BNE ToNightEnemies3_1

	LDA SunMoonNightEnemies, Y
	STA Objects_ID, X

	LDA SunMoonNightEnemyStates, Y
	STA Objects_State, X

	LDA SunMoonNightEnemyPals, Y
	STA Objects_SpriteAttributes, X
	BNE ToNightEnemies4

ToNightEnemies3_1:
	DEY
	BPL ToNightEnemies3_0

ToNightEnemies4:
	DEX
	BPL ToNightEnemies1
	LDX <CurrentObjectIndexZ
	RTS

ToDayEnemies:
	LDX #$04

ToDayEnemies1:
	LDA Objects_State, X
	BEQ ToDayEnemies4

	CMP #OBJSTATE_NORMAL
	BCC ToDayEnemies2

	CMP #OBJSTATE_KILLED
	BCS ToDayEnemies4

ToDayEnemies2:
ToDayEnemies3:
	LDY #$05

ToDayEnemies3_0:
	LDA Objects_ID, X
	CMP SunMoonNightEnemies, Y
	BNE ToDayEnemies3_1

	LDA SunMoonDayEnemies, Y
	STA Objects_ID, X

	LDA SunMoonDayEnemyStates, Y
	STA Objects_State, X

	CMP #OBJSTATE_POOFDEATH
	BNE ToDayEnemies3_1_1

	LDA #$1F
	STA Objects_Timer, X

ToDayEnemies3_1_1:

	LDA SunMoonDayEnemyPals, Y
	STA Objects_SpriteAttributes, X 
	BNE ToDayEnemies4

ToDayEnemies3_1:
	DEY
	BPL ToDayEnemies3_0

ToDayEnemies4:
	DEX
	BPL ToDayEnemies1
	LDX <CurrentObjectIndexZ
	RTS

ArrowPlat_XVel:
	.byte  $00	; Platform Type 0 (Up)
	.byte -$08	; Platform Type 1 (Left)
	.byte  $00	; Platform Type 2 (Up)
	.byte  $08	; Platform Type 3 (Right)

ArrowPlat_YVel:
	.byte -$08	; Platform Type 0 (Up)
	.byte  $00	; Platform Type 1 (Left)
	.byte -$08	; Platform Type 2 (Up)
	.byte  $00	; Platform Type 3 (Right)

ObjNorm_ArrowPlatform:
	RTS
ArrowPlat_Draw:
	RTS		 ; Return

ArrowPlat_CheckWorldCollide:
	RTS		 ; Return

Parabeetle_FlipByXVel:
	LDA #$00	 ; A = $00 (no flip)

	LDY <Objects_XVelZ,X
	BMI PRG005_B0E7	 ; If Parabeetle is moving to the left, jump to PRG005_B0E7

	LDA #SPR_HFLIP	 ; Otherwise, A = SPR_HFLIP (horizontal flip)

PRG005_B0E7:
	STA Objects_Orientation,X	 ; Set flip

	RTS		 ; Return

ParaBeetle_XVelTowardsPlayer:	.byte $08, -$08

ObjInit_ParaBeetle:
	JSR Object_XDistanceFromPlayer

	; Start out flying towards Player
	LDA ParaBeetle_XVelTowardsPlayer,Y
	STA <Objects_XVelZ,X

PRG005_B0F5:
	RTS		 ; Return


ObjNorm_ParaBeetle:
	LDA <Objects_XVelZ,X
	BPL PRG005_B0FD	 ; If Parabeetle is not moving to the left, jump to PRG005_B0FD

	JSR Negate	 ; Negate X velocity (get absolute value)

PRG005_B0FD:
	CMP #$10

	LDA #SPR_PAL1	 ; A = 1 (palette select 1 for "slow" Parabeetles)

	BLT PRG005_B105	 ; If absolute value of X velocity < $10, jump to PRG005_B105

	ADC #$00	 ; A = 2 (palette select 2 for "fast" Parabeetles) (ADC's is an unclear way to get A = 2 :P) 

PRG005_B105:
	STA Objects_SpriteAttributes,X	 ; Set sprite attribute

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Parabeetle_FlipByXVel	 ; Face correct direction based on travel

	; Toggle frame 0/1
	LDA Objects_Data3,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_Draw ; Draw Parabeetle

	LDA <Player_HaltGameZ
	BNE PRG005_B0F5	 ; If gameplay halted, jump to PRG005_B0F5 (RTS)

	INC Objects_Data3,X	 ; Var3++

	JSR Object_ApplyYVel_NoGravity	 ; Apply Y velocity
	JSR Object_ApplyXVel	 	; Apply X velocity

	; Temp_VarNP0 = Player hit status bits (previous frame's detection status)
	LDA Objects_PlayerHitStat,X
	STA Temp_VarNP0	

	; I'm not sure the reason for the modification of "Kill_Tally" here...
	; Maybe at one time this was just another stompable enemy?

	JSR Object_AttackOrDefeat	 ; Do Player to Parabeetle hit detection


	LDA Objects_PlayerHitStat,X
	BEQ PRG005_B1A8	 ; If no collision, jump to PRG005_B1A8

	CMP Temp_VarNP0	
	BEQ PRG005_B14C	 ; If detection status hasn't changed from last frame, jump to PRG005_B14C

	LDA #$0C

	LDY <Player_Suit
	BEQ PRG005_B14A	 ; If Player is small, jump to PRG005_B14A

	LDA #$14	; Parabeetle moves down further for non-small Player

PRG005_B14A:
	STA <Objects_YVelZ,X	 ; Set Y velocity as appropriate

PRG005_B14C:

	; Var3 += 2
	INC Objects_Data3,X
	INC Objects_Data3,X

	LDA #-$0C

	LDY <Player_Suit
	BNE PRG005_B15A	 ; If Player is NOT small, jump to PRG005_B15A

	LDA #-$10	; Parabeetle can go upward faster if Player is small

PRG005_B15A
	CMP <Objects_YVelZ,X
	BGS PRG005_B162	 ; If Parabeetle is at his limit, jump to PRG005_B162

	; Accelerate upward!
	DEC <Objects_YVelZ,X
	DEC <Objects_YVelZ,X	; Double decrement to overcome the INC below

PRG005_B162:
	INC <Objects_YVelZ,X	; Parabeetle starts to droop

	; Let's Player jump off Parabeetle 
	LDA #$05
	STA Player_AllowAirJump

	LDA <Player_YVel
	BMI PRG005_B1A7	 ; If Player is moving upward, jump to PRG005_B1A7 (RTS)

	LDY #$00	 ; Y = $00 (16-bit sign extension)

	LDA Object_VelCarry
	BPL PRG005_B175	 ; If there's not a negative carry from X velocity, jump to PRG005_B175

	DEY		 ; Y = $FF (16-bit sign extension)

PRG005_B175:
	ADD <Player_X	; Offset Player's X
	STA <Player_X	; Set it!

	; Carry to X Hi
	TYA
	ADC <Player_XHi
	STA <Player_XHi

	; Set Player at Parabeetle Y - 27
	LDA <Objects_YZ,X
	SUB #27
	STA <Player_Y
	LDA <Objects_YHiZ,X
	SBC #$00
	STA <Player_YHi

	; Clear Player's Y velocity and "in air" flags
	LDA #$00
	STA <Player_YVel
	STA <Player_InAir

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG005_B1A7	 ; If Player is not pressing left or right, jump to PRG005_B1A7 (RTS)

	JSR Fish_FixedYIfAppro	 ; ?? Also a strange thing to call, would align parabeetles with the vertical scroll in a raster-effect

	LDA <Player_XVel
	BEQ PRG005_B1A7	 ; If Player's X Velocity = 0, jump to PRG005_B1A7 (RTS)

	BPL PRG005_B1A5	 ; If Player's X Velocity is positive, jump to PRG005_B1A5

	; Negative Player velocity...

	; Double INC to overcome the DEC
	INC <Player_XVel
	INC <Player_XVel

PRG005_B1A5:
	DEC <Player_XVel

PRG005_B1A7:
	RTS		 ; Return

PRG005_B1A8:
	LDA <Objects_YVelZ,X
	BEQ PRG005_B1B4	 ; If Parabeetle's Y Velocity = 0, jump to PRG005_B1B4 (RTS)

	BPL PRG005_B1B2	 ; If Parabeetle's Y Velocity is positive, jump to PRG005_B1B2

	; Negative Parabeetle velocity...

	; Double INC to overcome the DEC
	INC <Objects_YVelZ,X
	INC <Objects_YVelZ,X

PRG005_B1B2:
	DEC <Objects_YVelZ,X

PRG005_B1B4:
	RTS


ObjInit_ProjBar:
	LDA Objects_XZ, X
	ADD #$04
	STA Objects_XZ, X
	LDA Objects_Property, X
	AND #$01
	STA Objects_Data5, X
	LDA Objects_Property, X
	LSR A
	AND #01
	STA Objects_Data4, X
	LDA Objects_Property, X
	AND #$04
	BEQ Init_ProjBarRTS
	LDA #$40
	STA Objects_Data3, X

Init_ProjBarRTS:
	RTS

BarTiles:
	.byte $65, $59

BarPalette:
	.byte $01, $02

RadialTable:
	.byte 08, 16, 24, 32
	.byte 08, 15, 23, 31
	.byte 07, 14, 22, 29
	.byte 07, 13, 20, 26
	.byte 05, 11, 17, 23
	.byte 04, 07, 13, 17
	.byte 03, 06, 09, 12
	.byte 01, 03, 04, 06

RadialTableY:
	.byte 00, 00, 00, 00
	.byte -01, -03, -04, -06
	.byte -03, -06, -09, -12
	.byte -04, -07, -13, -17
	.byte -05, -11, -17, -23
	.byte -07, -13, -20, -26
	.byte -07, -14, -22, -29
	.byte -08, -15, -23, -31
	.byte -08, -16, -24, -32
	.byte -08, -15, -23, -31
	.byte -07, -14, -22, -29
	.byte -07, -13, -20, -26
	.byte -05, -11, -17, -23
	.byte -04, -07, -13, -17
	.byte -03, -06, -09, -12
	.byte -01, -03, -04, -06
	.byte 00, 00, 00, 00
	.byte 01, 03, 04, 06
	.byte 03, 06, 09, 12
	.byte 04, 07, 13, 17
	.byte 05, 11, 17, 23
	.byte 07, 13, 20, 26
	.byte 07, 14, 22, 29
	.byte 08, 15, 23, 31
	.byte 08, 16, 24, 32
	.byte 08, 15, 23, 31
	.byte 07, 14, 22, 29
	.byte 07, 13, 20, 26
	.byte 05, 11, 17, 23
	.byte 04, 07, 13, 17
	.byte 03, 06, 09, 12
	.byte 01, 03, 04, 06

ObjNorm_ProjectileBarCW:
	JSR Object_DeleteOffScreen
	LDA <Player_HaltGameZ
	BNE DoBarBar
	LDA Objects_Property, X
	AND #$01
	BEQ DecBar
	INC Objects_Data3, X
	JMP DoBarBar

DecBar:
	DEC Objects_Data3, X

DoBarBar:
	LDY #$08
	JSR Object_DetermineVerticallyOffScreen
	LDY #$08
	JSR Object_DetermineHorizontallyOffScreen

DoPBarDraw:
	LDA Objects_SpritesVerticallyOffScreen, X
	ORA Objects_SpritesHorizontallyOffScreen, X
	BEQ DrawPBar
	RTS

DrawPBar:
	LDA Objects_XZ, X
	STA DAIZ_TEMP1
	STA PBarHitTestX
	LDA Objects_YZ, X
	STA DAIZ_TEMP2
	STA PBarHitTestY
	JSR Object_CalcSpriteXY_NoHi
	LDY Object_SpriteRAMOffset, X
	LDA Objects_Data4, X
	TAX
	LDA BarTiles, X
	STA Sprite_RAM + 1, Y
	STA Sprite_RAM + 5, Y
	STA Sprite_RAM + 9, Y
	STA Sprite_RAM + 13, Y
	STA Sprite_RAM + 17, Y
	LDA BarPalette, X
	STA Sprite_RAM + 2, Y
	STA Sprite_RAM + 6, Y
	STA Sprite_RAM + 10, Y
	STA Sprite_RAM + 14, Y
	STA Sprite_RAM + 18, Y
	LDX <CurrentObjectIndexZ

	LDA Objects_Data3, X
	AND #$7C
	STA TempX
	LDX <CurrentObjectIndexZ

DrawProjectileBar:
	LDA <Objects_SpriteX, X
	STA Sprite_RAM + 3, Y
	STA TempA
	LDA <Objects_SpriteY, X
	STA Sprite_RAM , Y
	LDA #$03
	STA TempY
	
SetXOffset:
	LDX TempX
	LDA RadialTable, X
	BPL DoXOffsetAdd
	EOR #$FF
	ADD #$01
	STA <Temp_Var1
	LDA DAIZ_TEMP1
	SUB <Temp_Var1
	LDX TempY
	STA PBarHitTestX + 1, X
	LDA TempA
	SUB <Temp_Var1
	BCS StoreXOffset
	LDA #$00
	BEQ StoreXOffset

DoXOffsetAdd:
	PHA
	ADD DAIZ_TEMP1
	LDX TempY
	STA PBarHitTestX + 1, X
	PLA
	ADD TempA
	BCC StoreXOffset
	LDA #$00

StoreXOffset:
	STA Sprite_RAM +  7, Y
	INC TempX
	INY
	INY
	INY
	INY
	DEC TempY
	BPL SetXOffset

	LDA TempX
	SUB #$04
	STA TempX
	
	LDX <CurrentObjectIndexZ
	LDA <Objects_SpriteY, X
	LDY Object_SpriteRAMOffset, X
	STA Sprite_RAM , Y
	STA TempA
	LDA #$03
	STA TempY
	
SetYOffset:
	LDX TempX
	LDA RadialTableY, X
	BPL DoYOffsetAdd
	EOR #$FF
	ADD #$01
	STA <Temp_Var1
	LDA DAIZ_TEMP2
	SUB <Temp_Var1
	LDX TempY
	STA PBarHitTestY + 1, X
	LDA TempA
	SUB <Temp_Var1
	BCS StoreYOffset
	LDA #$F8
	BEQ StoreYOffset

DoYOffsetAdd:
	PHA
	ADD DAIZ_TEMP2
	LDX TempY
	STA PBarHitTestY + 1, X
	PLA
	ADD TempA
	BCC StoreYOffset
	LDA #$F8

StoreYOffset:
	STA Sprite_RAM +  4, Y
	INC TempX
	INY
	INY
	INY
	INY
	DEC TempY 
	BPL SetYOffset

	LDA TempX
	SUB #$04
	STA TempX
	LDX #$04

CheckColide:
	STX TempX
	JSR ProjectileBarCollide
	LDX TempX
	DEX
	BPL CheckColide
	LDX CurrentObjectIndexZ
	RTS
		
ObjNorm_ProjectileBarCCW:

	RTS		 ; Return


	; Bit set per Big ? Block within the world; they can only be opened once!!

ObjInit_Dimmer:
	LDA #$00
	STA Objects_Data4, X
	RTS		 ; Return

ObjNorm_Dimmer:
	LDA <Counter_1
	AND #$03
	BNE FadeOutDone
	LDY #$07

DimmerFindBlocks:
	LDA SpinnerBlocksActive, Y
	BNE Dimmer_FadeIn
	DEY
	BPL DimmerFindBlocks
	JMP Dimmer_FadeOut

Dimmer_FadeOut:
	LDA Objects_Data4, X
	CMP #$04
	BEQ FadeOutDone
	INC Objects_Data4, X

	JMP Dimmer_Fade
FadeOutDone:
	RTS

Dimmer_FadeIn:
	LDA Objects_Data4, X
	BEQ FadeInDone
	DEC Objects_Data4, X
	JMP Dimmer_Fade

FadeInDone:
	RTS

Dimmer_Fade:
	LDA Objects_Data4, X
	ASL A
	ASL A
	ASL A
	ASL A
	STA TempA
	LDY #$0B

Dimmer_Fade2:
	LDA MasterPal_Data+4,Y	; Get this color
	SUB TempA	 	; Subtract 16 from it
	BPL Dimmer_Fade3	 	; If we didn't go below zero, jump to PRG026_AC55

	LDA #$0f	 	; Otherwise, set it to safe minimum

Dimmer_Fade3:
	STA Palette_Buffer+4,Y	; Update palette color
	DEY		 	; Y--
	BPL Dimmer_Fade2	 	; While Y >= 0, loop!

	STA Palette_Buffer + 16
	STA Palette_Buffer + 20
	STA Palette_Buffer + 24
	STA Palette_Buffer + 28
	; Commit palette fade
	LDA #$06
	STA <Graphics_Queue
	
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SpawnObjsAndBounce
;
; This spawns new objects as the screen scrolls, and also
; incidentally handles spawning the "bounced block" effect object
; if the Player just bounced off such a block... kind of weird to
; put those together, but I guess it has to go somewhere...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_SpawnObjsAndBounce:
	; Do scene-change-reset, if needed
	; NOTE!! Does NOT return here if it did!
	JSR Level_DoChangeReset	
	JMP Level_ObjectsSpawnByScroll	 ; Spawn objects as screen scrolls

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_ObjectsSpawnByScroll
;
; Spawns object while screen scrolls (how it goes from static 
; level data to dynamic stuff on the screen)
; Non-vertical variant of Level_ObjectsSpawnByScrollV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; This defines the values used as "look ahead" when screen is moving
	; Basically the values are $110 (one screen over + 16)
	; and -$20 (32 pixels to the left)
LOSBS_LookAhead:	.byte 16, -32
LOSBS_LookAheadHi:	.byte $01, $FF	; sign extensions
HARD_FLAG	= $20
DAY_FLAG		= $40
NIGHT_FLAG		= $60

Level_ObjectsSpawnByScroll:
	LDY <Scroll_LastDir	 

	LDA <Horz_Scroll
	ADD LOSBS_LookAhead,Y
	AND #$f0
	STA <Temp_Var6	 ; Temp_Var6 = Horz_Scroll + LOSBS_LookAhead[Y] (appropriate "look ahead" values)

	LDA <Horz_Scroll_Hi
	ADC LOSBS_LookAheadHi,Y
	STA <Temp_Var7	 ; Temp_Var7 = "look ahead" high part

	CMP <Level_Width
	BEQ PRG005_B852	
	BLT PRG005_B852	 ; If the "high part" is <= the level width, jump to PRG005_B852

	JMP PRG005_B956	 ; Otherwise, at the end, jump to PRG005_B956 (RTS)

PRG005_B852:
	LDX <Temp_Var7	 ; X = "look ahead" high part

	LDA Level_ObjIdxStartByScreen,X	 ; Get starting Level_Objects index for this screen
	BMI PRG005_B872	 ; If no objects on this screen, jump to PRG005_B872 (RTS)
 
	STA <Temp_Var2	 ; Starting index -> Temp_Var2
	TAX		 ; -> 'X'

	ASL A		 
	ADD <Temp_Var2	 ; Multiply by 3 (get to appropriate object)
	TAY		 ; -> 'Y'

	DEY		 ; Y-- (offset to object column, decrement to counteract Y += 3 on first pass)
	DEX		 ; X-- (basically to counteract following INX on first pass) 

PRG005_B863:
	INX		 ; X++ (next object index)

	INY
	INY
	INY		 ; Y += 3 (next object, aligned to "column" element)

	LDA Level_Objects,Y	 ; Get object column
	LSR A
	LSR A
	LSR A
	LSR A		 ; Divide by 16 to get "screen" (16 columns per screen)
	CMP <Temp_Var7	 
	BEQ PRG005_B873	 ; If object is on this "look ahead" screen, jump to PRG005_B873

PRG005_B872:
	RTS		 ; Return

PRG005_B873:
	LDA Level_Objects-1,Y	 ; Get object ID (we're aligned by column, hence -1)
	CMP #$ff	 
	BEQ PRG005_B872	 ; If this is the terminator, jump to PRG005_B872 (RTS)

	LDA Level_ObjectsSpawned,X
	CMP #$00	 
	BMI PRG005_B863	 ; If this object is already currently spawned, jump to PRG005_B863 (skip to next object)

	LDA Level_Objects,Y	 ; Get object column
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 ; Multiply by 16 (make pixel position)
	CMP <Temp_Var6	 
	BNE PRG005_B863	 ; If object not equal to "look ahead" low component, jump to PRG005_B863 (skip to next object)

	; Object should be spawned...

	STX <Temp_Var2		 ; Backup object index -> Temp_Var2
	STA <Temp_Var1		 ; Backup pixel X position -> Temp_Var1

	LDA Level_Objects-1,Y	 ; Get object ID
	CMP #OBJ_TOADANDKING
	BNE PRG005_B89C	 	; If object ID <> OBJ_TOADANDKING, jump to PRG005_B89C

	INC Cine_ToadKing	; OBJ_TOADANDKING initializes the cinematic
	BNE PRG005_B8BE	 	; Jump (technically always) to PRG005_B8BE (mark self as spawned so it never re-triggers)

PRG005_B89C:
	CMP #OBJ_BONUSCONTROLLER
	BNE PRG005_B8B3	 	; If object ID <> OBJ_BONUSCONTROLLER, jump to PRG005_B8B3

	LDA Level_Objects+1,Y	 ; Get object row
	BPL PRG005_B8BE	 ; Jump (technically always) to PRG005_B8BE (mark self as spawned so it never re-triggers)

PRG005_B8B3:
	CMP #OBJ_AUTOSCROLL
	BNE PRG005_B8CB	 ; If object ID <> OBJ_AUTOSCROLL, jump to PRG005_B8CB

	TYA		 ; Level_Objects index -> 'A'
	PHA		 ; Save it

	JSR ObjAutoScroller_Init ; Initialization code for OBJ_AUTOSCROLL

	PLA
	TAY		 ; Restore Level_Objects index

PRG005_B8BE:
	LDX <Temp_Var2	 ; Restore object index

	LDA Level_ObjectsSpawned,X
	ORA #$80	 
	STA Level_ObjectsSpawned,X	; Mark object as already spawned (even though technically it isn't, but prevents re-triggering)

	JMP PRG005_B863	 ; Jump to PRG005_B863 (next object)

PRG005_B8CB:
	LDA Level_Objects-1,Y	 ; Get object ID
	CMP #OBJ_TREASURESET
	BNE PRG005_B8DB	 ; If object ID <> OBJ_TREASURESET, jump to PRG005_B8DB

	; Set Level_TreasureItem by what row it was placed on
	LDA Level_Objects+1,Y	 ; Get object row
	STA Level_TreasureItem 	; Level_TreasureItem = row
	JMP PRG005_B8BE	 	; Jump to PRG005_B8BE (mark self as spawned so it never re-triggers)

PRG005_B8DB:

	CMP #OBJ_8WAYBULLETBILLS
	BLT PRG005_B909	 ; If object ID < OBJ_8WAYBULLETBILLS, jump to PRG005_B909

	; All object IDs higher than OBJ_8WAYBULLETBILLS are handled specially:

	CMP #OBJ_SPAWN3GREENTROOPAS
	BNE PRG005_B8E9	 ; If object ID <> OBJ_SPAWN3GREENTROOPAS, jump to PRG005_B8E9

	; OBJ_SPAWN3GREENTROOPAS specific...

	JSR Spawn3TroopsOrCheeps	 ; Spawn up to 3 hopping green paratroopas
	JMP PRG005_B863	 ; Jump to PRG005_B863 (next object)

PRG005_B8E9:
	CMP #OBJ_SPAWN3ORANGECHEEPS
	BNE PRG005_B8F3	 ; If object ID <> OBJ_SPAWN3ORANGECHEEPS, jump to PRG005_B8F3

	; OBJ_SPAWN3ORANGECHEEPS specific ...

	JSR Spawn3TroopsOrCheeps	 ; Spawn up to 3 "lost" orange cheep cheeps
	JMP PRG005_B863	 ; Jump to PRG005_B863 (next object)

PRG005_B8F3:
	CMP #OBJ_CFIRE_BULLETBILL
	BLT PRG005_B902	 ; If object ID < OBJ_CFIRE_BULLETBILL, jump to PRG005_B902

	; Object ID >= OBJ_CFIRE_BULLETBILL...

	SBC #OBJ_CFIRE_BULLETBILL	 ; Zero base it
	ADD #$01	 ; +1 (because zero means "empty/unused" in Cannon Fire)
	STY TempY
	JSR CannonFire_Init	 ; Initialize the Cannon Fire

	JMP PRG005_B863	 ; Jump to PRG005_B863 (next object)

PRG005_B902:
	; Trigger Level_Event
	SUB #(OBJ_8WAYBULLETBILLS-1)	; Base at 1
	STA Level_Event	 		; Set Level_Event

	RTS		 ; Return

PRG005_B909:
	LDX #$04	 ; X = 4

PRG005_B913:
	LDA Objects_State,X	
	BEQ PRG005_B91E	 ; If this object slot is "dead/empty", jump to PRG005_B91E
	DEX		 ; X--
	BPL PRG005_B913	 ; While X >= 0, loop!
	JMP PRG005_B956	 ; Jump to PRG005_B956 (RTS)

PRG005_B91E:

	; Set object X
	LDA <Temp_Var1
	STA <Objects_XZ,X
	LDA <Temp_Var7
	STA <Objects_XHiZ,X

	INY		 ; Y++ (different way of getting at row, I guess)

	LDA Level_Objects,Y
	AND #$E0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA Objects_Property, X

	; Upper 4 bits shifted right (high Y)
	LDA Level_Objects,Y	 ; Get object row
	AND #$10	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA <Objects_YHiZ,X

	; Lower 4 bits shifted left (low Y)
	LDA Level_Objects,Y	 ; Get object row
	AND #$0f	 
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 
	STA <Objects_YZ,X

	DEY		 
	DEY		 ; Y -= 2 (at object ID now)

	; Set object ID
	LDA Level_Objects,Y
	STA Objects_ID,X

	LDY <Temp_Var2			; Object index -> 'Y'

	; Mark this object as spawned
	LDA Level_ObjectsSpawned,Y
	ORA #$80
	STA Level_ObjectsSpawned,Y

	TYA		 ; Object index -> 'A'

	; Store original spawn index
	STA Objects_SpawnIdx,X

	; Set object state to 1
	INC Objects_State,X

PRG005_B956:
	RTS		 ; Return

	; OBJ_AUTOSCROLL specific initialization
	; Placing it on row $60 causes it to activate "water line" mode
	; This mode is used in 3-2 to have water tiles at the bottom
	; of the level.  Sprites do not appear below the line.  Only really
	; looks right when there's no vertical scrolling.
ObjAutoScroller_Init:
	LDA Level_Objects+1,Y	; Get object row
	CMP #$60	 	
	BNE PRG005_B964	 	; If object is NOT on row $60, jump to PRG005_B964

	LDA #UPDATERASTER_WATERLINE
	STA Update_Request	 ; Update_Request = UPDATERASTER_WATERLINE

	RTS		 ; Return

PRG005_B964:
	PHA		 ; Save object row 

	; Clear auto scroll variables
	LDY #$14	 ; Y = $14
	LDA #$00	 ; A = 0
PRG005_B969:
	STA AScroll_Anchor-1,Y	 ; Clear this auto scroll variable
	DEY		 ; Y--
	BNE PRG005_B969	 ; While Y <> 0, loop!

	PLA		 ; Restore object row

	PHA		 ; Save object row

	AND #$0f	 ; Cap 0 - 15
	TAY		 ; -> 'Y'

	PLA		 ; Restore object row

	LSR A
	LSR A
	LSR A
	LSR A		 ; Divide by 16

	STA Level_AScrlSelect
	CMP #$03	 
	BGE PRG005_B98E	 ; If Level_AScrlSelect >= 3 (Likely but not necessarily one of the Airships), jump to PRG005_B98E

	CMP #$01	 
	BNE PRG005_B988	 ; If Level_AScrlSelect <> 1 (World 3 Airship), jump to PRG005_B988

	TYA
	ORA #$10
	TAY		 ; New base for Y index at $10

PRG005_B988:
	LDA AScroll_HorizontalInitMove,Y
	STA Level_AScrlVar	 ; -> Level_AScrlVar

PRG005_B98E:
	STY Level_AScrlLimitSel	 ; Y -> Level_AScrlLimitSel

	LDA <Vert_Scroll
	STA Level_AScrlPosV	 ; Level_AScrlPosV = Vert_Scroll

	INC Level_HAutoScroll	 ; Level_HAutoScroll = 1 (enable auto horizontal scroll!)
	RTS		 ; Return


ObjLRFlags:	.byte SPR_HFLIP, $00	; If Player is to right of object vs left, stored into Objects_Orientation

Spawn3XOff:	.byte -32, 32	; X Lo offsets
Spawn3XHiOff:	.byte $FF, $00	; Sign extension

Spawn3YVels:	.byte 11, -5, -11	; Y velocities
Spawn3Var4:	.byte  1,  1,   0	; Initial value for Var 4

	; Spawns up to 3 hopping green paratroopas or the school of lost orange cheep cheeps
Spawn3TroopsOrCheeps:
	STA Temp_VarNP0  ; Backup object ID

	TXA		 
	PHA		 ; Save object index
	TYA		 
	PHA		 ; Save Level_Objects offset

	; Changing object row value into a 16-bit Y value

	; Upper 4 bits shifted right -> Temp_Var9 (high Y)
	LDA Level_Objects+1,Y	; Get object row
	AND #$10
 	LSR A
	LSR A
	LSR A
	LSR A	
	STA <Temp_Var9		 ; -> Temp_Var9 

	; Lower 4 bits shifted left -> Temp_Var10 (low Y)
	LDA Level_Objects+1,Y	 ; Get object row
	AND #$0f
	ASL A	
	ASL A	
	ASL A
	ASL A
	STA <Temp_Var10		 ; -> Temp_Var10

	LDA <Temp_Var7		
	STA <Temp_Var11		 ; Temp_Var11 = Temp_Var7 (pixel high X of object)

	LDA <Temp_Var1		 
	STA <Temp_Var12		 ; Temp_Var12 = Temp_Var1 (pixel X position of object)

	LDX <Temp_Var2		 ; Restore object index -> 'X'

	; Mark object as already spawned
	LDA Level_ObjectsSpawned,X
	ORA #$80
	STA Level_ObjectsSpawned,X

	; Spawning up to 3 of orange cheep cheeps or green hopping paratroopas
	LDA #$02
	STA <Temp_Var13		; Temp_Var13 = 2

PRG005_B9D9:
	LDX #$04	; X = 4

PRG005_B9DB:
	LDA Objects_State,X	
	BEQ PRG005_B9E6	 ; If this object slot is "dead/empty", jump to PRG005_B9E6
	DEX		 ; X--
	BPL PRG005_B9DB	 ; While X >= 0, loop!
	JMP PRG005_BA3D	 ; If no empty slots, jump to PRG005_BA3D

PRG005_B9E6:
	JSR Object_New	 ; Set up new object

	; Set object Y/Hi by calculated values
	LDA <Temp_Var9
	STA <Objects_YHiZ,X
	LDA <Temp_Var10	
	STA <Objects_YZ,X

	; Set object X/Hi
	LDA <Temp_Var12	
	STA <Objects_XZ,X
	LDA <Temp_Var11	
	STA <Objects_XHiZ,X

	; Difference of Player vs object X Lo -> Temp_Var16
	; Reg Y is set to 0 if Player is to the right of object, 1 if to the left
	JSR Object_XDistanceFromPlayer

	LDA ObjLRFlags,Y
	STA Objects_Orientation,X	 ; Set appropriate flag

	LDA <Temp_Var12
	ADD Spawn3XOff,Y
	STA <Temp_Var12		; Temp_Var12 += Spawn3XOff[Y]
	LDA <Temp_Var11
	ADC Spawn3XHiOff,Y	
	STA <Temp_Var11		; related sign extension

	LDA Temp_VarNP0		; Get object ID back
	CMP #OBJ_SPAWN3GREENTROOPAS	
	BEQ PRG005_BA2B	 	; If object ID = OBJ_SPAWN3GREENTROOPAS, jump to PRG005_BA2B

	; OBJ_SPAWN3ORANGECHEEPS specific...

	LDY <Temp_Var13		 ; 0 - 2, loop counter

	LDA Spawn3YVels,Y	 
	STA <Objects_YVelZ,X	 ; Set appropriate Y velocity

	LDA Spawn3Var4,Y
	STA Objects_Data1,X	 ; Set initial var 4 value

	INC Objects_InWater,X	 ; Set object as in water

	LDA #$00   ; #OBJ_PIRATEBRO	 ; A = OBJ_PIRATEBRO
	BNE PRG005_BA2D	 ; Jump (technically always) to PRG005_BA2D

PRG005_BA2B:
	LDA #OBJ_PARATROOPAGREENHOP	 ; A = OBJ_PARATROOPAGREENHOP

PRG005_BA2D:
	STA Objects_ID,X	 ; Set object ID

	; Set state to OBJSTATE_NORMAL
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA #SPR_PAL2
	STA Objects_SpriteAttributes,X	; Force palette 2

PRG005_BA3D:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG005_B9D9	 ; While Temp_Var13 >= 0, loop!

	PLA
	TAY		 ; Restore Level_Objects offset

	PLA
	TAX		 ; Restore object index

	RTS		 ; Return

CannonFire_Init:
	STA <Temp_Var16	 ; Store index value (1+)
	STX TempX
	TXA		 ; -> 'X
	PHA		 ; Save it too


	LDA CannonFire_ID+7
	PHA		 ; Backup last Cannon Fire ID

	LDA CannonFire_Parent+7
	PHA		 ; Backup last Cannon Fire parent index

	; Move over all current Cannon Fires
	LDX #$06	 ; X = 6
PRG005_BA54:
	LDA CannonFire_ID,X
	STA CannonFire_ID+1,X
	LDA CannonFire_YHi,X
	STA CannonFire_YHi+1,X
	LDA CannonFire_Y,X	
	STA CannonFire_Y+1,X	
	LDA CannonFire_XHi,X	
	STA CannonFire_XHi+1,X	
	LDA CannonFire_X,X	
	STA CannonFire_X+1,X	
	LDA CannonFire_Parent,X	
	STA CannonFire_Parent+1,X	
	LDA CannonFire_Timer,X	
	STA CannonFire_Timer+1,X	
	LDA CannonFire_Var,X	
	STA CannonFire_Var+1,X	
	LDA CannonFire_Timer2,X	
	STA CannonFire_Timer2+1,X	
	LDA CannonFire_Property,X	
	STA CannonFire_Property+1,X	

	DEX		 ; X--
	BPL PRG005_BA54	 ; While X >= 0, loop

	PLA		 ; Restore last Cannon Fire Parent index
	TAX		 ; -> 'X'

	PLA		 ; Restore last Cannon Fire ID
	BEQ PRG005_BA9A	 ; If last Cannon Fire ID = 0 (this slot was not previously in use), jump to PRG005_BA9A

	; Mark the parent creator object as NOT spawned since this cannon fire slot is being overwritten
	LDA Level_ObjectsSpawned,X
	AND #$7f
	STA Level_ObjectsSpawned,X

PRG005_BA9A:
	; Upper 4 bits shifted right -> CannonFire_YHi (high Y)
	STY TempY
	LDA Level_Objects+1,Y	 ; Get object row
	AND #$10	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA CannonFire_YHi

	; Upper 4 bits shifted left -> CannonFire_Y (low Y)
	LDA Level_Objects+1,Y	 ; Get object row
	AND #$0f	
	ASL A		
	ASL A		
	ASL A		
	ASL A		
	STA CannonFire_Y

	LDA <Temp_Var7	
	STA CannonFire_XHi	 ; CannonFire_XHi = (pixel high X of object)

	LDA <Temp_Var1	
	STA CannonFire_X	 ; CannonFire_X = (pixel X position of object)

	LDA #$00
	STA CannonFire_Var	; Clear Cannon Fire variable
	STA CannonFire_Timer2	; Clear Cannon Fire timer 2

	LDA #$60

	LDX <Temp_Var16	 ; X = Temp_Var16 (ID of Cannon Fire)

	CPX #CFIRE_4WAY
	BNE PRG005_BACE	 ; If X <> 4, jump to PRG005_BACE

	LDA #$00	 ; Otherwise, A = 0

PRG005_BACE:
	STA CannonFire_Timer	 ; CannonFire_Timer = $00 or $60, depending on whether we're a 4-Way cannon

	LDX <Temp_Var2		 ; Restore object index
	STX CannonFire_Parent	 ; CannonFire_Parent = Temp_Var2

	; Mark this object as spawned
	LDA Level_ObjectsSpawned,X
	ORA #$80	
	STA Level_ObjectsSpawned,X

	LDA <Temp_Var16	
	STA CannonFire_ID

	TXA
	TAY

	PLA		 ; Restore input index value
	TAX		 ; -> 'X'
	LDY TempY
	LDA Level_Objects+1,Y
	AND #$E0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA CannonFire_Property
	RTS		 ; Return

Level_ObjectsSpawnByScrollV:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelEvent_Do
;
; Performs a "level event" based on the value of Level_Event
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelEvent_Do:
	LDA Level_Event	
	BEQ PRG005_BBBF	 ; If no level event, jump to PRG005_BBBF (RTS)
	JSR DynJump	 ; Dynamic jump based on Level_Event... 
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!! 

	.word LevelEvent_DoNothing	; 0 - Do nothing (not used!)
	.word LevelEvent_8WayBulletBills	; 1 - Cheep Cheep attack
	.word LevelEvent_ProduceMines	; 2 - Spike Cheeps float by
	.word LevelEvent_LakituFlee	; 3 - Clears Lakitu_Active which causes an active Lakitu to flee / be removed
	.word LevelEvent_Earthquake	; 4 - Green and red parabeetles flyby!
	.word LevelEvent_CloudsinBG	; 5 - Floating clouds in background float by
	.word LevelEvent_WoodPlatforms	; 6 - Random wooden platforms 
	.word LevelEvent_TreasureBox	; 7 - Get a treasure box
	.word LevelEvent_Cancel		; 8 - Does nothing but clear Level_Event

LevelEvent_LakituFlee:

	; Clears Lakitu_Active

	LDA #$00
	STA Lakitu_Active

LevelEvent_Cancel:
	LDA #$00
	STA Level_Event

PRG005_BBBF:
	RTS		 ; Return


WoodenPlatform_XVel:
	.byte -$04, -$08, -$06, -$08

LevelEvent_WoodPlatforms:
	LDA Game_Counter
	AND #$7f
	BNE PRG005_BC41	 ; Only do anything every 127 ticks

	LDA #OBJ_PLATFORM_PATH
	JSR Level_CountNotDeadObjs
	CPY #$03
	BCS PRG005_BC41	 ; If there's already at least 3 wooden platforms, jump to PRG005_BC41 (RTS)

	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; ?? ObjectID 0?
	LDA #$00
	STA Objects_ID,X

	LDA RandomN,X
PRG005_BBDF:
	AND #$7f
	ADD #$40
	ADD Level_VertScroll
	AND #$e0	; Locks to 32 pixel grid
	ORA #$0f
	STA <Temp_Var1	 ; Temp_Var1 = 64 + (Random 0 to 127), locked to 32 pixel grid with 15 offset
	PHP		 ; Save process status

	; Now comes a lengthy check to make sure that no wooden 
	; platform appears where another already is (vertically)
	LDY #$04
PRG005_BBF1:
	LDA Objects_State,Y
	BEQ PRG005_BC11	 ; If this object slot is "dead/empty", jump to PRG005_BC11

	LDA Objects_ID,Y
	CMP #OBJ_PLATFORM_PATH
	BNE PRG005_BC11	 ; If this object slot is a OBJ_PLATFORM_PATH, jump to PRG005_BC11

	; This check specifically prevents two platforms from appearing in the same place
	LDA Objects_YZ,Y
	CMP <Temp_Var1	
	BNE PRG005_BC11	 ; If this object slot's Y position does not match what we generated, jump to PRG005_BC11

	; Random + $30
	LDA RandomN,X
	ADD #$30
	STA RandomN,X

	PLP		 ; Restore process status
	JMP PRG005_BBDF	 ; Jump to PRG005_BBDF

PRG005_BC11:
	DEY		 ; Y--
	BPL PRG005_BBF1	 ; While Y >= 0, loop!

	; Y coordinate checks out, assign!
	LDA <Temp_Var1
	STA <Objects_YZ,X
	PLP		 ; Restore process status
	LDA <Vert_Scroll_Hi
	ADC #$00
	STA <Objects_YHiZ,X

	; Set X coordinate
	LDA <Horz_Scroll
	ADD #$ff
	STA <Objects_XZ,X
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHiZ,X

	; Set X velocity
	LDA RandomN,X
	AND #$03
	TAY		 ; Y = random 0 to 3
	LDA WoodenPlatform_XVel,Y
	STA <Objects_XVelZ,X

	; Force palette 3
	LDA #SPR_PAL3
	STA Objects_SpriteAttributes,X

	; Set wooden platform ID at last
	LDA #OBJ_PLATFORM_PATH
	STA Objects_ID,X

PRG005_BC41:
	RTS		 ; Return

FloatingCloud_Var5:	.byte $00, $01, $02, $01
FloatingCloud_XVel:	.byte $10, $12, $14, $12

LevelEvent_CloudsinBG:
	LDA Game_Counter
	AND #$03
	BNE PRG005_BCA2
	INC LevelEvent_Cnt
	LDA LevelEvent_Cnt
	CMP #$c0
	BNE PRG005_BCA2	 ; Only do something every 768 ticks

	LDA #$00
	STA LevelEvent_Cnt	 ; LevelEvent_Cnt = 0

	LDA #OBJ_FLOATINGBGCLOUD
	JSR Level_CountNotDeadObjs
	CPY #$02
	BGE PRG005_BCA2	 ; If there at least 2 clouds already, jump to PRG005_BCA2

	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; Store floating cloud's ID
	LDA #OBJ_FLOATINGBGCLOUD
	STA Objects_ID,X

	; Set floating cloud's Y position (screen scroll + 48 + (Random 0 to 127))
	LDA RandomN,X
	AND #$7f
	ADD #$30
	ADD Level_VertScroll
	STA <Objects_YZ,X
	LDA <Vert_Scroll_Hi
	ADC #$00
	STA <Objects_YHiZ,X

	; Set starting X position
	LDA <Horz_Scroll
	SUB #$20
	STA <Objects_XZ,X
	LDA <Horz_Scroll_Hi
	SBC #$00
	STA <Objects_XHiZ,X

	LDA RandomN,X
	AND #$03
	TAY	; Y = random 0 to 3

	; Var 5 = FloatingCloud_Var5[Y]
	LDA FloatingCloud_Var5,Y
	STA Objects_Data2,X

	; Set cloud's X velocity
	LDA FloatingCloud_XVel,Y
	STA <Objects_XVelZ,X

PRG005_BCA2:
	RTS		 ; Return


LevelEvent_TreasureBox:

	; Used as delay until collected box kicks back to map
	LDY LevelEvent_Cnt
	BEQ PRG005_BCB6	 ; If LevelEvent_Cnt = 0, jump to PRG005_BCB6

	DEC LevelEvent_Cnt	; LevelEvent_Cnt--
	BNE PRG005_BCB5	 	; If LevelEvent_Cnt <> 0, jump to PRG005_BCB5 (RTS)

	; Exit to map
	INC Level_ExitToMap
	LDA #$00
	STA Map_ReturnStatus

PRG005_BCB5:
	RTS		 ; Return

PRG005_BCB6:

	; The following loop limits the appearance of the treasure box
	; to only when there's no objects...
	LDY #$07	 ; Y = 7

PRG005_BCB8:
	LDA SpecialObj_ID,Y
	BNE PRG005_BCF4	 ; If special object slot <> 0 (dead/empty), jump to PRG005_BCF4 (RTS)

	CPY #$05
	BGE PRG005_BCCD	 ; If Y >= 5, jump to PRG005_BCCD

	LDA Objects_ID,Y
	CMP #OBJ_BIRDO	 
	BEQ PRG005_BCCD	 ; If object ID = OBJ_BIRDO (the Giant World block controller), jump to PRG005_BCCD

	LDA Objects_State,Y	
	BNE PRG005_BCF4	 ; If this object slot is not "dead/empty", jump to PRG005_BCF4

PRG005_BCCD:
	DEY		 ; Y--
	BPL PRG005_BCB8	 ; While Y >= 0, loop!

	; Set treasure box state to Init
	LDA #OBJSTATE_INIT
	STA Objects_State

	; Set treasure box ID
	LDA #OBJ_SPINTULA
	STA Objects_ID

	; Treasure box always appears at Y coordinate $0170
	LDA #$01
	STA <Objects_YHiZ
	LDA #$70
	STA <Objects_YZ

	; Treasure box attempts to appear roughly at left quarter of screen
	LDA #$30
	LDY <Player_X
	BMI PRG005_BCEA
	LDA #$c0
PRG005_BCEA:
	ADC <Horz_Scroll
	STA <Objects_XZ
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHiZ

PRG005_BCF4:
	RTS		 ; Return


BB8WayXVels:
	.byte -$16, -$20, -$16, $00, $22, $20, $22, $00

BB8WayYVels:
	.byte -$16, $00, $16, $20, $16, $00, -$16, -$20

BB8WayXOffset:
	.byte $F8, $F8, $F8, $80, $00, $00, $00, $80

BB8WayYOffset:
	.byte $C0, $60, $00, $00, $00, $60, $C0, $C0

BB8WayFrame:
	.byte $04, $00, $01, $03, $01, $00, $04, $05

BB8WayAttr:
	.byte $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP, $00

LevelEvent_8WayBulletBills:	
	LDA Game_Counter
	AND #$7f	 ; Cap 0 - 31
	BNE PRG005_BD53	 ; If not zero, jump to PRG005_BD53 (RTS)

	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; Set the Cheep Cheep's object ID
	LDA #OBJ_BULLETBILL
	STA Objects_ID,X

	LDA RandomN
	AND #$07
	TAY

	LDA Level_VertScroll
	ADD BB8WayYOffset, Y
	STA <Objects_YZ,X

	LDA <Vert_Scroll_Hi
	ADC #$00
	STA <Objects_YHiZ,X

	
	LDA <Horz_Scroll 	; Horz_Scroll + X offset
	ADD BB8WayXOffset, Y
	STA <Objects_XZ,X	; Store as object's X

	; Apply carry as needed
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHiZ,X
	
	LDA BB8WayXVels, Y
	STA <Objects_XVelZ,X	 ; Set X velocity

	LDA BB8WayYVels, Y
	STA <Objects_YVelZ,X	 ; Set Y velocity = -$48

	LDA BB8WayFrame, Y
	STA Objects_Frame, X

	LDA BB8WayAttr, Y
	STA Objects_Orientation,X

	LDA #$02
	STA Objects_SpriteAttributes,X

	LDA #$4C
	STA PatTable_BankSel+4

	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

PRG005_BD53:
	RTS		 ; Return

	; The Spike Cheeps appear on the left or right side of the screen (respective)
	; And thus travel to the right or the left (respective again)
SpikeCheepX:	.byte 0, 255
SpikeCheepXVel:	.byte 8, -16

LevelEvent_ProduceMines:
	LDA <Player_HaltGameZ
	BNE PRG005_BDB0
	INC LevelEvent_Cnt	 ; LevelEvent_Cnt++
	LDA LevelEvent_Cnt
	CMP #$60
	BNE PRG005_BDB0
	LDA #$00
	STA LevelEvent_Cnt

	LDA #$00
	STA <Temp_Var1
	LDX #$04

LevelEvent_ProduceMines1:
	LDA Objects_State, X
	CMP #OBJSTATE_NORMAL
	BNE LevelEvent_ProduceMines2
	LDA Objects_ID,X
	CMP #OBJ_FLOATMINE
	BNE LevelEvent_ProduceMines2
	INC <Temp_Var1

LevelEvent_ProduceMines2:
	DEX
	BPL LevelEvent_ProduceMines1

	LDA <Temp_Var1
	CMP #$02
	BCS PRG005_BDB0
	
	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; Set Spike Cheep's object ID
	LDA #OBJ_FLOATMINE
	STA Objects_ID,X
	LDA #$01
	STA Objects_SpriteAttributes, X
	STA Objects_Data4, X

	LDA <Player_XHi
	STA Objects_XHiZ, X
	LDA #$01
	STA Objects_Data4,X	; var 1 = 1
	LDA #$A8
	STA Objects_YZ, X
	LDA #$01
	STA Objects_YHiZ, X
	STA Objects_Data4, X

	LDA RandomN
	ADC <Player_X
	STA Objects_XZ, X

PRG005_BDB0:
	RTS		 ; Return

EarthquakeEventTimers: .byte $80, $A0, $C0, $FF
DebrisOffset: .byte $F8, $F0, $E8, $E0, $08, $10, $18, $20
DebrisColors: .byte SPR_PAL1, SPR_PAL2, SPR_PAL3, SPR_PAL1

LevelEvent_Earthquake:
	LDA LevelEvent_Cnt
	BEQ LevelEvent_Earthquake0
	DEC LevelEvent_Cnt
	BNE LevelEvent_Earthquake0_1
	LDA #$20
	STA Level_Vibration

LevelEvent_Earthquake0_1:
	RTS

LevelEvent_Earthquake0:
	LDA Level_Vibration
	BNE LevelEvent_Earthquake0_1
	JSR Level_SpawnObj

	LDA #$0A
	STA PatTable_BankSel+4
	; Set Ice Block to state Kicked
	LDA #OBJ_BRICK
	STA Objects_ID,X

	LDA #$01
	STA Objects_Frame, X

	LDA RandomN + 3
	AND #$03
	TAY
	LDA DebrisColors, Y
	STA Objects_SpriteAttributes, X

	; Set Frame = 2
	LDA #$01
	STA Objects_Frame,X

	; Set expiration timer
	LDA #$ff
	STA Objects_Timer3,X

	LDA RandomN + 2
	AND #$07
	TAY
	LDA <Player_X
	ADD DebrisOffset, Y
	STA <Objects_XZ, X
	LDA <Player_XHi
	STA <Objects_XHiZ, X

	LDA <Vert_Scroll
	SUB #$40
	STA <Objects_YZ,X 
	LDA #$00
	SBC #$00
	STA <Objects_YHiZ, X
	LDA RandomN + 1
	AND #$03
	TAY
	LDA EarthquakeEventTimers, Y
	STA LevelEvent_Cnt

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SpawnObj	-- slots 0 - 4
; Level_SpawnObjSetMax	-- slots 0 - input X register
;
; This function "spawns" a new object (finds an empty object slot 
; from slots 0 - 4 (or custom) and preps it for normal operation.)
; Does not set up X, Y, ID, etc -- this is the responsibility of
; the caller to do so.
; NOTE!! If no slot is free, this function does NOT RETURN TO
; THE CALLER!! So no additional logic checking is necessary.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_SpawnObj:
	LDX #$04	 ; X = 4

Level_SpawnObjSetMax:
	LDA Objects_State,X	 ; Check the state of this object slot

	BEQ PRG005_BE26	 ; If this object slot is "dead/empty", jump to PRG005_BE26

	DEX		 ; X--
	BPL Level_SpawnObjSetMax	 ; While X >= 0, loop!

	; When no slots are open, does not return to caller!
	PLA		 
	PLA		 ; Do not return to caller!!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_CountNotDeadObjs
;
; This function counts the number of objects that are not in the
; "dead/empty" state in object slots 0 - 4
; It also sets X = CurrentObjectIndexZ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_CountNotDeadObjs:
	STA <Temp_Var1	 ; Store object ID we're hunting for -> Temp_Var1

	LDY #$00	 ; Y = 0 (count how many of this object already exist)
	LDX #$04	 ; X = 4

PRG005_BE13:
	LDA Objects_State,X
	BEQ PRG005_BE20	 ; If this object slot is "dead", jump to PRG005_BE20

	LDA Objects_ID,X
	CMP <Temp_Var1	
	BNE PRG005_BE20	 ; If this object slot does not have the same ID as what was input, jump to PRG005_BE20

	INY		 ; Otherwise, increment count

PRG005_BE20:
	DEX		 ; X--
	BPL PRG005_BE13	 ; While X >= 0, loop!

	LDX <CurrentObjectIndexZ	 ; X = CurrentObjectIndexZ
	RTS		 ; Return


PRG005_BE26:
	JSR Object_New	 ; Prepare new object!

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X	 ; Objects_State[X] = OBJSTATE_NORMAL (item alive, default state)

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_DoChangeReset
;
; Whenever a new "scene" of a level is entered into, the initial
; screen needs to be set up (clears old objects out, spawns new
; ones in!)  This activates only when Level_ObjectsInitialized = 0!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_DoChangeReset: 
	LDA Level_ObjectsInitialized
	BEQ PRG005_BE35	 ; If Level_ObjectsInitialized not set, jump to PRG005_BE35

	RTS		 ; Return

PRG005_BE35:
	LDY #$09	 	; Y = 9

PRG005_BE37:
	STA SpecialObj_ID,Y	; Set special object ID to 0

	CPY #$08	 
	BGE PRG005_BE41	 	; If Y >= 8, jump to PRG005_BE41

	LDX Level_KeepObjects
	BNE PRG005_BE41
	STA CannonFire_ID,Y

PRG005_BE41:
	CPY #$05
	BGE PRG005_BE4B	 ; If Y >= 5, jump to PRG005_BE4B


PRG005_BE4B:
	CPY #$03
	BEQ PRG005_BE64	 	; If Y = 3, jump to PRG005_BE64
	BGE PRG005_BE67	 	; If Y > 3, jump to PRG005_BE67

	STA Bubble_Cnt,Y	; Clear any water bubbles
	STA Splash_Counter,Y	; Clear any water splashes
	STA BrickBust_En,Y	; Clear any brick busting effects

	CPY #$02
	BGE PRG005_BE64	 	; If Y >= 2, jump to PRG005_BE64

	STA Buffer_Occupied,Y 	; Clear the buffer occupation flags
	STA PlayerProj_ID,Y 	; Clear Player projectiles

PRG005_BE64:
	STA CoinPUp_State,Y	; Clear power-up coin state

PRG005_BE67:
	DEY		 ; Y--
	BPL PRG005_BE37	 ; While Y >= 0, loop

	; Clear a bunch of stuff!
	STA EndCard_Flag
	STA RotatingColor_Cnt
	STA Player_TwisterSpin
	STA Level_Vibration
	STA Vert_Scroll_Off
	STA Player_VibeDisable
	STA Level_Event	
	STA LevelEvent_Cnt
	STA Splash_DisTimer
	STA Level_ScrollDiffH
	STA Wind
	STA WeatherActive
	STA Level_ScrollDiffV

	INC Top_Needs_Redraw
	INC Bottom_Needs_Redraw

	LDX Level_KeepObjects
	BNE PRG005_BE91

	; Clear Level_ObjectsSpawned (nothing spawned)
	LDY #$2f	 ; Y = $2F

PRG005_BE90:
	STA Level_ObjectsSpawned,Y
	DEY		 ; Y--
	BPL PRG005_BE90	 ; While Y >= 0, loop!

PRG005_BE91:
	LDY #$FF
	STY Level_ObjectsInitialized
	STA Player_PartDetEn
	STA Level_ObjIdxStartByScreen
	STA Player_InWater
	STA Air_Change
	STA Power_Change
	STA AScrlURDiag_WrapState_Copy
	STA AScrlURDiag_WrapState
	STA Level_AScrlVVel
	STA <Temp_Var1

	TAX		 ; X = 0

	TAY
	INY		 ; Y = 1

PRG005_BEB6:
	CPX #$10	 
	BEQ PRG005_BEFC	 ; If X = $10, jump to PRG005_BEFC
 
	LDA Level_Objects,Y
	CMP #$ff	 
	BEQ PRG005_BEE5	 ; If terminator, jump to PRG005_BEE5

	LDA Level_Objects+1,Y	; Get object column
PRG005_BECE:
	LSR A
	LSR A
	LSR A
	LSR A		 ; Get appropriate screen offset
	STA <Temp_Var2	 ; -> Temp_Var2

	CPX <Temp_Var2	
	BNE PRG005_BEE5	 ; If X <> screen offset, jump to PRG005_BEE5

	INC <Temp_Var1	 ; Temp_Var1++

	LDA <Temp_Var1	
	STA Level_ObjIdxStartByScreen+1,X ; Calculated first object index for next screen

	INY
	INY 
	INY		 ; Y += 3 (next object)
	JMP PRG005_BEB6	 ; Jump to PRG005_BEB6

PRG005_BEE5:
	LDA <Temp_Var1	 

	CPX #$0f	 
	BEQ PRG005_BEEE	 ; If X = $F, jump to PRG005_BEEE

	STA Level_ObjIdxStartByScreen+1,X ; Calculated first object index for next screen

PRG005_BEEE:
	CMP Level_ObjIdxStartByScreen,X	 
	BNE PRG005_BEF8	 ; If Level_ObjIdxStartByScreen[X] <> 0, jump to PRG005_BEF8

	LDA #$ff	 
	STA Level_ObjIdxStartByScreen,X	 ; Level_ObjIdxStartByScreen[X] = $FF (means no objects this screen)

PRG005_BEF8:
	INX		 ; X++
	JMP PRG005_BEB6	 ; Jump to PRG005_BEB6

	; Clear all object states
PRG005_BEFC:
PRG005_BEFD:
	LDX #$07	 ; X = 7

PRG005_BF001:
	LDA Objects_Global, X
	BNE PRG005_BF01

	LDA Level_KeepObjects
	BEQ PRG005_BF002

	LDA Objects_State, X
	CMP #OBJSTATE_NORMAL
	BNE PRG005_BF002
	
	JSR Object_SetDeadAndNotSpawned

PRG005_BF002:
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	 ; Clear object state

PRG005_BF01:
	DEX		 ; X--
	BPL PRG005_BF001	 ; While X >= 0, loop!

PRG005_BF02:
	LDA #$4f	 
	STA PatTable_BankSel+5	 ; Set sixth pattern table to $4F

	LDA <Horz_Scroll
	PHA		 ; Save Horz_Scroll

	LDA LOSBS_LookAhead	 ; $10
	SUB LOSBS_LookAhead+1	 ; $10 - $E0 = $30

	; Adds $130 to Horz_Scroll/Hi (basically one screen over to the right of the start)

	ADD <Horz_Scroll ; Horz_Scroll += $30

	AND #$f0	 ; Align to grid

	STA <Temp_Var14	 ; -> Temp_Var14

	LDA <Horz_Scroll_Hi
	PHA		 ; Save Horz_Scroll_Hi

	ADC LOSBS_LookAheadHi	 ; Add 1 with carry (LOSBS_LookAheadHi = 1)
	STA <Temp_Var15	 ; -> Temp_Var15

	LDA #$01
	STA <Scroll_LastDir	 ; Scroll_LastDir = 1 (screen last moved left)

	; Fake leftward scroll by 16
	LDA <Horz_Scroll
	SUB #16
	STA <Horz_Scroll	; Horz_Scroll -= $10

	BCS PRG005_BF49	 	; If carry set, jump to PRG005_BF49
	DEC <Horz_Scroll_Hi	; Apply carry

	; This loop spawns all objects which should be visible at the initial
	; screen of the level by pretending to scroll a whole screen's worth

PRG005_BF49:
	LDA <Horz_Scroll
	ADC #$10
	AND #$f0
	STA <Horz_Scroll ; Horz_Scroll += $10, aligned to grid

	BCC PRG005_BF55	 ; If no carry, jump to PRG005_BF55
	INC <Horz_Scroll_Hi	 ; Apply carry
PRG005_BF55:

	; Ensures all objects that should appear on the initial screen, will appear
	JSR Level_ObjectsSpawnByScroll
	JSR Level_ObjectsSpawnByScroll

	LDA <Temp_Var15
	CMP <Horz_Scroll_Hi
	BNE PRG005_BF49	 ; If we haven't reached the high target yet, loop

	LDA <Temp_Var14	
	CMP <Horz_Scroll
	BNE PRG005_BF49	 ; If we haven't reached the low target yet, loop

	PLA
	STA <Horz_Scroll_Hi	 ; Restore Horz_Scroll_Hi

	PLA
	STA <Horz_Scroll	 ; Restore Horz_Scroll

	; Do not return to caller!!
	PLA
	PLA

	RTS		 ; Return

; Rest of ROM bank was empty...

PObjYOff_PlayerSize:	.byte 18, 10	; Small vs not small
PObj_VLimit:	.byte $10, $16

ProjectileBarCollide:

	LDY #$00	 ; Y = 0 (small/ducking)

	LDA <Player_Suit
	BEQ P_PRG007_B7E4	 ; If Player is small, jump to PRG007_B7E4

	LDA Player_IsDucking
	BNE P_PRG007_B7E4	 ; If Player is ducking, jump to PRG007_B7E4

	INY		 ; Y = 1 (otherwise)

P_PRG007_B7E4:
	LDA PBarHitTestY,X		; Special object Y
	ADD #$08			; +8
	SUB <Player_Y			; Subtract Player Y
	SUB PObjYOff_PlayerSize,Y	; Subtract Player height offset
	CMP PObj_VLimit,Y
	BGE P_PRG007_B826	 	; If result >= SObj_VLimit, jump to PRG007_B843 (RTS)

	LDA PBarHitTestX,X		; Special object X
	ADD #$04			; +6
	SUB <Player_X			; Subtract Player X
	SBC #$00			; Carry?
	CMP #16
	BGE P_PRG007_B826	 	; If result >= 16, jump to PRG007_B843 (RTS)

P_PRG007_B805:
	LDA Player_FlashInv	; If Player is flashing from being hit ...
	ORA <Player_HaltGameZ	; ... if gameplay is halted ...
	ORA Player_IsDying	; ... Player is dying ...
	BEQ P_PRG007_B827	 	; ... jump to Player_Behind_En (RTS)

P_PRG007_B826:
	RTS		 ; Return

XKnockBacks: .byte $20, $E0, $E0, $20
YKnockBacks: .byte $E0, $20, $20, $E0

P_PRG007_B827:
	LDX <CurrentObjectIndexZ
	LDA Objects_Data4, X
	BEQ P_PRG007_B828
	JSR Object_YDistanceFromPlayer
	TYA
	ASL A
	ADD Objects_Data5, X
	TAY
	LDA XKnockBacks, Y
	STA <Player_XVel
	JSR Object_XDistanceFromPlayer
	TYA
	ASL A
	ADD Objects_Data5, X
	TAY
	LDA YKnockBacks, Y
	STA <Player_YVel 
	STA <Player_InAir
	JSR Player_Freeze
	LDX <CurrentObjectIndexZ
	PLA
	PLA
	RTS

P_PRG007_B828:
	JMP Player_GetHurt	 ; Hurt Player and don't come back!

ObjInit_Freezie:
	LDA Objects_Property, X
	BNE Freezie_NotMoving

	LDA #$01
	STA Freezie_State, X

	JSR Object_MoveTowardsPlayer
	RTS

Freezie_NotMoving:
	CMP #$01
	BNE Freezie_HorzontalPipe

	LDA <Objects_XZ, X
	ADD #$08
	STA <Objects_XZ, X
	RTS

Freezie_HorzontalPipe:
	LDA <Objects_YZ, X
	SUB #$06
	STA <Objects_YZ, X

	LDA <Objects_YHiZ, X
	SBC #$00
	STA <Objects_YHiZ, X
	RTS

Freezie_Frame = Objects_Data1
Freezie_State = Objects_Data2
Freezie_NoYVel = Objects_Timer
Freezie_NoImpact = Objects_Data3

ObjNorm_Freezie:
	LDA <Player_HaltGameZ
	BEQ Freezie_Norm

	LDA Freezie_State, X
	BNE Freezie_JustDraw

	RTS

Freezie_JustDraw:
	JMP Freezie_Draw

Freezie_Norm:

	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE Freezie_DoAction

	JMP Freezie_Die

Freezie_DoAction:
	JSR Object_DeleteOffScreen
	LDA Freezie_State, X
	JSR DynJump

	.word Freezie_Wait
	.word Freezie_Move

Freezie_Wait:
	JSR Object_CalcBoundBox
	JSR Object_XDistanceFromPlayer
	
	CMP #$28
	BCC Freezie_ComeOut

	RTS

Freezie_ComeOut:
	LDA Objects_Property, X
	JSR DynJump

	.word Freezie_PopOut
	.word Freezie_PopOut
	.word Freezie_SlideRight
	.word Freezie_SlideLeft

Freezie_PopOut:
	LDA #$C0
	STA Objects_YVelZ, X
	
	JSR	Object_MoveTowardsPlayer
	
	LDA #$10
	STA Freezie_NoImpact, X

	INC Freezie_State, X
	RTS

Freezie_SlideLeft:
	LDA #$F8
	BNE Freezie_SetMove

Freezie_SlideRight:
	LDA #$08

Freezie_SetMove:
	STA <Objects_XVelZ, X
	
	LDA #$20
	STA Freezie_NoImpact, X

	LDA #$20
	STA Freezie_NoYVel,X
	INC Freezie_State, X
	RTS

Freezie_Move:
	LDA Freezie_NoYVel, X
	STA NoGravity

FreezieMove0:
	JSR Object_Move
	JSR Object_FaceDirectionMoving
	JSR Object_CalcBoundBox
	JSR Object_InteractWithOtherObjects
	JSR Object_InteractWithPlayer
	
	JSR Object_DetectTiles

	LDA Freezie_NoImpact, X
	BEQ Freezie_DetectWorld

	DEC Freezie_NoImpact, X
	BNE Freezie_Animate

Freezie_DetectWorld:
	JSR Object_InteractWithTiles
	
	LDA Object_VertTileProp, X
	AND #$F0
	CMP #TILE_PROP_WATER
	BEQ Freezie_FreezeWater

	CMP #(TILE_PROP_WATER | TILE_PROP_FOREGROUND)
	BNE Freezie_CheckImpact

Freezie_FreezeWater:
	
	LDA <Objects_XZ, X
	ADD #$08
	STA Block_DetectX

	LDA <Objects_XHiZ, X
	ADC #$00
	STA Block_DetectXHi

	LDA <Objects_YZ, X
	ADD #$18
	STA Block_DetectY

	LDA <Objects_YHiZ, X
	ADC #$00
	STA Block_DetectYHi
	
	LDA Object_VertTileValue, X
	EOR #$01

	JSR Object_ChangeBlock
	JSR Object_HitGround
	 
Freezie_CheckImpact:
	LDA <Objects_TilesDetectZ, X
	AND #(HIT_LEFTWALL | HIT_RIGHTWALL | HIT_CEILING)
	BEQ Freezie_Animate

	JMP Freezie_Die

Freezie_Animate:
	INC Freezie_Frame, X
	
	LDA Freezie_Frame, X
	LSR A
	LSR A 
	LSR A
	AND #$03
	STA Objects_Frame, X

Freezie_Draw:
	LDA Freezie_NoImpact, X
	BEQ Freezie_NoBehindBg

	LDA Objects_SpriteAttributes, X
	ORA #SPR_BEHINDBG
	STA Objects_SpriteAttributes, X

Freezie_NoBehindBg:
	JMP Object_Draw

FreezieThrowPlayerX:
	.byte $E0, $20

ObjHit_Freezie:
	JSR Player_Freeze
	JSR Object_XDistanceFromPlayer
	
	LDA FreezieThrowPlayerX, Y
	STA <Player_XVel
	
	LDA #$A0
	STA <Player_YVel
	STA <Player_InAir

Freezie_Die:
	LDY Objects_SpawnIdx,X
	
	LDA Level_ObjectsSpawned,Y
	AND #$7F
	STA Level_ObjectsSpawned,Y
	
	JMP Object_BurstIce

ObjInit_Swoosh:
	LDA #$60
	STA Objects_Timer, X
	RTS


Swoosh_Pull:
	.byte $01, $FF

Swoosh_Push:
	.byte $FD, $03

Swoosh_Particles1:
	.byte $89, $8B, $8D, $8F

Swoosh_Particles2:
	.byte $8F, $8D, $8B, $89

Swoosh_Times:
	.byte $40, $60, $80, $A0

Swoosh_Frame = Objects_Data1
Swoosh_Action = Objects_Data2
Swoosh_Ticker = Objects_Data3
Swoosh_Direction = Objects_Data4

ObjNorm_Swoosh:
	LDA <Player_HaltGameZ
	BEQ Swoosh_Normal

	JMP Object_Draw

Swoosh_Normal:
	INC Swoosh_Ticker, X

	JSR Object_CalcBoundBox
	JSR Object_DeleteOffScreen
	JSR Object_RespondToTailAttack
	JSR Object_DetectPlayer

	BCC Swoosh_Normal1	 ; If collision occurred, jump to PRG000_D1C5

	JSR Object_DetermineContactKill

Swoosh_Normal1:

	LDA Swoosh_Action, X
	CMP #$03
	BEQ Swoosh_NoChase

	JSR Object_FacePlayer
	
	LDY #$00
	
	LDA Objects_Orientation, X
	BEQ Swoosh_StoreDirection

	INY

Swoosh_StoreDirection:
	TYA
	STA Swoosh_Direction, X

	LDA Objects_Property, X
	AND #$01
	BEQ Swoosh_NoChase
	
Swoosh_NoChase:

	LDA Swoosh_Action, X
	JSR DynJump

	.word Swoosh_Idle
	.word Swoosh_BreathIn
	.word Swoosh_Hold
	.word Swoosh_BreatheOut

Swoosh_Idle:
	INC Swoosh_Frame, X

	LDA Swoosh_Frame, X
	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame, X

	LDA Objects_Timer, X
	BNE Swoosh_IdleDone

	LDA #$00
	STA Objects_Frame, X
	INC Swoosh_Action, X

	LDA #$40
	STA Objects_Timer, X

Swoosh_IdleDone:
	JMP Object_Draw

Swoosh_BreathIn:
	
	JSR Object_YDistanceFromPlayer
	CMP #$30
	BCS Swoosh_SuckTimer

Swoosh_SuckIn2:
	JSR Object_XDistanceFromPlayer
	
	CMP #$10
	BCC Swoosh_SuckTimer

	CMP #$50
	BCS Swoosh_SuckTimer

	TYA
	CMP Swoosh_Direction, X
	BNE Swoosh_SuckTimer

	LDA <Player_XVel
	ADD Swoosh_Pull, Y
	STA <Player_XVel

Swoosh_SuckTimer:
	LDA Objects_Timer, X
	BNE Swoosh_SuckDraw
	
	INC Swoosh_Action, X
	
	LDA #$20
	STA Objects_Timer, X
	JMP Object_Draw

Swoosh_SuckDraw:
	LDA #$40
	SUB Objects_Timer, X
	
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A

	ORA #$02
	STA Objects_Frame, X

	JSR Object_Draw

	LDA #$F8
	STA <Temp_Var1

	LDA Objects_Orientation, X
	BEQ Swoosh_SuckDraw1

	LDA #$10
	STA <Temp_Var1

Swoosh_SuckDraw1:
	LDA Sprite_RAMX, Y
	ADD <Temp_Var1
	STA Sprite_RAMX + 8, Y

	LDA #SPR_PAL1
	ORA Objects_Orientation, X
	STA Sprite_RAMAttr + 8, Y

	LDA Swoosh_Ticker, X
	AND #$0C
	
	LSR A
	LSR A
	TAX

	LDA Swoosh_Particles1, X
	STA Sprite_RAMTile + 8, Y
	
	LDA Sprite_RAMY, Y
	STA Sprite_RAMY + 8, Y

	RTS

Swoosh_Hold:
	LDA Objects_Timer, X
	BNE Swoosh_HoldDone
	
	LDA #$20
	STA Objects_Timer, X

	LDA #SND_LEVELAIRSHIP
	STA Sound_QLevel2

	INC Swoosh_Action, X

Swoosh_HoldDone:
	JMP Object_Draw


Swoosh_BreatheOut:
	LDA Swoosh_Ticker, X
	AND #$01
	BEQ Swoosh_BlowTimer

	JSR Object_YDistanceFromPlayer
	CMP #$30
	BCS Swoosh_BlowTimer

	JSR Object_XDistanceFromPlayer

	CMP #$70
	BCS Swoosh_BlowTimer

	TYA
	CMP Swoosh_Direction, X
	BNE Swoosh_BlowTimer
	
	LDA <Player_XVel
	CMP #$3C
	BCC Swoos_AddPush

	CMP #$C4
	BCC Swoosh_BlowTimer

Swoos_AddPush:
	ADD Swoosh_Push, Y
	STA <Player_XVel

Swoosh_BlowTimer:
	LDA Objects_Timer, X
	BNE Swoosh_BlowDraw
	
	LDA #$00
	STA Swoosh_Action, X
	
	LDA RandomN
	AND #$03
	TAY
	
	LDA Swoosh_Times, Y
	STA Objects_Timer, X

	JMP Object_Draw

Swoosh_BlowDraw:
	LDA #$40
	SUB Objects_Timer, X
	
	LSR A
	LSR A
	LSR A
	LSR A

	ORA #$04
	STA Objects_Frame, X

	JSR Object_Draw

	LDA #$F8
	STA <Temp_Var1

	LDA Objects_Orientation, X
	BEQ Swoosh_BlowDraw1

	LDA #$10
	STA <Temp_Var1

Swoosh_BlowDraw1:
	LDA Sprite_RAMX, Y
	ADD <Temp_Var1
	STA Sprite_RAMX + 8, Y

	LDA #SPR_PAL1
	ORA Objects_Orientation, X
	STA Sprite_RAMAttr + 8, Y

	LDA Swoosh_Ticker, X
	AND #$0C
	
	LSR A
	LSR A
	TAX

	LDA Swoosh_Particles2, X
	STA Sprite_RAMTile + 8, Y
	
	LDA Sprite_RAMY, Y
	STA Sprite_RAMY + 8, Y

	RTS

ObjInit_IntroSequence:
	LDA #$FF
	STA <Objects_XHiZ, X
	LDA #$F0
	STA <Objects_XZ, X
	LDA #$FF
	STA Objects_Timer, X
	LDA #$08
	STA <Objects_XVelZ, X
	LDA #$01
	STA Player_QueueSuit
	RTS

ObjNorm_IntroSequence:
	LDA Objects_Data4, X

	JSR DynJump

Messages:
	.word DrawBowserMessage
	.word IntroWalkToad
	.word ToadTalk
	.word ToadFollow
	.word ToadBye


DrawToad:
	LDA <Objects_XZ, X
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X
	
	JSR Object_FaceMovement
	JSR Object_ShakeAndCalcSprite
	LDX <CurrentObjectIndexZ
	LDA #SPR_BEHINDBG
	ORA Objects_SpriteAttributes, X
	STA Objects_SpriteAttributes, X
	JSR Object_Draw16x32
	RTS

BowserMessage1:
	.byte $8E, $8F
	.byte " TRICKED YOU, MARIO! YOU  "

BowserMessage2:
	.byte $9E, $9F
	.byte " WILL NEVER ESCAPE ME NOW!"

DrawBowserMessage:
	LDA #$01
	STA Player_HaltTick
	LDA Objects_Timer, X
	BNE DrawBowserMessage1
	INC Objects_Data4, X

DrawBowserMessage1:
	LDA #$80
	STA StatusBar_Mode
	STA Last_StatusBar_Mode
	LDA Objects_Data5, X
	TAX

DrawBowserMessage2:
	LDA BowserMessage1, X
	STA Status_Bar_Top , X
	LDA BowserMessage2, X
	STA Status_Bar_Bottom , X
	INX
	CPX #28
	BNE DrawBowserMessage2

	RTS

IntroWalkToad:
	LDA #$00
	STA StatusBar_Mode
	LDA #$01
	STA Player_HaltTick
	LDA <Objects_XZ, X
	CMP #$30
	BNE IntroWalkToad1

	INC Objects_Data4, X
	LDA #$FF
	STA Objects_Timer, X

IntroWalkToad1:
	LDA #$08
	INC NoGravity
	JSR Object_ApplyXVel
	JSR DrawToad
	RTS

ToadMessage1:
	.byte $8A, $8B
	.byte " MARIO! IT IS A TRAP! OH  "
	.byte $8A, $8B
	.byte " BOWSER FORCED ME TO BUILD"
	.byte $8A, $8B
	.byte " HE DOES NOT KNOW I BUILT "
	.byte $8A, $8B
	.byte " I WILL HELP YOU ESCAPE.  "

ToadMessage2:
	.byte $9A, $9B
	.byte " I GUESS I WAS TOO LATE..."
	.byte $9A, $9B
	.byte " THIS PART OF THE CASTLE. "
	.byte $9A, $9B
	.byte " A WAY FOR YOU TO ESCAPE  "
	.byte $9A, $9B
	.byte " GO THROUGH THE RIGHT WALL"

ToadTalkOffsets:
	.byte $00, $1C, $38, $54

ToadTalk:
	LDA #$01
	STA Player_HaltTick
	LDA #$80
	STA StatusBar_Mode
	STA Last_StatusBar_Mode

	LDA Objects_Data5, X
	TAX
	LDA ToadTalkOffsets, X
	TAX
	LDY #$00

ToadTalk1:
	LDA ToadMessage1, X
	STA Status_Bar_Top , Y
	LDA ToadMessage2, X
	STA Status_Bar_Bottom , Y
	INX
	INY
	CPY #$1C
	BNE ToadTalk1
	LDX <CurrentObjectIndexZ
	LDA Objects_Timer, X
	BNE ToadTalk2
	LDA #$FF
	STA Objects_Timer, X
	INC Objects_Data5, X
	LDA Objects_Data5, X
	CMP #$04
	BNE ToadTalk2
	
	INC Objects_Data4, X
	LDA #$00
	STA Objects_Data5, X

ToadTalk2:
	JMP DrawToad

ToadFollow:
	LDA <Player_HaltGameZ
	BNE ToadFollow2
	LDA #$40
	STA Air_Time
	LDA <Objects_XHiZ, X
	CMP #$0C
	BNE ToadFollow0
	LDA #$FF
	STA Objects_Timer, X
	INC Objects_Data4, X

ToadFollow0:
	LDA #$00
	STA StatusBar_Mode
	LDA <Player_XVel
	STA <Objects_XVelZ, X
	JSR Object_ApplyXVel
	LDA Player_EffectiveSuit
	BEQ ToadFollow2

	LDA Player_EffectiveSuit
	CMP #$0B
	BEQ ToadFollow3

	SUB #$02
	CMP Objects_Data5, X
	BNE ToadFollow1

	INC Objects_Data5, X

ToadFollow1:
	JSR ToadExplainText

ToadFollow2:
	LDX <CurrentObjectIndexZ
	JMP DrawToad

ToadFollow3:
	LDA #$08
	STA Objects_Data5, X
	BNE ToadFollow1

ToadExplain1:
	.byte $8A, $8B
	.byte " THE SUPER MUSHROOM SHOULD"
	.byte $8A, $8B
	.byte " USE B TO THROW FIREBALLS "
	.byte $8A, $8B
	.byte " USE B TO BREAK BRICKS AND"
	.byte $8A, $8B
	.byte " HOLD DOWN AND PRESS B TO "
	.byte $8A, $8B
	.byte " DUCK WHEN MOVING TO GO IN"
	.byte $8A, $8B
	.byte " USE B TO THROW HAMMERS   "
	.byte $8A, $8B
	.byte " USE B TO THROW ICEBALLS  "
	.byte $8A, $8B
	.byte " DOUBLE TAP B TO DASH AND "
	.byte $8A, $8B
	.byte " PRESS AGAINST A WALL MID "
	

ToadExplain2:
	.byte $9A, $9B
	.byte " BE FAMILIAR TO YOU.      "
	.byte $9A, $9B
	.byte " THAT CAN MELT ICE.       "
	.byte $9A, $9B
	.byte " DEFLECT PROJECTILES.     "
	.byte $9A, $9B
	.byte " BE INVINCIBLE TEMPORARILY"
	.byte $9A, $9B
	.byte " YOUR SHELL TO BUST BRICKS"
	.byte $9A, $9B
	.byte " TO BREAK BIRCKS AND STONE"
	.byte $9A, $9B
	.byte " TO FREEZE WATER AND FOES."
	.byte $9A, $9B
	.byte " BREAK TURN BLOCKS.       "
	.byte $9A, $9B
	.byte " AIR AND TAP A TO WALLJUMP"

ToadExplainOffsets:
	.byte $00, $1C, $38, $54, $70, $8C, $A8, $C4, $E0

ToadExplainText:
	LDA #$80
	STA StatusBar_Mode
	STA Last_StatusBar_Mode
	LDA Objects_Data5, X
	TAX
	LDA ToadExplainOffsets, X
	TAX
	LDY #$00

ToadExplainText1:
	LDA ToadExplain1, X
	STA Status_Bar_Top , Y
	LDA ToadExplain2, X
	STA Status_Bar_Bottom , Y
	INX
	INY
	CPY #$1C
	BNE ToadExplainText1
	RTS


ToadByeMsg1:
	.byte $8A, $8B
	.byte " USE THE PIPE TO ESCAPE. I"

ToadByeMsg2:
	.byte $9A, $9B
	.byte " MUST STAY BEHIND FOR NOW."

ToadBye:
	LDA Objects_Timer, X
	BNE ToadBye0
	LDA #$00
	STA StatusBar_Mode
	RTS


ToadBye0:
	LDA #$01
	STA Player_HaltTick 
	LDA #$80
	STA StatusBar_Mode
	STA Last_StatusBar_Mode
	LDX #$00

ToadBye1:
	LDA ToadByeMsg1, X
	STA Status_Bar_Top , X
	LDA ToadByeMsg2, X
	STA Status_Bar_Bottom , X
	INX
	CPX #$1C
	BNE ToadBye1
	RTS