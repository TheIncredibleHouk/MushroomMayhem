; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-04-02 22:20:56.965729406 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup01 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $01 (i.e. objects starting at ID $24) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup01_InitJumpTable:
	.word ObjInit_CloudPlatFast	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjInit_PipewayCtlr	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjInit_WoodenPlat	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjInit_WoodenPlat	; Object $27 - OBJ_OSCILLATING_H
	.word ObjInit_WoodenPlat	; Object $28 - OBJ_OSCILLATING_V
	.word ObjInit_TowardsPlayer	; Object $29 - OBJ_SPIKE
	.word ObjInit_SparkRight		; Object $2A - OBJ_SPARKRIGHT
	.word ObjInit_SparkLeft		; Object $2B - OBJ_SPARKLEFT
	.word ObjInit_CloudPlatform	; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjInit_ChasingFish	; Object $2D - OBJ_BIGBERTHA
	.word ObjInit_DoNothing	; Object $2E - OBJ_PIRATEBOO
	.word ObjInit_DoNothing		; Object $2F - OBJ_BOO
	.word ObjInit_HotFootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjInit_Stretch		; Object $31 - OBJ_BOOSTRETCH
	.word ObjInit_StretchFlip	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word ObjInit_DoNothing		; Object $33 - OBJ_NIPPER
	.word ObjInit_Toad		; Object $34 - OBJ_TOAD
	.word ObjInit_DoNothing		; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjInit_WoodenPlatform	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjInit_OscillatingShort	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjInit_OscillatingShort	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjInit_NipperHopping	; Object $39 - OBJ_NIPPERHOPPING
	.word ObjInit_FallingPlatform	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjInit_ChasingFish	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjInit_WoodenFallingPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjInit_DoNothing		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjInit_FloatWoodenPlat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjInit_TowardsPlayer	; Object $3F - OBJ_DRYBONES
	.word ObjInit_BusterBeatle	; Object $40 - OBJ_BUSTERBEATLE
	.word ObjInit_DoNothing		; Object $41 - OBJ_ENDLEVELCARD
	.word ObjInit_CheepCheepP2P	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.word ObjInit_CheepCheepP2P2	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.word ObjInit_FallingPlatform	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjInit_HotFoot		; Object $45 - OBJ_HOTFOOT
	.word ObjInit_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjInit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup01_NormalJumpTable:
	.word ObjNorm_CloudPlat		; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjNorm_PipewayCtlr	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjNorm_WoodenPlatRider	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjNorm_OscillatingH	; Object $27 - OBJ_OSCILLATING_H
	.word ObjNorm_OscillatingV	; Object $28 - OBJ_OSCILLATING_V
	.word ObjNorm_Spike		; Object $29 - OBJ_SPIKE
	.word ObjNorm_Spark		; Object $2A - OBJ_SPARKRIGHT
	.word ObjNorm_Spark	; Object $2B - OBJ_SPARKLEFT
	.word ObjNorm_CloudPlat		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjNorm_BigBertha		; Object $2D - OBJ_BIGBERTHA
	.word ObjNorm_Boo	; Object $2E - OBJ_PIRATEBOO
	.word ObjNorm_Boo		; Object $2F - OBJ_BOO
	.word ObjNorm_HotfootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjNorm_Stretch		; Object $31 - OBJ_BOOSTRETCH
	.word ObjNorm_Stretch		; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word ObjNorm_Nipper		; Object $33 - OBJ_NIPPER
	.word ObjNorm_Toad		; Object $34 - OBJ_TOAD
	.word ObjNorm_ToadHouseItem	; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjNorm_WoodenPlatform	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjNorm_OscillatingH	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjNorm_OscillatingV	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjNorm_Nipper		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjNorm_PathFollowPlat	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjNorm_CharginCheepCheep	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjNorm_PathFollowPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjNorm_NipperFireBreathe	; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjNorm_WoodenPlatFloat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjNorm_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjNorm_BusterBeatle	; Object $40 - OBJ_BUSTERBEATLE
	.word ObjNorm_DoNothing	; Object $41 - OBJ_ENDLEVELCARD
	.word ObjNorm_CheepCheepP2P	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.word ObjNorm_CheepCheepP2P2	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.word ObjNorm_PathFollowPlat	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjNorm_Hotfoot		; Object $45 - OBJ_HOTFOOT
	.word ObjNorm_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjNorm_GiantBlockCtl	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup01_CollideJumpTable:
	.word ObjHit_CloudPlat		; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjHit_DoNothing		; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjHit_DoNothing		; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjHit_DoNothing		; Object $27 - OBJ_OSCILLATING_H
	.word ObjHit_DoNothing		; Object $28 - OBJ_OSCILLATING_V
	.word ObjHit_DoNothing		; Object $29 - OBJ_SPIKE
	.word Player_GetHurt		; Object $2A - OBJ_SPARKRIGHT
	.word Player_GetHurt	; Object $2B - OBJ_SPARKLEFT
	.word ObjHit_CloudPlat		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjHit_DoNothing		; Object $2D - OBJ_BIGBERTHA
	.word Player_Take_Coins		; Object $2E - OBJ_PIRATEBOO
	.word Player_GetHurt		; Object $2F - OBJ_BOO
	.word Player_GetHurt		; Object $30 - OBJ_HOTFOOT_SHY
	.word Player_GetHurt		; Object $31 - OBJ_BOOSTRETCH
	.word Player_GetHurt		; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word Player_GetHurt		; Object $33 - OBJ_NIPPER
	.word ObjHit_DoNothing		; Object $34 - OBJ_TOAD
	.word ObjHit_DoNothing		; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjHit_DoNothing		; Object $36 - OBJ_WOODENPLATFORM
	.word ObjHit_DoNothing		; Object $37 - OBJ_OSCILLATING_HS
	.word ObjHit_DoNothing		; Object $38 - OBJ_OSCILLATING_VS
	.word Player_GetHurt		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjHit_DoNothing		; Object $3A - OBJ_FALLINGPLATFORM
	.word Player_GetHurt		; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjHit_DoNothing		; Object $3C - OBJ_WOODENPLATFORMFALL
	.word Player_GetHurt		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjHit_DoNothing		; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjHit_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjHit_DoNothing		; Object $40 - OBJ_BUSTERBEATLE
	.word ObjHit_DoNothing	; Object $41 - OBJ_ENDLEVELCARD
	.word Player_GetHurt		; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.word Player_GetHurt		; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.word ObjHit_DoNothing		; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word Player_GetHurt		; Object $45 - OBJ_HOTFOOT
	.word Player_GetHurt		; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjHit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL

	
	; Object group $01 (i.e. objects starting at ID $24) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup01_Attributes:
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $25
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $27 - OBJ_OSCILLATING_H
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $28 - OBJ_OSCILLATING_V
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $29 - OBJ_SPIKE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2A - OBJ_SPARKRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2B - OBJ_SPARKLEFT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $2D - OBJ_BIGBERTHA
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2E - OBJ_PIRATEBOO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2F - OBJ_BOO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $31 - OBJ_BOOSTRETCH
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $33 - OBJ_NIPPER
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $34 - OBJ_TOAD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3F - OBJ_DRYBONES
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $45 - OBJ_HOTFOOT
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $47 - OBJ_GIANTBLOCKCTL

	; Object group $01 (i.e. objects starting at ID $24) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup01_Attributes2:
	.byte OA2_TDOGRP2	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA2_TDOGRP0	; Object $25
	.byte OA2_TDOGRP2	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA2_TDOGRP2	; Object $27 - OBJ_OSCILLATING_H
	.byte OA2_TDOGRP2	; Object $28 - OBJ_OSCILLATING_V
	.byte OA2_TDOGRP1	; Object $29 - OBJ_SPIKE
	.byte OA2_TDOGRP3	; Object $2A - OBJ_SPARKRIGHT
	.byte OA2_TDOGRP3	; Object $2B - OBJ_SPARKLEFT
	.byte OA2_TDOGRP2	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA2_TDOGRP0	; Object $2D - OBJ_BIGBERTHA
	.byte OA2_TDOGRP1	; Object $2E - OBJ_PIRATEBOO
	.byte OA2_TDOGRP1	; Object $2F - OBJ_BOO
	.byte OA2_TDOGRP0	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA2_TDOGRP1	; Object $31 - OBJ_BOOSTRETCH
	.byte OA2_TDOGRP1	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA2_TDOGRP1	; Object $33 - OBJ_NIPPER
	.byte OA2_TDOGRP2	; Object $34 - OBJ_TOAD
	.byte OA2_TDOGRP0	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA2_TDOGRP2	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA2_TDOGRP2	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA2_TDOGRP2	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA2_TDOGRP1	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA2_TDOGRP9	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA2_TDOGRP9	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA2_TDOGRP9	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA2_TDOGRP1	; Object $3F - OBJ_DRYBONES
	.byte OA2_NOSHELLORSQUASH | OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA2_TDOGRP0	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP0	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP0	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OA2_TDOGRP9	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA2_TDOGRP0	; Object $45 - OBJ_HOTFOOT
	.byte OA2_TDOGRP2	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA2_TDOGRP1	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup01_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $25
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $27 - OBJ_OSCILLATING_H
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $28 - OBJ_OSCILLATING_V
	.byte OA3_HALT_SPIKESPECIAL 	; Object $29 - OBJ_SPIKE
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE 	; Object $2A - OBJ_SPARKRIGHT
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE 	; Object $2B - OBJ_SPARKLEFT
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA3_HALT_NORMALONLY 	; Object $2D - OBJ_BIGBERTHA
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2E - OBJ_PIRATEBOO
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2F - OBJ_BOO
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $31 - OBJ_BOOSTRETCH
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $33 - OBJ_NIPPER
	.byte OA3_HALT_JUSTDRAWTALL | OA3_TAILATKIMMUNE	; Object $34 - OBJ_TOAD
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA3_HALT_JUSTDRAW 	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $3F - OBJ_DRYBONES
	.byte OA3_HALT_BUSTERSPECIAL 	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA3_HALT_ENDCARDSPECIAL | OA3_TAILATKIMMUNE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA3_HALT_JUSTDRAW 	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OA3_HALT_JUSTDRAW 	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $45 - OBJ_HOTFOOT
	.byte OA3_HALT_PIRANHASPECIAL 	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup01_PatTableSel:
	.byte OPTS_SETPT5 | $0E	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OPTS_NOCHANGE	; Object $25
	.byte OPTS_NOCHANGE	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OPTS_NOCHANGE	; Object $27 - OBJ_OSCILLATING_H
	.byte OPTS_NOCHANGE	; Object $28 - OBJ_OSCILLATING_V
	.byte OPTS_SETPT5 | $0A	; Object $29 - OBJ_SPIKE
	.byte OPTS_SETPT5 | $0A	; Object $2A - OBJ_SPARKRIGHT
	.byte OPTS_SETPT5 | $0A	; Object $2B - OBJ_SPARKLEFT
	.byte OPTS_SETPT5 | $0E	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OPTS_SETPT5 | $1A	; Object $2D - OBJ_BIGBERTHA
	.byte OPTS_SETPT5 | $4E	; Object $2E - OBJ_PIRATEBOO
	.byte OPTS_SETPT5 | $12	; Object $2F - OBJ_BOO
	.byte OPTS_SETPT5 | $12	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OPTS_SETPT5 | $12	; Object $31 - OBJ_BOOSTRETCH
	.byte OPTS_SETPT5 | $12	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OPTS_SETPT5 | $0A	; Object $33 - OBJ_NIPPER
	.byte OPTS_SETPT5 | $05	; Object $34 - OBJ_TOAD
	.byte OPTS_SETPT5 | $05	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OPTS_NOCHANGE	; Object $36 - OBJ_WOODENPLATFORM
	.byte OPTS_NOCHANGE	; Object $37 - OBJ_OSCILLATING_HS
	.byte OPTS_NOCHANGE	; Object $38 - OBJ_OSCILLATING_VS
	.byte OPTS_SETPT5 | $0A	; Object $39 - OBJ_NIPPERHOPPING
	.byte OPTS_SETPT6 | $13	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OPTS_SETPT6 | $4F	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OPTS_NOCHANGE	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OPTS_SETPT5 | $0A	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OPTS_NOCHANGE; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OPTS_SETPT6 | $13	; Object $3F - OBJ_DRYBONES
	.byte OPTS_SETPT5 | $0A	; Object $40 - OBJ_BUSTERBEATLE
	.byte OPTS_NOCHANGE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OPTS_SETPT6 | $4F	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OPTS_SETPT6 | $4F	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OPTS_NOCHANGE ; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OPTS_SETPT5 | $12	; Object $45 - OBJ_HOTFOOT
	.byte OPTS_SETPT5 | $0A	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OPTS_NOCHANGE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup01_KillAction:
	.byte KILLACT_STANDARD	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte KILLACT_STANDARD	; Object $25
	.byte KILLACT_STANDARD	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte KILLACT_STANDARD	; Object $27 - OBJ_OSCILLATING_H
	.byte KILLACT_STANDARD	; Object $28 - OBJ_OSCILLATING_V
	.byte KILLACT_STANDARD	; Object $29 - OBJ_SPIKE
	.byte KILLACT_STANDARD	; Object $2A - OBJ_SPARKRIGHT
	.byte KILLACT_STANDARD	; Object $2B - OBJ_SPARKLEFT
	.byte KILLACT_STANDARD	; Object $2C - OBJ_CLOUDPLATFORM
	.byte KILLACT_NORMALSTATE	; Object $2D - OBJ_BIGBERTHA
	.byte KILLACT_STANDARD	; Object $2E - OBJ_PIRATEBOO
	.byte KILLACT_STANDARD	; Object $2F - OBJ_BOO
	.byte KILLACT_POOFDEATH	; Object $30 - OBJ_HOTFOOT_SHY
	.byte KILLACT_POOFDEATH	; Object $31 - OBJ_BOOSTRETCH
	.byte KILLACT_POOFDEATH	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte KILLACT_STANDARD	; Object $33 - OBJ_NIPPER
	.byte KILLACT_STANDARD	; Object $34 - OBJ_TOAD
	.byte KILLACT_STANDARD	; Object $35 - OBJ_TOADHOUSEITEM
	.byte KILLACT_STANDARD	; Object $36 - OBJ_WOODENPLATFORM
	.byte KILLACT_STANDARD	; Object $37 - OBJ_OSCILLATING_HS
	.byte KILLACT_STANDARD	; Object $38 - OBJ_OSCILLATING_VS
	.byte KILLACT_STANDARD	; Object $39 - OBJ_NIPPERHOPPING
	.byte KILLACT_STANDARD	; Object $3A - OBJ_FALLINGPLATFORM
	.byte KILLACT_NORMALSTATE	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte KILLACT_STANDARD	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte KILLACT_STANDARD	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte KILLACT_STANDARD	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte KILLACT_NORMALANDKILLED	; Object $3F - OBJ_DRYBONES
	.byte KILLACT_STANDARD	; Object $40 - OBJ_BUSTERBEATLE
	.byte KILLACT_STANDARD	; Object $41 - OBJ_ENDLEVELCARD
	.byte KILLACT_STANDARD	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte KILLACT_STANDARD	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte KILLACT_STANDARD	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte KILLACT_POOFDEATH	; Object $45 - OBJ_HOTFOOT
	.byte KILLACT_NORMALSTATE	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte KILLACT_STANDARD	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) pattern index starts
	; These are used for all states except "normal"

OG1_POff .func (\1 - ObjectGroup01_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup01_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG1_POff(ObjP24), OG1_POff(ObjP25), OG1_POff(ObjP26), OG1_POff(ObjP27)
	.byte OG1_POff(ObjP28), OG1_POff(ObjP29), OG1_POff(ObjP2A), OG1_POff(ObjP2B)
	.byte OG1_POff(ObjP2C), OG1_POff(ObjP2D), OG1_POff(ObjP2E), OG1_POff(ObjP2F)
	.byte OG1_POff(ObjP30), OG1_POff(ObjP31), OG1_POff(ObjP32), OG1_POff(ObjP33)
	.byte OG1_POff(ObjP34), OG1_POff(ObjP35), OG1_POff(ObjP36), OG1_POff(ObjP37)
	.byte OG1_POff(ObjP38), OG1_POff(ObjP39), OG1_POff(ObjP3A), OG1_POff(ObjP3B)
	.byte OG1_POff(ObjP3C), OG1_POff(ObjP3D), OG1_POff(ObjP3E), OG1_POff(ObjP3F)
	.byte OG1_POff(ObjP40), OG1_POff(ObjP41), OG1_POff(ObjP42), OG1_POff(ObjP43)
	.byte OG1_POff(ObjP44), OG1_POff(ObjP45), OG1_POff(ObjP46), OG1_POff(ObjP47)


	; Object group $01 (i.e. objects starting at ID $24) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup01_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup01_PatternSets:
	; (End restricted alignment space)

ObjP25:
ObjP2F:
ObjP35:
ObjP47:
	.byte $95, $97, $B9, $BF
ObjP30:
ObjP45:
	.byte $85, $87, $89, $8B, $81, $83
ObjP31:
ObjP32:
	.byte $A1, $A3, $A5, $A7, $A9, $AB, $AD, $AF, $71, $71
ObjP26:
ObjP27:
ObjP28:
ObjP36:
ObjP37:
ObjP38:
ObjP3C:
ObjP3E:
ObjP44:
	.byte $5B, $5D, $5D, $5D, $5D, $5F
ObjP33:
ObjP39:
	.byte $A1, $A3, $AD, $AF, $A5, $A7, $A9, $AB
ObjP34:
	.byte $71, $71, $71, $71 ; #DAHRKDAIZ - Toad looks like Hammer Bros.
ObjP3D:
	.byte $A1, $A3, $A5, $A7, $A9, $AB
ObjP2D:
	.byte $81, $83, $85, $8D, $A1, $8B, $81, $83, $85, $87, $89, $8B, $81, $83, $85, $87, $89, $A4, $81, $83, $85, $8D, $A1, $8B, $81, $83, $85, $8D, $A1, $A4, $71, $A3, $A5, $71, $71, $71, $71, $99, $9B, $71, $71, $71
ObjP24:
ObjP2C:
	.byte $81, $83, $83, $83, $85, $87
ObjP3F:
	.byte $C1, $C3, $C5, $C7, $C9, $CB, $CD, $CF, $D1, $D3, $D5, $F9, $DD, $DF
	
	; Spike's / Patooie's spike ball patterns are actually here
SpikeBall_Patterns:
	.byte $95, $95, $D9, $DB
ObjP29:
ObjP2A:
ObjP2B:
	.byte $BD, $BD, $BF, $BF
ObjP46:
	.byte $E5, $E5, $E1, $E1, $E1, $E1, $BD, $BF, $E3, $E3
ObjP3B:
ObjP42:
ObjP43:
	.byte $E7, $E9, $E7, $EF, $E7, $EF
ObjP3A:
	.byte $71, $E1, $E3, $E1, $E3, $71
ObjP2E:
	.byte $71, $71, $A9, $AB
ObjP41:
	.byte $51, $51, $53, $53, $55, $55, $F7, $F7, $F9, $F9, $FB, $FB, $E3, $E3, $E5, $E5, $F5, $F5, $FD, $FD, $FD, $FD, $FD, $FD, $E3, $E3, $E5, $E5, $F5, $F5, $D1, $D3, $D5, $D7
ObjP40:
	.byte $B1, $B3, $B5, $B7, $B9, $BB, $75, $75

GiantBlockCtl_BlkBump:	.byte $00 ;CHNGTILE_GIANTBRICKFIX, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBRICKBUST
GiantBlockCtl_BlockStarts:	.byte $00 ;TILE11_BRICK_UL, TILE11_QBLOCKC_UL, TILE11_QBLOCKP_UL
GiantBlockCtl_Frames:	.byte $00, $08, $08

	.byte $00

PRG002_A27B:
	.byte $00, $00, $50, $40, $30, $20, $00, $E0, $D0, $C0, $B0

ObjNorm_GiantBlockCtl:
	RTS		 ; Return

PRG002_A2DB:
	JSR PRG002_A450

	LDA <Player_HaltGame
	BEQ PRG002_A2E3	 ; If gameplay halted, jump to PRG002_A2E3

	RTS		 ; Return

PRG002_A2E3:
	LDA Objects_Timer,X
	CMP #$0a
	BNE PRG002_A30C	 ; If timer <> $0A, jump to PRG002_A30C

	; Timer = $0A...

	PHA		 ; Save timer value

	; Object Y Hi -> Temp_Var13
	LDA <Objects_YHi,X
	STA <Temp_Var13	

	; Object Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14	

	; Object X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15	

	; Object X -> Temp_Var16
	LDA <Objects_X,X
	PHA		 ; Save Object X
	STA <Temp_Var16

	; Clear this tile
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore 'X'
	ORA #$10	 ; Intended as next tile to the right I think
	STA <Temp_Var16	 ; -> Temp_Var16

	; Clear this tile too
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore timer

PRG002_A30C:
	TAY		 ; current timer value -> 'Y'
	LDA PRG002_A27B,Y	
	STA <Objects_YVel,X	 ; Applies a staggering Y velocity

	JMP Object_ApplyYVel	 ; Apply Y velocity and don't come back!

GiantBlockCtl_DebrisXOff:	.byte $00, $10, $00, $10
GiantBlockCtl_DebrisYOff:	.byte $00, $00, $10, $10
GiantBlockCtl_DebrisXVel:	.byte -$10, $10, -$10, $10
GiantBlockCtl_DebrisYVel	.byte -$40, -$40, -$28, -$28

PRG002_A325:
	; Set like Player bounced up
	LDA #$01	 
	STA Player_BounceDir

	LDA <Temp_Var11	 ; A = Temp_Var11 (previous Var2)
	BNE PRG002_A35E	 ; If non-zero, jump to PRG002_A35E

	; Play "bump" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	; Set Object Y Hi = Player's Y Hi
	LDA <Player_YHi
	STA <Objects_YHi,X

	LDA <Player_Y

	LDY <Player_Suit
	BEQ PRG002_A347	 ; If Player is small, jump to PRG002_A347

	; Player is NOT small; subtract 16
	SUB #$10
	BCS PRG002_A347
	DEC <Objects_YHi,X	; Apply carry
PRG002_A347:

	AND #$f0	 ; Align to tile grid row
	ORA #$10	 ; Ensures nearest 32
	STA <Objects_Y,X ; -> Object_Y

	; Set Object X Hi = Player's X Hi
	LDA <Player_XHi	
	STA <Objects_XHi,X

	; Use Player X + 8
	LDA <Player_X
	ADD #$08	
	BCC PRG002_A35A	
	INC <Objects_XHi,X	; Apply carry
PRG002_A35A:

	AND #$e0	 ; Aligned to tile grid, left side only
	STA <Objects_X,X ; -> Object_X

PRG002_A35E:

	; Set BlkBump slot 2 coordinates to the object's position

	LDA <Objects_X,X
	STA Level_BlkBump_XLo+2

	LDA <Objects_XHi,X
	STA Level_BlkBump_XHi+2

	LDA <Objects_YHi,X
	STA Level_BlkBump_YHi+2

	LDA <Objects_Y,X
	STA Level_BlkBump_YLo+2

	;LDA #CHNGTILE_GIANTBRICKBUST
	STA Level_BlkBump+2

	LDA Objects_Var1,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GBCtl_BrickBump	; 0: Giant brick bump (small Player hit it)
	.word GBCtl_CoinBlock	; 1: Giant [?] block with coin
	.word GBCtl_LeafBlock	; 2: Giant [?] block with power up
	.word GBCtl_BrickBust	; 3: Giant brick bust

GBCtl_BrickBump:
	JMP PRG002_A420	; Jump to PRG002_A420

GBCtl_CoinBlock:
	INC Coins_Earned	 ; Give a coin

	LDA <Objects_Y,X
	STA <Temp_Var1		; Temp_Var1 = Object's Y

	LDA <Objects_X,X
	ORA #$0e
	STA <Temp_Var2		; Temp_Var2 = Object's X aligned evenly in column

	JSR Produce_Coin	 ; Init for emerging coin

	JMP PRG002_A420	 ; Jump to Produce_Coin

GBCtl_LeafBlock:
	LDA <Player_X
	AND #$10
	STA Player_MushFall ; Determine which way a powerup should fall

	LDA #$1e	; A = $1E if Player is not small (Super Leaf)

	LDY <Player_Suit
	BNE PRG002_A3AA	 ; If Player is NOT small, jump to PRG002_A3AA

	LDA #$0d	 ; Otherwise, A = $0D (Mushroom)

PRG002_A3AA:
	LDY #$05	 ; Y = 5 (altering fifth object slot)

	; Make power up appear
	STA Level_ObjectID,Y

	; Set State = 1 (Init)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set X as +8 from Object X
	LDA <Objects_X,X
	ADD #$08
	STA Objects_X,Y

	; Match other coordinates
	LDA <Objects_XHi,X
	STA Objects_XHi,Y
	LDA <Objects_Y,X
	STA Objects_Y,Y	
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	JMP PRG002_A420	 ; Jump to PRG002_A420

GBCtl_BrickBust:
	; Crumbling brick noise
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDX #$03	 ; X = 3 (looking for up to 4 special objects, the brick debris)
	LDY #$05	 ; Y = 5

PRG002_A3DA:
	LDA SpecialObj_ID,Y
	BEQ PRG002_A3E5	 ; If this special object slot is free, jump to PRG002_A3E5

	DEY		 ; Y--
	BPL PRG002_A3DA	 ; While Y >= 0, loop!

	JMP PRG002_A417	 ; Jump to PRG002_A417

PRG002_A3E5:

	; Found a free slot!

	; Brick debris
	LDA #SOBJ_BRICKDEBRIS
	STA SpecialObj_ID,Y

	; Set brick debris coordinates
	LDA GiantBlockCtl_DebrisXOff,X
	ADD Level_BlkBump_XLo+2	
	STA SpecialObj_XLo,Y	

	LDA GiantBlockCtl_DebrisYOff,X	
	ADD Level_BlkBump_YLo+2
	STA SpecialObj_YLo,Y
	LDA #$00	
	ADC Level_BlkBump_YHi+2	
	STA SpecialObj_YHi,Y	

	; Set brick debris X Velocity
	LDA GiantBlockCtl_DebrisXVel,X	
	STA SpecialObj_XVel,Y	

	; Set brick debris Y Velocity
	LDA GiantBlockCtl_DebrisYVel,X	
	STA SpecialObj_YVel,Y

	; Brick data = 0
	LDA #$00
	STA SpecialObj_Data,Y

PRG002_A417:
	DEY		 ; Y--
	DEX		 ; X--
	BPL PRG002_A3DA	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_A420	 ; Jump to PRG002_A420

PRG002_A420:
	LDA <Temp_Var11	; A = Temp_Var11 (previous Var2)
	BNE PRG002_A428	 ; If non-zero, jump to PRG002_A428

	; Otherwise, halt Player's vertical movement
	LDA #$00
	STA <Player_YVel

PRG002_A428:

	; Set timer to $0B
	LDA #$0b
	STA Objects_Timer,X

	JMP PRG002_A450	 ; Jump to PRG002_A450

GiantBlockCtl_Pats:	.byte $73, $7B, $7B, $73, $7D, $7F, $7F, $7D, $79, $7B, $7B, $79, $79, $7B, $7B, $79
GiantBlockCtl_Attrs:	.byte $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_VFLIP, SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, SPR_HFLIP | SPR_VFLIP

PRG002_A450:
	LDA Objects_Var1,X
	CMP #$03
	BEQ PRG002_A487	 ; If Var1 = 3, jump to PRG002_A487 (RTS)

	JSR Object_CalcSpriteXY_NoHi

	LDA <Objects_SpriteX,X
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X

	PHA		 ; Save it

	DEC <Objects_SpriteY,X	 ; Sprite Y--

	LDA <Objects_SpriteY,X
	STA <Temp_Var3		 ; Temp_Var3 = Sprite Y

	PHA		 ; Save it

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_Frame,X
	TAX		 ; X = object's frame
	JSR GiantBlockCtl_Draw
	JSR GiantBlockCtl_Draw

	PLA		 ; Restore Sprite Y
	ADD #16
	STA <Temp_Var3	 ; Temp_Var3 = Sprite Y + 16

	PLA		 ; Restore Sprite X
	STA <Temp_Var2	 ; -> Temp_Var2

	JSR GiantBlockCtl_Draw
	JSR Object_GetRandNearUnusedSpr	 ; Get random nearby unused sprite
	JSR GiantBlockCtl_Draw

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_A487:
	RTS		 ; Return

GiantBlockCtl_Draw:
	LDA Player_AboveTop
	BNE PRG002_A4B7	 ; If Player is way up high, jump to PRG002_A4B7 (RTS)

	LDA #$02
	STA <Temp_Var5	 ; Temp_Var5 = 2
PRG002_A4A4:
	; Store Sprite Y
	LDA <Temp_Var3
	STA Sprite_RAM+$00,Y

	; Store appropriate pattern
	LDA GiantBlockCtl_Pats,X
	STA Sprite_RAM+$01,Y

	; Set attributes
	LDA #SPR_PAL3	; Palette select 3
	ORA GiantBlockCtl_Attrs,X	; And what he's having
	STA Sprite_RAM+$02,Y

	; Store Sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; X += 8
	ADD #$08
	STA <Temp_Var2

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	INX		 ; X++ (next pattern/attribute)

	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG002_A4A4	 ; While Temp_Var5 > 0, loop!

PRG002_A4B7:
	RTS		 ; Return

	; Carry is set if gameplay not halted and object not dead
CarryClearIfAliveAndNoHalt:
	LDA Objects_State,X	  
	CMP #OBJSTATE_KILLED	; Carry is clear unless state >= OBJSTATE_KILLED
	BEQ PRG002_A4C5	 ; If object state is Dying, jump to PRG002_A4C5

	CLC		 ; Clear carry (if any state other than OBJSTATE_KILLED)

	LDA <Player_HaltGame
	BEQ PRG002_A4C5	 ; If gameplay is not halted, jump to PRG002_A4C5

	SEC		 ; Set carry

PRG002_A4C5:
	RTS		 ; Return

Buster_XVel:	.byte -$10, $10

ObjInit_BusterBeatle:
	LDY <Scroll_LastDir	; Get last scroll direction

	; Set flip bits to face Player
	LDA FacePlayer_FlipBitsStart,Y
	STA Objects_FlipBits,X

	; Set appropriate X velocity for Buster Beatle
	LDA Buster_XVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return


ObjNorm_BusterBeatle:

	JSR Object_Move	 ; Do standard object movements
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block
	JSR Object_HitFloorAlign	 ; If Buster hits floor, align him

	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG002_A535	 ; If not hit wall, jump to PRG002_A535

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A532	 ; If Buster has not hit floor, jump to PRG002_A532

	JSR Object_AnySprOffscreen
	BNE PRG002_A532	 ; If any of Buster's sprite are off-screen, jump to PRG002_A532

	LDY #$02	; Y = 1 (Buster's got brick!)

	LDA Object_TileWall
	AND #$F0
	CMP #TILE_PROP_SOLID_ALL
	BNE PRG002_A532
	LDA Object_TileWall
	AND #$0F
	CMP #TILE_PROP_STONE
	BNE PRG002_A532	 ; If Buster's touching an ice brick, jump to PRG002_A508


	STY <Objects_Var5,X	 ; Update Var5

	; Change tile event (to background) by ice brick
	LDA #01
	STA Level_ChgTileEvent

	; Set all of the block change coordinates to remove the ice brick
	LDA ObjTile_DetYHi
	STA Level_BlockChgYHi

	LDA ObjTile_DetYLo
	AND #$f0
	STA Level_BlockChgYLo

	LDA ObjTile_DetXHi
	STA Level_BlockChgXHi

	LDA ObjTile_DetXLo
	AND #$f0
	STA Level_BlockChgXLo

	; Set Buster's timer 2 to $0F
	LDA #$0f
	STA Objects_Timer2,X

	BNE PRG002_A535	 ; Jump (technically always) to PRG002_A535

PRG002_A532:
	JSR Object_AboutFace	 ; Buster turns around

PRG002_A535:
	LDA Objects_Timer,X
	BNE PRG002_A542	 ; If timer not expired, jump to PRG002_A542

	LDA Objects_Timer2,X 
	BEQ PRG002_A542	 ; If timer 2 expired, jump to PRG002_A542

	; Timer 2 not expired...
	ADD #29	 ; Add to timer 2 value

PRG002_A542:
	LSR A		 
	STA <Objects_Var4,X	 ; Var4 = timer2 / 2

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Buster_DrawHoldingIceBrick	 ; Draw Buster with his ice brick if he has it

	LDA <Objects_Var5,X
	ORA Objects_Timer,X
	BNE PRG002_A568	 	; If Buster is holding a brick or his timer is not expired, jump to PRG002_A568

	LDY #$10	 ; Y = $10 (Run right)

	LDA Objects_FlipBits,X
	ASL A
	BMI PRG002_A55C	 ; If horizontally flipped, jump to PRG002_A55C

	LDY #-$10	 ; Y = -$10 (Run left)

PRG002_A55C:
	STY <Objects_XVel,X	 ; Set Buster's X Velocity

	; Buster's little frame toggle
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A568:

	; Buster with brick or timer not expired

	; Halt Buster's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDA Objects_Timer2,X
	BEQ PRG002_A57B	 ; If Timer 2 expired, jump to PRG002_A57B

	; Timer 2 not expired...

	AND #%00011000
	BNE PRG002_A5A1	 ; Timing jump to PRG002_A5A1 (RTS)
 
	; Buster's frame = 2 
	LDA #$02
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A57B:
	LDA Objects_Timer,X
	BEQ PRG002_A587	 ; If timer expired, jump to PRG002_A587

	CMP #$11
	BNE PRG002_A5A1	 ; If timer <> $11, jump to PRG002_A5A1 (RTS)
	JMP PRG002_A5A2	 ; Otherwise, jump to PRG002_A5A2

PRG002_A587:
	LDA <Counter_1
	AND #$07
	BNE PRG002_A5A1	 ; 1:8 ticks continue, otherwise jump to PRG002_A5A1 (RTS)

	; Set Buster's flip to face towards Player
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	CMP #$0c
	BGE PRG002_A5A1	 ; If Player is too far away, jump to PRG002_A5A1 (RTS)

	; "Stay close for $1B and I'll getcha..."
	LDA #$1b
	STA Objects_Timer,X

PRG002_A5A1:
	RTS		 ; Return

PRG002_A5A2:
	LDX #$04	 ; X = 4

PRG002_A5A4:
	LDA Objects_State,X
	BEQ PRG002_A5AE	 ; If this object slot's state is Dead/Empty, jump to PRG002_A5AE

	DEX		 ; X--
	BPL PRG002_A5A4	 ; While X >= 0, loop!
	BMI PRG002_A5F8	 ; Otherwise, jump to PRG002_A5F8

PRG002_A5AE:
	JSR Level_PrepareNewObject	; Generate new object for tossed ice block

	LDY <SlotIndexBackup	 ; Y = Buster's slot index

	; Var5 and Frame = 0
	LDA #$00
	STA Objects_Var5,Y
	STA Objects_Frame,Y

	; Set Ice Block to state Kicked
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	; It's an Ice Block
	LDA #OBJ_STONEBLOCK
	STA Level_ObjectID,X

	LDA #$01
	STA Objects_SprAttr, X

	; Set Frame = 2
	LDA #$00
	STA Objects_Frame,X

	; Set expiration timer
	LDA #$ff
	STA Objects_Timer3,X

	; Set X
	LDA Objects_X,Y
	STA <Objects_X,X

	; Set X Hi
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	; Set Y/Hi
	LDA Objects_Y,Y
	SUB #16
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	LDA Objects_FlipBits,Y

	LDY #$30	 ; Y = $30
	ASL A
	BMI PRG002_A5F2	 ; If Buster's turned around, jump to PRG002_A5F2
	LDY #-$30	 ; Otherwise, Y = -$30
PRG002_A5F2:
	STY <Objects_XVel,X

	; Set Y velocity
	LDA #-$30
	STA <Objects_YVel,X

PRG002_A5F8:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Buster_BlockLiftXOff:
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $02, $03, $02, $01, $00
	.byte $01, $03, $05, $07, $08, $09, $0A, $0A

Buster_BlockLiftYOff:
	.byte -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0D
	.byte -$0C, -$0D, -$0E, -$0E, -$0F, -$0E, -$0D, -$0B, -$09, -$06, -$03, $00 

Buster_DrawHoldingIceBrick:
	JSR Object_ShakeAndCalcSprite	 

	LDA <Temp_Var3
	BPL PRG002_A641	 ; If object is not vertically flipped, jump to PRG002_A641

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var4,X
	TAX		 	; X = Var4 (lift offset index)

	; Offset sprite Y by the index given in Var4
	LDA <Temp_Var1
	ADD Buster_BlockLiftYOff,X
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = Var6

PRG002_A641:
	JSR Object_Draw16x16Sprite	 ; Draw Buster

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var5,X
	BEQ PRG002_A68B	 	; If Var5 = 0 (not holding brick), jump to PRG002_A68B (RTS)

	; Var5 not zero...

	PHA		 	; Save Var5

	LDA <Objects_SpriteY,X

	LDY <Objects_Var4,X	 ; Y = Var4

	BIT <Temp_Var3
	BMI PRG002_A657	 	; If vertically flipped, jump to PRG002_A657

	; Adds an offset in case Buster's holding a block... but since it's
	; applied all the time, it just looks odd otherwise...
	ADD Buster_BlockLiftYOff,Y

PRG002_A657:
	STA <Temp_Var1		 ; Update Sprite Y

	LDA Buster_BlockLiftXOff,Y
	BIT <Temp_Var3
	BVS PRG002_A663	 ; If Buster is horizontally flipped, jump to PRG002_A663

	JSR Negate	 ; Negate the X offset if he's flipped around

PRG002_A663:
	ADD <Temp_Var2	; Apply X offset
	STA <Temp_Var2	; Update Sprte X

	PLA		 ; Restore Var5

	LDA <Temp_Var7
	ADD #$08	
	TAY		 ; Y = Sprite_RAM + 8
	
	LDA <Temp_Var1
	STA Sprite_RAM , Y
	STA Sprite_RAM + 4, Y
	LDA <Temp_Var2
	STA Sprite_RAM + 3, Y
	ADC #$08
	STA Sprite_RAM + 7, Y
	LDA #$01
	STA Sprite_RAM + 2, Y
	STA Sprite_RAM + 6, Y
	LDA #$97
	STA Sprite_RAM + 1, Y
	LDA #$99
	STA Sprite_RAM + 5, Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_A68B:
	RTS		 ; Return

ObjInit_PipewayCtlr:
	; Changes Objects_Y into a grid row position (including the high) rather than a pixel position
	; Used as index (see ObjNorm_PipewayCtlr)
	LSR <Objects_YHi,X
	LDA <Objects_Y,X
	ROR A	; Carries in the high bit, first division
	LSR A
	LSR A
	LSR A	; Completes divide-by-16 (makes grid row position)
	STA <Objects_Y,X

	; Flag we were just in a Pipeway
	INC Map_WasInPipeway

	RTS		 ; Return

	; Sets the "Map_Entered_XHi" value based on whether you're coming or going
	; That means the Player's X Hi position on the map (not screen scroll position!)
	; Almost the same as PipewayCtlr_MapScrlXHi without the centering bit.
PipewayCtlr_MapXHi:
	.byte $10	; 0
	.byte $00	; 1
	.byte $00	; 2
	.byte $11	; 3
	.byte $00	; 4
	.byte $00	; 5
	.byte $00	; 6
	.byte $01	; 7
	.byte $01	; 8
	.byte $01	; 9
	.byte $11	; 10
	.byte $11	; 11
	.byte $01	; 12
	.byte $12	; 13
	.byte $23	; 14
	.byte $01	; 15
	.byte $12	; 16
	.byte $22	; 17
	.byte $00	; 18
	.byte $01	; 19
	.byte $12	; 20
	.byte $01	; 21
	.byte $01	; 22
	.byte $00	; 23


	; This contains two values for Map X (*16) whether you're coming or going.
	; That means the Player's X Lo position on the map (not screen scroll position!)
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
PipewayCtlr_MapX:
	.byte $8C	; 0
	.byte $8E	; 1
	.byte $4E	; 2
	.byte $06	; 3
	.byte $43	; 4
	.byte $6D	; 5
	.byte $59	; 6
	.byte $50	; 7
	.byte $81	; 8
	.byte $B6	; 9
	.byte $2D	; 10
	.byte $3A	; 11
	.byte $8C	; 12
	.byte $22	; 13
	.byte $62	; 14
	.byte $6A	; 15
	.byte $8C	; 16
	.byte $4C	; 17
	.byte $4A	; 18
	.byte $A6	; 19
	.byte $4D	; 20
	.byte $4A	; 21
	.byte $22	; 22
	.byte $46	; 23

	; This contains two values for Map Y (*16) whether you're coming or going.
	; That means the Player's Y position on the map
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
PipewayCtlr_MapY:
	.byte $44	; 0
	.byte $86	; 1
	.byte $84	; 2
	.byte $62	; 3
	.byte $57	; 4
	.byte $53	; 5
	.byte $73	; 6
	.byte $99	; 7
	.byte $95	; 8
	.byte $57	; 9
	.byte $74	; 10
	.byte $53	; 11
	.byte $37	; 12
	.byte $55	; 13
	.byte $57	; 14
	.byte $53	; 15
	.byte $57	; 16
	.byte $99	; 17
	.byte $A8	; 18
	.byte $A6	; 19
	.byte $68	; 20
	.byte $48	; 21
	.byte $84	; 22
	.byte $44	; 23

	; This is for the horizontal scroll position of the map.
	; The lower bits of each nibble specify the hard screen position 
	; (i.e. scroll X Hi) and if the highest bit is set means to use
	; the center $80 position instead of the $00 position.
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
PipewayCtlr_MapScrlXHi:
	.byte $10	; 0
	.byte $08	; 1
	.byte $08	; 2
	.byte $81	; 3
	.byte $00	; 4
	.byte $08	; 5
	.byte $00	; 6
	.byte $08	; 7
	.byte $08	; 8
	.byte $01	; 9
	.byte $81	; 10
	.byte $81	; 11
	.byte $01	; 12
	.byte $12	; 13
	.byte $23	; 14
	.byte $01	; 15
	.byte $12	; 16
	.byte $22	; 17
	.byte $00	; 18
	.byte $01	; 19
	.byte $12	; 20
	.byte $01	; 21
	.byte $08	; 22
	.byte $00	; 23

ObjNorm_PipewayCtlr:
	LDA #$00
	STA Objects_UseShortHTest,X
	JMP Object_DeleteOffScreen

; #TOREMOVE
;PipewyCtl_SetCarryByPPos:
;	LDY <Objects_YHi,X	 
;	BNE PRG002_A749	 ; If Player is on lower part of level, jump to PRG002_A749
;
;	; Player is on upper part of level...
;
;	LDA <Player_SpriteX
;	ASL A		 ; Set carry by Player's sprite X bit 7 (i.e. Player on right half of screen sets carry = 1)
;	RTS		 ; Return
;
;PRG002_A749:
;
;	; Player is on lower part of level...
;
;	LDA <Player_YHi	
;	LSR A		 ; Set carry = 1
;	RTS		 ; Return


PipewyCtl_GetUpperValue:
	BIT <Temp_Var1
	BPL PRG002_A755	 ; If , jump to PRG002_A755

	; Shift value into upper 4 bits
	ASL A
	ASL A
	ASL A
	ASL A

PRG002_A755:
	AND #%11110000	; Keep only upper 4 bits
	RTS		 ; Return

ObjInit_CheepCheepP2P2:
	LDA #$04
	STA <Objects_Var4,X	 ; Var4 = 4

ObjInit_CheepCheepP2P:
	LDA #$00
	STA Objects_InWater,X
	RTS

Restart_CheepCheepP2P2:
	; Timer = $40
	LDA #$20
	STA Objects_Timer,X

	; Set attribute $20 (sprite priority)
	LSR A
	STA Objects_FlipBits,X

	RTS		 ; Return

CheepP2P_XVel:	.byte -$10, -$10, $10, $10, $10, -$10
CheepP2P_YVel:	.byte -$36, -$36, -$47, -$47, -$4F, -$4F

PRG002_A772:	.byte $20, $20, -$20, -$20, $00, $00
	
ObjNorm_CheepCheepP2P:
	LDA Objects_Timer,X
	BEQ PRG002_A793	 ; If timer expired, jump to PRG002_A793

	; Timer not expired...

	LSR A
	BNE PRG002_A7932	 ; If timer > 1, jump to PRG002_A7E0

	; Timer = 1...

	; Loop Var4 3-0
	LDY <Objects_Var4,X	; Y = Var4
	DEY		 	; Y--
	BPL PRG002_A787	 	; If Y >= 0, jump to PRG002_A787
	LDY #$03	 	; Otherwise, Y = 3
PRG002_A787:
	STY <Objects_Var4,X	; Update Var4
	
	; if cheep cheep is not in water
	CLC
	LDA Objects_InWater,X
	BNE CCInWater
	SEC 

CCInWater:
; Set Cheep Cheep's Y Velocity
	LDA CheepP2P_YVel,Y
	BCC NormCCVelY
; cheep cheep is not in water, dampen it's jump
	ADC #$1F
NormCCVelY:
	STA <Objects_YVel,X

	; Set Cheep Cheep's X velocity
	LDA CheepP2P_XVel,Y
	STA <Objects_XVel,X

PRG002_A793:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity

PRG002_A7932:
	JSR Player_HitEnemy	 ; Standard Enemy Collision routine

	LDY <Objects_YVel,X	; Y = Cheep Cheep's Y velocity

	; Y += 2 (gravity)
	INY
	INY

	TYA		 		 ; Restore velocity
	STA <Objects_YVel,X	 ; Set it (ignore the water velocity)

; this detects a solid tile. If the fish is on a solid tile the cheep cheep is considered "beached"
	JSR Object_WorldDetectN1
	LDA <Objects_DetStat,X 
	PHA
	AND #$04 
	BEQ NotBeached
	LDA #$D8
	STA <Objects_YVel,X
	LDA <Objects_XVel,X
	BNE NotBeached
	LDA #$-10
	STA <Objects_XVel,X

; if it hits a wall it reverses direction
NotBeached:
	PLA
	PHA
	AND #$03
	BEQ  NotHittingWall
	LDA <Objects_XVel,X
	EOR #$FF
	ADD #$01
	STA <Objects_XVel,X

NotHittingWall:
	PLA
	AND #$08
	BEQ NotHittingCeiling
	LDA #$00
	STA <Objects_YVel, X

NotHittingCeiling:
	; NOTE: This only works on a limited range of velocities (not a problem here)
	; but it should have been a right shift for a more general implementation.
	LDA <Objects_XVel,X
	ASL A
	AND #SPR_HFLIP
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Set facing by velocity

	LDY <Objects_Var4,X	 ; Y = Var4

	LDA <Objects_Var5,X
	ADD Object_VelCarry
	CMP PRG002_A772,Y
	BLS PRG002_A7D4	 ; If Var5 < limit value, jump to PRG002_A7D4

	; Limit value hit...

	LDA Objects_InWater, X
	BEQ PRG002_A7D4	 ; If Cheep Cheep is not water, jump to PRG002_A7D4

	JSR Restart_CheepCheepP2P2	 ; Re-initialize!

	LDA #$00	 ; Reset Var5

PRG002_A7D4:
	STA <Objects_Var5,X	 ; Update Var5

	; Toggle Cheep Cheep's frame
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

PRG002_A7E0:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JMP Object_ShakeAndDraw	 ; Draw Cheep Cheep and don't come back!

ObjNorm_CheepCheepP2P2:

	; Alternate pool-to-pool Cheep Cheep is pretty much the same,
	; and reuses most of the code, just inverts the movements...

	LDA Objects_Timer,X
	BEQ PRG002_A793	 ; If timer not expired, jump to PRG002_A793

	LSR A
	BNE PRG002_A7E0	 ; If timer > 1, jump to PRG002_A7E0

	LDA <Objects_Var4,X
	EOR #$01	 ; Invert Var4
	TAY		 ; -> Y
	JMP PRG002_A787	 ; Jump (technically always) to PRG002_A787

	; Different "entropy" values by the object's slot -- keeps things random looking
Entropy_BySlot:	.byte $13, $D7, $F9, $36, $7F

ObjInit_HotFoot:
	LDA Entropy_BySlot,X
	STA <Objects_Var5,X

ObjInit_HotFootShy:

	; Center Hot Foot
	LDA <Objects_X,X
	ORA #$04
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_HotfootShy:
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; Hotfoot's gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	JSR Object_WorldDetectN1
	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG002_A81B	 ; If Hotfoot hit a wall, jump to PRG002_A81B

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG002_A81B:
	JSR Object_HitFloorAlign	 ; If HotFoot hits the floor, align him to it
	JSR Boo_CheckPlayerSight	 ; Uses Boo's check-facing logic

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot has NOT hit floor, jump to PRG002_A846

	LDA #$00	; Don't move (if not chasing Player)

	BCC PRG002_A844	 ; (From Boo_CheckPlayerSight) if not chasing Player, jump to PRG002_A844

	; Hotfoot is chasing Player...

	; Face same way as Player
	LDA <Player_FlipBits
	STA Objects_FlipBits,X

PRG002_A832:
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02
	TAY		 ; Y = 0 or 2

	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA #$08	; Walk right

	BCS PRG002_A844	; If horizontally flipped, jump to PRG002_A844

	LDA #-$08	; Walk left

PRG002_A844:
	STA <Objects_XVel,X	 ; Set X velocity appropriately

PRG002_A846:
	TYA		 ; A = 0 or 2
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_A850:
	LSR Objects_Frame,X	 ; Frame becomes 0 or 1 (to be ROLled back)

	LDA <Counter_1
	LSR A	
	ROL Objects_Frame,X	 ; Frame is now 0/1 or 2/3, depending on counter LSb (flickering effect) 

Bank2_HotFootHaltAction:
	JSR Object_AnySprOffscreen
	BNE PRG002_A888	 ; If any of Hotfoot's sprites are off-screen, jump to PRG002_A888 (RTS)

	JSR Object_CalcSpriteXY_NoHi	; Calculate Hotfoot's sprites
	LDY ObjGroupRel_Idx	 	; Y = Object's group relative index
	LDA ObjectGroup_PatternStarts,Y	; Get Hotfoot's starting pattern index
	ADD Objects_Frame,X	 	; Offset by frame
	TAY		 		; -> 'Y'
	LDA ObjectGroup_PatternSets,Y	; Get appropriate sprite pattern for this frame

	; Store pattern into sprite RAM
	LDY Object_SprRAM,X
	STA Sprite_RAM+$01,Y

	; Store Y coordinate
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

	; Store attributes
	LDA Objects_SprAttr,X
	ORA Objects_FlipBits,X
	STA Sprite_RAM+$02,Y

	; Store X coordinate
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$03,Y	

PRG002_A888: 
	RTS		 ; Return


ObjNorm_Hotfoot:

	; Mostly reuses the "shy" Hotfoot's code

	JSR CarryClearIfAliveAndNoHalt
	BCS PRG002_A850	 ; If Hotfoot is not alive or gameplay is halted, jump to PRG002_A850

	; Hotfoot alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot hasn't hit floor, jump to PRG002_A846

	INC <Objects_Var5,X	 ; Var5++
	LDA <Objects_Var5,X	
	AND #$a0
	BEQ PRG002_A844	 ; If Var5 = $A0, jump to PRG002_A844

	ASL A

	LDA <Objects_Var5,X
	TAY		 ; Y = Var5
	AND #%01011111
	BNE PRG002_A8B6	 ; Most of the time, jump to PRG002_A8B6

	BCC PRG002_A8B3	 ; If Var5 bit 7 not set, jump to PRG002_A8B3

	JSR Object_CalcCoarseXDiff
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Store flip towards Player

PRG002_A8B3:
	JSR Object_FlipFace	 ; Turn around

PRG002_A8B6:
	JMP PRG002_A832	 ; Jump to PRG002_A832

Boo_CheckPlayerSight:
	LDY <Objects_Var5,X

	JSR Object_CalcCoarseXDiff
	EOR <Player_FlipBits	 ; Check flip direction against Player; if Player and Boo are facing eachother, result is non-zero
	ASL A		 ; Push up result so it is $00 or $80
	BPL PRG002_A8C5	 ; If Player is not facing Boo, jump to PRG002_A8C5

	LDY #$00	 ; Otherwise, Y = 0

PRG002_A8C5:
	CPY #$14
	BGE PRG002_A8CC	 ; If Var5 >= $14 (Time to start chasing!), jump to PRG002_A8CC

	INY		 ; Y++ (Delaying before starting chase)

	STY <Objects_Var5,X	; Update Var5

PRG002_A8CC:
	RTS		 ; Return

Boo_VelAccel:	.byte $01, -$01
Boo_VelLimit:	.byte $10, -$10

ObjNorm_Boo:
	LDA Level_ObjectID, X
	CMP #OBJ_PIRATEBOO		; it's pirate boo, chase Mario ALWAYS!
	BEQ PRG002_A8DE
	JSR Boo_CheckPlayerSight
	BCS PRG002_A8DE	 ; If carry set, it's time to start chasing Player!  Jump to PRG002_A8DE

	; Otherwise, Boo just sits still
	LDA #$00
	STA <Objects_XVel,X
	STA <Objects_YVel,X

	BEQ PRG002_AA46	 ; Jump (technically always) to PRG002_AA46

PRG002_A8DE:
	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP Boo_VelLimit,Y	
	BEQ PRG002_A8EE	 ; If Boo is at his acceleration limit, jump to PRG002_A8EE

	ADD Boo_VelAccel,Y	 ; Boo accelerates!
	STA <Objects_XVel,X	 ; Update Boo's X velocity

PRG002_A8EE:

	; Set flip bit as appropriate
	LDA FacePlayer_FlipBitsStart+1,Y
	STA Objects_FlipBits,X	

	JSR Object_CalcCoarseYDiff

	LDY #$00	 ; Y = 0 (Player is lower, move down!)

	LDA <Temp_Var15
	SUB #$04
	BMI PRG002_A841

	INY		 ; Y = 1 (Player is higher, move up!)

PRG002_A841:
	LDA <Objects_YVel,X
	CMP Boo_VelLimit,Y
	BEQ PRG002_A84E	 ; If Boo is at his acceleration limit, jump to PRG002_A84E

	ADD Boo_VelAccel,Y	 ; Boo accelerates!
	STA <Objects_YVel,X	 ; Update Boo's Y velocity

PRG002_A84E:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	LDA #$01	 ; A = 1 (frame 1, chase!)

PRG002_AA46:
	STA Objects_Frame,X	 ; Update Boo's frame

	JSR Object_HitTestRespond	; Do collision test with Player and respond
	JSR Fish_FixedYIfAppro	 	; Fix Boo Y for raster area

Object_DeleteOrDraw:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JMP Object_ShakeAndDraw	 	; Draw and don't come back!

Stretch_XVelStart:	.byte -$10, $10
FacePlayer_FlipBitsStart:	.byte $00, SPR_HFLIP, $00	; Boo uses an off-by-1 index here, hence the other $00

ObjInit_Stretch:

	; Stretch starts 4 pixels lower than his placement
	LDA <Objects_Y,X
	ADD #$04
	STA <Objects_Y,X
	BCC PRG002_A935
	INC <Objects_YHi,X
PRG002_A935:

	; Determine which direction Player was moving when Stretch appeared
	LDY <Scroll_LastDir	

	; Set Stretch's flip to be towards Player
	LDA FacePlayer_FlipBitsStart,Y
	STA Objects_FlipBits,X	

	; Set Stretch's X velocity to be towards Player
	LDA Stretch_XVelStart,Y	
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_StretchFlip:
	JSR PRG002_A935	 ; Do most of what the un-flipped Stretch does

	; Flipped Stretch's Y velocity = -$80 (Ram into nearest ceiling)
	LDA #-$80
	STA <Objects_YVel,X

	; Set vertical flip
	ORA Objects_FlipBits,X
	STA Objects_FlipBits,X

	; Set Stretch at 6 pixels above his placement position
	LDA <Objects_Y,X
	SUB #$06
	STA <Objects_Y,X
	BCS PRG002_A95B
	DEC <Objects_YHi,X
PRG002_A95B:

	RTS		 ; Return

	; Stretch timer reset values by internal state (Var5)
Stretch_TimerByIntState:
	.byte $7F, $1F, $1F, $17

ObjNorm_Stretch:
	LDY <Objects_Var5,X	 ; Y = Var5 (internal state)

	LDA Objects_Timer,X
	BNE PRG002_A974	 ; If timer not expired, jump to PRG002_A974

	DEY		 ; Y--
	BPL PRG002_A96C	 ; If Y >= 0, jump to PRG002_A96C

	LDY #$03	 ; Otherwise, Y = 3

PRG002_A96C:
	STY <Objects_Var5,X	 ; Var5 = 0 to 3

	; Set timer based on Var5
	LDA Stretch_TimerByIntState,Y
	STA Objects_Timer,X

PRG002_A974:
	TYA
	LSR A
	PHP		 ; Save CPU state (most importantly, zero flag)
	BCS PRG002_A9A0	 ; If in internal state 1 or 3, jump to PRG002_A9A0

	JSR Object_ApplyXVel	 ; Apply X velocity
	LDY ObjGroupRel_Idx	 ; Y = Object's group relative index

	LDA ObjectGroup01_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_TDOGRPMASK		; Mask out the root tile detection group offset
	LSR A		 	; Correct the index
	TAY		 	; -> 'Y'

	LDA <Objects_YVel,X
	BPL PRG002_A98C	 ; If Stretch is on top, jump to PRG002_A98C

	; Otherwise, Y += 2 (Different detection offset)
	INY
	INY

PRG002_A98C:
	JSR Object_DetectTile
	CMP #TILE2_GHOSTM
	BEQ PRG002_A996	 ; If Stretch is gliding along a non-edge "Ghost tile", jump to PRG002_A996

	JSR Object_AboutFace	 ; Otherwise, turn around!

PRG002_A996:

	; FYI: You don't come here in internal state 1 or 3; those are explicitly handled by PRG002_A9A0

	LDA #$02	 ; A = 2
	PLP		 ; Restore CPU state (most importantly, zero flag, which means internal state 0 or 1)
	BEQ PRG002_A9AD	 ; If in internal state 0, jump to PRG002_A9AD

	; Use frame 4 if in internal state 2 
	ASL A
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A9A0:

	; Internal state 1 or 3 ONLY (Stretch rising or Stretch receding)

	LDA Objects_Timer,X
	LSR A
	LSR A
	LSR A
	AND #$03	 ; A = 0 to 3, by timer

	PLP		 ; Restore CPU state (most importantly, zero flag, which means internal state 0 or 1)
	BNE PRG002_A9AD	 ; If in internal state 3, jump to PRG002_A9AD

	EOR #$03	 ; In state 1, invert the value

PRG002_A9AD:
	STA Objects_Frame,X	 ; Store the frame
	JSR Object_DeleteOrDraw	 ; Delete Stretch if he falls off-screen, or draw him
	JMP Object_HitTestRespond	 ; Do collision test and respond, and don't come back!

ObjInit_InvisibleLift:

	; Object appears 11 pixels below placement
	LDA <Objects_Y,X
	ADD #11
	STA <Objects_Y,X
	BCC PRG002_A9C1	
	INC <Objects_YHi,X
PRG002_A9C1:

	RTS		 ; Return

ObjNorm_InvisibleLift:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the Sprite X and Sprite Y

	LDA <Objects_Var5,X
	BNE PRG002_A9D2	 ; If Var5 <> 0 (Lift activated), jump to PRG002_A9D2

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)
	BEQ PRG002_A9F5	 ; Otherwise, jump to PRG002_A9F5

PRG002_A9D2:

	; Lift activated...

	JSR InvisiLift_Draw	 ; Draw the lift

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)

	; Lift accelerates to -$20
	LDA <Objects_YVel,X
	SUB #$04
	CMP #-$20
	BGE PRG002_A9E4
	LDA #-$20
PRG002_A9E4:

	LDY <Objects_YHi,X
	BNE PRG002_A9F0	 ; If lift is on lower part of screen, jump to PRG002_A9F0

	; Lift is on higher part of screen...

	LDY <Objects_Y,X
	CPY #64
	BGE PRG002_A9F0	 ; If lift's Y >= 64, jump to PRG002_A9F0

	LDA #$00	 ; Otherwise, halt!

PRG002_A9F0:
	STA <Objects_YVel,X	 ; Update Y Velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity

PRG002_A9F5:

	; Don't worry about carry since this platform doesn't move horizontally
	LDA #$00
	STA Object_VelCarry

	JSR PlayerPlatform_Collide
	BCC PRG002_AA03	 ; If Player is not being carried by lift, jump to PRG002_AA03 (RTS)

	; Otherwise, Var5 = 1 (lift activated)
	LDA #$01
	STA <Objects_Var5,X

PRG002_AA03:
	RTS		 ; Return


InvisiLift_Draw:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	; Strip any horizontal or vertical flips from flip bits
	LDA <Temp_Var3
	AND #%00111111
	STA <Temp_Var3

	LDA <Counter_1
	LSR A	

	PHP		 ; Save CPU state
	BCC PRG002_AA17	 ; Every other tick, jump to PRG002_AA17

	; Otherwise, use Sprite_RAM offset +8
	TYA
	ADC #$07
	TAY

PRG002_AA17:
	JSR Object_Draw16x16Sprite	; Draw the first half of lift

	LDA <Temp_Var7
	PLP		 ; Restore CPU state
	BCS PRG002_AA21	 ; Every other opposite tick, jump to PRG002_AA21

	; Otherwise, use Sprite_RAM offset +8
	ADC #$08

PRG002_AA21:
	TAY		 ; Sprite_RAM offset -> 'Y'

	; X += 2 (starting sprite tile)
	INX
	INX

	; +16 for second part of lift
	LDA #16
	ADD <Temp_Var2
	STA <Temp_Var2

	; Use latter horizontal visibility bits
	ASL <Temp_Var8
	ASL <Temp_Var8
	JSR Object_Draw16x16Sprite	 ; Draw the second half of lift

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ObjInit_CloudPlatFast:

	; Set X velocity to -$0A
	LDA #-$0A

PRG002_AA37:
	STA <Objects_XVel,X

ObjInit_WoodenPlat:

	; Platform starts one pixel higher than its placement
	LDA <Objects_Y,X
	BNE PRG002_AA3F
	DEC <Objects_YHi,X
PRG002_AA3F:
	DEC <Objects_Y,X

PRG002_AA41:
	RTS		 ; Return


ObjInit_CloudPlatform:
	LDA #-$06	 ; X velocity = -$06
	BNE PRG002_AA37	 ; Jump (technically always) to PRG002_AA37

ObjInit_WoodenPlatform:
	LDA #-$08	 ; X velocity = -$08
	BNE PRG002_AA37	 ; Jump (technically always) to PRG002_AA37

ObjInit_OscillatingShort:
	INC <Objects_Var4,X	; Objects_Var4 = 1 (selects the short timer, less distance)
	BNE ObjInit_WoodenPlat	 ; Jump (technically always) to ObjInit_WoodenPlat


ObjNorm_CloudPlat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AA41	 ; If gameplay halted, jump to PRG002_AA41 (RTS)

	JSR Object_ApplyXVel	 	; Apply object's X velocity
	JMP Object_HitTestRespond	; Do hit test and respond, and don't come back!


ObjHit_CloudPlat:
	LDA <Temp_Var12
	LSR A
	BCC PRG002_AA85	 ; If not hit by Player jumping on top, jump to PRG002_AA85 (RTS)

	LDA <Player_YVel
	BMI PRG002_AA85	 ; If Player is moving upward, jump to PRG002_AA85 (RTS)

Player_StandOnPlatform:
	; Set Player to object's Y - 31
	LDA <Objects_Y,X	 
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Flag Player as NOT mid-air
	LDY #$00
	STY <Player_InAir

	LDA Object_VelCarry
	BPL PRG002_AA7B	

	DEY		 ; Y = -1 (provides a sort of carry if Player's X Velocity caused one)

PRG002_AA7B:
	; Add to Player_X, with carry
	ADD <Player_X
	STA <Player_X
	TYA
	ADC <Player_XHi
	STA <Player_XHi

PRG002_AA85:
	RTS		 ; Return

ObjNorm_WoodenPlatRider:

	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AAA6	 ; If gameplay is halted, jump to PRG002_AAA6 (RTS)

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Collide and ride

	LDA <Objects_XVel,X
	BNE PRG002_AA9A	 ; If platform is moving horizontally, jump to PRG002_AA9A

	; Platform not moving horizontally...
	BCS PRG002_AAA4	 ; If carry-collision occurred with platform, jump to PRG002_AAA4

	RTS		 ; Return


PRG002_AA9A:

	; Platform rider picks up speed until X Vel = $10

	CMP #$10
	BEQ PRG002_AAA6	 ; If Platform's X velocity = $10, jump to PRG002_AAA6 (RTS)

	LDA Level_NoStopCnt
	LSR A	
	BCS PRG002_AAA6	 ; Every other tick, jump to PRG002_AAA6 (RTS)

PRG002_AAA4:
	INC <Objects_XVel,X	 ; Increase platform's speed to the right

PRG002_AAA6:
	RTS		 ; Return


Enemy_CollideWithWorld:
	JSR Object_Move	 ; Do standard object movements

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG002_AAB2	 ; If enemy has NOT hit ceiling, jump to PRG002_AAB2

	; Otherwise, hit off ceiling
	STA <Objects_YVel,X

PRG002_AAB2:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ Object_HitFloorAlign	 ; If enemy has NOT hit walls, jump to Object_HitFloorAlign

	LDA <Objects_XVel,X
	BEQ Object_HitFloorAlign	 ; If object is not moving horizontally, jump to Object_HitFloorAlign

	JSR Object_AboutFace	 ; Otherwise, turn around

Object_HitFloorAlign:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AAA6	 ; If object has NOT hit ground, jump to PRG002_AAA6 (RTS)
	JMP Object_HitGround	 ; Otherwise, align to ground and don't come back!

	; Oscillating platform velocity and limits by direction
OscXVelLimit:	.byte -$10, $10
OscXVel:	.byte -$01, $01

ObjNorm_OscillatingH:
	LDA <Player_HaltGame
	BNE DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	JSR Platform_Oscillate	 ; Do platform oscillation
	JSR Object_ApplyXVel	 ; Apply X velocity
	JMP PlayerPlatform_Collide	 ; Do platform-player collision tests and don't come back!

	; Timers set per direction (long and short, respectively)
OscTimerSets:	.byte $41, $23	; longer timer means longer travel

Platform_Oscillate:
	LDA Objects_Timer,X	 
	BNE DeleteIfOffAndDrawWide	 ; If timer not expired, Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA Level_NoStopCnt
	LSR A
	BCS DeleteIfOffAndDrawWide	 ; Every other tick, Delete if off-screen, otherwise draw wide 48x16 sprite

	LDY <Objects_Var5,X	 ; Y = Objects_Var5 (direction of oscillation)

	; 
	LDA <Objects_XVel,X
	ADC OscXVel,Y
	STA <Objects_XVel,X

	CMP OscXVelLimit,Y
	BNE DeleteIfOffAndDrawWide	 ; If platform not hit the velocity limit, Delete if off-screen, otherwise draw wide 48x16 sprite

	; Change direction!
	TYA
	EOR #$01
	STA <Objects_Var5,X

	LDY <Objects_Var4,X	; Y = Var4 (specifies length)

	; Reset timer
	LDA OscTimerSets,Y
	STA Objects_Timer,X

DeleteIfOffAndDrawWide:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JMP LogPlat_Draw	 ; Jump to LogPlat_Draw

ObjNorm_OscillatingV:
	LDA <Player_HaltGame
	BNE DeleteIfOffAndDrawWide	 ; If gameplay halted, Delete if off-screen, otherwise draw wide 48x16 sprite

	; Vertical oscillating platform reuses the horizontal's code,
	; so the YVel is set equal to the XVel
	LDA <Objects_YVel,X
	STA <Objects_XVel,X

	JSR Platform_Oscillate	 ; Do platform oscillation

	; Same deal, Platform_Oscillate is working with the XVel, 
	; so transfer is into the YVel..
	LDA <Objects_XVel,X
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; Clear X velocity remainders
	LDA #$00
	STA Object_VelCarry

	JMP PlayerPlatform_Collide	; Do Player-platform collision and don't come back!

ObjInit_FloatWoodenPlat:
	LDA Level_AScrlConfig
	BEQ PRG002_AB35	 ; If no raster, jump to PRG002_AB35 (RTS)

	; If raster active (assuming a level with constant water level)...

	; Set fixed position at water level (vertical scroll +148)
	LDA Level_VertScroll
	ADD #148
	STA <Objects_Y,X
	LDA Level_VertScrollH
	ADC #$00		; Apply carry
	STA <Objects_YHi,X

PRG002_AB35:
	RTS		 ; Return


ObjNorm_WoodenPlatFloat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AB35	 ; If gameplay is halted, jump to PRG002_AB35 (RTS)

PRG002_AB5E:
	LDA Objects_Var1, X
	BNE Float_Do_Fall

	LDA #$00
	STA Objects_Var2, X

	JSR Object_Move	 ; Apply Y Velocity
	LDA <Objects_DetStat, X

	AND #$04
	ORA Objects_InWater, X
	BEQ Float_Do_Fall
	LDA <Objects_Y, X
	AND #$F0
	STA <Objects_Y, X
	LDA #$00
	STA <Objects_YVel, X

Try_Float:	
	LDA Objects_InWater, X
	BEQ Float_Do_Fall
	LDA <Objects_Y, X
	ADD #$0C
	STA <Objects_Y, X
	INC Objects_Var1, X

Float_Do_Fall:
	LDA #$00
	STA Object_VelCarry
	JSR PlayerPlatform_Collide	; Do Player-platform collision
	BCC PRG002_AB8F	 		; If Player did not collide with Platform, jump to PRG002_AB8F

	; Player collided with floater

	ROL Player_NoSlopeStick	 	; Set Player_NoSlopeStick

PRG002_AB8F:
	RTS		 ; Return

ObjNorm_WoodenPlatform:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABAA	 	; If gameplay halted, jump to PRG002_ABAA (RTS)

	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Player collision with platform

	LDA <Objects_YVel,X
	BNE PRG002_ABA8	 ; If Platform is moving vertically, jump to PRG002_ABA8

	BCC PRG002_ABAA	 ; If Player did not collide with platform, jump to PRG002_ABAA (RTS)

	STA <Objects_XVel,X	 ; Otherwise, X Vel = Y Vel

PRG002_ABA8:
	INC <Objects_YVel,X	 ; Platform descends

PRG002_ABAA:
	RTS		 ; Return

ObjInit_WoodenFallingPlat:
	INC <Objects_Var4,X	 ; Var4 = 1

ObjInit_FallingPlatform:

	; Center the platform
	LDA <Objects_X,X
	ORA #$08
	STA <Objects_X,X

	LDA <Objects_Y,X
	ORA #$06
	STA <Objects_Y,X

PRG002_ABB9:
	RTS		 ; Return

	; Index offsets looking for next path element
WoodenPlat_ScanIndices:
	.byte -$06, $06, -$05, $05, -$04, $04, -$03, $03, -$02, $02, -$01, $01, $00
WoodenPlat_ScanIndices_End:


	; All of the following WoodenPlat_* are parallel arrays 

	; Determines which direction the platform should seek for its next path tile
WoodenPlat_NextTileIdx:
	.byte $03, $02, $02, $02
	.byte $02, $00, $00, $00
	.byte $01, $01, $01, $01
	.byte $03, $03, $03, $03

	; The different path tiles the platform may encounter (Typical Set)
WoodenPlat_PathTiles:
	.byte TILEA_PATH_VERT, TILEA_PATH_625B2T_L, TILEA_PATH_625B2T_U, TILEA_PATH_45B2T
	.byte TILEA_PATH_HORZ, TILEA_PATH_45T2B, TILEA_PATH_625T2B_L, TILEA_PATH_625T2B_U
	.byte TILEA_PATH_VERT, TILEA_PATH_625B2T_U, TILEA_PATH_625B2T_L, TILEA_PATH_45B2T
	.byte TILEA_PATH_HORZ, TILEA_PATH_45T2B, TILEA_PATH_625T2B_U, TILEA_PATH_625T2B_L

	; Same setup as WoodenPlat_PathTiles, but for Tileset 2 (Fortress Style)
WoodenPlat_PathTilesAlt:
	.byte TILE2_PATH_VERT, TILE2_PATH_625B2T_L, TILE2_PATH_625B2T_U, TILE2_PATH_45B2T
	.byte TILE2_PATH_HORZ, TILE2_PATH_45T2B, TILE2_PATH_625T2B_L, TILE2_PATH_625T2B_U
	.byte TILE2_PATH_VERT, TILE2_PATH_625B2T_U, TILE2_PATH_625B2T_L, TILE2_PATH_45B2T
	.byte TILE2_PATH_HORZ, TILE2_PATH_45T2B, TILE2_PATH_625T2B_U, TILE2_PATH_625T2B_L

	; Y velocities appropriate to path tile hit
WoodenPlat_YVel:
	.byte -$10, -$10, -$10, -$10	; forward
	.byte  $00,  $10,  $10,  $10
	.byte  $10,  $10,  $10,  $10	; reverse
	.byte  $00, -$10, -$10, -$10
	.byte  $00	; Stop

	; X velocities appropriate to path tile hit
WoodenPlat_XVel:
	.byte  $00,  $08,  $08,  $10	; forward
	.byte  $10,  $10,  $08,  $08
	.byte  $00, -$08, -$08, -$10	; reverse
	.byte -$10, -$10, -$08, -$08
	.byte  $00	; Stop


ObjNorm_PathFollowPlat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABB9	 ; If gameplay is halted, jump to PRG002_ABB9 (RTS)

	LDA <Objects_Var4,X
	BEQ PRG002_AC29	 ; If Var4 = 0, jump to PRG002_AC29

	LSR A
	BEQ PRG002_AC2C	 ; If Var4 < 2, jump to PRG002_AC2C

	; Var4 >= 2...

	INC <Objects_YVel,X	 ; Increase platform's fall rate

PRG002_AC29:
	JMP PRG002_ACAB	 ; Jump to PRG002_ACAB

PRG002_AC2C:

	; Var4 = 1...

	LDA <Objects_YVel,X
	BEQ PRG002_AC3A	 ; If platform is not vertically moving, jump to PRG002_AC3A

	; Platform is vertically moving...

	LDA <Objects_Y,X
	AND #$0f	; Consider platform vertical relative to current grid row only
	CMP #$06
	BNE PRG002_ACAB	 ; If platform is NOT about halfway down this grid row, jump to PRG002_ACAB
	BEQ PRG002_AC42	 ; Otherwise, jump to PRG002_AC42

PRG002_AC3A:

	; Platform is about halfway down current grid row

	LDA <Objects_X,X
	AND #$0f	 ; Consider platform horizontal relative to current grid column only
	CMP #$08	 
	BNE PRG002_ACAB	 ; If platform is NOT about halfway across current grid row, jump to PRG002_ACAB

PRG002_AC42:

	; Platform is about centered

	; Going to detect the four tiles this Platform may be touching	

	LDA #$03
	STA <Temp_Var13		 ; Update Temp_Var13

	LDY ObjGroupRel_Idx	 ; Y = Object's group relative index
	LDA ObjectGroup01_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_TDOGRPMASK		; Mask out the root tile detection group offset
	LSR A		 	; Correct the index
	TAY		 	; -> 'Y'
PRG002_AC50:
	STY <Temp_Var14		 ; Update Temp_Var14

	JSR Object_DetectTile	 ; Detect tile platform is seeing

	LDY <Temp_Var13		 ; Y = Temp_Var13
	STA Temp_Var9,Y	 ; Store detected tile -> Temp_Var[9...12]

	LDY <Temp_Var14		; Y = Temp_Var14

	; Y += 2 (next DetectTile offset pair)
	INY
	INY

	DEC <Temp_Var13		 ; Temp_Var13--
	BPL PRG002_AC50	 	; While Temp_Var13 >= 0, loop!

	; Temp_Var13 = 12
	LDA #(WoodenPlat_ScanIndices_End - WoodenPlat_ScanIndices - 1)
	STA <Temp_Var13

	; Temp_Var14 = Var5 (travel direction, offset of 0 or 8)
	LDA <Objects_Var5,X
	STA <Temp_Var14

PRG002_AC6A:
	LDY <Temp_Var13		; Y = Temp_Var13

	LDA WoodenPlat_ScanIndices,Y
	ADD <Temp_Var14		; Travel direction offset
	AND #$0f		; Mod 16
	TAY			; -> 'Y' 

	LDX WoodenPlat_NextTileIdx,Y	 ; X = which of the four tiles that should be checked next

	LDA <Temp_Var9,X	 ; Get this tile
	CMP WoodenPlat_PathTiles,Y	 
	BEQ PRG002_AC9C	 	; If it's one of the path tiles (Typical set), jump to PRG002_AC9C

	CMP WoodenPlat_PathTilesAlt,Y
	BEQ PRG002_AC9C	 	; If it's one of the path tiles (Fortress set), jump to PRG002_AC9C

	CPY <Temp_Var14	
	BNE PRG002_AC92	 ; If Temp_Var14 <> 0, jump to PRG002_AC92 (stop platform)

	CMP #TILE4_PLATFORMPULLER
	BNE PRG002_AC92	 ; If tile is NOT the "Platform Puller" twirly thing, jump to PRG002_AC92 (stop platform)

	; Temp_Var14 = 0 and platform hit a path ending "platform puller" twirly thing

	; Change direction!
	TYA
	EOR #$08
	TAY	

	BPL PRG002_AC9C	 ; Jump (technically always) to PRG002_AC9C

PRG002_AC92:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG002_AC6A	 ; While Temp_Var13 >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	INC <Objects_Var4,X	 ; Objects_Var4 = 1 (platform stop)

	LDY #16	; Y = 16 (uses stop velocities)

PRG002_AC9C:

	; Hit a path tile...

	LDX <SlotIndexBackup		 ; X = object slot index

	TYA
	STA <Objects_Var5,X	 ; Store the directional offset (0 or 8)

	; Set Platform X Velocity appropriate for path tile
	LDA WoodenPlat_XVel,Y
	STA <Objects_XVel,X

	; Set Platform Y Velocity appropriate for path tile
	LDA WoodenPlat_YVel,Y
	STA <Objects_YVel,X

PRG002_ACAB:
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Do Player-to-platform collision
	BCC PRG002_ACBC	 ; If Player did not collide with platform, jump to PRG002_ACBC (RTS)

	; Mark Player standing on platform
	LDA <Objects_Var4,X
	ORA #$01
	STA <Objects_Var4,X

PRG002_ACBC:
	RTS		 ; Return

EnemyEnterFlip:	.byte  $00, SPR_HFLIP
EnemyEnterXVel:	.byte -$08, $08

ObjInit_TowardsPlayer:

	; Get last scroll direction so we know which way to face
	LDY Scroll_LastDir

	; Enemy faces Player relative to which direction he's headed
	LDA EnemyEnterFlip,Y
	STA Objects_FlipBits,X

	; Enemy charges at Player the same
	LDA EnemyEnterXVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return

Spike_Frames:
	.byte $04, $04, $04, $04, $04, $02, $02, $03, $03, $03, $03, $02, $02, $02, $02

Spike_XOff:
	.byte $00
	.byte $02, $03, $02, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

Spike_YOff:
	.byte $00, $F4, $F4
	.byte $F4, $F4, $F4, $F4, $F2, $F0, $EF, $EE, $EE, $EF, $F0, $F2, $F4, $F6, $F9, $FC
	.byte $FF, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


ObjNorm_Spike:
	LDA Objects_Timer,X
	LSR A
	STA <Objects_Var4,X	 ; Var4 = timer / 2

	ROL A		; Puts bit 0 back
	BEQ PRG002_AD3F	 ; If timer expired, jump to PRG002_AD3F

	LSR A
	BNE PRG002_AD31	 ; If timer > 2, jump to PRG002_AD31

	JSR Spike_TossSpikeBall	 ; Cough up a spike ball!

	LDA <Objects_Var5,X
	BEQ PRG002_AD31	 	; ?? I think this was meant to check that no sprites are off-screen, but most likely you'll make this jump

	INC Objects_Timer,X	 ; Timer++ (delay decrementing it)

PRG002_AD31:
	LDA Objects_Timer,X
	LSR A
	LSR A
	TAY		 ; Y = timer / 4

	; Set Spike's frame
	LDA Spike_Frames,Y
	STA Objects_Frame,X
	BPL PRG002_AD95	 ; If positive, jump to PRG002_AD95

PRG002_AD3F:
	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AD80	 ; If Spike has not touched the ground, jump to PRG002_AD80

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Set Spike's frame alternating 0/1 (walking)

	; This keeps Spike interesting
	LDA <Counter_1
	ADC Entropy_BySlot,X	; Add an arbitrary value based on which slot this Spike is in
	BMI PRG002_AD95	 ; If the result has bit 7 set, jump to PRG002_AD95

	JSR Object_CalcCoarseXDiff
	EOR Objects_FlipBits,X
	ASL A
	BPL PRG002_AD6E	 ; If the signs aren't different, Spike doesn't change direction; jump to PRG002_AD6E

	; Spike needs to change direction

	LDA <Counter_1
	AND #$07	
	BNE PRG002_AD80	 ; But only a 1:7 chance, otherwise jump to PRG002_AD80

	JSR Object_FlipFace	 ; Turn around
	JMP PRG002_AD80	 	; Jump to PRG002_AD80

PRG002_AD6E:

	; This gets a little tricky to follow...

	LDA <Temp_Var15	
	ADD #$20
	CMP #$40
	BGE PRG002_AD80	 ; Player out of X range

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	CMP #$08	
	BCC PRG002_AD84	 ; Player out of Y range

PRG002_AD80:
	LDA #$00
	BEQ PRG002_AD88	 

PRG002_AD84:
	LDA <Objects_Var5,X	
	ADC #$10

PRG002_AD88:
	STA <Objects_Var5,X	 
	BPL PRG002_AD95

	; Timer = $3A
	LDA #$3a
	STA Objects_Timer,X

	; Halt Spike's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG002_AD95:
	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_SpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDA <Temp_Var3
	BPL PRG002_ADB4	 ; If Spike is not flipped, jump to PRG002_ADB4

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Objects_Var4,X
	TAX		 ; X = Var4

	; Add to Sprite Y by Var4 index
	LDA <Temp_Var1	
	ADD Spike_YOff,X
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = object's starting tiles index

PRG002_ADB4:
	JSR Object_Draw16x16Sprite	 ; Draw Spike

	LDX <SlotIndexBackup		 ; X = object slot index

	LDY <Objects_Var4,X	 ; Y = Var4

	LDA <Objects_SpriteY,X
	BIT <Temp_Var3		
	BMI PRG002_ADC5	 ; If Spike is vertically flipped, jump to PRG002_ADC5

	ADD Spike_YOff,Y	 ; Otherwise, add appropriate offset

PRG002_ADC5:
	STA <Temp_Var1		 ; -> Temp_Var1
 
	LDA Spike_XOff,Y

	BIT <Temp_Var3
	BVC PRG002_ADD1	 ; If Spike is NOT horizontally flipped, jump to PRG002_ADD1

	JSR Negate	; Negate the X Offset

PRG002_ADD1:
	ADD <Temp_Var2		 ; Offset by Spike's X
	STA <Temp_Var2		 ; -> Temp_Var2

	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball

	; Draw Spike's pre-thrown spike ball sprite at +8 to Spike's assigned Sprite_RAM offset
	LDA <Temp_Var7
	ADD #$08	
	TAY		
	JSR Object_Draw16x16Sprite

	; Set Spike's spike ball attributes
	LDA #$02
	STA Sprite_RAM+$02,Y
	ORA #$c0
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Spike_TossSpikeBall:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot if on-screen (or don't come back!)	 
	STA <Objects_Var5,X	 ; Objects_Var5 = 0 (because we wouldn't be here otherwise)

	; Spike's spike ball
	LDA #SOBJ_SPIKEBALL	 
	STA SpecialObj_ID,Y

	; Set Spike's ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike's ball Y
	LDA <Objects_Y,X
	SUB #14
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction
	ASL A	
	ASL A		; Multiply result by 4
	STA SpecialObj_XVel,Y	 ; Set as Spike's ball X velocity

	; Spike's ball Y velocity and Data = 0
	LDA #$00
	STA SpecialObj_YVel,Y
	STA SpecialObj_Data,Y

	RTS		 ; Return


	; Sets X velocity by facing flip direction
Object_SetXVelByFacingDir:
	LDA Objects_FlipBits,X
	ASL A
	ASL A	; If HFlip is set, pushed into carry

	LDA #$08
	BCS PRG002_AE28
	LDA #-$08
PRG002_AE28:
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_PiranhaSpikeBall:
	; Center piranha
	LDA <Objects_X,X
	ORA #$08
	STA <Objects_X,X

	; Set Objects_Var5 = $10
	LDA #$10
	BNE PRG002_AE3A	 ; Jump (technically always) to PRG002_AE3A

ObjInit_Patooie:
	JSR ObjInit_TowardsPlayer	; Have enemy facing/moving towards Player

	; Set Objects_Var5 = $0C 
	LDA #$0c
PRG002_AE3A:
	STA <Objects_Var5,X

	RTS		 ; Return

ObjInit_SparkRight:
	LDA #$00
	STA Objects_Var1, X
	STA Objects_Var2, X
	RTS

ObjInit_SparkLeft:
	LDA #$01
	STA Objects_Var1, X
	LDA #$00
	STA Objects_Var2, X
	RTS

; this basically detects certain corners based on current movement direction
SparkDetects:
	.byte (HIT_DET_RIGHT | HIT_DET_GRND), (HIT_DET_LEFT | HIT_DET_GRND), (HIT_DET_CEIL | HIT_DET_LEFT), (HIT_DET_RIGHT | HIT_DET_CEIL)
	.byte (HIT_DET_LEFT | HIT_DET_GRND), (HIT_DET_RIGHT | HIT_DET_GRND), (HIT_DET_CEIL | HIT_DET_RIGHT), (HIT_DET_LEFT | HIT_DET_CEIL)

SparkYVel:
	.byte $10, $10, $F0, $F0
	.byte $10, $10, $F0, $F0

SparkXVeL:
	.byte $10, $F0, $F0, $10
	.byte $F0, $10, $10, $F0

ObjNorm_Spark:
	LDA <Counter_1
	AND #$04
	LSR A
	LSR A
	STA Objects_Frame, X
	JSR Object_ShakeAndDrawMirrored
	JSR Object_DeleteOffScreen
	LDA Objects_Var1, X
	ASL A
	ASL A
	ORA Objects_Var2, X
	TAY
	LDA SparkXVeL, Y
	STA <Objects_XVel, X
	LDA SparkYVel, Y
	STA <Objects_YVel, X
	TYA
	AND #$01			; only odd numbered states move vertically, even move horzontally
	BNE NoSparkXVel
	LDA <Objects_Y, X
	AND #$0F
	BNE ApplySparkX
	JSR Object_ApplyYVel_NoLimit

ApplySparkX:
	JSR Object_ApplyXVel
	LDA <Objects_X, X
	AND #$0F
	CMP #$0F
	BEQ SparkHitDetection
	CMP #$01
	BEQ SparkHitDetection
	BNE KeepGoing

NoSparkXVel:
	LDA <Objects_X, X
	AND #$0F
	BNE ApplySparkY
	JSR Object_ApplyXVel

ApplySparkY:
	JSR Object_ApplyYVel_NoLimit
	LDA <Objects_Y, X
	AND #$0F
	CMP #$0F
	BEQ SparkHitDetection
	CMP #$01
	BEQ SparkHitDetection
	BNE KeepGoing

SparkHitDetection:
	JSR Object_WorldDetect4
	LDA Objects_Var1, X		; var1 = 0 -> clockwise movement, var1 = 1 -> counter clockwise
	ASL A
	ASL A
	ORA Objects_Var2, X
	TAY
	LDA <Objects_DetStat, X
	AND SparkDetects, Y  
	BNE WallCeilGrndDet
	LDA Objects_Var2, X	; neither corner was detected (no ground or wall) so we need to wrap around the tile
	ADD #$01
	AND #$03
	STA Objects_Var2, X
	RTS

WallCeilGrndDet:
	CMP SparkDetects, Y
	BNE KeepGoing
	LDA Objects_Var2, X		; both corners were detected, we need to crawl against the tile
	SUB #$01
	AND #$03
	STA Objects_Var2, X

KeepGoing:						; if we only detected one ground or wall we keep going in the same direction
	JMP Object_HitTestRespond


ObjNorm_PiranhaSpikeBall:

	; Mostly reuses Patooie's code
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_AE47	 ; If piranha is dead, jump to PRG002_AE47

	JMP PRG002_AEE1	 ; Otherwise, jump to PRG002_AEE1

PRG002_AE47:

	; Use "poof" death
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X

	; Set timer to $1F (poof death timer)
	LDA #$1f
	STA Objects_Timer,X

PRG002_AE51:
	INC Objects_HitCount,X	 ; Increase hit count (??)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Patooie's Spike ball
	LDA #SOBJ_SPIKEBALL
	STA SpecialObj_ID,Y

	; Set Spike ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike ball Y -- Objects_Var5 is used as the height of the spiked ball Patooie is blowing
	LDA <Objects_Y,X
	SUB <Objects_Var5,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Spike ball data
	LDA #$01
	STA SpecialObj_Data,Y

	LSR A	
	STA SpecialObj_XVel,Y	 ; X Vel = 0

	LDA Objects_Var6,X
	AND #%01111100	; Masking the lower bits not strictly necessary...
	LSR A	
	LSR A	
	TAX	; X = value 0 to 31

	; Set the Patooie ball Y velocity
	;LDA Patooie_BallYDelta,X
	JSR Negate
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_AF30	 ; Jump to PRG002_AF30


ObjNorm_Patooie:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_AEBE	 ; If Patooie's state is not Killed, jump to PRG002_AEBE

	; Patooie is killed...

	LDA Objects_HitCount,X
	BEQ PRG002_AE51	 ; If object hasn't been hit by Player weapon, jump to PRG002_AE51

	JMP PRG002_AF30	 ; Jump to PRG002_AF30

PRG002_AEBE:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AEE1	 ; If object did not hit floor, jump to PRG002_AEE1

	LDA <Counter_1
	ADC Entropy_BySlot,X	 ; Add an arbitrary value by this object's slot index
	AND #%10011111
	BNE PRG002_AED7	 	; Semi-randomly jump to PRG002_AED7

	; Sometimes, reverse direction
	LDA <Objects_XVel,X
	JSR Negate	
	STA <Objects_XVel,X

PRG002_AED7:
	; Flip sprite back and forth to simulate walking
	LDA <Counter_1
	ASL A		
	ASL A		
	ASL A		
	AND #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_AEE1:
	LDA Objects_Var6,X
	BEQ PRG002_AEEF	 ; If Var6 = 0, jump to PRG002_AEEF

	LDA Level_NoStopCnt
	LSR A
	BCC PRG002_AEEF	 ; Every other tick, jump to PRG002_AEEF

	DEC Objects_Var6,X	 ; Otherwise, Var6--

PRG002_AEEF:
	LDY #$00	 ; Y = 0 (Mouth closed)

	LDA Objects_Var6,X
	PHA		 ; Save Var6

	AND #%11000000
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = $00, $10, $20, or $30

	PLA		 ; Restore Var6

	; Times the mouth animation to be similar to the spike ball's ascend/descend
	ASL A
	EOR Objects_Var6,X
	AND <Temp_Var1	
	BEQ PRG002_AF05

	INY		 ; Y = 1 (Mouth open)

PRG002_AF05:
	TYA
	STA Objects_Frame,X	 ; Set frame 0 or 1

	LDA Objects_Var6,X
	AND #$3f
	BNE PRG002_AF1D	 ; Only continue 1:64 ticks, otherwise jump to PRG002_AF1D

	LDY #$bf	 ; Y = $BF (BIG Blow)

	LDA Level_NoStopCnt
	BPL PRG002_AF19	 ; If the counter is not negative, jump to PRG002_AF19

	LDY #$5f	 ; Otherwise, Y = $5F (SHORT blow)

PRG002_AF19:
	TYA
	STA Objects_Var6,X	 ; Var6 = $5F or $BF

PRG002_AF1D:
	LDA Objects_Var6,X
	AND #%01111100
	LSR A
	LSR A
	TAY		 ; Y = 0 to 31

	; Adjusts height of spike ball
	LDA <Objects_Var5,X
	;ADD Patooie_BallYDelta,Y
	STA <Objects_Var5,X

	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_AF30:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_PiranhaSpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_PIRANHASPIKEBALL
	BEQ PRG002_AF46	 ; If this is just the piranha with the spike ball rather than a true Patooie, jump to PRG002_AF46

	; Temp_Var1 += 6
	LDA <Temp_Var1
	ADD #$06
	STA <Temp_Var1

PRG002_AF46:
	LDX <Temp_Var6	 ; X = object's starting tiles

	LDA <Temp_Var3
	BPL PRG002_AF4F	 ; If object is not vertically flipped, jump to PRG002_AF4F

	JSR PatooiePiranha_StartTileX	 ; Get correct starting sprite tile

PRG002_AF4F:
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LSR <Temp_Var5	; Shifting out next vertical visibility bit

	; Sprite Y += 16 for lower half
	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	; 'Y' += 8 (two sprite index over)
	TYA
	ADD #$08
	TAY

	LDX <Temp_Var6	 ; X = starting tiles index

	LDA <Temp_Var3
	BMI PRG002_AF69	 ; If vertically flipped, jump to PRG002_AF69
	JSR PatooiePiranha_StartTileX	 ; Otherwise, get correct starting tile again
PRG002_AF69:
	JSR Object_Draw16x16Sprite	 ; Draw lower half

	LDA <Temp_Var3
	BMI PRG002_AF72	 ; If vertically flipped, jump to PRG002_AF72

	LDY <Temp_Var7		 ; Y = original Sprite_RAM offset

PRG002_AF72:
	; Sets attributes and mirrors piranha sprites
	LDA <Temp_Var3	; Get object attributes
	AND #~(SPR_HFLIP | $03)	 ; Keep everything except the horizontal flip and the palette select
	ORA #SPR_PAL1	 ; Force palette select 1
	STA Sprite_RAM+$02,Y	 ; Set attributes
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y	 ; Set other half of piranha

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	
	CMP #OBJ_PIRANHASPIKEBALL
	BNE PRG002_AF96	 ; If this is Patooie, jump to PRG002_AF96

	; Piranha needs his body mirrored
	LDA Sprite_RAM+$0A,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$0A,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$0E,Y

PRG002_AF96:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B01A	 ; If this piranha/Patooie state is Killed, jump to PRG002_B01A

	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi

	LDA <Objects_Y,X
	PHA		 ; Save Y

	; Temporarily using object's Y/HI to calculate the spike ball's position
	SUB <Objects_Var5,X
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

	LDY #$00	 ; Y = 0 (height of 16)
	JSR Object_DetermineVertVisY	 ; Determine visibility of spike ball sprites
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data for spike ball

	LDA Level_NoStopCnt
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3, based on timer

	; Cause the spike ball to jiggle slightly (Temp_Var2 is X)
	LDA <Temp_Var2
	;ADD Patooie_BallXJiggle,X
	STA <Temp_Var2

	; Jump Sprite_RAM offset ahead 16 (four sprites, get passed Patooie/Piranha)
	TYA	
	ADD #16	
	TAY	

	; Draw sprite
	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball
	JSR Object_Draw16x16Sprite

	; Set spike ball vertical flip periodically
	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP	; Toggled vertical flip
	ORA #SPR_PAL2	; Set palette select 2
	STA Sprite_RAM+$02,Y
	EOR #$c0	; Invert vertical flip and apply horizontal flip
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B00E	 ; If Patooie/Piranha's state is Killed, jump to PRG002_B00E

	LDA <Player_HaltGame
	BNE PRG002_B00E	 ; If gameplay is halted, jump to PRG002_B00E

	JSR Object_AnySprOffscreen
	BNE PRG002_B00E	 ; If any sprites of the spike ball are off-screen, jump to PRG002_B00E

	LDA Level_ObjectID,X
	PHA		 ; Save piranha/Patooie iID

	; Temporarily switch and masquerade as a OBJ_CHEEPCHEEPPOOL2POOL
	; NOTE: This really just needs to be a 16x16 sized object so we
	; can "cheat" and use Object_HitTest on a "special object"
	LDA #OBJ_CHEEPCHEEPPOOL2POOL
	STA Level_ObjectID,X

	JSR Object_HitTest
	BCC PRG002_B00A	 ; If Player did NOT hit spike ball, jump to PRG002_B00A

	LDA Player_StarInv
	BNE PRG002_B00A	 ; If Player is Starman invincible, jump to PRG002_B00A

	JSR Object_DoCollision ; Do the collision routine

PRG002_B00A:
	; Restore the object ID
	PLA
	STA Level_ObjectID,X

PRG002_B00E:
	; Restore the Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis	 ; Restore true vertical visibility for this Patooie/piranha
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the true sprite positions

PRG002_B01A:
	;JMP PRG002_B196		; Jump to PRG002_B196 (set pattern bank $4F)

	; Get the correct starting sprite tile based on whether this is
	; a true Patooie or just the piranha pretending to be one
PatooiePiranha_StartTileX:
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	 ; Get object ID

	LDX #(ObjP2A - ObjectGroup01_PatternSets + $06)	 ; If Patooie
	CMP #OBJ_SPARKRIGHT
	BEQ PRG002_B02A	 ; If this is Patooie, jump to PRG002_B02A (RTS)
	LDX #(ObjP46 - ObjectGroup01_PatternSets + $08)	 ; If the piranha with spike ball
PRG002_B02A:
	RTS		 ; Return


ObjNorm_GoombaInShoe:

	RTS		 ; Return

ObjInit_NipperHopping:
	INC <Objects_Var4,X	 ; Var4 = 1
	RTS		 ; Return


ObjNorm_Nipper:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02	 
	TAY		 ; Y = 0 or 2

	JSR Object_CalcCoarseXDiff	 ; Get X difference between Nipper and Player
	STA <Temp_Var14		 ; Store flip direction -> Temp_Var14

	LDA <Temp_Var15	
	ADD #$03
	CMP #$06
	BGE PRG002_B1CD	 ; If Player is horizontally too far away from Nipper, jump to PRG002_B1CD

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	BMI PRG002_B1CD	 ; If Player is below Nipper, jump to PRG002_B1CD

	INY		 ; Y = 1 or 3

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B1CD	 ; If Nipper has not touched ground, jump to PRG002_B1CD

	; Nipper plant don't move horizontally!
	LDA #$00
	STA <Objects_XVel,X

	; Jump little Nipper!
	LDA #-$30
	STA <Objects_YVel,X

PRG002_B1CD:
	TYA	
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOrDraw	 ; Delete if falls off-screen, otherwise draw
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

	LDA <Objects_Var4,X
	BNE PRG002_B1E1	 ; If Var4 <> 0, jump to PRG002_B1E1

	; Set the flip bits
	LDA <Temp_Var14
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B1E1:
	LDA Objects_Timer,X
	BEQ PRG002_B1EC	 ; If timer expired, jump to PRG002_B1EC

	LSR A
	BNE PRG002_B20F	 ; If timer > 1, jump to PRG002_B20F (RTS)

	JSR Object_FlipFace	 ; Otherwise, turn around

PRG002_B1EC:

	; Timer expired...

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B20F	 ; If Nipper has not touched ground, jump to PRG002_B20F (RTS)

	LDA <Objects_YVel,X
	BMI PRG002_B20F	 ; If Nipper is moving upward, jump to PRG002_B20F (RTS)

	DEC <Objects_Var5,X	; Var5--
	BPL PRG002_B208	 ; If Var5 >= 0, jump to PRG002_B208

	; Reset Var5 = 8
	LDA #$08
	STA <Objects_Var5,X

	; Reset timer to $20
	LDA #$20
	STA Objects_Timer,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG002_B208:
	JSR Object_SetXVelByFacingDir	; Face travel direction 

	; Hop hop hop
	LDA #-$10
	STA <Objects_YVel,X

PRG002_B20F:
	RTS		 ; Return

ObjInit_Toad:
	LDA Objects_X,X		 ; Otherwise, Y = 1 
	AND #$70
	LSR A
	LSR A
	LSR A
	LSR A
	TAY

PRG002_B21A:
	STY <Objects_Var5,X	 ; -> Objects_Var5 (which message Toad gives)

	; Toad is always on the lower screen space
	LDA #$01
	STA <Objects_YHi,X

	; Stop the timer
	STA Level_TimerEn

	; Halt the Player
	LDA #$ff
	STA Player_HaltTick

	LDA #$00
	STA <Map_UseItem	; Clear item usage flag
	STA Player_Behind	; Player is not behind anything
	STA ToadTalk_CPos	; Clear the Toad character position counter

	; Set the starting VRAM addresses
	LDA #$28
	STA ToadTalk_VH
	LDA #$c8
	STA ToadTalk_VL

	RTS		 ; Return

PRG002_B23D:
	.byte $08, $04, $02, $01

ObjNorm_Toad:

	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X
 
	; Do Toad's dialog message
	LDA #$5C
	STA PatTable_BankSel+1
	LDA #$5b
	STA PatTable_BankSel+5
	JSR Toad_Speak

	LDA #$01
	STA Player_HaltTick
	LDA #$00
	STA Tile_Anim_Enabled
	RTS


Toad_Speak:
	LDA <Objects_Var4,X	 ; Get current dialog state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Toad_DrawDiagBox		; 0
	.word Toad_DoToadText		; 1
	.word Decide_What_Next		; 2
	.word Enough_Magic_Stars	; 3
	.word Deduct_Coins			; 4
	.word End_Level				; 5
	.word Do_Shop_Controls		; 6
	.word Challenge_Toad		; 7

TDiagBox_R1:	.byte $E8, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $EA
TDiagBox_R2:	.byte $F8, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $FA
TDiagBox_R3:	.byte $DC, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DE

TDiagBox_RowOffs:
	.byte (TDiagBox_R1 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1)
	.byte (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R3 - TDiagBox_R1)
TDiagBox_RowOffs_End

Toad_DrawDiagBox:
	LDX Graphics_BufCnt	 ; X = current graphics buffer counter

	; Store the current VRAM address into the buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,X
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,X

	; Store the next row address (+32 bytes to next row)
	ADD #$20	; 32 bytes to next row
	STA ToadTalk_VL
	BCC PRG002_B2D5
	INC ToadTalk_VH	 ; Apply carry
PRG002_B2D5:

	LDA #(TDiagBox_R2 - TDiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY ToadTalk_CPos	 ; Y = current dialog box row
	LDA TDiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG002_B2E3:
	; Store next pattern in dialog box
	LDA TDiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG002_B2E3	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	LDX <SlotIndexBackup	 ; X = object slot index

	INC ToadTalk_CPos	 ; Next row

	LDA ToadTalk_CPos
	CMP #(TDiagBox_RowOffs_End - TDiagBox_RowOffs)
	BLT PRG002_B325	 ; If row count < 8, jump to PRG002_B325 (RTS)

	; Dialog box is complete

	LDY <Objects_Var5,X	 ; Y = Objects_Var5

	; Toad's Var1 and Var2 store the current pointer to the text he's reciting
	LDA ToadMsg_Low,Y
	STA Objects_Var1,X
	LDA ToadMsg_High,Y
	STA Objects_Var2,X

	; Reset the VRAM address for the dialog text
	LDA #$28
	STA ToadTalk_VH
	LDA #$e9
	STA ToadTalk_VL

	; Toad's timer = $10
	LDA #$10
	STA Objects_Timer,X

	INC <Objects_Var4,X	 ; Objects_Var4 = 1 (next dialog state)

PRG002_B325:
	RTS		 ; Return

HammerCoinsRequired:
	.byte $01, $00, $00, $00, $00, $00, $00, $00, $00

ToadMsg_Standard:

	.byte "IN ORDER TO    "
	.byte "PASS, YOU NEED "
	.byte "TO COLLECT ()  "
	.byte "STARS.         "
	.byte "               "
	.byte "               "

	
ToadMsg_Shop:
	.byte "WELCOME TO THE "
	.byte "SHOP. USE LEFT "
	.byte "AND RIGHT TO   "
	.byte "BROWSE, A TO   "
	.byte "BUY, B TO LEAVE"
	.byte "THE SHOP.      "

	
ChallengeMessage:
	.byte "CAN YOU HANDLE "
	.byte "THE CHALLENGE? "
	.byte "COMPLETE THIS  "
	.byte "LEVEL FOR GREAT"
	.byte "REWARDS.       "
	.byte "               "

	; Pointer table to Toad's three messages
	; Warp Whistle
	; Standard
	; Anchor/P-Wing
ToadMsg_Low:	.byte LOW(ToadMsg_Standard), LOW(ToadMsg_Shop), LOW(ChallengeMessage)
ToadMsg_High:	.byte HIGH(ToadMsg_Standard), HIGH(ToadMsg_Shop), HIGH(ChallengeMessage)


Toad_DoToadText:
	LDA Objects_Timer,X
	BEQ DoNextLetter
	JMP PRG002_B4B1	 ; If timer not expired, jump to PRG002_B4B1

DoNextLetter:

	; Store address of text -> Temp_Var1/2
	LDA Objects_Var1,X
	STA <Temp_Var1
	LDA Objects_Var2,X
	STA <Temp_Var2

	INC Objects_Var1,X	; Next character
	BNE PRG002_B451
	INC Objects_Var2,X	; Apply carry
PRG002_B451:

	LDY #$00	 	; Y = 0
	LDA [Temp_Var1],Y	; Get character here
	TAY		 	; -> 'Y'
	CPY #$20
	BEQ PRG002_B468	 	; If this is a "space", jump to PRG002_B468

	; Play "blip" sound every other letter
	LDA ToadTalk_VL
	LSR A
	BCC PRG002_B468

	; Play text "blip" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1

PRG002_B468:
	TYA
	CMP #$28
	BEQ DoFirstDigit
	CMP #$29
	BNE Draw_Letter
	LDY StarLevel
	LDA HammerCoinsRequired, Y
	AND #$0F
	ORA #$30
	JMP Draw_Letter

DoFirstDigit:
	LDY StarLevel
	LDA HammerCoinsRequired, Y
	AND #$F0
	ASL A
	ASL A
	ASL A
	ASL A
	ORA #$30

Draw_Letter:
	CLC
	ADC #$80

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	STA Graphics_Buffer+3,Y	 ; Store into buffer

	; Insert one character into graphics buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,Y	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,Y	; run length
	LSR A
	STA Graphics_Buffer+4,Y	; terminator
	TYA
	ADD #$04
	STA Graphics_BufCnt	; count
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,Y	; address low

	INC ToadTalk_VL	 ; Next VRAM byte
	AND #$1f	 	; Get current column
	CMP #$17
	BNE PRG002_B4AC	 	; If we're not in column 23, jump to PRG024_A25B

	; Line break!

	LDA ToadTalk_VL
	ADC #$10		; Add enough bytes to get to next row
	STA ToadTalk_VL
	BCC PRG002_B4A1
	INC ToadTalk_VH	; Apply carry
PRG002_B4A1:

	CMP #$a9
	BNE PRG002_B4AC	 ; If we haven't reached the last character, jump to PRG002_B4AC

	INC <Objects_Var4,X	 ; Objects_Var4 = 2 (next dialog state)
	LDA #$08
	STA Pay_Toll_Timer

	LDA #$00
	STA ToadTalk_CPos

PRG002_B4AC:

	; Set timer to $04
	LDA #$04
	STA Objects_Timer,X

PRG002_B4B1:
	RTS		 ; Return

ObjNorm_ToadHouseItem:
	RTS		 ; Return

LogPlat_Draw:
	JSR Object_ShakeAndCalcSprite

	; Do not preserve the H/V flip bits
	LDA <Temp_Var3
	AND #%00111111
	STA <Temp_Var3

	LDA <Counter_1
	LSR A
	PHP		 ; Save CPU state (most importantly the carry flag)
	BCC PRG002_B5BD	 ; Every other tick, jump to PRG002_B5BD

	; Y += (11 + C = 12) -- Every other tick, offset Sprite_RAM
	TYA
	ADC #$0b
	TAY

PRG002_B5BD:
	JSR Object_Draw48x16Sprite	 ; Draw wide sprite

	LDA <Temp_Var7	 ; Get Sprite_RAM offset (as determined by Object_ShakeAndCalcSprite)
	PLP		 ; Restore CPU state
	BCS PRG002_B5C7	 ; Every other opposite tick, jump to PRG002_B5C7

	; Otherwise, add +12 to Sprite_RAM offset
	ADC #$0c

PRG002_B5C7:
	TAY		 ; Sprite_RAM offset -> 'Y'

	INX
	INX
	INX	; X += 3 (starting tiles index)

	; Temp_Var2 (Sprite Y) += 24
	LDA #24
	ADD <Temp_Var2
	STA <Temp_Var2

	; Alters horizontal visibility ??
	ASL <Temp_Var8
	ASL <Temp_Var8
	ASL <Temp_Var8

	JSR Object_Draw48x16Sprite	 ; Draw wide sprite

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ObjNorm_NipperFireBreathe:
	JSR Enemy_CollideWithWorld	; Collide with world
	JSR Object_DeleteOrDraw	 	; Delete if Nipper off-screen or draw it
	JSR Object_HitTestRespond	; Do collision test with Player and respond

	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X	 ; Set flip towards Player
 
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Nipper just smacks his lips

	JSR Object_AnySprOffscreen
	BNE PRG002_B65A	 ; If any of Nipper's sprites are not visible, jump to PRG002_B65A (RTS)

	LDA <Counter_1
	AND #$a0
	BNE PRG002_B65A	; Fire breather only does things in a limited window; otherwise, jump to PRG002_B65A (RTS)

	; Fire breather frame!
	LDA #$02
	STA Objects_Frame,X

	LDA <Counter_1
	AND #$07
	BNE PRG002_B65A	 ; Only do anything 1:8 ticks, otherwise jump to PRG002_B65A (RTS)

	; Set 'Y' to $10 or -$10 based on which side Player is on
	LDA <Temp_Var15
	TAY	
	ADD #$10
	CMP #$20
	BLT PRG002_B61F

	LDY #$10	 ; Y = $10

	LDA <Temp_Var15
	BPL PRG002_B61F

	LDY #-$10	 ; Y = -$10

PRG002_B61F:
	STY <Temp_Var1		 ; Temp_Var1 = $10 or -$10, based on which side Player is on

	JSR Object_CalcCoarseYDiff

	LDA <Temp_Var15
	ADD #$20
	CMP #$40
	BGE PRG002_B65A	 	; If Player is too high above Nipper, jump to PRG002_B65A (RTS)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Nipper fireball ID
	LDA #SOBJ_NIPPERFIREBALL
	STA SpecialObj_ID,Y

	; Nipper fireball X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Nipper fireball Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Nipper fireball X velocity
	LDA <Temp_Var1
	ASL A		
	JSR Negate	
	STA SpecialObj_XVel,Y

	; Nipper fireball Y velocity
	LDA #-$40
	SUB <Temp_Var15
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_B65A:
	RTS		 ; Return

DryBones_XVelConveyor:	.byte $08, $08, $0A	; Dry Bones' X Velocities with conveyor handling 
DryBones_AnimCntrMask:	.byte $04, $08, $08	; These values mask against the counter (Dry Bones animates faster walking against conveyor)

	; While Dry Bones is reassembling, provides frame and timer values
DryBones_ReassembleFrames:	.byte $01, $02, $03, $03, $03, $03, $03, $02
DryBones_ReassembleTimers:	.byte $10, $0A, $06, $06, $06, $06, $FF, $0A
	
ObjNorm_DryBones:
	JSR CarryClearIfAliveAndNoHalt
	BCS DryBones_Draw	 ; If Dry Bones is Dying or gameplay halted, jump to DryBones_Draw

	; Dry Bones is alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR DryBones_Draw		 ; Draw Dry Bones
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond
	JSR DryBones_BumpOffOthers	 ; Bump off other objects

	LDA <Objects_Var5,X
	BNE PRG002_B6B2	 ; If Var5 <> 0 (Dry Bones is crumpled), jump to PRG002_B6B2

	JSR Object_HandleConveyorBounceVel	; Sets LRBounce_Vel which way Dry Bones will need to be effected by conveyor
	LDY LRBounce_Vel
	INY		 ; Y++ (index into DryBones_XVelConveyor)

	; Set carry if horizontally flipped
	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA DryBones_XVelConveyor,Y	 ; Get velocity appropriate to Dry Bones' predicament
	BCS PRG002_B69D	 ; If horizontally flipped, jump to PRG002_B69D
	JSR Negate	 ; Otherwise, negate
PRG002_B69D:
	STA <Objects_XVel,X	 ; Set Dry Bones' X velocity

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B6B1	 ; If Dry Bones is NOT on the ground, jump to PRG002_B6B1

	; Toggle Dry Bones' walking frames by counter and whether he's running against a conveyor 
	LDA <Counter_1
	AND DryBones_AnimCntrMask,Y
	BEQ PRG002_B6AE	 
	LDA #$01
PRG002_B6AE:
	STA Objects_Frame,X

PRG002_B6B1:
	RTS		 ; Return

PRG002_B6B2:

	; Crumpled Dry Bones...

	LDA Objects_Timer,X
	BNE PRG002_B6D0	 ; If timer not expired, jump to PRG002_B6D0 (RTS)

	DEC <Objects_Var5,X	 ; Var5--
	BNE PRG002_B6C2	 ; If Var5 <> 0 (still reassembling), jump to PRG002_B6C2

	; Dry Bones gets back up and faces Player!
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B6C2:

	; Reassembling Dry Bones

	LDY <Objects_Var5,X	; Y = Var5 (0 = fully reassembled, hence -1 used below)

	LDA DryBones_ReassembleFrames-1,Y
	STA Objects_Frame,X

	LDA DryBones_ReassembleTimers-1,Y
	STA Objects_Timer,X

PRG002_B6D0:
	RTS		 ; Return

	; Patterns used when Dry Bones is crumbling
DryBones_CrumblePats:	.byte (ObjP3F - ObjectGroup01_PatternSets + $08), (ObjP3F - ObjectGroup01_PatternSets + $0B)
	; Little head bounce when crumbled
DryBones_HeadYOff:	.byte 0, 0, 0, -1, -2, -1, 0, 0, 0

DryBones_Draw:
	LDA Objects_Frame,X
	CMP #$02
	BGE PRG002_B706	 ; If Dry Bones' frame >= 2 (crumbling), jump to PRG002_B706

	; Frame 0 or 1

	; Save Dry Bones' Y/Hi
	LDA <Objects_YHi,X
	PHA		
	LDA <Objects_Y,X
	PHA		

	; Subtract 16 from Dry Bones' Y position
	SUB #16
	STA <Objects_Y,X
	BCS PRG002_B6F2
	DEC <Objects_YHi,X
PRG002_B6F2:

	; Draw Dry Bones
	LDY #$01	 ; 32 pixels height for Object_DetermineVertVisY
	JSR Object_DetermineVertVisY
	JSR Object_Draw16x32Sprite

	; Restore Dry Bones' Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate sprite X/Y and don't come back!

PRG002_B706:

	; Frame >= 2 (crumbling)...

	LDA Objects_FlipBits,X
	ASL A
	ASL A	; Sets carry if horizontally flipped

	; Save Dry Bones' X/Hi
	LDA <Objects_XHi,X
	PHA
	LDA <Objects_X,X
	PHA

	BCS PRG002_B71C	 ; If Dry Bones is horizontally flipped, jump to PRG002_B71C

	; Subtract 8 from Dry Bones' X position
	SUB #$08
	STA <Objects_X,X
	BCS PRG002_B71C
	DEC <Objects_XHi,X
PRG002_B71C:

	LDY #$02	 ; Select width = 24 for Object_DetermineHorzVisY
	JSR Object_DetermineHorzVisY	 ; Determine horizontal visibility
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite X/Y

	LDX <SlotIndexBackup	 	 ; X = object slot index
	LDY Objects_Frame,X	 	 ; Y = Dry Bones' frame

	LDX DryBones_CrumblePats-2,Y	 ; X = pattern start for this frame of Dry Bones (-2 because we start crumbling at frame 2)
	LDY <Temp_Var7			 ; Y = Sprite_RAM offset
	JSR Object_Draw48x16Sprite	 ; Draw wide sprite (crumbled Dry Bones)

	LDX <SlotIndexBackup		 ; X = object slot index
	BIT <Temp_Var3
	BVC PRG002_B73C	 	; If Dry Bones is not horizontally flipped, jump to PRG002_B73C

	; Otherwise, 'Y' += 8 (two sprites over)
	TYA
	ADD #$08
	TAY

PRG002_B73C:
	LDA <Objects_Var5,X
	TAX		 ; X = Var5 (head bounce index)

	; Apply bounce to his head after crumbling
	LDA Sprite_RAM+$00,Y
	ADD DryBones_HeadYOff,X	
	STA Sprite_RAM+$00,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	; Restore Dry Bones' X/Hi
	PLA
	STA <Objects_X,X
	PLA
	STA <Objects_XHi,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of Dry Bones' sprites
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate Sprite X/Y and don't come back!


ObjHit_DryBones:
	LDA <Objects_Var5,X
	BNE PRG002_B77D	 ; If head bouncing, jump to PRG002_B77D (RTS)

	; Head not bouncing yet

	LDA <Temp_Var12
	LSR A
	BCC PRG002_B77E	 ; If not hit by Player jumping on head, jump to PRG002_B77E (Player_GetHurt)

	; Var5 = 9
	LDA #$09
	STA <Objects_Var5,X

	; Dry Bones stop horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Bounce Player
	LDA #-$40
	STA <Player_YVel

	; Crumble sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR Exp_Inc

PRG002_B77D:
	RTS		 ; Return

PRG002_B77E:
	JMP Player_GetHurt	 ; Hurt Player and don't come back!


	; Essentially an implementation of Object_BumpOffOthers tailored
	; for Dry Bones, handling one or the other being crumpled
DryBones_BumpOffOthers:
	TXA		  
	ADD <Counter_1
	LSR A		
	BCS PRG002_B789	 ; Semi-randomly jump to PRG002_B789

PRG002_B788:
	RTS		 ; Return

PRG002_B789:
	LDA Objects_SprVVis,X
	BNE PRG002_B77D	 ; If any sprite of Dry Bones is vertically off-screen, jump to PRG002_B77D (RTS)

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B77D	 ; If some of Dry Bones is horizontally off-screen, jump to PRG002_B77D (RTS)

	JSR Object_CalcBoundBox2
	TXA	
	BEQ PRG002_B788	 ; If this Dry Bones is in object slot 0, jump to PRG002_B788

	DEX		 ; X-- (consider the previous object)
PRG002_B79E:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG002_B7A9	 ; If previous object state is Normal, jump to PRG002_B7A9

	CMP #OBJSTATE_SHELLED
	BNE PRG002_B815	 ; If previous object state is not Shelled, jump to PRG002_B815

PRG002_B7A9:
	LDY Level_ObjectID,X	 ; Y = object's ID

	LDA Object_AttrFlags,Y
	AND #OAT_BOUNCEOFFOTHERS
	BEQ PRG002_B815	 ; If OAT_BOUNCEOFFOTHERS is NOT set, jump to PRG002_B815

	LDA Objects_SprVVis,X
	BNE PRG002_B815	 ; If any sprite is vertically off-screen, jump to PRG002_B815

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B815	 ; If previous object has sprites horizontally off-screen, jump to PRG002_B815

	JSR Object_CalcBoundBox 
	JSR ObjectObject_Intersect 
	BCC PRG002_B815	 ; If object did not intersect with prior object, jump to PRG002_B815

	LDY <SlotIndexBackup	 ; Y = object slot index

	LDA <Objects_X,X
	SUB Objects_X,Y
	PHA		 ; Save the difference between the two objects' Xs

	LDA <Objects_XHi,X
	SBC Objects_XHi,Y
	STA <Temp_Var1	 ; Temp_Var1 = the difference between the two objects' X His

	; Determine which way this object should face relative to its position
	ROL <Temp_Var2
	PLA	
	ADC #$80
	LDA <Temp_Var1
	ADC #$00	
	BNE PRG002_B815	 

	LSR <Temp_Var2	
	LDY #$00	 ; Y = $00 (face one way)
	BCS PRG002_B7EC	

	LDY #SPR_HFLIP	 ; Y = SPR_HFLIP (face the other)

PRG002_B7EC:
	TYA		 
	STA <Temp_Var1	 ; Temp_Var1

	LDY <SlotIndexBackup	 ; Y = The Dry Bones who started this

	LDA Objects_Var5,Y
	BNE PRG002_B7FB	 ; If Var5 <> 0, jump to PRG002_B7FB (crumbled Dry Bones need not turn around)

	; I'm not crumbled, I get to turn...
	LDA <Temp_Var1
	STA Objects_FlipBits,Y

PRG002_B7FB:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG002_B815	 ; If bumped-into object's state is not Normal, jump to PRG002_B815

	LDA Level_ObjectID,X
	CMP #OBJ_DRYBONES
	BNE PRG002_B80E	 ; If Dry Bones bumped into something that's not a Dry Bones, jump to PRG002_B80E

	LDA Objects_Var5,X
	BNE PRG002_B815	 ; If Dry Bones bumped into a crumpled Dry Bones, jump to PRG002_B815

PRG002_B80E:
	; Dry Bones "bumps" into a non-crumpled Dry Bones or something not a Dry Bones, turn around
	LDA <Temp_Var1
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_B815:
	DEX		 ; X--
	BPL PRG002_B79E	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Respawn_XLo:	.byte $40, -$40
Respawn_XHi:	.byte $00, $FF

Fish_Repawn:
	LDY <Scroll_LastDir	 ; Y = last scroll direction value

	; Respawn near Player depending on direction he last moved
	LDA <Player_X
	ADD Respawn_XLo,Y
	STA <Objects_X,X
	LDA <Player_XHi
	ADC Respawn_XHi,Y
	STA <Objects_XHi,X

	TYA
	STA <Objects_Var5,X	 ; Objects_Var5 = entrance direction

ObjInit_ChasingFish:

	; Chasing fish always appear at the current vertical scroll + 160
	LDA Level_VertScroll
	ADD #160
	STA <Objects_Y,X
	LDA Level_VertScrollH
	ADC #$00
	STA <Objects_YHi,X

	; Come in hopping!
	LDA #-$08
	STA <Objects_YVel,X

	; Frame -1??
	LDA #-1
	STA Objects_Frame,X

	RTS		 ; Return

BigBertha_ProxLimit:	.byte $08, -$09	; How close (in coarse units) Big Bertha must be to Player to lunge
BigBertha_XVelLimit:	.byte $30, $50	; Limit on X Velocity (relative, used in addition)
BigBertha_Accel:	.byte -$04, $04	; X Velocity acceleration for each direction
BigBertha_XCoarseLimit:	.byte $10, $70	; How far away Big Bertha can be before turning around
BigBertha_EatLimit:	.byte $01, $03	; In coarse units (relative, used in addition), when Player is close enough to be eaten

ObjNorm_BigBertha:
	JSR Fish_FixedYIfAppro	 ; Fixes 'Y' coordinate for Big Bertha that swims in fixed water
	JSR BigBertha_Draw	 ; Draw Big Bertha

	LDA <Player_HaltGame
	BNE PRG002_B896	 ; If gameplay is halted, jump to PRG002_B896

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_B897	 ; If Big Bertha's state is not Dying, jump to PRG002_B897

PRG002_B867:
	; Big Bertha is dying...

	LDA Objects_Timer,X
	BEQ PRG002_B87A	 ; If timer expired, jump to PRG002_B87A

	LSR A	
	BNE PRG002_B896	 ; If timer >= 2, jump to PRG002_B896 (RTS)

	; Timer tick 1...

	; Big Bertha recreates self!
	JSR Level_PrepareNewObject

	; Set back to state 2 (Normal operation)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	JMP Fish_Repawn	 ; Jump to Fish_Repawn

PRG002_B87A:

	; Timer expired on dying Big Bertha...

	; Fix the flip bits
	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

	LDA Objects_Var7,X
	BEQ PRG002_B889	 ; If Var7 = 0 (Mario not devoured), jump to PRG002_B889
	JMP PRG002_B981	 ; Jump to PRG002_B981

PRG002_B889:
	JSR Object_Move	 ; Do standard object movements

	LDA Objects_SprVVis,X
	BEQ PRG002_B896	 ; If no sprites are vertically off-screen, jump to PRG002_B896

	; Otherwise, set Big Bertha's timer to $FF (time until Big Bertha respawns!)
	LDA #$ff
	STA Objects_Timer,X

PRG002_B896:
	RTS		 ; Return


PRG002_B897:
	LDY Objects_Var7,X
	BEQ PRG002_B8A0	 ; If Mario not devoured, jump to PRG002_B8A0

	INY
	STY Player_HaltTick	; Player is halted until Big Bertha drowns him!

PRG002_B8A0:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

	LDA Objects_Frame,X
	BPL PRG002_B840	 ; If frame = 0, jump to PRG002_B840

	LDA <Objects_SpriteY,X
	CMP #154
	BGE PRG002_B8B8	 ; If Big Bertha's SpriteY >= 154, jump to PRG002_B8B8

	; Otherwise, halt vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG002_B8B8:
	LDY <Objects_Var5,X	 ; Y = Var5 (current direction)

	LDA <Objects_XVel,X
	ADD BigBertha_XVelLimit,Y
	BMI PRG002_B8CA		; If negative result, jump to PRG002_B8CA

	; Apply acceleration
	LDA <Objects_XVel,X
	ADD BigBertha_Accel,Y
	STA <Objects_XVel,X

PRG002_B8CA:
	LDA <Objects_XVel,X
	LSR A		; Shift right 1
	AND #SPR_HFLIP	; Mask if it was negative
	EOR #SPR_HFLIP	; Flip it
	STA Objects_FlipBits,X	 ; Store horizontal flip bit

	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15		 ; Get coarse X diff
	ADD BigBertha_XCoarseLimit,Y
	BPL PRG002_B8E4	 ; If limit not reached, jump to PRG002_B8E4

	; Turn Big Bertha around
	TYA		
	EOR #$01	
	STA <Objects_Var5,X	 ; Store reversed direction flag

PRG002_B8E4:
	LDA <Temp_Var15		
	CMP BigBertha_ProxLimit,Y
	BNE PRG002_B896	 ; If not hit limit, jump to PRG002_B896 (RTS)

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	CMP #$10
	BGE PRG002_B896	 ; If Big Bertha is vertically too far from Player, jump to PRG002_B896

	; Does ... nothing to X Velocity?
	LDA <Objects_XVel,X
	ASL A			; Bit 7 shifted into carry
	ROR <Objects_XVel,X	; Carry shifted back into Bit 7

	; Big Bertha jumps!
	LDA #-$28
	STA <Objects_YVel,X

	; Gaping mouth
	INC Objects_Frame,X

PRG002_B840:

	; Big Bertha's gravity, Y Vel += 2
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDA <Objects_SpriteY,X

	; NOTE: Big Bertha is clearly abusing the purpose of Objects_Frame

	LDY Objects_Frame,X
	CPY #$05
	BGE PRG002_B978	 ; If frame >= 5, jump to PRG002_B978

	CPY #$04
	BLT PRG002_BA49	 ; If frame < 4, jump to PRG002_BA49

	CMP #148
	BLT PRG002_B896	 ; If SpriteY < 148, jump to PRG002_B896 (RTS)

	LDA #$05
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (sets Objects_Frame)

PRG002_BA49:
	LDA <Counter_1
	AND #$07
	BNE PRG002_B925	 ; Only 1:8 ticks we don't jump to PRG002_B925

	; Reverse frame
	TYA
	EOR #$01
	STA Objects_Frame,X

PRG002_B925:
	CPY #$02
	BGE PRG002_B95C	 ; If frame >= 2, jump to PRG002_B95C

	JSR Object_CalcCoarseXDiff
	LDY <Objects_Var5,X	; get direction flag
	LDA <Temp_Var15
	ADD BigBertha_EatLimit,Y
	CMP #$02
	BGE PRG002_B95C	 ; If Player is horizontally too far away to be eaten, jump to PRG002_B95C

	; Player might get eaten!

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	ADD #$08
	CMP #$0a
	BGE PRG002_B95C	 ; If Player is vertically too far away to be eaten, jump to PRG002_B95C

	LDA Player_StarInv
	ORA <Player_IsDying
	BNE PRG002_B95C	 ; If Player is invincible by Starman, dying, or "behind the scenes", jump to PRG002_B95C

	; Player gets eaten!

	INC Objects_Var7,X ; Flag Player as devoured

	LDA #$08
	STA <Player_YHi		; Set Player impossibly low
	STA Player_OffScreen	; Flag Player as off-screen

	LDA #$02
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (set frame)

PRG002_B95C:
	LDA <Objects_YVel,X
	BMI PRG002_B996	 ; If Big Bertha is moving upward, jump to PRG002_B996 (RTS)

	; Big Bertha is falling...
	
	LDA <Objects_SpriteY,X
	CMP #160
	BLT PRG002_B996	 ; If SpriteY < 160, jump to PRG002_B996 (RTS)

	JSR BigBertha_Splash	 ; Splash!

	; Big Bertha Y -= 24
	LDA <Objects_Y,X
	SUB #24
	STA <Objects_Y,X
	BCS PRG002_B974
	DEC <Objects_YHi,X	 ; Apply carry
PRG002_B974:

	LDA #$04
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (set frame)

PRG002_B978:
	CMP #160
	BLT PRG002_B996	 ; If Big Bertha's Y < 160, jump to PRG002_B996

	LDA Objects_Var7,X
	BEQ PRG002_B98D	 ; If Player is not devoured, jump to PRG002_B98D

PRG002_B981:
	LDA #$00
	STA Player_HaltTick	; Player not halted
	STA Player_AboveTop	; Player not above top of screen

	; Hold Player really low
	LDA #196
	STA <Player_SpriteY

PRG002_B98D:
	; Big Bertha Y Vel = -$08
	LDA #-$08
	STA <Objects_YVel,X

	; Sprite frame = -1 (??)
	LDA #$ff

PRG002_B993:
	STA Objects_Frame,X

PRG002_B996:
	RTS		 ; Return

PRG002_B997:
	.byte $FE, $02, $05, $FB, $01, $02, $03, $00

BigBertha_Splash:
	LDY #$02	 ; Y = 2 (use splash slot 2)

	LDA Splash_Counter,Y
	BEQ PRG002_B9A7	 ; If this slot is free, jump to PRG002_B9A7

	DEY		 ; Otherwise, try slot 1

PRG002_B9A7:

	; Initialize splash
	LDA #$01
	STA Splash_Counter,Y
	STA Splash_NoScrollY,Y

	; Set Splash Y
	LDA #147
	STA Splash_Y,Y

	; Set Splash X
	LDA <Objects_X,X
	STA Splash_X,Y
	RTS		 ; Return

BigBertha_Draw:
	LDA Objects_Var7,X	 
	BNE PRG002_B9CB	 ; If there's fractional X, jump to PRG002_B9CB

	LDY Objects_State,X
	CPY #OBJSTATE_KILLED
	BNE PRG002_B9CB	 ; If Big Bertha's state is not Killed, jump to PRG002_B9CB

	; Big Bertha's frame set to 1 if Dying
	LDA #$01
	STA Objects_Frame,X

PRG002_B9CB:
	INC Objects_Frame,X	 ; Big Bertha's frame++
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Objects_Frame,X
	DEC Objects_Frame,X	 ; Big Bertha's frame--
	ASL A	
	ASL A			; Multiply by 4
	ADD <Temp_Var6		 ; Add to starting tile
	STA <Temp_Var6		 ; Set as starting tile
	TAX		 ; Starting tile -> 'X'

	LDA <Temp_Var3
	BPL PRG002_B9E8	 ; If Big Bertha is not vertically flipped, jump to PRG002_B9E8

	; Otherwise, starting tile += 3
	INX
	INX
	INX

PRG002_B9E8:
	JSR Object_Draw48x16Sprite ; Draw upper half of Big Bertha

	LSR <Temp_Var5	; Shift the vertical visibility bits

	; Sprite_RAM offset += 12 (3 sprites ahead)
	TYA
	ADD #$0c
	TAY

	LDX <Temp_Var6	 ; X = starting tile

	LDA <Temp_Var3	
	BMI PRG002_B9FB	 ; If Big Bertha is vertically flipped, jump to PRG002_B9FB

	; Otherwise, starting tile += 3
	INX
	INX
	INX

PRG002_B9FB:
	; Sprite Y += 16 (lower half of Big Bertha)
	LDA #16
	ADD <Temp_Var1
	STA <Temp_Var1
	JSR Object_Draw48x16Sprite ; Draw lower half of Big Bertha

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

CheepCheepCharge_ProxLimit:	.byte $06, -$06	; How close (in coarse units) Cheep Cheep must be to Player to lunge
CheepCheepCharge_XVelLimit:	.byte $20, $60	; Limit on X Velocity (relative, used in addition)
CheepCheepCharge_Accel:		.byte -$01, $01	; X Velocity acceleration for each direction
CheepCheepCharge_XCoarseLimit:	.byte $10, $70	; How far away Cheep Cheep can be before turning around


ObjNorm_CharginCheepCheep:
	JSR Fish_FixedYIfAppro	 ; Fixes 'Y' coordinate for Cheep Cheep that swims in fixed water
	JSR Object_ShakeAndDraw	 ; Draw Cheep Cheep

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_BA20	 ; If Cheep Cheep's state is not Killed, jump to PRG002_BA20

	JMP PRG002_B867	 ; Jump to PRG002_B867 (use Big Bertha style respawn routine)

PRG002_BA20:

	; Cheep Cheep is not dying...

	; Toggle Cheep Cheep's frame
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block

	LDA <Objects_Var4,X
	BNE PRG002_BA96	 ; If Var4 <> 0 (Cheep Cheep is lunging), jump to PRG002_BA96

	LDA <Objects_SpriteY,X
	CMP #156
	BGE PRG002_BA40	 ; If Cheep Cheep's SpriteY >= 156, jump to PRG002_BA40

	; Stop Cheep Cheep's vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG002_BA40:
	LDY <Objects_Var5,X	 ; Y = Var5

	LDA <Objects_XVel,X
	ADD CheepCheepCharge_XVelLimit,Y
	BMI PRG002_BA52	 ; If Cheep Cheep has hit velocity limit, jump to PRG002_BA52

	; Cheep Cheep accelerate!
	LDA <Objects_XVel,X
	ADD CheepCheepCharge_Accel,Y
	STA <Objects_XVel,X	

PRG002_BA52:

	LDA <Objects_XVel,X
	LSR A
	AND #SPR_HFLIP
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Store flip bit by X velocity

	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15	
	ADD #$40
	CMP #$80
	BLT PRG002_BA6B		; If Cheep Cheep isn't too far away, jump to PRG002_BA6B

	JMP Fish_Repawn	 	; Cheep Cheep went too far, restart

PRG002_BA6B:
	LDA <Temp_Var15
	ADD CheepCheepCharge_XCoarseLimit,Y
	BPL PRG002_BA78	 ; If Cheep Cheep hasn't gotten too close to Player, jump to PRG002_BA78

	; Reverse direction
	TYA	
	EOR #$01
	STA <Objects_Var5,X

PRG002_BA78:
	LDA <Temp_Var15	
	CMP CheepCheepCharge_ProxLimit,Y
	BNE PRG002_BAA6	 ; If not hit limit, jump to PRG002_BAA6 (RTS)

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	SUB #$05
	CMP #$18
	BGE PRG002_BAA6	 ; If Cheep Cheep is vertically too far from Player, jump to PRG002_BAA6 (RTS)

	; Big Bertha jumps!
	LDA #-$28
	STA <Objects_YVel,X

	; Does ... nothing to X Velocity?
	LDA <Objects_XVel,X
	ASL A			; Bit 7 shifted into carry
	ROR <Objects_XVel,X	; Carry shifted back into Bit 7

	INC <Objects_Var4,X	 ; Var4 = 1 (Cheep Cheep lunge)

PRG002_BA96:

	; Cheep Cheep's gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDA <Objects_SpriteY,X
	CMP #168
	BLT PRG002_BAA6	 ; If Cheep Cheep Y < 168, jump to PRG002_BAA6 (RTS)

	; Stop Cheep Cheep from falling too far; bounce back up
	LDA #-$08
	STA <Objects_YVel,X

	DEC <Objects_Var4,X	 ; Var4 = 0 (Cheep Cheep done lunging)

PRG002_BAA6:
	RTS		 ; Return


	; Performs collision tests against platform and enables Player
	; to stand on the platform, hit head off platform, etc.
	; Carry set if carrying collision occurred
PlayerPlatform_Collide:
	JSR Object_HitTest	 ; Test if Player is touching object
	BCC PRG002_BAEE	 	; If not, jump to PRG002_BAEE (RTS)

	; Test if Player is standing on top of platform

	LDA <Player_SpriteY
	ADD #24
	CMP <Objects_SpriteY,X
	BGE PRG002_BABE	 ; If Player's bottom is beneath object's top, jump to PRG002_BABE

	LDA <Player_YVel
	BMI PRG002_BABD	 ; If Player is moving upward, jump to PRG002_BABD

	JSR Player_StandOnPlatform	 ; Stand on platform
	SEC		 ; Set carry (collided)

PRG002_BABD:
	RTS		 ; Return

PRG002_BABE:

	; Check if Player is hitting off bottom of platform

	LDA #-$08	; A = -8 unless small or ducking

	LDY <Player_Suit
	BEQ PRG002_BAC9	 ; If Player is small, jump to PRG002_BAC9

	LDY Player_IsDucking
	BEQ PRG002_BACB	 ; If Player is NOT ducking, jump to PRG002_BACB

PRG002_BAC9:
	LDA #$08	 ; A = 8 if small or ducking

PRG002_BACB:
	ADD <Player_SpriteY
	CMP <Objects_SpriteY,X
	BLT PRG002_BADC	 ; If Player's Sprite top is near object's top, jump to PRG002_BADC

	LDA <Player_YVel
	BPL PRG002_BADA	 ; If Player is falling, jump to PRG002_BADA

	; Player hits head off platform
	LDA #$10
	STA <Player_YVel

PRG002_BADA:
	CLC		 ; Clear carry (no collision)
	RTS		 ; Return

PRG002_BADC:
	LDA <Objects_XVel,X
	BEQ PRG002_BAF4	 ; If platform is not moving horizontally, jump to PRG002_BAF4

	; Platform is moving horizontally...

	LDA <Player_X
	SUB <Objects_X,X	; Difference between Player and Platform X
	EOR <Objects_XVel,X	; Most importantly, check if sign differs from velocity

	CLC		 ; Clear carry (no collision)
	BMI PRG002_BAEF	 ; If signs differ, jump to PRG002_BAEF

	; Otherwise, set Player's X velocity to platform's X velocity
	LDA <Objects_XVel,X
	STA <Player_XVel

PRG002_BAEE:
	RTS		 ; Return


PRG002_BAEF:

	; Halt Player's movement
	LDA #$00
	STA <Player_XVel

	RTS		 ; Return

PRG002_BAF4:

	; Platform is not moving horizontally... 

	JSR Level_ObjCalcXDiffs

	INY		 ; Y = 1 or 2, depending on Player's relative position

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	STA <Temp_Var1	 ; Temp_Var1 is non-zero if Player is pressing left/right

	CPY <Temp_Var1	 ; Check if Player is pressing a direction favorable to his position

	CLC		 ; Clear carry (no collision)

	BNE PRG002_BAEF	 ; If Player is pressing against it, jump to PRG002_BAEF (halt Player's movement)

	; Player pushing with platform
	LDA PlayerPushWithPlatform_XVel-1,Y
	STA <Player_XVel

	RTS		 ; Return

PlayerPushWithPlatform_XVel:	.byte $04, -$04

	; Attribute by frame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Start goal card routine removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	; Returns 'Y' as offset to Mario's or Luigi's inventory memory
Player_GetInventoryOffset:
	RTS		 ; Return

	; Draws the card backs, though the backs are almost immediately
	; overwritten with the proper card face...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Start goal card routine removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Enough_Magic_Stars:
	LDA Pay_Toll_Timer
	BNE Skip_Pay_Toll_Timer
	LDY World_Num
	LDA Magic_Stars + 1
	LSR A
	LSR A
	LSR A
	LSR A
	ORA Magic_Stars
	CMP HammerCoinsRequired, Y
	BCS Pay_Toll
	LDA Sound_QMap		; Not enough coins
	ORA #SND_MAPDENY
	STA Sound_QMap
	LDA #$40
	STA End_Level_Timer	; end level
	LDA #$00
	STA TollPaid		; toll not paid
	INC <Objects_Var4,X
	INC <Objects_Var4,X
	RTS

Skip_Pay_Toll_Timer:
	DEC Pay_Toll_Timer
	RTS

Pay_Toll:
	LDA HammerCoinsRequired, Y
	AND #$0F
	STA DAIZ_TEMP1
	LDA HammerCoinsRequired, Y
	AND #$F0
	ASL A
	ASL A
	ASL A					; get coins needed to deduct
	ASL A
	TAY
Multiply_10_Loop:
	DEY
	BMI Store_Coins_Deduct
	CLC
	LDA DAIZ_TEMP1
	ADC #$0A
	STA DAIZ_TEMP1
	JMP Multiply_10_Loop

Store_Coins_Deduct:
	LDA DAIZ_TEMP1
	STA Coins_To_Deduct
	LDA #$10
	STA Deduct_Coin_Timer
	INC <Objects_Var4,X
	RTS

Deduct_Coins:
	DEC Deduct_Coin_Timer
	BNE Deduct_CoinsRTS
	JSR Decrease_Magic_Stars
	DEC Coins_To_Deduct
	BEQ Deduct_Coins_Done
	LDA #$10
	STA Deduct_Coin_Timer

Deduct_CoinsRTS:
	RTS

Deduct_Coins_Done:
	LDA #$20
	STA End_Level_Timer
	STA TollPaid
	INC <Objects_Var4,X
	RTS

End_Level:
	DEC End_Level_Timer
	LDA End_Level_Timer
	BNE End_LevelRTS
	
	LDA #$01
	STA Level_ExitToMap	
	LDA TollPaid		; if TollPaid = 1, complete this sprite
	BEQ Return_Map
	LDA #$00			; if toll not paid, return to last spot
	BEQ Store_Return_Status

Return_Map:
	LDA #$01

Store_Return_Status:
	STA Map_ReturnStatus

End_LevelRTS:
	RTS

Decrease_Magic_Stars:
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	DEC Magic_Stars
	LDA Magic_Stars
	AND #$0F
	CMP #$0A
	BCC No_HBros_Dec
	LDA Magic_Stars
	AND #$F0
	ORA #$09
	STA Magic_Stars

No_HBros_Dec:
	RTS

Next_Toad_Routine: .byte  $03, $06, $07

Toad_Do_Nothing:
	RTS

Decide_What_Next:
	LDA Objects_Var5, X
	TAY
	LDA Next_Toad_Routine, Y
	STA Objects_Var4, X
	RTS

Do_Shop_Controls:
	STX DAIZ_TEMP1
	LDA #$08
	STA Player_HaltTick
	LDA #$5E
	STA PatTable_BankSel
	LDA #$5B
	STA PatTable_BankSel + 5
	LDA Shop_Mode_Initialized
	BEQ Initialize_Shop_Mode
	LDA <Pad_Input
	AND #PAD_RIGHT
	BEQ Try_Shop_Left
	JSR Move_Items_Right
	JSR Draw_Current_Items
	JMP Shop_RTS

Try_Shop_Left:
	LDA <Pad_Input
	AND #PAD_LEFT
	BEQ Try_Leave_Shop
	JSR Move_Items_Left
	JSR Draw_Current_Items
	JMP Shop_RTS

Try_Leave_Shop:
	LDA <Pad_Input
	AND #PAD_B
	BEQ Try_Buy_Item
	INC Level_ExitToMap
	JMP Shop_RTS

Try_Buy_Item:
	LDA <Pad_Input
	AND #PAD_A
	BEQ Shop_RTS
	JSR Buy_Item
Shop_RTS:
	JSR Draw_Item_Sprite
	LDX DAIZ_TEMP1
	RTS

Item_Frame_Top:		.byte $E8, $E9, $E9, $EA
Item_Frame_Bottom:	.byte $DC, $DD, $DD, $DE

Initialize_Shop_Mode:
	LDA #$00 
	STA Item_Shop_Window + 1
	LDA #$01
	STA Item_Shop_Window + 2
	LDA #(Max_Item_Count - 1)
	STA Item_Shop_Window
	STA Shop_Mode_Initialized
	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$2E
	STA Graphics_Buffer, Y
	INY
	LDA #$04
	STA Graphics_Buffer, Y
	INY
	LDX #$00

Top_Frame_Loop:
	LDA Item_Frame_Top, X
	STA Graphics_Buffer, Y
	INY
	INX
	CPX #$04
	BNE Top_Frame_Loop
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$8E
	STA Graphics_Buffer, Y
	INY
	LDA #$04
	STA Graphics_Buffer, Y
	INY
	LDX #$00

Bottom_Frame_Loop:
	LDA Item_Frame_Bottom, X
	STA Graphics_Buffer, Y
	INY
	INX
	CPX #$04
	BNE Bottom_Frame_Loop
	LDA #$00
	STA Graphics_Buffer, Y
	LDA Graphics_BufCnt
	CLC
	ADC #$0E
	STA Graphics_BufCnt
	JSR Draw_Current_Items
	RTS

Move_Items_Right:
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1
	INC Item_Shop_Window
	INC Item_Shop_Window + 1
	INC Item_Shop_Window + 2
	LDX #$02

Check_OverFlow_Item:
	LDA Item_Shop_Window, X
	CMP #Max_Item_Count
	BNE Next_Item_Please
	LDA #$00
	STA Item_Shop_Window, X
Next_Item_Please:
	DEX
	BPL Check_OverFlow_Item
	RTS

Move_Items_Left:
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1
	DEC Item_Shop_Window
	DEC Item_Shop_Window + 1
	DEC Item_Shop_Window + 2
	LDX #$02

Check_UnderFlow_Item:
	LDA Item_Shop_Window, X
	CMP #$FF
	BNE Next_Item_Please2
	LDA #(Max_Item_Count - 1)
	STA Item_Shop_Window, X

Next_Item_Please2:
	DEX
	BPL Check_UnderFlow_Item
	RTS

Item_Tiles:
	.byte $30, $31, $40, $41
	.byte $32, $33, $42, $43
	.byte $3C, $3D, $4C, $4D
	.byte $34, $35, $44, $45
	.byte $36, $37, $46, $47
	.byte $38, $39, $48, $49
	.byte $5C, $5D, $6C, $6D
	.byte $3A, $3B, $4A, $4B
	.byte $5E, $5F, $6E, $6F
	.byte $3E, $3F, $4E, $4F
	.byte $04, $05, $14, $15
	.byte $06, $07, $16, $17
	.byte $08, $09, $18, $19
	.byte $0A, $0B, $1A, $1B
	.byte $0E, $0F, $1E, $1F

Item_Prices:
	.byte $00, $02, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $09, $00, $00
	.byte $01, $04, $00, $00
	.byte $01, $04, $00, $00
	.byte $02, $01, $00, $00
	.byte $02, $02, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $09, $00, $00
	.byte $02, $00, $00, $00
	.byte $01, $00, $00, $00
	.byte $00, $09, $00, $00
	.byte $01, $00, $00, $00

Draw_Current_Items:
	LDA #$00
	STA DAIZ_TEMP1
	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$4C
	STA Graphics_Buffer, Y
	INY
	LDA #$08
	STA Graphics_Buffer, Y
	INY

Draw_Item_Window_Top:
	LDX DAIZ_TEMP1
	LDA Item_Shop_Window, X
	ASL A
	ASL A
	TAX
	LDA Item_Tiles, X
	STA Graphics_Buffer, Y
	INY
	LDA Item_Tiles + 1, X
	STA Graphics_Buffer, Y
	INY
	INY
	INC DAIZ_TEMP1
	LDA DAIZ_TEMP1
	CMP #$03
	BNE Draw_Item_Window_Top
	LDY Graphics_BufCnt
	LDA #$F8
	STA Graphics_Buffer + 5, Y
	LDA #$FA
	STA Graphics_Buffer + 8, Y

	LDA #$00
	STA DAIZ_TEMP1
	LDA Graphics_BufCnt
	CLC
	ADC #$0B
	STA Graphics_BufCnt
	TAY
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$6C
	STA Graphics_Buffer, Y
	INY
	LDA #$08
	STA Graphics_Buffer, Y
	INY

Draw_Item_Window_Bottom:
	LDX DAIZ_TEMP1
	LDA Item_Shop_Window, X
	ASL A
	ASL A
	TAX
	INX
	INX
	LDA Item_Tiles, X
	STA Graphics_Buffer, Y
	INY
	LDA Item_Tiles + 1, X
	STA Graphics_Buffer, Y
	INY
	INY
	INC DAIZ_TEMP1
	LDA DAIZ_TEMP1
	CMP #$03
	BNE Draw_Item_Window_Bottom
	LDY Graphics_BufCnt
	LDA #$F8
	STA Graphics_Buffer + 5, Y
	LDA #$FA
	STA Graphics_Buffer + 8, Y
	LDA #$00
	STA Graphics_Buffer + 11, Y
	LDA Graphics_BufCnt
	CLC
	ADC #$0B
	STA Graphics_BufCnt

	LDA Item_Shop_Window + 1
	ASL A
	ASL A
	TAX
	LDA #$00
	STA DAIZ_TEMP1

	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$AE
	STA Graphics_Buffer, Y
	INY
	LDA #$04
	STA Graphics_Buffer, Y
	INY

Next_Price_Digit:
	LDA Item_Prices, X
	CMP #$7F
	BEQ Skip_Digit
	CLC
	ADC #$A2

Skip_Digit:
	STA Graphics_Buffer, Y
	INY
	INX
	INC DAIZ_TEMP1
	LDA DAIZ_TEMP1
	CMP #$04
	BNE Next_Price_Digit
	LDA #$00
	STA Graphics_Buffer, Y
	LDA Graphics_BufCnt
	CLC
	ADC #$08
	STA Graphics_BufCnt
	RTS

Buy_Item:
	JSR Clear_Calc
	LDA Item_Shop_Window + 1
	ASL A
	ASL A
	TAX
	INX
	INX
	INX
	LDY #$07

Store_Next_Price:
	LDA Item_Prices, X
	STA Calc_Value, Y
	DEX
	DEY
	CPY #$03
	BNE Store_Next_Price
	LDX #$03

Store_Next_Coin:
	LDA Player_Coins, X
	STA Calc_From + 4, Y
	DEX
	DEY
	BPL Store_Next_Coin
	JSR Subtract_Values
	LDA Calc_From + 3
	BEQ Take_Item

Cannot_Take_Item:
	LDA Sound_QMap		; Not enough coins
	ORA #SND_MAPDENY
	STA Sound_QMap
	RTS

Take_Item:
	LDX #$00

Find_Slot:
	LDA Inventory_Items, X
	BEQ Slot_Found
	INX
	CPX #$1C
	BNE Find_Slot
	BEQ Cannot_Take_Item

Slot_Found:
	LDY Item_Shop_Window + 1
	INY
	TYA
	STA Inventory_Items, X
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	STA Force_Coin_Update
	LDX #$03

Store_New_Coin:
	LDA Calc_From + 4, X
	STA Player_Coins, X
	DEX
	BPL Store_New_Coin
	RTS

Item_Sprites:
	.byte $C1, $C1
	.byte $C3, $C3
	.byte $C5, $C5
	.byte $C7, $C9
	.byte $CB, $CB
	.byte $CD, $CD
	.byte $CF, $CF
	.byte $D1, $D1
	.byte $D3, $D3
	.byte $D5, $D5
	.byte $D7, $D5
	.byte $D9, $DB
	.byte $DD, $DF
	.byte $E1, $E3
	.byte $E5, $E7

Item_Pal:
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL2, SPR_PAL2 | SPR_HFLIP
	.byte SPR_PAL2, SPR_PAL2  | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1
	.byte SPR_PAL2, SPR_PAL2 | SPR_HFLIP
	.byte SPR_PAL2, SPR_PAL2 | SPR_HFLIP
	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP
	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1
	.byte SPR_PAL3, SPR_PAL3
	.byte SPR_PAL1, SPR_PAL1
	.byte SPR_PAL1, SPR_PAL1

Draw_Item_Sprite:
	LDA Item_Shop_Window + 1 
	ASL A
	TAX
	JSR Object_GetRandNearUnusedSpr
	LDA #$90
	STA Sprite_RAM, Y
	LDA #$78
	STA Sprite_RAM + 3, Y
	LDA Item_Sprites, X
	STA Sprite_RAM + 1, Y
	LDA Item_Pal, X
	STA Sprite_RAM + 2, Y
	INX
	JSR Object_GetRandNearUnusedSpr
	LDA #$90
	STA Sprite_RAM, Y
	LDA #$80
	STA Sprite_RAM + 3, Y
	LDA Item_Sprites, X
	STA Sprite_RAM + 1, Y
	LDA Item_Pal, X
	STA Sprite_RAM + 2, Y
	RTS

Challenge_Toad:
	LDA #$01
	STA Level_JctCtl
	LDX #$00				; use first pointer as transition
	LDA Pointers, X
	STA LevelLoadPointer
	LDA Pointers + 3, X
	AND #$0F
	STA <Player_XHi
	LDA Pointers + 3, X
	AND #$F0
	ORA #$08
	STA <Player_X
	LDA Pointers + 4, X
	AND #$0F
	STA <Player_YHi
	LDA Pointers + 4, X
	AND #$F0
	STA <Player_Y

	LDA Pointers + 5, X
	AND #$0F
	STA Level_PipeExitDir	 ; Store into Level_PipeExitDir
	
	CMP #$03
	BLT Skip_Line_Up2	 ; If Level_PipeExitDir < 3, jump to PRG026_AABD
	
	; Otherwise, don't center Player (better for starting on block)
	LDA <Player_X
	AND #$f0
	STA <Player_X

Skip_Line_Up2:
	RTS

Player_Take_Coins:
	STX DAIZ_TEMP1
	LDA <Counter_1
	AND #$03
	BNE No_More_Coins
	JSR Clear_Calc
	LDX #$03

Store_Next_Coin1:
	LDA Player_Coins, X
	STA Calc_From + 4, X
	DEX
	BPL Store_Next_Coin1
	LDA #$01
	STA Calc_Value + 7
	JSR Subtract_Values
	LDA Calc_From
	BMI No_More_Coins
	LDX #$03

Taking_Coins:
	LDA Calc_From + 4, X
	STA Player_Coins, X
	DEX
	BPL Taking_Coins
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	STA Force_Coin_Update

No_More_Coins:
	LDX DAIZ_TEMP1
	RTS