; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-04-02 22:20:56.965729406 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup01 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $01 (i.e. objects starting at ID $24) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup01_InitJumpTable:
	.word ObjInit_WoodenPlatHorz	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjInit_WoodenPlatVert	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjInit_WoodenPlatFallGen	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjInit_WoodenPlatDiagonal1	; Object $27 - OBJ_OSCILLATING_H
	.word ObjInit_WoodenPlatDiagonal2	; Object $28 - OBJ_OSCILLATING_V
	.word ObjInit_TowardsPlayer	; Object $29 - OBJ_SPIKE
	.word ObjInit_Spark		; Object $2A - OBJ_SPARKRIGHT
	.word ObjInit_SparkLeft		; Object $2B - OBJ_SPARKLEFT
	.word ObjInit_WoodenPlatCCW	; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjInit_WoodenPlatCW	; Object $2D - OBJ_BIGBERTHA
	.word ObjInit_DoNothing	; Object $2E - OBJ_PIRATEBOO
	.word ObjInit_DoNothing		; Object $2F - OBJ_BOO
	.word ObjInit_HotFootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjInit_Stretch		; Object $31 - OBJ_BOOSTRETCH
	.word ObjInit_StretchFlip	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word ObjInit_DoNothing		; Object $33 - OBJ_NIPPER
	.word ObjInit_Toad		; Object $34 - OBJ_TOAD
	.word ObjInit_DoNothing		; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjInit_DoNothing	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjInit_DoNothing	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjInit_DoNothing	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjInit_NipperHopping	; Object $39 - OBJ_NIPPERHOPPING
	.word ObjInit_FallingPlatform	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjInit_DoNothing	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjInit_WoodenFallingPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjInit_DoNothing		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjInit_FloatWoodenPlat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjInit_TowardsPlayer	; Object $3F - OBJ_DRYBONES
	.word ObjInit_BusterBeatle	; Object $40 - OBJ_BUSTERBEATLE
	.word ObjInit_DoNothing		; Object $41 - OBJ_ENDLEVELCARD
	.word ObjInit_DoNothing	; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.word ObjInit_BeachedCheep	; Object $43 - OBJ_BEACHEDCHEEP
	.word ObjInit_FallingPlatform	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjInit_HotFoot		; Object $45 - OBJ_HOTFOOT
	.word ObjInit_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjInit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup01_NormalJumpTable:
	.word ObjNorm_PlatformPattern		; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjNorm_PlatformPattern	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjNorm_WoodenPlatFallGen	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjNorm_PlatformPattern	; Object $27 - OBJ_OSCILLATING_H
	.word ObjNorm_PlatformPattern	; Object $28 - OBJ_OSCILLATING_V
	.word ObjNorm_Spike		; Object $29 - OBJ_SPIKE
	.word ObjNorm_Spark		; Object $2A - OBJ_SPARKRIGHT
	.word ObjNorm_Spark	; Object $2B - OBJ_SPARKLEFT
	.word ObjNorm_PlatformPattern		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjNorm_PlatformPattern		; Object $2D - OBJ_BIGBERTHA
	.word ObjNorm_Boo	; Object $2E - OBJ_PIRATEBOO
	.word ObjNorm_Boo		; Object $2F - OBJ_BOO
	.word ObjNorm_HotfootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjNorm_Stretch		; Object $31 - OBJ_BOOSTRETCH
	.word ObjNorm_Stretch		; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word ObjNorm_Nipper		; Object $33 - OBJ_NIPPER
	.word ObjNorm_Toad		; Object $34 - OBJ_TOAD
	.word ObjNorm_ToadHouseItem	; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjNorm_WoodenPlatform	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjNorm_PlatformPattern	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjNorm_PlatformPattern	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjNorm_Nipper		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjNorm_PathFollowPlat	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjNorm_DoNothing	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjNorm_PathFollowPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjNorm_NipperFireBreathe	; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjNorm_WoodenPlatFloat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjNorm_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjNorm_BusterBeatle	; Object $40 - OBJ_BUSTERBEATLE
	.word ObjNorm_DoNothing	; Object $41 - OBJ_ENDLEVELCARD
	.word ObjNorm_BeachedCheep	; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.word ObjNorm_BeachedCheep	; Object $43 - OBJ_BEACHEDCHEEP
	.word ObjNorm_PathFollowPlat	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjNorm_Hotfoot		; Object $45 - OBJ_HOTFOOT
	.word ObjNorm_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjNorm_GiantBlockCtl	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup01_CollideJumpTable:
	.word ObjHit_DoNothing		; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjHit_DoNothing		; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjHit_DoNothing		; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjHit_DoNothing		; Object $27 - OBJ_OSCILLATING_H
	.word ObjHit_DoNothing		; Object $28 - OBJ_OSCILLATING_V
	.word ObjHit_DoNothing		; Object $29 - OBJ_SPIKE
	.word Player_GetHurt		; Object $2A - OBJ_SPARKRIGHT
	.word Player_GetHurt	; Object $2B - OBJ_SPARKLEFT
	.word ObjHit_DoNothing		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjHit_DoNothing		; Object $2D - OBJ_BIGBERTHA
	.word Player_Take_Coins		; Object $2E - OBJ_PIRATEBOO
	.word Player_GetHurt		; Object $2F - OBJ_BOO
	.word Player_GetHurt		; Object $30 - OBJ_HOTFOOT_SHY
	.word Player_GetHurt		; Object $31 - OBJ_BOOSTRETCH
	.word Player_GetHurt		; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word Player_GetHurt		; Object $33 - OBJ_NIPPER
	.word ObjHit_DoNothing		; Object $34 - OBJ_TOAD
	.word ObjHit_DoNothing		; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjHit_DoNothing		; Object $36 - OBJ_WOODENPLATFORM
	.word ObjHit_DoNothing		; Object $37 - OBJ_OSCILLATING_HS
	.word ObjHit_DoNothing		; Object $38 - OBJ_OSCILLATING_VS
	.word Player_GetHurt		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjHit_DoNothing		; Object $3A - OBJ_FALLINGPLATFORM
	.word Player_GetHurt		; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjHit_DoNothing		; Object $3C - OBJ_WOODENPLATFORMFALL
	.word Player_GetHurt		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjHit_DoNothing		; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjHit_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjHit_DoNothing		; Object $40 - OBJ_BUSTERBEATLE
	.word ObjHit_DoNothing	; Object $41 - OBJ_ENDLEVELCARD
	.word Player_GetHurt		; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.word Player_GetHurt		; Object $43 - OBJ_BEACHEDCHEEP
	.word ObjHit_DoNothing		; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word Player_GetHurt		; Object $45 - OBJ_HOTFOOT
	.word Player_GetHurt		; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjHit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL

	
	; Object group $01 (i.e. objects starting at ID $24) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup01_Attributes:
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48		; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48		; Object $25
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $27 - OBJ_OSCILLATING_H
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $28 - OBJ_OSCILLATING_V
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $29 - OBJ_SPIKE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2A - OBJ_SPARKRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2B - OBJ_SPARKLEFT
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $2D - OBJ_BIGBERTHA
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2E - OBJ_PIRATEBOO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2F - OBJ_BOO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $31 - OBJ_BOOSTRETCH
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $33 - OBJ_NIPPER
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $34 - OBJ_TOAD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3F - OBJ_DRYBONES
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $43 - OBJ_BEACHEDCHEEP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $45 - OBJ_HOTFOOT
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $47 - OBJ_GIANTBLOCKCTL

	; Object group $01 (i.e. objects starting at ID $24) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup01_Attributes2:
	.byte OA2_TDOGRP2	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA2_TDOGRP2	; Object $25
	.byte OA2_TDOGRP2	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA2_TDOGRP2	; Object $27 - OBJ_OSCILLATING_H
	.byte OA2_TDOGRP2	; Object $28 - OBJ_OSCILLATING_V
	.byte OA2_TDOGRP1	; Object $29 - OBJ_SPIKE
	.byte OA2_TDOGRP3	; Object $2A - OBJ_SPARKRIGHT
	.byte OA2_TDOGRP3	; Object $2B - OBJ_SPARKLEFT
	.byte OA2_TDOGRP2	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA2_TDOGRP2	; Object $2D - OBJ_BIGBERTHA
	.byte OA2_TDOGRP1	; Object $2E - OBJ_PIRATEBOO
	.byte OA2_TDOGRP1	; Object $2F - OBJ_BOO
	.byte OA2_TDOGRP0	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA2_TDOGRP1	; Object $31 - OBJ_BOOSTRETCH
	.byte OA2_TDOGRP1	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA2_TDOGRP1	; Object $33 - OBJ_NIPPER
	.byte OA2_TDOGRP2	; Object $34 - OBJ_TOAD
	.byte OA2_TDOGRP0	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA2_TDOGRP2	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA2_TDOGRP2	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA2_TDOGRP2	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA2_TDOGRP1	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA2_TDOGRP9	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA2_TDOGRP9	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA2_TDOGRP9	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA2_TDOGRP1	; Object $3F - OBJ_DRYBONES
	.byte OA2_NOSHELLORSQUASH | OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA2_TDOGRP0	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP0	; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $43 - OBJ_BEACHEDCHEEP
	.byte OA2_TDOGRP9	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA2_TDOGRP0	; Object $45 - OBJ_HOTFOOT
	.byte OA2_TDOGRP2	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA2_TDOGRP1	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup01_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $25
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $27 - OBJ_OSCILLATING_H
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $28 - OBJ_OSCILLATING_V
	.byte OA3_HALT_SPIKESPECIAL 	; Object $29 - OBJ_SPIKE
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE 	; Object $2A - OBJ_SPARKRIGHT
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE 	; Object $2B - OBJ_SPARKLEFT
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $2D - OBJ_BIGBERTHA
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2E - OBJ_PIRATEBOO
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2F - OBJ_BOO
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $31 - OBJ_BOOSTRETCH
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $33 - OBJ_NIPPER
	.byte OA3_HALT_JUSTDRAWTALL | OA3_TAILATKIMMUNE	; Object $34 - OBJ_TOAD
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA3_HALT_JUSTDRAW 	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $3F - OBJ_DRYBONES
	.byte OA3_HALT_BUSTERSPECIAL 	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA3_HALT_ENDCARDSPECIAL | OA3_TAILATKIMMUNE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA3_HALT_JUSTDRAW 	; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.byte OA3_HALT_JUSTDRAW 	; Object $43 - OBJ_BEACHEDCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $45 - OBJ_HOTFOOT
	.byte OA3_HALT_PIRANHASPECIAL 	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup01_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OPTS_NOCHANGE	; Object $25
	.byte OPTS_NOCHANGE	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OPTS_NOCHANGE	; Object $27 - OBJ_OSCILLATING_H
	.byte OPTS_NOCHANGE	; Object $28 - OBJ_OSCILLATING_V
	.byte OPTS_SETPT5 | $0A	; Object $29 - OBJ_SPIKE
	.byte OPTS_SETPT5 | $0A	; Object $2A - OBJ_SPARKRIGHT
	.byte OPTS_SETPT5 | $0A	; Object $2B - OBJ_SPARKLEFT
	.byte OPTS_NOCHANGE	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OPTS_NOCHANGE	; Object $2D - OBJ_BIGBERTHA
	.byte OPTS_SETPT5 | $4E	; Object $2E - OBJ_PIRATEBOO
	.byte OPTS_SETPT5 | $12	; Object $2F - OBJ_BOO
	.byte OPTS_SETPT5 | $12	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OPTS_SETPT5 | $12	; Object $31 - OBJ_BOOSTRETCH
	.byte OPTS_SETPT5 | $12	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OPTS_SETPT5 | $0A	; Object $33 - OBJ_NIPPER
	.byte OPTS_SETPT5 | $05	; Object $34 - OBJ_TOAD
	.byte OPTS_SETPT5 | $05	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OPTS_NOCHANGE	; Object $36 - OBJ_WOODENPLATFORM
	.byte OPTS_NOCHANGE	; Object $37 - OBJ_OSCILLATING_HS
	.byte OPTS_NOCHANGE	; Object $38 - OBJ_OSCILLATING_VS
	.byte OPTS_SETPT5 | $0A	; Object $39 - OBJ_NIPPERHOPPING
	.byte OPTS_SETPT6 | $13	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OPTS_SETPT6 | $4F	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OPTS_NOCHANGE	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OPTS_SETPT5 | $0A	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OPTS_NOCHANGE; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OPTS_SETPT6 | $13	; Object $3F - OBJ_DRYBONES
	.byte OPTS_SETPT5 | $0A	; Object $40 - OBJ_BUSTERBEATLE
	.byte OPTS_NOCHANGE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OPTS_SETPT6 | $4F	; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.byte OPTS_SETPT6 | $4F	; Object $43 - OBJ_BEACHEDCHEEP
	.byte OPTS_NOCHANGE ; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OPTS_SETPT5 | $12	; Object $45 - OBJ_HOTFOOT
	.byte OPTS_SETPT5 | $0A	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OPTS_NOCHANGE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup01_KillAction:
	.byte KILLACT_STANDARD	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte KILLACT_STANDARD	; Object $25
	.byte KILLACT_STANDARD	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte KILLACT_STANDARD	; Object $27 - OBJ_OSCILLATING_H
	.byte KILLACT_STANDARD	; Object $28 - OBJ_OSCILLATING_V
	.byte KILLACT_STANDARD	; Object $29 - OBJ_SPIKE
	.byte KILLACT_STANDARD	; Object $2A - OBJ_SPARKRIGHT
	.byte KILLACT_STANDARD	; Object $2B - OBJ_SPARKLEFT
	.byte KILLACT_STANDARD	; Object $2C - OBJ_CLOUDPLATFORM
	.byte KILLACT_STANDARD	; Object $2D - OBJ_BIGBERTHA
	.byte KILLACT_STANDARD	; Object $2E - OBJ_PIRATEBOO
	.byte KILLACT_STANDARD	; Object $2F - OBJ_BOO
	.byte KILLACT_POOFDEATH	; Object $30 - OBJ_HOTFOOT_SHY
	.byte KILLACT_POOFDEATH	; Object $31 - OBJ_BOOSTRETCH
	.byte KILLACT_POOFDEATH	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte KILLACT_STANDARD	; Object $33 - OBJ_NIPPER
	.byte KILLACT_STANDARD	; Object $34 - OBJ_TOAD
	.byte KILLACT_STANDARD	; Object $35 - OBJ_TOADHOUSEITEM
	.byte KILLACT_STANDARD	; Object $36 - OBJ_WOODENPLATFORM
	.byte KILLACT_STANDARD	; Object $37 - OBJ_OSCILLATING_HS
	.byte KILLACT_STANDARD	; Object $38 - OBJ_OSCILLATING_VS
	.byte KILLACT_STANDARD	; Object $39 - OBJ_NIPPERHOPPING
	.byte KILLACT_STANDARD	; Object $3A - OBJ_FALLINGPLATFORM
	.byte KILLACT_NORMALSTATE	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte KILLACT_STANDARD	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte KILLACT_STANDARD	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte KILLACT_STANDARD	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte KILLACT_NORMALANDKILLED	; Object $3F - OBJ_DRYBONES
	.byte KILLACT_STANDARD	; Object $40 - OBJ_BUSTERBEATLE
	.byte KILLACT_STANDARD	; Object $41 - OBJ_ENDLEVELCARD
	.byte KILLACT_STANDARD	; Object $42 - OBJ_ANTIGRAVITYCHEEP
	.byte KILLACT_STANDARD	; Object $43 - OBJ_BEACHEDCHEEP
	.byte KILLACT_STANDARD	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte KILLACT_POOFDEATH	; Object $45 - OBJ_HOTFOOT
	.byte KILLACT_NORMALSTATE	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte KILLACT_STANDARD	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) pattern index starts
	; These are used for all states except "normal"

OG1_POff .func (\1 - ObjectGroup01_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup01_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG1_POff(ObjP24), OG1_POff(ObjP25), OG1_POff(ObjP26), OG1_POff(ObjP27)
	.byte OG1_POff(ObjP28), OG1_POff(ObjP29), OG1_POff(ObjP2A), OG1_POff(ObjP2B)
	.byte OG1_POff(ObjP2C), OG1_POff(ObjP2D), OG1_POff(ObjP2E), OG1_POff(ObjP2F)
	.byte OG1_POff(ObjP30), OG1_POff(ObjP31), OG1_POff(ObjP32), OG1_POff(ObjP33)
	.byte OG1_POff(ObjP34), OG1_POff(ObjP35), OG1_POff(ObjP36), OG1_POff(ObjP37)
	.byte OG1_POff(ObjP38), OG1_POff(ObjP39), OG1_POff(ObjP3A), OG1_POff(ObjP3B)
	.byte OG1_POff(ObjP3C), OG1_POff(ObjP3D), OG1_POff(ObjP3E), OG1_POff(ObjP3F)
	.byte OG1_POff(ObjP40), OG1_POff(ObjP41), OG1_POff(ObjP42), OG1_POff(ObjP43)
	.byte OG1_POff(ObjP44), OG1_POff(ObjP45), OG1_POff(ObjP46), OG1_POff(ObjP47)


	; Object group $01 (i.e. objects starting at ID $24) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup01_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup01_PatternSets:
	; (End restricted alignment space)


ObjP2F:
ObjP35:
ObjP47:
	.byte $91, $93, $B9, $BF
ObjP30:
ObjP45:
	.byte $85, $87, $89, $8B, $81, $83
ObjP31:
ObjP32:
	.byte $A1, $A3, $A5, $A7, $A9, $AB, $AD, $AF, $71, $71

ObjP25:
ObjP26:
ObjP27:
ObjP2C:
ObjP2D:
ObjP28:
ObjP36:
ObjP37:
ObjP38:
ObjP3C:
ObjP3E:
ObjP44:
	.byte $5B, $5D, $5D, $5D, $5D, $5F
ObjP33:
ObjP39:
	.byte $A1, $A3, $AD, $AF, $A5, $A7, $A9, $AB
ObjP34:
	.byte $71, $71, $71, $71 ; #DAHRKDAIZ - Toad looks like Hammer Bros.
ObjP3D:
	.byte $A1, $A3, $A5, $A7, $A9, $AB
ObjP24:
ObjP3F:
	.byte $C1, $C3, $C5, $C7, $C9, $CB, $CD, $CF, $D1, $D3, $D5, $F9, $DD, $DF
	
	; Spike's / Patooie's spike ball patterns are actually here
SpikeBall_Patterns:
	.byte $95, $95, $D9, $DB
ObjP29:
ObjP2A:
ObjP2B:
	.byte $BD, $BD, $BF, $BF
ObjP46:
	.byte $E5, $E5, $E1, $E1, $E1, $E1, $BD, $BF, $E3, $E3
ObjP3B:
ObjP42:
ObjP43:
	.byte $E7, $E9, $E7, $EF, $E7, $EF
ObjP3A:
	.byte $71, $E1, $E3, $E1, $E3, $71
ObjP2E:
	.byte $71, $71, $A9, $AB
ObjP41:
	.byte $51, $51, $53, $53, $55, $55, $F7, $F7, $F9, $F9, $FB, $FB, $E3, $E3, $E5, $E5, $F5, $F5, $FD, $FD, $FD, $FD, $FD, $FD, $E3, $E3, $E5, $E5, $F5, $F5, $D1, $D3, $D5, $D7
ObjP40:
	.byte $B1, $B3, $B5, $B7, $B9, $BB, $75, $75

GiantBlockCtl_BlkBump:	.byte $00 ;CHNGTILE_GIANTBRICKFIX, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBRICKBUST
GiantBlockCtl_BlockStarts:	.byte $00 ;TILE11_BRICK_UL, TILE11_QBLOCKC_UL, TILE11_QBLOCKP_UL
GiantBlockCtl_Frames:	.byte $00, $08, $08

	.byte $00

PRG002_A27B:
	.byte $00, $00, $50, $40, $30, $20, $00, $E0, $D0, $C0, $B0

ObjNorm_GiantBlockCtl:
	RTS		 ; Return

PRG002_A2DB:
	JSR PRG002_A450

	LDA <Player_HaltGame
	BEQ PRG002_A2E3	 ; If gameplay halted, jump to PRG002_A2E3

	RTS		 ; Return

PRG002_A2E3:
	LDA Objects_Timer,X
	CMP #$0a
	BNE PRG002_A30C	 ; If timer <> $0A, jump to PRG002_A30C

	; Timer = $0A...

	PHA		 ; Save timer value

	; Object Y Hi -> Temp_Var13
	LDA <Objects_YHi,X
	STA <Temp_Var13	

	; Object Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14	

	; Object X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15	

	; Object X -> Temp_Var16
	LDA <Objects_X,X
	PHA		 ; Save Object X
	STA <Temp_Var16

	; Clear this tile
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore 'X'
	ORA #$10	 ; Intended as next tile to the right I think
	STA <Temp_Var16	 ; -> Temp_Var16

	; Clear this tile too
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore timer

PRG002_A30C:
	TAY		 ; current timer value -> 'Y'
	LDA PRG002_A27B,Y	
	STA <Objects_YVel,X	 ; Applies a staggering Y velocity

	JMP Object_ApplyYVel	 ; Apply Y velocity and don't come back!

GiantBlockCtl_DebrisXOff:	.byte $00, $10, $00, $10
GiantBlockCtl_DebrisYOff:	.byte $00, $00, $10, $10
GiantBlockCtl_DebrisXVel:	.byte -$10, $10, -$10, $10
GiantBlockCtl_DebrisYVel	.byte -$40, -$40, -$28, -$28

PRG002_A325:
	; Set like Player bounced up
	LDA #$01	 
	STA Player_BounceDir

	LDA <Temp_Var11	 ; A = Temp_Var11 (previous Var2)
	BNE PRG002_A35E	 ; If non-zero, jump to PRG002_A35E

	; Play "bump" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	; Set Object Y Hi = Player's Y Hi
	LDA <Player_YHi
	STA <Objects_YHi,X

	LDA <Player_Y

	LDY <Player_Suit
	BEQ PRG002_A347	 ; If Player is small, jump to PRG002_A347

	; Player is NOT small; subtract 16
	SUB #$10
	BCS PRG002_A347
	DEC <Objects_YHi,X	; Apply carry
PRG002_A347:

	AND #$f0	 ; Align to tile grid row
	ORA #$10	 ; Ensures nearest 32
	STA <Objects_Y,X ; -> Object_Y

	; Set Object X Hi = Player's X Hi
	LDA <Player_XHi	
	STA <Objects_XHi,X

	; Use Player X + 8
	LDA <Player_X
	ADD #$08	
	BCC PRG002_A35A	
	INC <Objects_XHi,X	; Apply carry
PRG002_A35A:

	AND #$e0	 ; Aligned to tile grid, left side only
	STA <Objects_X,X ; -> Object_X

PRG002_A35E:

	; Set BlkBump slot 2 coordinates to the object's position

	LDA <Objects_X,X
	STA Level_BlkBump_XLo+2

	LDA <Objects_XHi,X
	STA Level_BlkBump_XHi+2

	LDA <Objects_YHi,X
	STA Level_BlkBump_YHi+2

	LDA <Objects_Y,X
	STA Level_BlkBump_YLo+2

	;LDA #CHNGTILE_GIANTBRICKBUST
	STA Level_BlkBump+2

	LDA Objects_Var1,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GBCtl_BrickBump	; 0: Giant brick bump (small Player hit it)
	.word GBCtl_CoinBlock	; 1: Giant [?] block with coin
	.word GBCtl_LeafBlock	; 2: Giant [?] block with power up
	.word GBCtl_BrickBust	; 3: Giant brick bust

GBCtl_BrickBump:
	JMP PRG002_A420	; Jump to PRG002_A420

GBCtl_CoinBlock:
	INC Coins_Earned	 ; Give a coin

	LDA <Objects_Y,X
	STA <Temp_Var1		; Temp_Var1 = Object's Y

	LDA <Objects_X,X
	ORA #$0e
	STA <Temp_Var2		; Temp_Var2 = Object's X aligned evenly in column

	JSR Produce_Coin	 ; Init for emerging coin

	JMP PRG002_A420	 ; Jump to Produce_Coin

GBCtl_LeafBlock:
	LDA <Player_X
	AND #$10
	STA Player_MushFall ; Determine which way a powerup should fall

	LDA #$1e	; A = $1E if Player is not small (Super Leaf)

	LDY <Player_Suit
	BNE PRG002_A3AA	 ; If Player is NOT small, jump to PRG002_A3AA

	LDA #$0d	 ; Otherwise, A = $0D (Mushroom)

PRG002_A3AA:
	LDY #$05	 ; Y = 5 (altering fifth object slot)

	; Make power up appear
	STA Level_ObjectID,Y

	; Set State = 1 (Init)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set X as +8 from Object X
	LDA <Objects_X,X
	ADD #$08
	STA Objects_X,Y

	; Match other coordinates
	LDA <Objects_XHi,X
	STA Objects_XHi,Y
	LDA <Objects_Y,X
	STA Objects_Y,Y	
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	JMP PRG002_A420	 ; Jump to PRG002_A420

GBCtl_BrickBust:
	; Crumbling brick noise
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDX #$03	 ; X = 3 (looking for up to 4 special objects, the brick debris)
	LDY #$05	 ; Y = 5

PRG002_A3DA:
	LDA SpecialObj_ID,Y
	BEQ PRG002_A3E5	 ; If this special object slot is free, jump to PRG002_A3E5

	DEY		 ; Y--
	BPL PRG002_A3DA	 ; While Y >= 0, loop!

	JMP PRG002_A417	 ; Jump to PRG002_A417

PRG002_A3E5:

	; Found a free slot!

	; Brick debris
	LDA #SOBJ_BRICKDEBRIS
	STA SpecialObj_ID,Y

	; Set brick debris coordinates
	LDA GiantBlockCtl_DebrisXOff,X
	ADD Level_BlkBump_XLo+2	
	STA SpecialObj_XLo,Y	

	LDA GiantBlockCtl_DebrisYOff,X	
	ADD Level_BlkBump_YLo+2
	STA SpecialObj_YLo,Y
	LDA #$00	
	ADC Level_BlkBump_YHi+2	
	STA SpecialObj_YHi,Y	

	; Set brick debris X Velocity
	LDA GiantBlockCtl_DebrisXVel,X	
	STA SpecialObj_XVel,Y	

	; Set brick debris Y Velocity
	LDA GiantBlockCtl_DebrisYVel,X	
	STA SpecialObj_YVel,Y

	; Brick data = 0
	LDA #$00
	STA SpecialObj_Data,Y

PRG002_A417:
	DEY		 ; Y--
	DEX		 ; X--
	BPL PRG002_A3DA	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_A420	 ; Jump to PRG002_A420

PRG002_A420:
	LDA <Temp_Var11	; A = Temp_Var11 (previous Var2)
	BNE PRG002_A428	 ; If non-zero, jump to PRG002_A428

	; Otherwise, halt Player's vertical movement
	LDA #$00
	STA <Player_YVel

PRG002_A428:

	; Set timer to $0B
	LDA #$0b
	STA Objects_Timer,X

	JMP PRG002_A450	 ; Jump to PRG002_A450

GiantBlockCtl_Pats:	.byte $73, $7B, $7B, $73, $7D, $7F, $7F, $7D, $79, $7B, $7B, $79, $79, $7B, $7B, $79
GiantBlockCtl_Attrs:	.byte $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_VFLIP, SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, SPR_HFLIP | SPR_VFLIP

PRG002_A450:
	LDA Objects_Var1,X
	CMP #$03
	BEQ PRG002_A487	 ; If Var1 = 3, jump to PRG002_A487 (RTS)

	JSR Object_CalcSpriteXY_NoHi

	LDA <Objects_SpriteX,X
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X

	PHA		 ; Save it

	DEC <Objects_SpriteY,X	 ; Sprite Y--

	LDA <Objects_SpriteY,X
	STA <Temp_Var3		 ; Temp_Var3 = Sprite Y

	PHA		 ; Save it

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_Frame,X
	TAX		 ; X = object's frame
	JSR GiantBlockCtl_Draw
	JSR GiantBlockCtl_Draw

	PLA		 ; Restore Sprite Y
	ADD #16
	STA <Temp_Var3	 ; Temp_Var3 = Sprite Y + 16

	PLA		 ; Restore Sprite X
	STA <Temp_Var2	 ; -> Temp_Var2

	JSR GiantBlockCtl_Draw
	JSR Object_GetRandNearUnusedSpr	 ; Get random nearby unused sprite
	JSR GiantBlockCtl_Draw

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_A487:
	RTS		 ; Return

GiantBlockCtl_Draw:
	LDA Player_AboveTop
	BNE PRG002_A4B7	 ; If Player is way up high, jump to PRG002_A4B7 (RTS)

	LDA #$02
	STA <Temp_Var5	 ; Temp_Var5 = 2
PRG002_A4A4:
	; Store Sprite Y
	LDA <Temp_Var3
	STA Sprite_RAM+$00,Y

	; Store appropriate pattern
	LDA GiantBlockCtl_Pats,X
	STA Sprite_RAM+$01,Y

	; Set attributes
	LDA #SPR_PAL3	; Palette select 3
	ORA GiantBlockCtl_Attrs,X	; And what he's having
	STA Sprite_RAM+$02,Y

	; Store Sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; X += 8
	ADD #$08
	STA <Temp_Var2

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	INX		 ; X++ (next pattern/attribute)

	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG002_A4A4	 ; While Temp_Var5 > 0, loop!

PRG002_A4B7:
	RTS		 ; Return

	; Carry is set if gameplay not halted and object not dead
CarryClearIfAliveAndNoHalt:
	LDA Objects_State,X	  
	CMP #OBJSTATE_KILLED	; Carry is clear unless state >= OBJSTATE_KILLED
	BEQ PRG002_A4C5	 ; If object state is Dying, jump to PRG002_A4C5

	CLC		 ; Clear carry (if any state other than OBJSTATE_KILLED)

	LDA <Player_HaltGame
	BEQ PRG002_A4C5	 ; If gameplay is not halted, jump to PRG002_A4C5

	SEC		 ; Set carry

PRG002_A4C5:
	RTS		 ; Return

Buster_XVel:	.byte -$10, $10

ObjInit_BusterBeatle:
	LDY <Scroll_LastDir	; Get last scroll direction

	; Set flip bits to face Player
	LDA FacePlayer_FlipBitsStart,Y
	STA Objects_FlipBits,X

	; Set appropriate X velocity for Buster Beatle
	LDA Buster_XVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return


ObjNorm_BusterBeatle:

	JSR Object_Move	 ; Do standard object movements
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block
	JSR Object_HitFloorAlign	 ; If Buster hits floor, align him

	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG002_A535	 ; If not hit wall, jump to PRG002_A535

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A532	 ; If Buster has not hit floor, jump to PRG002_A532

	JSR Object_AnySprOffscreen
	BNE PRG002_A532	 ; If any of Buster's sprite are off-screen, jump to PRG002_A532

	LDY #$02	; Y = 1 (Buster's got brick!)

	LDA Object_TileWall
	AND #$F0
	CMP #TILE_PROP_SOLID_ALL
	BNE PRG002_A532
	LDA Object_TileWall
	AND #$0F
	CMP #TILE_PROP_STONE
	BNE PRG002_A532	 ; If Buster's touching an ice brick, jump to PRG002_A508


	STY <Objects_Var5,X	 ; Update Var5

	; Change tile event (to background) by ice brick
	LDA #01
	STA Level_ChgTileEvent

	; Set all of the block change coordinates to remove the ice brick
	LDA ObjTile_DetYHi
	STA Level_BlockChgYHi

	LDA ObjTile_DetYLo
	AND #$f0
	STA Level_BlockChgYLo

	LDA ObjTile_DetXHi
	STA Level_BlockChgXHi

	LDA ObjTile_DetXLo
	AND #$f0
	STA Level_BlockChgXLo

	; Set Buster's timer 2 to $0F
	LDA #$0f
	STA Objects_Timer2,X

	BNE PRG002_A535	 ; Jump (technically always) to PRG002_A535

PRG002_A532:
	JSR Object_AboutFace	 ; Buster turns around

PRG002_A535:
	LDA Objects_Timer,X
	BNE PRG002_A542	 ; If timer not expired, jump to PRG002_A542

	LDA Objects_Timer2,X 
	BEQ PRG002_A542	 ; If timer 2 expired, jump to PRG002_A542

	; Timer 2 not expired...
	ADD #29	 ; Add to timer 2 value

PRG002_A542:
	LSR A		 
	STA <Objects_Var4,X	 ; Var4 = timer2 / 2

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Buster_DrawHoldingIceBrick	 ; Draw Buster with his ice brick if he has it

	LDA <Objects_Var5,X
	ORA Objects_Timer,X
	BNE PRG002_A568	 	; If Buster is holding a brick or his timer is not expired, jump to PRG002_A568

	LDY #$10	 ; Y = $10 (Run right)

	LDA Objects_FlipBits,X
	ASL A
	BMI PRG002_A55C	 ; If horizontally flipped, jump to PRG002_A55C

	LDY #-$10	 ; Y = -$10 (Run left)

PRG002_A55C:
	STY <Objects_XVel,X	 ; Set Buster's X Velocity

	; Buster's little frame toggle
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A568:

	; Buster with brick or timer not expired

	; Halt Buster's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDA Objects_Timer2,X
	BEQ PRG002_A57B	 ; If Timer 2 expired, jump to PRG002_A57B

	; Timer 2 not expired...

	AND #%00011000
	BNE PRG002_A5A1	 ; Timing jump to PRG002_A5A1 (RTS)
 
	; Buster's frame = 2 
	LDA #$02
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A57B:
	LDA Objects_Timer,X
	BEQ PRG002_A587	 ; If timer expired, jump to PRG002_A587

	CMP #$11
	BNE PRG002_A5A1	 ; If timer <> $11, jump to PRG002_A5A1 (RTS)
	JMP PRG002_A5A2	 ; Otherwise, jump to PRG002_A5A2

PRG002_A587:
	LDA <Counter_1
	AND #$07
	BNE PRG002_A5A1	 ; 1:8 ticks continue, otherwise jump to PRG002_A5A1 (RTS)

	; Set Buster's flip to face towards Player
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	CMP #$0c
	BGE PRG002_A5A1	 ; If Player is too far away, jump to PRG002_A5A1 (RTS)

	; "Stay close for $1B and I'll getcha..."
	LDA #$1b
	STA Objects_Timer,X

PRG002_A5A1:
	RTS		 ; Return

PRG002_A5A2:
	LDX #$04	 ; X = 4

PRG002_A5A4:
	LDA Objects_State,X
	BEQ PRG002_A5AE	 ; If this object slot's state is Dead/Empty, jump to PRG002_A5AE

	DEX		 ; X--
	BPL PRG002_A5A4	 ; While X >= 0, loop!
	BMI PRG002_A5F8	 ; Otherwise, jump to PRG002_A5F8

PRG002_A5AE:
	JSR Level_PrepareNewObject	; Generate new object for tossed ice block

	LDY <SlotIndexBackup	 ; Y = Buster's slot index

	; Var5 and Frame = 0
	LDA #$00
	STA Objects_Var5,Y
	STA Objects_Frame,Y

	; Set Ice Block to state Kicked
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	; It's an Ice Block
	LDA #OBJ_STONEBLOCK
	STA Level_ObjectID,X

	LDA #$02
	STA Objects_SprAttr, X

	; Set Frame = 2
	LDA #$00
	STA Objects_Frame,X

	; Set expiration timer
	LDA #$ff
	STA Objects_Timer3,X

	; Set X
	LDA Objects_X,Y
	STA <Objects_X,X

	; Set X Hi
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	; Set Y/Hi
	LDA Objects_Y,Y
	SUB #16
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	LDA Objects_FlipBits,Y

	LDY #$30	 ; Y = $30
	ASL A
	BMI PRG002_A5F2	 ; If Buster's turned around, jump to PRG002_A5F2
	LDY #-$30	 ; Otherwise, Y = -$30
PRG002_A5F2:
	STY <Objects_XVel,X

	; Set Y velocity
	LDA #-$30
	STA <Objects_YVel,X

PRG002_A5F8:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Buster_BlockLiftXOff:
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $02, $03, $02, $01, $00
	.byte $01, $03, $05, $07, $08, $09, $0A, $0A

Buster_BlockLiftYOff:
	.byte -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0D
	.byte -$0C, -$0D, -$0E, -$0E, -$0F, -$0E, -$0D, -$0B, -$09, -$06, -$03, $00 

Buster_DrawHoldingIceBrick:
	JSR Object_ShakeAndCalcSprite	 

	LDA <Temp_Var3
	BPL PRG002_A641	 ; If object is not vertically flipped, jump to PRG002_A641

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var4,X
	TAX		 	; X = Var4 (lift offset index)

	; Offset sprite Y by the index given in Var4
	LDA <Temp_Var1
	ADD Buster_BlockLiftYOff,X
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = Var6

PRG002_A641:
	JSR Object_Draw16x16Sprite	 ; Draw Buster

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var5,X
	BEQ PRG002_A68B	 	; If Var5 = 0 (not holding brick), jump to PRG002_A68B (RTS)

	; Var5 not zero...

	PHA		 	; Save Var5

	LDA <Objects_SpriteY,X

	LDY <Objects_Var4,X	 ; Y = Var4

	BIT <Temp_Var3
	BMI PRG002_A657	 	; If vertically flipped, jump to PRG002_A657

	; Adds an offset in case Buster's holding a block... but since it's
	; applied all the time, it just looks odd otherwise...
	ADD Buster_BlockLiftYOff,Y

PRG002_A657:
	STA <Temp_Var1		 ; Update Sprite Y

	LDA Buster_BlockLiftXOff,Y
	BIT <Temp_Var3
	BVS PRG002_A663	 ; If Buster is horizontally flipped, jump to PRG002_A663

	JSR Negate	 ; Negate the X offset if he's flipped around

PRG002_A663:
	ADD <Temp_Var2	; Apply X offset
	STA <Temp_Var2	; Update Sprte X

	PLA		 ; Restore Var5

	LDA <Temp_Var7
	ADD #$08	
	TAY		 ; Y = Sprite_RAM + 8
	
	LDA <Temp_Var1
	STA Sprite_RAM , Y
	STA Sprite_RAM + 4, Y
	LDA <Temp_Var2
	STA Sprite_RAM + 3, Y
	ADC #$08
	STA Sprite_RAM + 7, Y
	LDA #$02
	STA Sprite_RAM + 2, Y
	STA Sprite_RAM + 6, Y
	LDA #$97
	STA Sprite_RAM + 1, Y
	LDA #$99
	STA Sprite_RAM + 5, Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_A68B:
	RTS		 ; Return

ObjInit_BeachedCheep:
	LDY Objects_Property, X
	LDA BeachedCheep_VFlip, Y
	STA Objects_FlipBits, X
	STA Objects_Var1, X
	CPY #$02
	BNE ObjInit_BeachedCheep2
	LDA #$30
	STA <Objects_YVel, X

ObjInit_BeachedCheep2:
	JSR Object_WorldDetect4
	LDA Objects_InWater, X
	BEQ ObjInit_BeachedCheep1
	RTS

BeachedCheepReset:
	LDA #$00
	STA Objects_Var1, X
	LDA #$20
	STA Objects_Timer,X
	RTS		 ; Return

ObjInit_BeachedCheep1:
	INC Objects_Var1, X
	JSR Level_ObjCalcXDiffs
	LDA BeachedCheep_XVel, Y
	STA <Objects_XVel, X
	LDA BeachedCheep_Flip, Y
	LDY Objects_Property, X
	ORA BeachedCheep_VFlip, Y
	STA Objects_FlipBits, X
	RTS

PRG002_A772:	.byte $20, $20, -$20, -$20, $00, $00
	
BeachedCheep_XVel: .byte $10, $F0
BeachedCheep_Flip: .byte SPR_HFLIP, 00
BeachedCheep_VFlip: .byte $00, SPR_VFLIP, $00

BeachedCheep_PondJump:
	.byte $A0, $50

BeachedCheep_GroundBounce: 
	.byte $D0, $08, $D0

BeachedCheep_CeilingBounce: 
	.byte $08, $30, $30

ObjNorm_BeachedCheep:
	LDA <Player_HaltGame
	BNE PRG002_A7E1
	LDA Objects_Timer,X
	BNE PRG002_A7E0	 ; If timer expired, jump to PRG002_A793

	LDA Objects_Var1, X
	BNE ObjNorm_BeachedCheep1
	INC Objects_Var1, X
	LDY Objects_Property, X
	LDA BeachedCheep_PondJump, Y
	STA <Objects_YVel, X
	JSR Level_ObjCalcXDiffs
	LDA BeachedCheep_XVel, Y
	STA <Objects_XVel, X
	LDA BeachedCheep_Flip, Y
	LDY Objects_Property, X
	ORA BeachedCheep_VFlip, Y
	STA Objects_FlipBits, X

ObjNorm_BeachedCheep1:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	LDA Objects_Property, X
	BEQ Normal_Bounce
	CMP #$01
	BNE DoNoGravity
	STA ReverseGravity
	BEQ Normal_Bounce

DoNoGravity:
	STA NoGravity

Normal_Bounce:
	JSR Object_InteractWithWorld
	JSR Player_HitEnemy

	LDA Objects_DetStat, X
	AND #$04
	BEQ ObjNorm_BeachedCheep2

	LDY Objects_Property, X
	LDA BeachedCheep_GroundBounce, Y
	STA <Objects_YVel, X

ObjNorm_BeachedCheep2:
	LDA Objects_DetStat, X
	AND #$08
	BEQ ObjNorm_BeachedCheep3

	LDY Objects_Property, X
	LDA BeachedCheep_CeilingBounce, Y
	STA <Objects_YVel, X

ObjNorm_BeachedCheep3:
	LDA Objects_Property, X
	BEQ PRG002_A7DF
	LDA <Objects_Y, X
	AND #$0F
	BNE PRG002_A7E0

PRG002_A7DF:
	LDA Objects_InWater, X
	BEQ PRG002_A7E0
	JSR BeachedCheepReset

PRG002_A7E0:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X

PRG002_A7E1:
	JMP Object_ShakeAndDraw	 ; Draw Cheep Cheep and don't come back!

	; Different "entropy" values by the object's slot -- keeps things random looking
Entropy_BySlot:	.byte $13, $D7, $F9, $36, $7F

ObjInit_HotFoot:
	LDA Entropy_BySlot,X
	STA <Objects_Var5,X

ObjInit_HotFootShy:

	; Center Hot Foot
	LDA <Objects_X,X
	ORA #$04
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_HotfootShy:
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; Hotfoot's gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	JSR Object_WorldDetectN1
	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG002_A81B	 ; If Hotfoot hit a wall, jump to PRG002_A81B

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG002_A81B:
	JSR Object_HitFloorAlign	 ; If HotFoot hits the floor, align him to it
	JSR Boo_CheckPlayerSight	 ; Uses Boo's check-facing logic

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot has NOT hit floor, jump to PRG002_A846

	LDA #$00	; Don't move (if not chasing Player)

	BCC PRG002_A844	 ; (From Boo_CheckPlayerSight) if not chasing Player, jump to PRG002_A844

	; Hotfoot is chasing Player...

	; Face same way as Player
	LDA <Player_FlipBits
	STA Objects_FlipBits,X

PRG002_A832:
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02
	TAY		 ; Y = 0 or 2

	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA #$08	; Walk right

	BCS PRG002_A844	; If horizontally flipped, jump to PRG002_A844

	LDA #-$08	; Walk left

PRG002_A844:
	STA <Objects_XVel,X	 ; Set X velocity appropriately

PRG002_A846:
	TYA		 ; A = 0 or 2
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_A850:
	LSR Objects_Frame,X	 ; Frame becomes 0 or 1 (to be ROLled back)

	LDA <Counter_1
	LSR A	
	ROL Objects_Frame,X	 ; Frame is now 0/1 or 2/3, depending on counter LSb (flickering effect) 

Bank2_HotFootHaltAction:
	JSR Object_AnySprOffscreen
	BNE PRG002_A888	 ; If any of Hotfoot's sprites are off-screen, jump to PRG002_A888 (RTS)

	JSR Object_CalcSpriteXY_NoHi	; Calculate Hotfoot's sprites
	LDY ObjGroupRel_Idx	 	; Y = Object's group relative index
	LDA ObjectGroup_PatternStarts,Y	; Get Hotfoot's starting pattern index
	ADD Objects_Frame,X	 	; Offset by frame
	TAY		 		; -> 'Y'
	LDA ObjectGroup_PatternSets,Y	; Get appropriate sprite pattern for this frame

	; Store pattern into sprite RAM
	LDY Object_SprRAM,X
	STA Sprite_RAM+$01,Y

	; Store Y coordinate
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

	; Store attributes
	LDA Objects_SprAttr,X
	ORA Objects_FlipBits,X
	STA Sprite_RAM+$02,Y

	; Store X coordinate
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$03,Y	

PRG002_A888: 
	RTS		 ; Return


ObjNorm_Hotfoot:

	; Mostly reuses the "shy" Hotfoot's code

	JSR CarryClearIfAliveAndNoHalt
	BCS PRG002_A850	 ; If Hotfoot is not alive or gameplay is halted, jump to PRG002_A850

	; Hotfoot alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot hasn't hit floor, jump to PRG002_A846

	INC <Objects_Var5,X	 ; Var5++
	LDA <Objects_Var5,X	
	AND #$a0
	BEQ PRG002_A844	 ; If Var5 = $A0, jump to PRG002_A844

	ASL A

	LDA <Objects_Var5,X
	TAY		 ; Y = Var5
	AND #%01011111
	BNE PRG002_A8B6	 ; Most of the time, jump to PRG002_A8B6

	BCC PRG002_A8B3	 ; If Var5 bit 7 not set, jump to PRG002_A8B3

	JSR Object_CalcCoarseXDiff
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Store flip towards Player

PRG002_A8B3:
	JSR Object_FlipFace	 ; Turn around

PRG002_A8B6:
	JMP PRG002_A832	 ; Jump to PRG002_A832

Boo_CheckPlayerSight:
	LDY <Objects_Var5,X

	JSR Object_CalcCoarseXDiff
	EOR <Player_FlipBits	 ; Check flip direction against Player; if Player and Boo are facing eachother, result is non-zero
	ASL A		 ; Push up result so it is $00 or $80
	BPL PRG002_A8C5	 ; If Player is not facing Boo, jump to PRG002_A8C5

	LDY #$00	 ; Otherwise, Y = 0

PRG002_A8C5:
	CPY #$14
	BGE PRG002_A8CC	 ; If Var5 >= $14 (Time to start chasing!), jump to PRG002_A8CC

	INY		 ; Y++ (Delaying before starting chase)

	STY <Objects_Var5,X	; Update Var5

PRG002_A8CC:
	RTS		 ; Return

ObjNorm_Boo:
	LDA Level_ObjectID, X
	CMP #OBJ_PIRATEBOO		; it's pirate boo, chase Mario ALWAYS!
	BEQ PRG002_A8DE
	JSR Boo_CheckPlayerSight
	BCS PRG002_A8DE	 ; If carry set, it's time to start chasing Player!  Jump to PRG002_A8DE

	; Otherwise, Boo just sits still
	LDA #$00
	STA <Objects_XVel,X
	STA <Objects_YVel,X

	BEQ PRG002_AA46	 ; Jump (technically always) to PRG002_AA46

PRG002_A8DE:
	JSR Chase
	LDA #$01	 ; A = 1 (frame 1, chase!)

PRG002_AA46:
	STA Objects_Frame,X	 ; Update Boo's frame

	JSR Object_HitTestRespond	; Do collision test with Player and respond
	JSR Fish_FixedYIfAppro	 	; Fix Boo Y for raster area

Object_DeleteOrDraw:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JMP Object_ShakeAndDraw	 	; Draw and don't come back!

Stretch_XVelStart:	.byte -$10, $10
FacePlayer_FlipBitsStart:	.byte $00, SPR_HFLIP, $00	; Boo uses an off-by-1 index here, hence the other $00

ObjInit_Stretch:

	; Stretch starts 4 pixels lower than his placement
	LDA <Objects_Y,X
	ADD #$04
	STA <Objects_Y,X
	BCC PRG002_A935
	INC <Objects_YHi,X
PRG002_A935:

	; Determine which direction Player was moving when Stretch appeared
	LDY <Scroll_LastDir	

	; Set Stretch's flip to be towards Player
	LDA FacePlayer_FlipBitsStart,Y
	STA Objects_FlipBits,X	

	; Set Stretch's X velocity to be towards Player
	LDA Stretch_XVelStart,Y	
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_StretchFlip:
	JSR PRG002_A935	 ; Do most of what the un-flipped Stretch does

	; Flipped Stretch's Y velocity = -$80 (Ram into nearest ceiling)
	LDA #-$80
	STA <Objects_YVel,X

	; Set vertical flip
	ORA Objects_FlipBits,X
	STA Objects_FlipBits,X

	; Set Stretch at 6 pixels above his placement position
	LDA <Objects_Y,X
	SUB #$06
	STA <Objects_Y,X
	BCS PRG002_A95B
	DEC <Objects_YHi,X
PRG002_A95B:

	RTS		 ; Return

	; Stretch timer reset values by internal state (Var5)
Stretch_TimerByIntState:
	.byte $7F, $1F, $1F, $17

ObjNorm_Stretch:
	LDY <Objects_Var5,X	 ; Y = Var5 (internal state)

	LDA Objects_Timer,X
	BNE PRG002_A974	 ; If timer not expired, jump to PRG002_A974

	DEY		 ; Y--
	BPL PRG002_A96C	 ; If Y >= 0, jump to PRG002_A96C

	LDY #$03	 ; Otherwise, Y = 3

PRG002_A96C:
	STY <Objects_Var5,X	 ; Var5 = 0 to 3

	; Set timer based on Var5
	LDA Stretch_TimerByIntState,Y
	STA Objects_Timer,X

PRG002_A974:
	TYA
	LSR A
	PHP		 ; Save CPU state (most importantly, zero flag)
	BCS PRG002_A9A0	 ; If in internal state 1 or 3, jump to PRG002_A9A0

	JSR Object_ApplyXVel	 ; Apply X velocity
	LDY ObjGroupRel_Idx	 ; Y = Object's group relative index

	LDA ObjectGroup01_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_TDOGRPMASK		; Mask out the root tile detection group offset
	LSR A		 	; Correct the index
	TAY		 	; -> 'Y'

	LDA <Objects_YVel,X
	BPL PRG002_A98C	 ; If Stretch is on top, jump to PRG002_A98C

	; Otherwise, Y += 2 (Different detection offset)
	INY
	INY

PRG002_A98C:
	JSR Object_DetectTile
	CMP #TILE2_GHOSTM
	BEQ PRG002_A996	 ; If Stretch is gliding along a non-edge "Ghost tile", jump to PRG002_A996

	JSR Object_AboutFace	 ; Otherwise, turn around!

PRG002_A996:

	; FYI: You don't come here in internal state 1 or 3; those are explicitly handled by PRG002_A9A0

	LDA #$02	 ; A = 2
	PLP		 ; Restore CPU state (most importantly, zero flag, which means internal state 0 or 1)
	BEQ PRG002_A9AD	 ; If in internal state 0, jump to PRG002_A9AD

	; Use frame 4 if in internal state 2 
	ASL A
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A9A0:

	; Internal state 1 or 3 ONLY (Stretch rising or Stretch receding)

	LDA Objects_Timer,X
	LSR A
	LSR A
	LSR A
	AND #$03	 ; A = 0 to 3, by timer

	PLP		 ; Restore CPU state (most importantly, zero flag, which means internal state 0 or 1)
	BNE PRG002_A9AD	 ; If in internal state 3, jump to PRG002_A9AD

	EOR #$03	 ; In state 1, invert the value

PRG002_A9AD:
	STA Objects_Frame,X	 ; Store the frame
	JSR Object_DeleteOrDraw	 ; Delete Stretch if he falls off-screen, or draw him
	JMP Object_HitTestRespond	 ; Do collision test and respond, and don't come back!

ObjInit_InvisibleLift:

	; Object appears 11 pixels below placement
	LDA <Objects_Y,X
	ADD #11
	STA <Objects_Y,X
	BCC PRG002_A9C1	
	INC <Objects_YHi,X
PRG002_A9C1:

	RTS		 ; Return

ObjNorm_InvisibleLift:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the Sprite X and Sprite Y

	LDA <Objects_Var5,X
	BNE PRG002_A9D2	 ; If Var5 <> 0 (Lift activated), jump to PRG002_A9D2

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)
	BEQ PRG002_A9F5	 ; Otherwise, jump to PRG002_A9F5

PRG002_A9D2:

	; Lift activated...

	JSR InvisiLift_Draw	 ; Draw the lift

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)

	; Lift accelerates to -$20
	LDA <Objects_YVel,X
	SUB #$04
	CMP #-$20
	BGE PRG002_A9E4
	LDA #-$20
PRG002_A9E4:

	LDY <Objects_YHi,X
	BNE PRG002_A9F0	 ; If lift is on lower part of screen, jump to PRG002_A9F0

	; Lift is on higher part of screen...

	LDY <Objects_Y,X
	CPY #64
	BGE PRG002_A9F0	 ; If lift's Y >= 64, jump to PRG002_A9F0

	LDA #$00	 ; Otherwise, halt!

PRG002_A9F0:
	STA <Objects_YVel,X	 ; Update Y Velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity

PRG002_A9F5:

	; Don't worry about carry since this platform doesn't move horizontally
	LDA #$00
	STA Object_VelCarry

	JSR PlayerPlatform_Collide
	BCC PRG002_AA03	 ; If Player is not being carried by lift, jump to PRG002_AA03 (RTS)

	; Otherwise, Var5 = 1 (lift activated)
	LDA #$01
	STA <Objects_Var5,X

PRG002_AA03:
	RTS		 ; Return


InvisiLift_Draw:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	; Strip any horizontal or vertical flips from flip bits
	LDA <Temp_Var3
	AND #%00111111
	STA <Temp_Var3

	LDA <Counter_1
	LSR A	

	PHP		 ; Save CPU state
	BCC PRG002_AA17	 ; Every other tick, jump to PRG002_AA17

	; Otherwise, use Sprite_RAM offset +8
	TYA
	ADC #$07
	TAY

PRG002_AA17:
	JSR Object_Draw16x16Sprite	; Draw the first half of lift

	LDA <Temp_Var7
	PLP		 ; Restore CPU state
	BCS PRG002_AA21	 ; Every other opposite tick, jump to PRG002_AA21

	; Otherwise, use Sprite_RAM offset +8
	ADC #$08

PRG002_AA21:
	TAY		 ; Sprite_RAM offset -> 'Y'

	; X += 2 (starting sprite tile)
	INX
	INX

	; +16 for second part of lift
	LDA #16
	ADD <Temp_Var2
	STA <Temp_Var2

	; Use latter horizontal visibility bits
	ASL <Temp_Var8
	ASL <Temp_Var8
	JSR Object_Draw16x16Sprite	 ; Draw the second half of lift

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

PlatformTimers:
	.byte $00, $10, $20, $30, $40, $50, $60

ObjInit_WoodenPlatHorz:
	LDA Objects_Property, X
	TAY
	LDA PlatformTimers, Y
	STA Objects_Var10, X
	LDA #$00
	STA Objects_Property, X
	JMP InitPatrol

ObjInit_WoodenPlatVert:
	LDA Objects_Property, X
	TAY
	LDA PlatformTimers, Y
	STA Objects_Var11, X
	LDA #$01
	STA Objects_Property, X
	JMP InitPatrol

ObjInit_WoodenPlatDiagonal1:
	LDA Objects_Property, X
	TAY
	LDA PlatformTimers, Y
	STA Objects_Var10, X
	STA Objects_Var11, X
	LDA #$02
	STA Objects_Property, X
	JMP InitPatrol

ObjInit_WoodenPlatDiagonal2:
	LDA Objects_Property, X
	TAY
	LDA PlatformTimers, Y
	STA Objects_Var10, X
	STA Objects_Var11, X
	LDA #$03
	STA Objects_Property, X
	JMP InitPatrol

ObjInit_WoodenPlatCCW:
	LDA Objects_Property, X
	TAY
	LDA PlatformTimers, Y
	STA Objects_Var10, X
	STA Objects_Var11, X
	LDA #$04
	STA Objects_Property, X
	JMP InitPatrol

ObjInit_WoodenPlatCW:
	LDA Objects_Property, X
	TAY
	LDA PlatformTimers, Y
	STA Objects_Var10, X
	STA Objects_Var11, X
	LDA #$05
	STA Objects_Property, X
	JMP InitPatrol
	
ObjInit_WoodenPlat:
	RTS		 ; Return


Player_StandOnPlatform:
	; Set Player to object's Y - 31
	LDA <Player_YVel
	BMI PRG002_AA85
	LDA <Objects_Y,X	 
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	LDA <Objects_XVel, X
	BEQ PRG002_AA84
	LDA #$01
	STA Player_OnPlatform

	; Flag Player as NOT mid-air
PRG002_AA84:
	LDY #$00
	STY <Player_InAir

PRG002_AA85:
	RTS		 ; Return

ObjInit_WoodenPlatFallGen:
	LDA #$FC
	STA <Objects_YVel, X
	LDA Objects_SprAttr,X
	ORA #SPR_BEHINDBG
	STA Objects_SprAttr,X

ObjInit_WoodenPlatFallGen1:
	LDA <Objects_Y, X
	STA Objects_Var1, X
	LDA <Objects_YHi, X
	STA Objects_Var2, X
	RTS

Reset_WoodenPlatFallGen:
	LDA #$60
	STA Objects_Timer, X
	LDA Objects_Var1, X
	STA <Objects_Y, X
	LDA Objects_Var2, X
	STA <Objects_YHi, X
	LDA #00
	STA Objects_Var3, X
	RTS

ObjNorm_WoodenPlatFallGen:

	LDA Objects_Timer, X
	BNE ObjNorm_WoodenPlatFallGenRTS

	JSR DeleteIfOffAndDrawWide

	LDA <Player_HaltGame
	BNE ObjNorm_WoodenPlatFallGenRTS	 ; If gameplay is halted, jump to PRG002_AAA6 (RTS)

	LDA Objects_Y, X
	AND #$0F
	CMP #$0D
	BNE ObjNorm_WoodenPlatFallApplyY

	LDA Objects_Var3, X
	CMP #$07
	BEQ CreatePlatForm
	INC Objects_Var3, X
	BNE ObjNorm_WoodenPlatFallApplyY

CreatePlatForm:
	JSR FindEmptyEnemySlot
	CPX #$FF
	BEQ ObjNorm_WoodenPlatFallGenRTS

	LDY <SlotIndexBackup
	LDA #OBJ_WOODENPLATUNSTABLE
	STA Level_ObjectID,X

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA #$00
	STA Objects_Frame, X

	LDA Objects_X,Y
	STA <Objects_X,X
	LDA Objects_XHi,Y
	STA <Objects_XHi,X
	LDA Objects_Y,Y
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	STA <Objects_YHi,X
	INC Objects_Var4,X
	LDA #SPR_PAL3
	STA Objects_SprAttr,X
	LDX <SlotIndexBackup
	JMP Reset_WoodenPlatFallGen
	
ObjNorm_WoodenPlatFallApplyY:
	LDA #$FC
	STA <Objects_YVel, X
	JSR Object_ApplyYVel	 ; Apply X velocity

ObjNorm_WoodenPlatFallGenRTS:
	RTS		 ; Return


PRG002_AAA6:
	RTS

Enemy_CollideWithWorld:
	JSR Object_Move	 ; Do standard object movements

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG002_AAB2	 ; If enemy has NOT hit ceiling, jump to PRG002_AAB2

	; Otherwise, hit off ceiling
	STA <Objects_YVel,X

PRG002_AAB2:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ Object_HitFloorAlign	 ; If enemy has NOT hit walls, jump to Object_HitFloorAlign

	LDA <Objects_XVel,X
	BEQ Object_HitFloorAlign	 ; If object is not moving horizontally, jump to Object_HitFloorAlign

	JSR Object_AboutFace	 ; Otherwise, turn around

Object_HitFloorAlign:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AAA6	 ; If object has NOT hit ground, jump to PRG002_AAA6 (RTS)
	JMP Object_HitGround	 ; Otherwise, align to ground and don't come back!

	; Timers set per direction (long and short, respectively)

DeleteIfOffAndDrawWide:
	JSR Object_DeleteOffScreen_N2	 ; Delete object if it falls off-screen
	JMP LogPlat_Draw	 ; Jump to LogPlat_Draw

ObjNorm_PlatformPattern:
	LDA <Player_HaltGame
	BNE DeleteIfOffAndDrawWide	 ; If gameplay halted, Delete if off-screen, otherwise draw wide 48x16 sprite

	JSR DoPatrol
	JSR PlayerPlatform_Collide
	JMP DeleteIfOffAndDrawWide

ObjInit_FloatWoodenPlat:
	LDA Level_AScrlConfig
	BEQ PRG002_AB35	 ; If no raster, jump to PRG002_AB35 (RTS)

	; If raster active (assuming a level with constant water level)...

	; Set fixed position at water level (vertical scroll +148)
	LDA Level_VertScroll
	ADD #148
	STA <Objects_Y,X
	LDA Level_VertScrollH
	ADC #$00		; Apply carry
	STA <Objects_YHi,X

PRG002_AB35:
	LDA #$01
	STA ObjSplash_DisTimer, X
	RTS		 ; Return


ObjNorm_WoodenPlatFloat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AB35	 ; If gameplay is halted, jump to PRG002_AB35 (RTS)

PRG002_AB5E:
	JSR Object_Move	 ; Apply Velocity
	LDA Object_TileFeet2
	BEQ PRG002_AB5E2
	AND #$3F
	BNE PRG002_AB5E2
	LDA #$E0
	STA <Objects_YVel, X
	RTS

PRG002_AB5E2:
	LDA Objects_InWater, X
	BNE PRG002_AB60
	JSR Object_DetectTile	; Get tile here	
	JSR Object_Check_Water
	LDA Objects_InWater, X
	BNE PRG002_AB60
	LDY #(Platform_Extended_Check - Object_TileDetectOffsets)
	INY
	INY
	JSR Object_DetectTile	; Get tile here	
	JSR Object_Check_Water

	LDA Objects_InWater, X
	BEQ Float_Do_Fall

PRG002_AB60:
	LDA <Objects_Y, X
	AND #$0F
	CMP #$0E
	BCC Float_Do_Carry
	LDA <Objects_Y, X
	AND #$F0
	ORA #$0E
	STA <Objects_Y, X
	LDA #$00
	STA <Objects_YVel, X
	BNE Float_Do_Carry

Float_Do_Fall:
	LDA <Objects_DetStat, X
	AND #$04
	BEQ Float_Do_Carry
	LDA <Objects_Y, X
	AND #$F0
	STA <Objects_Y, X
	LDA #$00
	STA <Objects_YVel, X

Float_Do_Carry:
	LDA Object_TileFeet
	CMP #TILE_ITEM_COIN
	BCS No_Carry
	AND #$0F
	STA TempA
	LDA #TILE_PROP_MOVE_RIGHT
	SUB TempA
	BMI No_Carry
	CMP #$02
	BCS No_Carry
	LDY #$10
	CMP #01
	BNE Float_Do_Carry1
	LDY #$F0
 
Float_Do_Carry1:
	TYA
	STA Objects_XVel, X

No_Carry:
	JSR PlayerPlatform_Collide	; Do Player-platform collision

PRG002_AB8F:
	RTS		 ; Return

ObjNorm_WoodenPlatform:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABAA	 	; If gameplay halted, jump to PRG002_ABAA (RTS)

	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Player collision with platform

	LDA <Objects_YVel,X
	BNE PRG002_ABA8	 ; If Platform is moving vertically, jump to PRG002_ABA8

	BCC PRG002_ABAA	 ; If Player did not collide with platform, jump to PRG002_ABAA (RTS)

	STA <Objects_XVel,X	 ; Otherwise, X Vel = Y Vel

PRG002_ABA8:
	INC <Objects_YVel,X	 ; Platform descends

PRG002_ABAA:
	RTS		 ; Return

ObjInit_WoodenFallingPlat:
	INC <Objects_Var4,X	 ; Var4 = 1

ObjInit_FallingPlatform:

	; Center the platform

PRG002_ABB9:
	RTS		 ; Return


ObjNorm_PathFollowPlat:
	RTS		 ; Return

EnemyEnterFlip:	.byte  $00, SPR_HFLIP
EnemyEnterXVel:	.byte -$08, $08

ObjInit_TowardsPlayer:

	; Get last scroll direction so we know which way to face
	LDY Scroll_LastDir

	; Enemy faces Player relative to which direction he's headed
	LDA EnemyEnterFlip,Y
	STA Objects_FlipBits,X

	; Enemy charges at Player the same
	LDA EnemyEnterXVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return

Spike_Frames:
	.byte $04, $04, $04, $04, $04, $02, $02, $03, $03, $03, $03, $02, $02, $02, $02

Spike_XOff:
	.byte $00
	.byte $02, $03, $02, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

Spike_YOff:
	.byte $00, $F4, $F4
	.byte $F4, $F4, $F4, $F4, $F2, $F0, $EF, $EE, $EE, $EF, $F0, $F2, $F4, $F6, $F9, $FC
	.byte $FF, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


ObjNorm_Spike:
	LDA Objects_Timer,X
	LSR A
	STA <Objects_Var4,X	 ; Var4 = timer / 2

	ROL A		; Puts bit 0 back
	BEQ PRG002_AD3F	 ; If timer expired, jump to PRG002_AD3F

	LSR A
	BNE PRG002_AD31	 ; If timer > 2, jump to PRG002_AD31

	JSR Spike_TossSpikeBall	 ; Cough up a spike ball!

	LDA <Objects_Var5,X
	BEQ PRG002_AD31	 	; ?? I think this was meant to check that no sprites are off-screen, but most likely you'll make this jump

	INC Objects_Timer,X	 ; Timer++ (delay decrementing it)

PRG002_AD31:
	LDA Objects_Timer,X
	LSR A
	LSR A
	TAY		 ; Y = timer / 4

	; Set Spike's frame
	LDA Spike_Frames,Y
	STA Objects_Frame,X
	BPL PRG002_AD95	 ; If positive, jump to PRG002_AD95

PRG002_AD3F:
	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AD80	 ; If Spike has not touched the ground, jump to PRG002_AD80

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Set Spike's frame alternating 0/1 (walking)

	; This keeps Spike interesting
	LDA <Counter_1
	ADC Entropy_BySlot,X	; Add an arbitrary value based on which slot this Spike is in
	BMI PRG002_AD95	 ; If the result has bit 7 set, jump to PRG002_AD95

	JSR Object_CalcCoarseXDiff
	EOR Objects_FlipBits,X
	ASL A
	BPL PRG002_AD6E	 ; If the signs aren't different, Spike doesn't change direction; jump to PRG002_AD6E

	; Spike needs to change direction

	LDA <Counter_1
	AND #$07	
	BNE PRG002_AD80	 ; But only a 1:7 chance, otherwise jump to PRG002_AD80

	JSR Object_FlipFace	 ; Turn around
	JMP PRG002_AD80	 	; Jump to PRG002_AD80

PRG002_AD6E:

	; This gets a little tricky to follow...

	LDA <Temp_Var15	
	ADD #$20
	CMP #$40
	BGE PRG002_AD80	 ; Player out of X range

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	CMP #$08	
	BCC PRG002_AD84	 ; Player out of Y range

PRG002_AD80:
	LDA #$00
	BEQ PRG002_AD88	 

PRG002_AD84:
	LDA <Objects_Var5,X	
	ADC #$10

PRG002_AD88:
	STA <Objects_Var5,X	 
	BPL PRG002_AD95

	; Timer = $3A
	LDA #$3a
	STA Objects_Timer,X

	; Halt Spike's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG002_AD95:
	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_SpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDA <Temp_Var3
	BPL PRG002_ADB4	 ; If Spike is not flipped, jump to PRG002_ADB4

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Objects_Var4,X
	TAX		 ; X = Var4

	; Add to Sprite Y by Var4 index
	LDA <Temp_Var1	
	ADD Spike_YOff,X
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = object's starting tiles index

PRG002_ADB4:
	JSR Object_Draw16x16Sprite	 ; Draw Spike

	LDX <SlotIndexBackup		 ; X = object slot index

	LDY <Objects_Var4,X	 ; Y = Var4

	LDA <Objects_SpriteY,X
	BIT <Temp_Var3		
	BMI PRG002_ADC5	 ; If Spike is vertically flipped, jump to PRG002_ADC5

	ADD Spike_YOff,Y	 ; Otherwise, add appropriate offset

PRG002_ADC5:
	STA <Temp_Var1		 ; -> Temp_Var1
 
	LDA Spike_XOff,Y

	BIT <Temp_Var3
	BVC PRG002_ADD1	 ; If Spike is NOT horizontally flipped, jump to PRG002_ADD1

	JSR Negate	; Negate the X Offset

PRG002_ADD1:
	ADD <Temp_Var2		 ; Offset by Spike's X
	STA <Temp_Var2		 ; -> Temp_Var2

	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball

	; Draw Spike's pre-thrown spike ball sprite at +8 to Spike's assigned Sprite_RAM offset
	LDA <Temp_Var7
	ADD #$08	
	TAY		
	JSR Object_Draw16x16Sprite

	; Set Spike's spike ball attributes
	LDA #$02
	STA Sprite_RAM+$02,Y
	ORA #$c0
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Spike_TossSpikeBall:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot if on-screen (or don't come back!)	 
	STA <Objects_Var5,X	 ; Objects_Var5 = 0 (because we wouldn't be here otherwise)

	; Spike's spike ball
	LDA #SOBJ_NINJASTAR	 
	STA SpecialObj_ID,Y

	; Set Spike's ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike's ball Y
	LDA <Objects_Y,X
	SUB #14
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction
	ASL A	
	ASL A		; Multiply result by 4
	STA SpecialObj_XVel,Y	 ; Set as Spike's ball X velocity

	; Spike's ball Y velocity and Data = 0
	LDA #$00
	STA SpecialObj_YVel,Y
	STA SpecialObj_Data,Y

	RTS		 ; Return


	; Sets X velocity by facing flip direction
Object_SetXVelByFacingDir:
	LDA Objects_FlipBits,X
	ASL A
	ASL A	; If HFlip is set, pushed into carry

	LDA #$08
	BCS PRG002_AE28
	LDA #-$08
PRG002_AE28:
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_PiranhaSpikeBall:
	; Center piranha
	LDA <Objects_X,X
	ORA #$08
	STA <Objects_X,X

	; Set Objects_Var5 = $10
	LDA #$10
	BNE PRG002_AE3A	 ; Jump (technically always) to PRG002_AE3A

ObjInit_Patooie:
	JSR ObjInit_TowardsPlayer	; Have enemy facing/moving towards Player

	; Set Objects_Var5 = $0C 
	LDA #$0c
PRG002_AE3A:
	STA <Objects_Var5,X

	RTS		 ; Return

ObjInit_Spark:
	LDA #$00
	STA Objects_Var1, X
	STA Objects_Var2, X
	RTS

ObjInit_SparkLeft:
	LDA #$01
	STA Objects_Var1, X
	LDA #$00
	STA Objects_Var2, X
	RTS

; this basically detects certain corners based on current movement direction
SparkDetects:
	.byte (HIT_DET_RIGHT | HIT_DET_GRND), (HIT_DET_LEFT | HIT_DET_GRND), (HIT_DET_CEIL | HIT_DET_LEFT), (HIT_DET_RIGHT | HIT_DET_CEIL)
	.byte (HIT_DET_LEFT | HIT_DET_GRND), (HIT_DET_RIGHT | HIT_DET_GRND), (HIT_DET_CEIL | HIT_DET_RIGHT), (HIT_DET_LEFT | HIT_DET_CEIL)

SparkYVel:
	.byte $04, $04, $fc, $fc
	.byte $04, $04, $fc, $fc

SparkXVeL:
	.byte $04, $fc, $fc, $04
	.byte $fc, $04, $04, $fc

ObjNorm_Spark:
	LDA <Player_HaltGame
	BEQ  Norm_Spark
	RTS

Norm_Spark:
	JSR Object_ShakeAndDrawMirrored
	LDA <Counter_1
	AND #$04
	LSR A
	LSR A
	STA Objects_Frame, X
	JSR Object_DeleteOffScreen
	JSR Object_HitTestRespond
	LDA Objects_Property, X
	LSR A
	STA <Temp_Var5
	INC <Temp_Var5

Spark_Again:
	JSR Do_Spark
	DEC <Temp_Var5
	BPL Spark_Again
	RTS

Do_Spark:
	LDA Objects_Property, X
	AND #$01
	ASL A
	ASL A
	ORA Objects_Var2, X
	TAY
	LDA SparkXVeL, Y
	STA <Objects_XVel, X
	LDA SparkYVel, Y
	STA <Objects_YVel, X
	TYA
	AND #$01			; only odd numbered states move vertically, even move horzontally
	BNE NoSparkXVel
	LDA <Objects_Y, X
	AND #$0F
	BNE ApplySparkX
	JSR Object_ApplyYVel_NoLimit

ApplySparkX:
	JSR Object_ApplyXVel
	LDA <Objects_X, X
	AND #$0F
	CMP #$0F
	BEQ SparkHitDetection
	CMP #$01
	BEQ SparkHitDetection
	BNE KeepGoing

NoSparkXVel:
	LDA <Objects_X, X
	AND #$0F
	BNE ApplySparkY
	JSR Object_ApplyXVel

ApplySparkY:
	JSR Object_ApplyYVel_NoLimit
	LDA <Objects_Y, X
	AND #$0F
	CMP #$0F
	BEQ SparkHitDetection
	CMP #$01
	BEQ SparkHitDetection
	BNE KeepGoing

SparkHitDetection:
	LDA Objects_XVelFrac, X
	BNE KeepGoing
	LDA Objects_YVelFrac, X
	BNE KeepGoing
	JSR Object_WorldDetect4
	LDA Objects_Property, X		; var1 = 0 -> clockwise movement, var1 = 1 -> counter clockwise
	AND #$01
	ASL A
	ASL A
	ORA Objects_Var2, X
	TAY
	LDA <Objects_DetStat, X
	AND SparkDetects, Y  
	BNE WallCeilGrndDet
	LDA Objects_Var2, X	; neither corner was detected (no ground or wall) so we need to wrap around the tile
	ADD #$01
	AND #$03
	STA Objects_Var2, X
	RTS

WallCeilGrndDet:
	CMP SparkDetects, Y
	BNE KeepGoing
	LDA Objects_Var2, X		; both corners were detected, we need to crawl against the tile
	SUB #$01
	AND #$03
	STA Objects_Var2, X

KeepGoing:						; if we only detected one ground or wall we keep going in the same direction
	RTS


ObjNorm_PiranhaSpikeBall:

	; Mostly reuses Patooie's code
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_AE47	 ; If piranha is dead, jump to PRG002_AE47

	JMP PRG002_AEE1	 ; Otherwise, jump to PRG002_AEE1

PRG002_AE47:

	; Use "poof" death
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X

	; Set timer to $1F (poof death timer)
	LDA #$1f
	STA Objects_Timer,X

PRG002_AE51:
	INC Objects_HitCount,X	 ; Increase hit count (??)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Patooie's Spike ball
	LDA #SOBJ_NINJASTAR
	STA SpecialObj_ID,Y

	; Set Spike ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike ball Y -- Objects_Var5 is used as the height of the spiked ball Patooie is blowing
	LDA <Objects_Y,X
	SUB <Objects_Var5,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Spike ball data
	LDA #$01
	STA SpecialObj_Data,Y

	LSR A	
	STA SpecialObj_XVel,Y	 ; X Vel = 0

	LDA Objects_Var6,X
	AND #%01111100	; Masking the lower bits not strictly necessary...
	LSR A	
	LSR A	
	TAX	; X = value 0 to 31

	; Set the Patooie ball Y velocity
	;LDA Patooie_BallYDelta,X
	JSR Negate
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_AF30	 ; Jump to PRG002_AF30


ObjNorm_Patooie:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_AEBE	 ; If Patooie's state is not Killed, jump to PRG002_AEBE

	; Patooie is killed...

	LDA Objects_HitCount,X
	BEQ PRG002_AE51	 ; If object hasn't been hit by Player weapon, jump to PRG002_AE51

	JMP PRG002_AF30	 ; Jump to PRG002_AF30

PRG002_AEBE:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AEE1	 ; If object did not hit floor, jump to PRG002_AEE1

	LDA <Counter_1
	ADC Entropy_BySlot,X	 ; Add an arbitrary value by this object's slot index
	AND #%10011111
	BNE PRG002_AED7	 	; Semi-randomly jump to PRG002_AED7

	; Sometimes, reverse direction
	LDA <Objects_XVel,X
	JSR Negate	
	STA <Objects_XVel,X

PRG002_AED7:
	; Flip sprite back and forth to simulate walking
	LDA <Counter_1
	ASL A		
	ASL A		
	ASL A		
	AND #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_AEE1:
	LDA Objects_Var6,X
	BEQ PRG002_AEEF	 ; If Var6 = 0, jump to PRG002_AEEF

	LDA Level_NoStopCnt
	LSR A
	BCC PRG002_AEEF	 ; Every other tick, jump to PRG002_AEEF

	DEC Objects_Var6,X	 ; Otherwise, Var6--

PRG002_AEEF:
	LDY #$00	 ; Y = 0 (Mouth closed)

	LDA Objects_Var6,X
	PHA		 ; Save Var6

	AND #%11000000
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = $00, $10, $20, or $30

	PLA		 ; Restore Var6

	; Times the mouth animation to be similar to the spike ball's ascend/descend
	ASL A
	EOR Objects_Var6,X
	AND <Temp_Var1	
	BEQ PRG002_AF05

	INY		 ; Y = 1 (Mouth open)

PRG002_AF05:
	TYA
	STA Objects_Frame,X	 ; Set frame 0 or 1

	LDA Objects_Var6,X
	AND #$3f
	BNE PRG002_AF1D	 ; Only continue 1:64 ticks, otherwise jump to PRG002_AF1D

	LDY #$bf	 ; Y = $BF (BIG Blow)

	LDA Level_NoStopCnt
	BPL PRG002_AF19	 ; If the counter is not negative, jump to PRG002_AF19

	LDY #$5f	 ; Otherwise, Y = $5F (SHORT blow)

PRG002_AF19:
	TYA
	STA Objects_Var6,X	 ; Var6 = $5F or $BF

PRG002_AF1D:
	LDA Objects_Var6,X
	AND #%01111100
	LSR A
	LSR A
	TAY		 ; Y = 0 to 31

	; Adjusts height of spike ball
	LDA <Objects_Var5,X
	;ADD Patooie_BallYDelta,Y
	STA <Objects_Var5,X

	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_AF30:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_PiranhaSpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_PIRANHASPIKEBALL
	BEQ PRG002_AF46	 ; If this is just the piranha with the spike ball rather than a true Patooie, jump to PRG002_AF46

	; Temp_Var1 += 6
	LDA <Temp_Var1
	ADD #$06
	STA <Temp_Var1

PRG002_AF46:
	LDX <Temp_Var6	 ; X = object's starting tiles

	LDA <Temp_Var3
	BPL PRG002_AF4F	 ; If object is not vertically flipped, jump to PRG002_AF4F

	JSR PatooiePiranha_StartTileX	 ; Get correct starting sprite tile

PRG002_AF4F:
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LSR <Temp_Var5	; Shifting out next vertical visibility bit

	; Sprite Y += 16 for lower half
	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	; 'Y' += 8 (two sprite index over)
	TYA
	ADD #$08
	TAY

	LDX <Temp_Var6	 ; X = starting tiles index

	LDA <Temp_Var3
	BMI PRG002_AF69	 ; If vertically flipped, jump to PRG002_AF69
	JSR PatooiePiranha_StartTileX	 ; Otherwise, get correct starting tile again
PRG002_AF69:
	JSR Object_Draw16x16Sprite	 ; Draw lower half

	LDA <Temp_Var3
	BMI PRG002_AF72	 ; If vertically flipped, jump to PRG002_AF72

	LDY <Temp_Var7		 ; Y = original Sprite_RAM offset

PRG002_AF72:
	; Sets attributes and mirrors piranha sprites
	LDA <Temp_Var3	; Get object attributes
	AND #~(SPR_HFLIP | $03)	 ; Keep everything except the horizontal flip and the palette select
	ORA #SPR_PAL1	 ; Force palette select 1
	STA Sprite_RAM+$02,Y	 ; Set attributes
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y	 ; Set other half of piranha

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	
	CMP #OBJ_PIRANHASPIKEBALL
	BNE PRG002_AF96	 ; If this is Patooie, jump to PRG002_AF96

	; Piranha needs his body mirrored
	LDA Sprite_RAM+$0A,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$0A,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$0E,Y

PRG002_AF96:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B01A	 ; If this piranha/Patooie state is Killed, jump to PRG002_B01A

	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi

	LDA <Objects_Y,X
	PHA		 ; Save Y

	; Temporarily using object's Y/HI to calculate the spike ball's position
	SUB <Objects_Var5,X
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

	LDY #$00	 ; Y = 0 (height of 16)
	JSR Object_DetermineVertVisY	 ; Determine visibility of spike ball sprites
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data for spike ball

	LDA Level_NoStopCnt
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3, based on timer

	; Cause the spike ball to jiggle slightly (Temp_Var2 is X)
	LDA <Temp_Var2
	;ADD Patooie_BallXJiggle,X
	STA <Temp_Var2

	; Jump Sprite_RAM offset ahead 16 (four sprites, get passed Patooie/Piranha)
	TYA	
	ADD #16	
	TAY	

	; Draw sprite
	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball
	JSR Object_Draw16x16Sprite

	; Set spike ball vertical flip periodically
	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP	; Toggled vertical flip
	ORA #SPR_PAL2	; Set palette select 2
	STA Sprite_RAM+$02,Y
	EOR #$c0	; Invert vertical flip and apply horizontal flip
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B00E	 ; If Patooie/Piranha's state is Killed, jump to PRG002_B00E

	LDA <Player_HaltGame
	BNE PRG002_B00E	 ; If gameplay is halted, jump to PRG002_B00E

	JSR Object_AnySprOffscreen
	BNE PRG002_B00E	 ; If any sprites of the spike ball are off-screen, jump to PRG002_B00E

	LDA Level_ObjectID,X
	PHA		 ; Save piranha/Patooie iID

	; Temporarily switch and masquerade as a OBJ_ANTIGRAVITYCHEEP
	; NOTE: This really just needs to be a 16x16 sized object so we
	; can "cheat" and use Object_HitTest on a "special object"
	LDA #OBJ_ANTIGRAVITYCHEEP
	STA Level_ObjectID,X

	JSR Object_HitTest
	BCC PRG002_B00A	 ; If Player did NOT hit spike ball, jump to PRG002_B00A

	LDA Player_StarInv
	BNE PRG002_B00A	 ; If Player is Starman invincible, jump to PRG002_B00A

	JSR Object_DoCollision ; Do the collision routine

PRG002_B00A:
	; Restore the object ID
	PLA
	STA Level_ObjectID,X

PRG002_B00E:
	; Restore the Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis	 ; Restore true vertical visibility for this Patooie/piranha
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the true sprite positions

PRG002_B01A:
	;JMP PRG002_B196		; Jump to PRG002_B196 (set pattern bank $4F)

	; Get the correct starting sprite tile based on whether this is
	; a true Patooie or just the piranha pretending to be one
PatooiePiranha_StartTileX:
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	 ; Get object ID

	LDX #(ObjP2A - ObjectGroup01_PatternSets + $06)	 ; If Patooie
	CMP #OBJ_SPARKRIGHT
	BEQ PRG002_B02A	 ; If this is Patooie, jump to PRG002_B02A (RTS)
	LDX #(ObjP46 - ObjectGroup01_PatternSets + $08)	 ; If the piranha with spike ball
PRG002_B02A:
	RTS		 ; Return


ObjNorm_GoombaInShoe:

	RTS		 ; Return

ObjInit_NipperHopping:
	INC <Objects_Var4,X	 ; Var4 = 1
	RTS		 ; Return


ObjNorm_Nipper:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02	 
	TAY		 ; Y = 0 or 2

	JSR Object_CalcCoarseXDiff	 ; Get X difference between Nipper and Player
	STA <Temp_Var14		 ; Store flip direction -> Temp_Var14

	LDA <Temp_Var15	
	ADD #$03
	CMP #$06
	BGE PRG002_B1CD	 ; If Player is horizontally too far away from Nipper, jump to PRG002_B1CD

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	BMI PRG002_B1CD	 ; If Player is below Nipper, jump to PRG002_B1CD

	INY		 ; Y = 1 or 3

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B1CD	 ; If Nipper has not touched ground, jump to PRG002_B1CD

	; Nipper plant don't move horizontally!
	LDA #$00
	STA <Objects_XVel,X

	; Jump little Nipper!
	LDA #-$30
	STA <Objects_YVel,X

PRG002_B1CD:
	TYA	
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOrDraw	 ; Delete if falls off-screen, otherwise draw
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

	LDA <Objects_Var4,X
	BNE PRG002_B1E1	 ; If Var4 <> 0, jump to PRG002_B1E1

	; Set the flip bits
	LDA <Temp_Var14
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B1E1:
	LDA Objects_Timer,X
	BEQ PRG002_B1EC	 ; If timer expired, jump to PRG002_B1EC

	LSR A
	BNE PRG002_B20F	 ; If timer > 1, jump to PRG002_B20F (RTS)

	JSR Object_FlipFace	 ; Otherwise, turn around

PRG002_B1EC:

	; Timer expired...

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B20F	 ; If Nipper has not touched ground, jump to PRG002_B20F (RTS)

	LDA <Objects_YVel,X
	BMI PRG002_B20F	 ; If Nipper is moving upward, jump to PRG002_B20F (RTS)

	DEC <Objects_Var5,X	; Var5--
	BPL PRG002_B208	 ; If Var5 >= 0, jump to PRG002_B208

	; Reset Var5 = 8
	LDA #$08
	STA <Objects_Var5,X

	; Reset timer to $20
	LDA #$20
	STA Objects_Timer,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG002_B208:
	JSR Object_SetXVelByFacingDir	; Face travel direction 

	; Hop hop hop
	LDA #-$10
	STA <Objects_YVel,X

PRG002_B20F:
	RTS		 ; Return

ObjInit_Toad:
	LDA Objects_X,X		 ; Otherwise, Y = 1 
	AND #$70
	LSR A
	LSR A
	LSR A
	LSR A
	TAY

PRG002_B21A:
	STY <Objects_Var5,X	 ; -> Objects_Var5 (which message Toad gives)

	; Toad is always on the lower screen space
	LDA #$01
	STA <Objects_YHi,X

	; Stop the timer
	STA Level_TimerEn

	; Halt the Player
	LDA #$ff
	STA Player_HaltTick

	LDA #$00
	STA <Map_UseItem	; Clear item usage flag
	STA Player_Behind	; Player is not behind anything
	STA ToadTalk_CPos	; Clear the Toad character position counter

	; Set the starting VRAM addresses
	LDA #$28
	STA ToadTalk_VH
	LDA #$c8
	STA ToadTalk_VL

	RTS		 ; Return

PRG002_B23D:
	.byte $08, $04, $02, $01

ObjNorm_Toad:

	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X
 
	; Do Toad's dialog message
	LDA #$5C
	STA PatTable_BankSel+1
	LDA #$5b
	STA PatTable_BankSel+5
	JSR Toad_Speak

	LDA #$01
	STA Player_HaltTick
	LDA #$00
	STA Tile_Anim_Enabled
	RTS


Toad_Speak:
	LDA <Objects_Var4,X	 ; Get current dialog state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Toad_DrawDiagBox		; 0
	.word Toad_DoToadText		; 1
	.word Decide_What_Next		; 2
	.word Enough_Magic_Stars	; 3
	.word Deduct_Coins			; 4
	.word End_Level				; 5
	.word Do_Shop_Controls		; 6
	.word Bank_Toad		; 7

TDiagBox_R1:	.byte $E8, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $E9, $EA
TDiagBox_R2:	.byte $F8, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $A1, $FA
TDiagBox_R3:	.byte $DC, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DD, $DE

TDiagBox_RowOffs:
	.byte (TDiagBox_R1 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1)
	.byte (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R3 - TDiagBox_R1)

TDiagBox_RowOffs_End

Toad_DrawDiagBox:
	LDX Graphics_BufCnt	 ; X = current graphics buffer counter

	; Store the current VRAM address into the buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,X
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,X

	; Store the next row address (+32 bytes to next row)
	ADD #$20	; 32 bytes to next row
	STA ToadTalk_VL
	BCC PRG002_B2D5
	INC ToadTalk_VH	 ; Apply carry
PRG002_B2D5:

	LDA #(TDiagBox_R2 - TDiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY ToadTalk_CPos	 ; Y = current dialog box row
	LDA TDiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG002_B2E3:
	; Store next pattern in dialog box
	LDA TDiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG002_B2E3	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	LDX <SlotIndexBackup	 ; X = object slot index

	INC ToadTalk_CPos	 ; Next row

	LDA ToadTalk_CPos
	CMP #(TDiagBox_RowOffs_End - TDiagBox_RowOffs)
	BLT PRG002_B325	 ; If row count < 8, jump to PRG002_B325 (RTS)

	; Dialog box is complete

	LDY <Objects_Var5,X	 ; Y = Objects_Var5

	; Toad's Var1 and Var2 store the current pointer to the text he's reciting
	LDA ToadMsg_Low,Y
	STA Objects_Var1,X
	LDA ToadMsg_High,Y
	STA Objects_Var2,X

	; Reset the VRAM address for the dialog text
	LDA #$28
	STA ToadTalk_VH
	LDA #$e9
	STA ToadTalk_VL

	; Toad's timer = $10
	LDA #$10
	STA Objects_Timer,X

	INC <Objects_Var4,X	 ; Objects_Var4 = 1 (next dialog state)

PRG002_B325:
	RTS		 ; Return

HammerCoinsRequired:
	.byte $01, $00, $00, $00, $00, $00, $00, $00, $00

ToadMsg_Standard:

	.byte "IN ORDER TO    "
	.byte "PASS, YOU NEED "
	.byte "TO COLLECT ()  "
	.byte "STARS.         "
	.byte "               "
	.byte "               "

	
ToadMsg_Shop:
	.byte "WELCOME TO THE "
	.byte "SHOP. USE LEFT "
	.byte "AND RIGHT TO   "
	.byte "BROWSE, A TO   "
	.byte "BUY, B TO LEAVE"
	.byte "THE SHOP.      "

	
ChallengeMessage:
	.byte "USE UP AND DOWN"
	.byte "TO SET AMOUNT. "
	.byte "LEFT AND RIGHT "
	.byte "TO SET ACTION. "
	.byte "A TO ACCEPT.   "
	.byte "B TO LEAVE.    "

	; Pointer table to Toad's three messages
	; Warp Whistle
	; Standard
	; Anchor/P-Wing
ToadMsg_Low:	.byte LOW(ToadMsg_Standard), LOW(ToadMsg_Shop), LOW(ChallengeMessage)
ToadMsg_High:	.byte HIGH(ToadMsg_Standard), HIGH(ToadMsg_Shop), HIGH(ChallengeMessage)


Toad_DoToadText:
	LDA Objects_Timer,X
	BEQ DoNextLetter
	JMP PRG002_B4B1	 ; If timer not expired, jump to PRG002_B4B1

DoNextLetter:

	; Store address of text -> Temp_Var1/2
	LDA Objects_Var1,X
	STA <Temp_Var1
	LDA Objects_Var2,X
	STA <Temp_Var2

	INC Objects_Var1,X	; Next character
	BNE PRG002_B451
	INC Objects_Var2,X	; Apply carry
PRG002_B451:

	LDY #$00	 	; Y = 0
	LDA [Temp_Var1],Y	; Get character here
	TAY		 	; -> 'Y'
	CPY #$20
	BEQ PRG002_B468	 	; If this is a "space", jump to PRG002_B468

	; Play "blip" sound every other letter
	LDA ToadTalk_VL
	LSR A
	BCC PRG002_B468

	; Play text "blip" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1

PRG002_B468:
	TYA
	CMP #$28
	BEQ DoFirstDigit
	CMP #$29
	BNE Draw_Letter
	LDY StarLevel
	LDA HammerCoinsRequired, Y
	AND #$0F
	ORA #$30
	JMP Draw_Letter

DoFirstDigit:
	LDY StarLevel
	LDA HammerCoinsRequired, Y
	AND #$F0
	ASL A
	ASL A
	ASL A
	ASL A
	ORA #$30

Draw_Letter:
	CLC
	ADC #$80

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	STA Graphics_Buffer+3,Y	 ; Store into buffer

	; Insert one character into graphics buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,Y	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,Y	; run length
	LSR A
	STA Graphics_Buffer+4,Y	; terminator
	TYA
	ADD #$04
	STA Graphics_BufCnt	; count
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,Y	; address low

	INC ToadTalk_VL	 ; Next VRAM byte
	AND #$1f	 	; Get current column
	CMP #$17
	BNE PRG002_B4AC	 	; If we're not in column 23, jump to PRG024_A25B

	; Line break!

	LDA ToadTalk_VL
	ADC #$10		; Add enough bytes to get to next row
	STA ToadTalk_VL
	BCC PRG002_B4A1
	INC ToadTalk_VH	; Apply carry
PRG002_B4A1:

	CMP #$a9
	BNE PRG002_B4AC	 ; If we haven't reached the last character, jump to PRG002_B4AC

	INC <Objects_Var4,X	 ; Objects_Var4 = 2 (next dialog state)
	LDA #$08
	STA Pay_Toll_Timer

	LDA #$00
	STA ToadTalk_CPos

PRG002_B4AC:

	; Set timer to $04
	LDA #$04
	STA Objects_Timer,X

PRG002_B4B1:
	RTS		 ; Return

ObjNorm_ToadHouseItem:
	RTS		 ; Return

LogPlat_Draw:
	JSR Object_ShakeAndCalcSprite

	; Do not preserve the H/V flip bits
	LDA <Temp_Var3
	AND #%00111111
	STA <Temp_Var3

	LDA <Counter_1
	LSR A
	PHP		 ; Save CPU state (most importantly the carry flag)
	BCC PRG002_B5BD	 ; Every other tick, jump to PRG002_B5BD

	; Y += (11 + C = 12) -- Every other tick, offset Sprite_RAM
	TYA
	ADC #$0b
	TAY

PRG002_B5BD:
	JSR Object_Draw48x16Sprite	 ; Draw wide sprite

	LDA <Temp_Var7	 ; Get Sprite_RAM offset (as determined by Object_ShakeAndCalcSprite)
	PLP		 ; Restore CPU state
	BCS PRG002_B5C7	 ; Every other opposite tick, jump to PRG002_B5C7

	; Otherwise, add +12 to Sprite_RAM offset
	ADC #$0c

PRG002_B5C7:
	TAY		 ; Sprite_RAM offset -> 'Y'

	INX
	INX
	INX	; X += 3 (starting tiles index)

	; Temp_Var2 (Sprite Y) += 24
	LDA #24
	ADD <Temp_Var2
	STA <Temp_Var2

	; Alters horizontal visibility ??
	ASL <Temp_Var8
	ASL <Temp_Var8
	ASL <Temp_Var8

	JSR Object_Draw48x16Sprite	 ; Draw wide sprite

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ObjNorm_NipperFireBreathe:
	JSR Enemy_CollideWithWorld	; Collide with world
	JSR Object_DeleteOrDraw	 	; Delete if Nipper off-screen or draw it
	JSR Object_HitTestRespond	; Do collision test with Player and respond

	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X	 ; Set flip towards Player
 
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Nipper just smacks his lips

	JSR Object_AnySprOffscreen
	BNE PRG002_B65A	 ; If any of Nipper's sprites are not visible, jump to PRG002_B65A (RTS)

	LDA <Counter_1
	AND #$a0
	BNE PRG002_B65A	; Fire breather only does things in a limited window; otherwise, jump to PRG002_B65A (RTS)

	; Fire breather frame!
	LDA #$02
	STA Objects_Frame,X

	LDA <Counter_1
	AND #$07
	BNE PRG002_B65A	 ; Only do anything 1:8 ticks, otherwise jump to PRG002_B65A (RTS)

	; Set 'Y' to $10 or -$10 based on which side Player is on
	LDA <Temp_Var15
	TAY	
	ADD #$10
	CMP #$20
	BLT PRG002_B61F

	LDY #$10	 ; Y = $10

	LDA <Temp_Var15
	BPL PRG002_B61F

	LDY #-$10	 ; Y = -$10

PRG002_B61F:
	STY <Temp_Var1		 ; Temp_Var1 = $10 or -$10, based on which side Player is on

	JSR Object_CalcCoarseYDiff

	LDA <Temp_Var15
	ADD #$20
	CMP #$40
	BGE PRG002_B65A	 	; If Player is too high above Nipper, jump to PRG002_B65A (RTS)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Nipper fireball ID
	LDA #SOBJ_NIPPERFIREBALL
	STA SpecialObj_ID,Y

	; Nipper fireball X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Nipper fireball Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Nipper fireball X velocity
	LDA <Temp_Var1
	ASL A		
	JSR Negate	
	STA SpecialObj_XVel,Y

	; Nipper fireball Y velocity
	LDA #-$40
	SUB <Temp_Var15
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_B65A:
	RTS		 ; Return

DryBones_XVelConveyor:	.byte $08, $08, $0A	; Dry Bones' X Velocities with conveyor handling 
DryBones_AnimCntrMask:	.byte $04, $08, $08	; These values mask against the counter (Dry Bones animates faster walking against conveyor)

	; While Dry Bones is reassembling, provides frame and timer values
DryBones_ReassembleFrames:	.byte $01, $02, $03, $03, $03, $03, $03, $02
DryBones_ReassembleTimers:	.byte $10, $0A, $06, $06, $06, $06, $FF, $0A
	
ObjNorm_DryBones:
	JSR CarryClearIfAliveAndNoHalt
	BCS DryBones_Draw	 ; If Dry Bones is Dying or gameplay halted, jump to DryBones_Draw

	; Dry Bones is alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR DryBones_Draw		 ; Draw Dry Bones
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond
	JSR DryBones_BumpOffOthers	 ; Bump off other objects

	LDA <Objects_Var5,X
	BNE PRG002_B6B2	 ; If Var5 <> 0 (Dry Bones is crumpled), jump to PRG002_B6B2

	JSR Object_HandleConveyorBounceVel	; Sets LRBounce_Vel which way Dry Bones will need to be effected by conveyor
	LDY LRBounce_Vel
	INY		 ; Y++ (index into DryBones_XVelConveyor)

	; Set carry if horizontally flipped
	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA DryBones_XVelConveyor,Y	 ; Get velocity appropriate to Dry Bones' predicament
	BCS PRG002_B69D	 ; If horizontally flipped, jump to PRG002_B69D
	JSR Negate	 ; Otherwise, negate
PRG002_B69D:
	STA <Objects_XVel,X	 ; Set Dry Bones' X velocity

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B6B1	 ; If Dry Bones is NOT on the ground, jump to PRG002_B6B1

	; Toggle Dry Bones' walking frames by counter and whether he's running against a conveyor 
	LDA <Counter_1
	AND DryBones_AnimCntrMask,Y
	BEQ PRG002_B6AE	 
	LDA #$01
PRG002_B6AE:
	STA Objects_Frame,X

PRG002_B6B1:
	RTS		 ; Return

PRG002_B6B2:

	; Crumpled Dry Bones...

	LDA Objects_Timer,X
	BNE PRG002_B6D0	 ; If timer not expired, jump to PRG002_B6D0 (RTS)

	DEC <Objects_Var5,X	 ; Var5--
	BNE PRG002_B6C2	 ; If Var5 <> 0 (still reassembling), jump to PRG002_B6C2

	; Dry Bones gets back up and faces Player!
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B6C2:

	; Reassembling Dry Bones

	LDY <Objects_Var5,X	; Y = Var5 (0 = fully reassembled, hence -1 used below)

	LDA DryBones_ReassembleFrames-1,Y
	STA Objects_Frame,X

	LDA DryBones_ReassembleTimers-1,Y
	STA Objects_Timer,X

PRG002_B6D0:
	RTS		 ; Return

	; Patterns used when Dry Bones is crumbling
DryBones_CrumblePats:	.byte (ObjP3F - ObjectGroup01_PatternSets + $08), (ObjP3F - ObjectGroup01_PatternSets + $0B)
	; Little head bounce when crumbled
DryBones_HeadYOff:	.byte 0, 0, 0, -1, -2, -1, 0, 0, 0

DryBones_Draw:
	LDA Objects_Frame,X
	CMP #$02
	BGE PRG002_B706	 ; If Dry Bones' frame >= 2 (crumbling), jump to PRG002_B706

	; Frame 0 or 1

	; Save Dry Bones' Y/Hi
	LDA <Objects_YHi,X
	PHA		
	LDA <Objects_Y,X
	PHA		

	; Subtract 16 from Dry Bones' Y position
	SUB #16
	STA <Objects_Y,X
	BCS PRG002_B6F2
	DEC <Objects_YHi,X
PRG002_B6F2:

	; Draw Dry Bones
	LDY #$01	 ; 32 pixels height for Object_DetermineVertVisY
	JSR Object_DetermineVertVisY
	JSR Object_Draw16x32Sprite

	; Restore Dry Bones' Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate sprite X/Y and don't come back!

PRG002_B706:

	; Frame >= 2 (crumbling)...

	LDA Objects_FlipBits,X
	ASL A
	ASL A	; Sets carry if horizontally flipped

	; Save Dry Bones' X/Hi
	LDA <Objects_XHi,X
	PHA
	LDA <Objects_X,X
	PHA

	BCS PRG002_B71C	 ; If Dry Bones is horizontally flipped, jump to PRG002_B71C

	; Subtract 8 from Dry Bones' X position
	SUB #$08
	STA <Objects_X,X
	BCS PRG002_B71C
	DEC <Objects_XHi,X
PRG002_B71C:

	LDY #$02	 ; Select width = 24 for Object_DetermineHorzVisY
	JSR Object_DetermineHorzVisY	 ; Determine horizontal visibility
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite X/Y

	LDX <SlotIndexBackup	 	 ; X = object slot index
	LDY Objects_Frame,X	 	 ; Y = Dry Bones' frame

	LDX DryBones_CrumblePats-2,Y	 ; X = pattern start for this frame of Dry Bones (-2 because we start crumbling at frame 2)
	LDY <Temp_Var7			 ; Y = Sprite_RAM offset
	JSR Object_Draw48x16Sprite	 ; Draw wide sprite (crumbled Dry Bones)

	LDX <SlotIndexBackup		 ; X = object slot index
	BIT <Temp_Var3
	BVC PRG002_B73C	 	; If Dry Bones is not horizontally flipped, jump to PRG002_B73C

	; Otherwise, 'Y' += 8 (two sprites over)
	TYA
	ADD #$08
	TAY

PRG002_B73C:
	LDA <Objects_Var5,X
	TAX		 ; X = Var5 (head bounce index)

	; Apply bounce to his head after crumbling
	LDA Sprite_RAM+$00,Y
	ADD DryBones_HeadYOff,X	
	STA Sprite_RAM+$00,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	; Restore Dry Bones' X/Hi
	PLA
	STA <Objects_X,X
	PLA
	STA <Objects_XHi,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of Dry Bones' sprites
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate Sprite X/Y and don't come back!


ObjHit_DryBones:
	LDA <Objects_Var5,X
	BNE PRG002_B77D	 ; If head bouncing, jump to PRG002_B77D (RTS)

	; Head not bouncing yet

	LDA <Temp_Var12
	LSR A
	BCC PRG002_B77E	 ; If not hit by Player jumping on head, jump to PRG002_B77E (Player_GetHurt)

	; Var5 = 9
	LDA #$09
	STA <Objects_Var5,X

	; Dry Bones stop horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Bounce Player
	LDA #-$40
	STA <Player_YVel

	; Crumble sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR Exp_Inc

PRG002_B77D:
	RTS		 ; Return

PRG002_B77E:
	JMP Player_GetHurt	 ; Hurt Player and don't come back!


	; Essentially an implementation of Object_BumpOffOthers tailored
	; for Dry Bones, handling one or the other being crumpled
DryBones_BumpOffOthers:
	TXA		  
	ADD <Counter_1
	LSR A		
	BCS PRG002_B789	 ; Semi-randomly jump to PRG002_B789

PRG002_B788:
	RTS		 ; Return

PRG002_B789:
	LDA Objects_SprVVis,X
	BNE PRG002_B77D	 ; If any sprite of Dry Bones is vertically off-screen, jump to PRG002_B77D (RTS)

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B77D	 ; If some of Dry Bones is horizontally off-screen, jump to PRG002_B77D (RTS)

	JSR Object_CalcBoundBox2
	TXA	
	BEQ PRG002_B788	 ; If this Dry Bones is in object slot 0, jump to PRG002_B788

	DEX		 ; X-- (consider the previous object)
PRG002_B79E:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG002_B7A9	 ; If previous object state is Normal, jump to PRG002_B7A9

	CMP #OBJSTATE_SHELLED
	BNE PRG002_B815	 ; If previous object state is not Shelled, jump to PRG002_B815

PRG002_B7A9:
	LDY Level_ObjectID,X	 ; Y = object's ID

	LDA Object_AttrFlags,Y
	AND #OAT_BOUNCEOFFOTHERS
	BEQ PRG002_B815	 ; If OAT_BOUNCEOFFOTHERS is NOT set, jump to PRG002_B815

	LDA Objects_SprVVis,X
	BNE PRG002_B815	 ; If any sprite is vertically off-screen, jump to PRG002_B815

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B815	 ; If previous object has sprites horizontally off-screen, jump to PRG002_B815

	JSR Object_CalcBoundBox 
	JSR ObjectObject_Intersect 
	BCC PRG002_B815	 ; If object did not intersect with prior object, jump to PRG002_B815

	LDY <SlotIndexBackup	 ; Y = object slot index

	LDA <Objects_X,X
	SUB Objects_X,Y
	PHA		 ; Save the difference between the two objects' Xs

	LDA <Objects_XHi,X
	SBC Objects_XHi,Y
	STA <Temp_Var1	 ; Temp_Var1 = the difference between the two objects' X His

	; Determine which way this object should face relative to its position
	ROL <Temp_Var2
	PLA	
	ADC #$80
	LDA <Temp_Var1
	ADC #$00	
	BNE PRG002_B815	 

	LSR <Temp_Var2	
	LDY #$00	 ; Y = $00 (face one way)
	BCS PRG002_B7EC	

	LDY #SPR_HFLIP	 ; Y = SPR_HFLIP (face the other)

PRG002_B7EC:
	TYA		 
	STA <Temp_Var1	 ; Temp_Var1

	LDY <SlotIndexBackup	 ; Y = The Dry Bones who started this

	LDA Objects_Var5,Y
	BNE PRG002_B7FB	 ; If Var5 <> 0, jump to PRG002_B7FB (crumbled Dry Bones need not turn around)

	; I'm not crumbled, I get to turn...
	LDA <Temp_Var1
	STA Objects_FlipBits,Y

PRG002_B7FB:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG002_B815	 ; If bumped-into object's state is not Normal, jump to PRG002_B815

	LDA Level_ObjectID,X
	CMP #OBJ_DRYBONES
	BNE PRG002_B80E	 ; If Dry Bones bumped into something that's not a Dry Bones, jump to PRG002_B80E

	LDA Objects_Var5,X
	BNE PRG002_B815	 ; If Dry Bones bumped into a crumpled Dry Bones, jump to PRG002_B815

PRG002_B80E:
	; Dry Bones "bumps" into a non-crumpled Dry Bones or something not a Dry Bones, turn around
	LDA <Temp_Var1
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_B815:
	DEX		 ; X--
	BPL PRG002_B79E	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return


	; Performs collision tests against platform and enables Player
	; to stand on the platform, hit head off platform, etc.
	; Carry set if carrying collision occurred
PlayerPlatform_Collide:
	JSR Object_HitTest	 ; Test if Player is touching object
	BCC PRG002_BABD	 	; If not, jump to PRG002_BAEE (RTS)

	; Test if Player is standing on top of platform

	LDA <Player_SpriteY
	ADD #24
	CMP <Objects_SpriteY,X
	BGE PRG002_BABD	 ; If Player's bottom is beneath object's top, jump to PRG002_BABE

	JSR Player_StandOnPlatform	 ; Stand on platform
	LDA <Objects_XVel, X
	STA Player_CarryXVel
	LDA <Objects_YVel,X
	STA Player_CarryYVel

PRG002_BABC:
	SEC		 ; Set carry (collided)

PRG002_BABD:
	RTS		 ; Return

	; Attribute by frame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Start goal card routine removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	; Returns 'Y' as offset to Mario's or Luigi's inventory memory
Player_GetInventoryOffset:
	RTS		 ; Return

	; Draws the card backs, though the backs are almost immediately
	; overwritten with the proper card face...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #DAHRKDAIZ - Start goal card routine removed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Enough_Magic_Stars:
	LDA Pay_Toll_Timer
	BNE Skip_Pay_Toll_Timer
	LDY World_Num
	LDA Magic_Stars + 1
	LSR A
	LSR A
	LSR A
	LSR A
	ORA Magic_Stars
	CMP HammerCoinsRequired, Y
	BCS Pay_Toll
	LDA Sound_QMap		; Not enough coins
	ORA #SND_MAPDENY
	STA Sound_QMap
	LDA #$40
	STA End_Level_Timer	; end level
	LDA #$00
	STA TollPaid		; toll not paid
	INC <Objects_Var4,X
	INC <Objects_Var4,X
	RTS

Skip_Pay_Toll_Timer:
	DEC Pay_Toll_Timer
	RTS

Pay_Toll:
	LDA HammerCoinsRequired, Y
	AND #$0F
	STA DAIZ_TEMP1
	LDA HammerCoinsRequired, Y
	AND #$F0
	ASL A
	ASL A
	ASL A					; get coins needed to deduct
	ASL A
	TAY
Multiply_10_Loop:
	DEY
	BMI Store_Coins_Deduct
	CLC
	LDA DAIZ_TEMP1
	ADC #$0A
	STA DAIZ_TEMP1
	JMP Multiply_10_Loop

Store_Coins_Deduct:
	LDA DAIZ_TEMP1
	STA Coins_To_Deduct
	LDA #$10
	STA Deduct_Coin_Timer
	INC <Objects_Var4,X
	RTS

Deduct_Coins:
	DEC Deduct_Coin_Timer
	BNE Deduct_CoinsRTS
	JSR Decrease_Magic_Stars
	DEC Coins_To_Deduct
	BEQ Deduct_Coins_Done
	LDA #$10
	STA Deduct_Coin_Timer

Deduct_CoinsRTS:
	RTS

Deduct_Coins_Done:
	LDA #$20
	STA End_Level_Timer
	STA TollPaid
	INC <Objects_Var4,X
	RTS

End_Level:
	DEC End_Level_Timer
	LDA End_Level_Timer
	BNE End_LevelRTS
	
	LDA #$01
	STA Level_ExitToMap	
	LDA TollPaid		; if TollPaid = 1, complete this sprite
	BEQ Return_Map
	LDA #$00			; if toll not paid, return to last spot
	BEQ Store_Return_Status

Return_Map:
	LDA #$01

Store_Return_Status:
	STA Map_ReturnStatus

End_LevelRTS:
	RTS

Decrease_Magic_Stars:
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	DEC Magic_Stars
	LDA Magic_Stars
	AND #$0F
	CMP #$0A
	BCC No_HBros_Dec
	LDA Magic_Stars
	AND #$F0
	ORA #$09
	STA Magic_Stars

No_HBros_Dec:
	RTS

Next_Toad_Routine: .byte  $03, $06, $07

Toad_Do_Nothing:
	RTS

Decide_What_Next:
	LDA Objects_Var5, X
	TAY
	LDA Next_Toad_Routine, Y
	STA Objects_Var4, X
	RTS

Do_Shop_Controls:
	STX DAIZ_TEMP1
	LDA #$08
	STA Player_HaltTick
	LDA #$5E
	STA PatTable_BankSel
	LDA #$5B
	STA PatTable_BankSel + 5
	LDA Shop_Mode_Initialized
	BEQ Initialize_Shop_Mode
	LDA <Pad_Input
	AND #PAD_RIGHT
	BEQ Try_Shop_Left
	JSR Move_Items_Right
	JSR Draw_Current_Items
	JMP Shop_RTS

Try_Shop_Left:
	LDA <Pad_Input
	AND #PAD_LEFT
	BEQ Try_Leave_Shop
	JSR Move_Items_Left
	JSR Draw_Current_Items
	JMP Shop_RTS

Try_Leave_Shop:
	LDA <Pad_Input
	AND #PAD_B
	BEQ Try_Buy_Item
	INC Level_ExitToMap
	JMP Shop_RTS

Try_Buy_Item:
	LDA <Pad_Input
	AND #PAD_A
	BEQ Shop_RTS
	JSR Buy_Item
Shop_RTS:
	JSR Draw_Item_Sprite
	LDX DAIZ_TEMP1
	RTS

Item_Frame_Top:		.byte $E8, $E9, $E9, $EA
Item_Frame_Bottom:	.byte $DC, $DD, $DD, $DE

Initialize_Shop_Mode:
	LDA #$00 
	STA Item_Shop_Window + 1
	LDA #$01
	STA Item_Shop_Window + 2
	LDA #(Max_Item_Count - 1)
	STA Item_Shop_Window
	STA Shop_Mode_Initialized
	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$2E
	STA Graphics_Buffer, Y
	INY
	LDA #$04
	STA Graphics_Buffer, Y
	INY
	LDX #$00

Top_Frame_Loop:
	LDA Item_Frame_Top, X
	STA Graphics_Buffer, Y
	INY
	INX
	CPX #$04
	BNE Top_Frame_Loop
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$8E
	STA Graphics_Buffer, Y
	INY
	LDA #$04
	STA Graphics_Buffer, Y
	INY
	LDX #$00

Bottom_Frame_Loop:
	LDA Item_Frame_Bottom, X
	STA Graphics_Buffer, Y
	INY
	INX
	CPX #$04
	BNE Bottom_Frame_Loop
	LDA #$00
	STA Graphics_Buffer, Y
	LDA Graphics_BufCnt
	CLC
	ADC #$0E
	STA Graphics_BufCnt
	JSR Draw_Current_Items
	RTS

Move_Items_Right:
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1
	INC Item_Shop_Window
	INC Item_Shop_Window + 1
	INC Item_Shop_Window + 2
	LDX #$02

Check_OverFlow_Item:
	LDA Item_Shop_Window, X
	CMP #Max_Item_Count
	BNE Next_Item_Please
	LDA #$00
	STA Item_Shop_Window, X
Next_Item_Please:
	DEX
	BPL Check_OverFlow_Item
	RTS

Move_Items_Left:
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1
	DEC Item_Shop_Window
	DEC Item_Shop_Window + 1
	DEC Item_Shop_Window + 2
	LDX #$02

Check_UnderFlow_Item:
	LDA Item_Shop_Window, X
	CMP #$FF
	BNE Next_Item_Please2
	LDA #(Max_Item_Count - 1)
	STA Item_Shop_Window, X

Next_Item_Please2:
	DEX
	BPL Check_UnderFlow_Item
	RTS

Item_Tiles:
	.byte $30, $31, $40, $41
	.byte $32, $33, $42, $43
	.byte $3C, $3D, $4C, $4D
	.byte $34, $35, $44, $45
	.byte $36, $37, $46, $47
	.byte $38, $39, $48, $49
	.byte $5C, $5D, $6C, $6D
	.byte $3A, $3B, $4A, $4B
	.byte $5E, $5F, $6E, $6F
	.byte $3E, $3F, $4E, $4F
	.byte $04, $05, $14, $15
	.byte $06, $07, $16, $17
	.byte $08, $09, $18, $19
	.byte $0A, $0B, $1A, $1B
	.byte $0E, $0F, $1E, $1F

Item_Prices:
	.byte $00, $02, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $09, $00, $00
	.byte $01, $04, $00, $00
	.byte $01, $04, $00, $00
	.byte $02, $01, $00, $00
	.byte $02, $02, $00, $00
	.byte $00, $05, $00, $00
	.byte $00, $09, $00, $00
	.byte $02, $00, $00, $00
	.byte $01, $00, $00, $00
	.byte $00, $09, $00, $00
	.byte $01, $00, $00, $00

Draw_Current_Items:
	LDA #$00
	STA DAIZ_TEMP1
	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$4C
	STA Graphics_Buffer, Y
	INY
	LDA #$08
	STA Graphics_Buffer, Y
	INY

Draw_Item_Window_Top:
	LDX DAIZ_TEMP1
	LDA Item_Shop_Window, X
	ASL A
	ASL A
	TAX
	LDA Item_Tiles, X
	STA Graphics_Buffer, Y
	INY
	LDA Item_Tiles + 1, X
	STA Graphics_Buffer, Y
	INY
	INY
	INC DAIZ_TEMP1
	LDA DAIZ_TEMP1
	CMP #$03
	BNE Draw_Item_Window_Top
	LDY Graphics_BufCnt
	LDA #$F8
	STA Graphics_Buffer + 5, Y
	LDA #$FA
	STA Graphics_Buffer + 8, Y

	LDA #$00
	STA DAIZ_TEMP1
	LDA Graphics_BufCnt
	CLC
	ADC #$0B
	STA Graphics_BufCnt
	TAY
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$6C
	STA Graphics_Buffer, Y
	INY
	LDA #$08
	STA Graphics_Buffer, Y
	INY

Draw_Item_Window_Bottom:
	LDX DAIZ_TEMP1
	LDA Item_Shop_Window, X
	ASL A
	ASL A
	TAX
	INX
	INX
	LDA Item_Tiles, X
	STA Graphics_Buffer, Y
	INY
	LDA Item_Tiles + 1, X
	STA Graphics_Buffer, Y
	INY
	INY
	INC DAIZ_TEMP1
	LDA DAIZ_TEMP1
	CMP #$03
	BNE Draw_Item_Window_Bottom
	LDY Graphics_BufCnt
	LDA #$F8
	STA Graphics_Buffer + 5, Y
	LDA #$FA
	STA Graphics_Buffer + 8, Y
	LDA #$00
	STA Graphics_Buffer + 11, Y
	LDA Graphics_BufCnt
	CLC
	ADC #$0B
	STA Graphics_BufCnt

	LDA Item_Shop_Window + 1
	ASL A
	ASL A
	TAX
	LDA #$00
	STA DAIZ_TEMP1

	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	INY
	LDA #$AE
	STA Graphics_Buffer, Y
	INY
	LDA #$04
	STA Graphics_Buffer, Y
	INY

Next_Price_Digit:
	LDA Item_Prices, X
	CMP #$7F
	BEQ Skip_Digit
	CLC
	ADC #$A2

Skip_Digit:
	STA Graphics_Buffer, Y
	INY
	INX
	INC DAIZ_TEMP1
	LDA DAIZ_TEMP1
	CMP #$04
	BNE Next_Price_Digit
	LDA #$00
	STA Graphics_Buffer, Y
	LDA Graphics_BufCnt
	CLC
	ADC #$08
	STA Graphics_BufCnt
	RTS

Buy_Item:
	JSR Clear_Calc
	LDA Item_Shop_Window + 1
	ASL A
	ASL A
	TAX
	INX
	INX
	INX
	LDY #$07

Store_Next_Price:
	LDA Item_Prices, X
	STA Calc_Value, Y
	DEX
	DEY
	CPY #$03
	BNE Store_Next_Price
	LDX #$03

Store_Next_Coin:
	LDA Player_Coins, X
	STA Calc_From + 4, Y
	DEX
	DEY
	BPL Store_Next_Coin
	JSR Subtract_Values
	LDA Calc_From + 3
	BEQ Take_Item

Cannot_Take_Item:
	LDA Sound_QMap		; Not enough coins
	ORA #SND_MAPDENY
	STA Sound_QMap
	RTS

Take_Item:
	LDX #$00

Find_Slot:
	LDA Inventory_Items, X
	BEQ Slot_Found
	INX
	CPX #$1C
	BNE Find_Slot
	BEQ Cannot_Take_Item

Slot_Found:
	LDY Item_Shop_Window + 1
	INY
	TYA
	STA Inventory_Items, X
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	STA Force_Coin_Update
	LDX #$03

Store_New_Coin:
	LDA Calc_From + 4, X
	STA Player_Coins, X
	DEX
	BPL Store_New_Coin
	RTS

Item_Sprites:
	.byte $C1, $C1
	.byte $C3, $C3
	.byte $C5, $C5
	.byte $C7, $C9
	.byte $CB, $CB
	.byte $CD, $CD
	.byte $CF, $CF
	.byte $D1, $D1
	.byte $D3, $D3
	.byte $D5, $D5
	.byte $D7, $D5
	.byte $D9, $DB
	.byte $DD, $DF
	.byte $E1, $E3
	.byte $E5, $E7

Item_Pal:
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL2, SPR_PAL2 | SPR_HFLIP
	.byte SPR_PAL2, SPR_PAL2  | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1
	.byte SPR_PAL2, SPR_PAL2 | SPR_HFLIP
	.byte SPR_PAL2, SPR_PAL2 | SPR_HFLIP
	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP
	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1 | SPR_HFLIP
	.byte SPR_PAL1, SPR_PAL1
	.byte SPR_PAL3, SPR_PAL3
	.byte SPR_PAL1, SPR_PAL1
	.byte SPR_PAL1, SPR_PAL1

Draw_Item_Sprite:
	LDA Item_Shop_Window + 1 
	ASL A
	TAX
	JSR Object_GetRandNearUnusedSpr
	LDA #$90
	STA Sprite_RAM, Y
	LDA #$78
	STA Sprite_RAM + 3, Y
	LDA Item_Sprites, X
	STA Sprite_RAM + 1, Y
	LDA Item_Pal, X
	STA Sprite_RAM + 2, Y
	INX
	JSR Object_GetRandNearUnusedSpr
	LDA #$90
	STA Sprite_RAM, Y
	LDA #$80
	STA Sprite_RAM + 3, Y
	LDA Item_Sprites, X
	STA Sprite_RAM + 1, Y
	LDA Item_Pal, X
	STA Sprite_RAM + 2, Y
	RTS

Bank_Toad:
	LDA #$02
	STA Player_HaltTick
	LDA Shop_Mode_Initialized
	JSR DynJump
	
	.word Bank_Init1
	.word Bank_Init2
	.word Do_Bank

WithdrawDepositFrames:
	.byte $2E, $6A, $0E, $00, $01, $01, $01, $01, $02, $00, $01, $01, $01, $01, $01, $01, $02
	.byte $2E, $8A, $0E, $10, $7E, $7E, $7E, $7E, $12, $10, $7E, $7E, $7E, $7E, $7E, $7E, $12
	.byte $2E, $AA, $0E, $20, $21, $21, $21, $21, $22, $20, $21, $21, $21, $21, $21, $21, $22

ActionFrames:
	.byte $2E, $0A, $0E, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $02
	.byte $2E, $2A, $0E, $10, $7E, $C4, $C5, $D0, $CF, $D3, $C9, $D4, $7E, $7E, $7E, $7E, $12
	.byte $2E, $4A, $0E, $20, $21, $21, $21, $21, $21, $21, $21, $21, $21, $21, $21, $21, $22

Bank_Init1:
	JSR Draw_BankFrames
	INC Shop_Mode_Initialized
	RTS

Bank_Init2:
	JSR Draw_ActionFrames
	INC Shop_Mode_Initialized
	RTS

Draw_BankFrames:
	LDY Graphics_BufCnt
	LDX #$00

DoDrawBF:
	LDA WithdrawDepositFrames, X
	STA Graphics_Buffer, Y
	INY
	INX
	CPX #$33
	BNE DoDrawBF
	INY
	STY Graphics_BufCnt
	RTS

Draw_ActionFrames:
	LDY Graphics_BufCnt
	LDX #$00

DoDrawAct:
	LDA ActionFrames, X
	STA Graphics_Buffer, Y
	INY
	INX
	CPX #$33
	BNE DoDrawAct
	INY
	STY Graphics_BufCnt
	RTS

Do_Bank:
	JSR Clear_Calc
	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN)
	BNE Do_Small_Change
	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ Update_Action
	INC SpinnerBlocksX + 5
	LDX SpinnerBlocksX + 5
	CPX #$07
	BNE Done_Bank

Do_Small_Change:
	LDX #$01
	STX SpinnerBlocksX + 5
	STX Calc_Value + 6
	AND #PAD_UP
	BEQ Decrease_By_Ten
	JSR Add_To_DW
	JMP Update_Bank

Decrease_By_Ten:
	JSR Sub_From_DW

Update_Bank:
	JSR Update_DepositWithdraw
	JMP Done_Bank

Update_Action:
	LDA <Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ Update_Bank
	INC SpinnerBlocksX + 6
	JSR Draw_Action

Done_Bank:
	LDA <Pad_Input
	AND #PAD_B
	BEQ Try_Bank_Action
	INC Level_ExitToMap

Try_Bank_Action:
	LDA <Pad_Input
	AND #PAD_A
	BEQ Bank_RTS
	JSR Do_Action

Bank_RTS
	RTS

Action_Tiles:
	.byte "DEPOSIT "
	.byte "WITHDRAW"

Draw_Action:
	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	LDA #$2C
	STA Graphics_Buffer + 1, Y
	LDA #$08
	STA Graphics_Buffer + 2, Y
	LDA SpinnerBlocksX + 6
	AND #$01
	ASL A
	ASL A
	ASL A
	TAX
	LDA #$07
	STA <Temp_Var1

DrawAction:
	LDA Action_Tiles, X
	ADD #$80
	STA Graphics_Buffer + 3, Y
	INY
	INX
	DEC <Temp_Var1
	BPL DrawAction
	TYA
	ADD #$03
	TAY
	STY Graphics_BufCnt
	LDA #$00
	STA Graphics_Buffer, Y
	RTS

Set_DW_Amount:
	LDX #$00

CopyDWAmount:
	LDA SpinnerBlocksX, X
	STA Calc_From + 4, X
	INX
	CPX #$04
	BNE CopyDWAmount
	RTS

Set_New_DW_Amount:
	LDX #$00

CopyNewDWAmount:
	LDA Calc_From + 4, X
	STA SpinnerBlocksX, X
	INX
	CPX #$04
	BNE CopyNewDWAmount
	RTS

Add_To_DW:
	LDX #$02

TestMaxDWMax:
	
	LDA SpinnerBlocksX, X
	CMP #$09
	BCC Do_DW_Add
	DEX
	BPL TestMaxDWMax
	RTS

Do_DW_Add:
	JSR Set_DW_Amount
	JSR Add_Values
	JSR Set_New_DW_Amount
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1
	RTS

Sub_From_DW:
	LDX #$02
	LDA #$00

TestMaxDWMin:
	ADD SpinnerBlocksX, X
	DEX
	BPL TestMaxDWMin
	CMP #$00
	BNE Do_DW_Sub
	RTS

Do_DW_Sub:
	JSR Set_DW_Amount
	JSR Subtract_Values
	JSR Set_New_DW_Amount
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1
	RTS

Update_DepositWithdraw: ; - reusing spinner area for this part

	LDY Graphics_BufCnt
	LDA #$2A
	STA Graphics_Buffer, Y
	LDA #$8B
	STA Graphics_Buffer + 1, Y
	LDA #$04
	STA Graphics_Buffer + 2, Y
	LDA #$00
	STA Graphics_Buffer + 7, Y

	LDX #$00

DrawDWAmount:
	LDA SpinnerBlocksX, X
	ADD #$B0
	STA Graphics_Buffer + 3, Y
	INY
	INX
	CPX #$04
	BNE DrawDWAmount
	TYA
	ADD #$03
	TAY
	LDA #$2A
	STA Graphics_Buffer, Y
	LDA #$91
	STA Graphics_Buffer + 1, Y
	LDA #$06
	STA Graphics_Buffer + 2, Y
	
	LDX #$00
	

DrawBankAmount:
	LDA BankCoins, X
	ADD #$B0
	STA Graphics_Buffer + 3, Y
	INY
	INX
	CPX #$06
	BNE DrawBankAmount
	TYA
	ADD #$03
	TAY
	LDA #$00
	STA Graphics_Buffer, Y
	STY Graphics_BufCnt
	RTS

Do_Action:
	LDA SpinnerBlocksX + 6
	AND #$01
	BNE Do_Withdraw_Instead
	JSR Set_Player_Coins_From
	JSR Set_DW_Coins_Value
	JSR Subtract_Values
	LDA Calc_From
	BMI Cannot_Do_Action
	JSR Backup_From_Value
	JSR Set_Bank_Coins_From
	JSR Add_Values
	LDA Calc_From + 1
	CMP #$01
	BCS Cannot_Do_Action
	JSR Set_New_Bank_Value
	JSR Set_New_Player_Coins
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	STA Force_Coin_Update
	RTS

Do_Withdraw_Instead:
	JSR Set_Player_Coins_From
	JSR Set_DW_Coins_Value
	JSR Add_Values
	LDA Calc_From + 3
	CMP #$01
	BCS Cannot_Do_Action
	JSR Backup_From_Value
	JSR Set_Bank_Coins_From
	JSR Subtract_Values
	LDA Calc_From
	BMI Cannot_Do_Action
	JSR Set_New_Bank_Value
	JSR Set_New_Player_Coins
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	STA Force_Coin_Update
	RTS

Cannot_Do_Action:
	LDA Sound_QMap		; Not enough coins
	ORA #SND_MAPDENY
	STA Sound_QMap
	RTS

Set_Player_Coins_From:
	LDX #$03

SPCF:
	LDA Player_Coins, X
	STA Calc_From + 4, X
	DEX
	BPL SPCF
	RTS

Set_Bank_Coins_From:
	LDX #$00

SBCF:
	LDA BankCoins, X
	STA Calc_From + 2, X
	INX
	CPX #$06
	BNE SBCF
	RTS

Set_DW_Coins_Value:
	LDX #$03

SDWCV:
	LDA SpinnerBlocksX, X
	STA Calc_Value + 4, X
	DEX
	BPL SDWCV
	RTS

Backup_From_Value:
	LDX #$03

BFV:
	LDA Calc_From + 4, X
	STA SpinnerBlocksY, X
	DEX
	BPL BFV
	RTS

Set_New_Bank_Value:
	LDX #$05

SNBV:
	LDA Calc_From + 2, X
	STA BankCoins, X
	DEX
	BPL SNBV
	RTS

Set_New_Player_Coins:
	LDX #$03

SNPC:
	LDA SpinnerBlocksY, X
	STA Player_Coins, X
	DEX
	BPL SNPC
	RTS


Player_Take_Coins:
	STX DAIZ_TEMP1
	LDA <Counter_1
	AND #$03
	BNE No_More_Coins
	JSR Clear_Calc
	LDX #$03

Store_Next_Coin1:
	LDA Player_Coins, X
	STA Calc_From + 4, X
	DEX
	BPL Store_Next_Coin1
	LDA #$01
	STA Calc_Value + 7
	JSR Subtract_Values
	LDA Calc_From
	BMI No_More_Coins
	LDX #$03

Taking_Coins:
	LDA Calc_From + 4, X
	STA Player_Coins, X
	DEX
	BPL Taking_Coins
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	STA Force_Coin_Update

No_More_Coins:
	LDX DAIZ_TEMP1
	RTS