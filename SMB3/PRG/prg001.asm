; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-19 22:50:51.409583184 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

	; CAUTION!! ObjectGroup00 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $00 (i.e. objects starting at ID $00) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup00_InitJumpTable:
	.word ObjInit_DoNothing	; Object $00
	.word ObjInit_DoNothing	; Object $01
	.word ObjInit_DoNothing	; Object $02
	.word ObjInit_EaterBlock	; Object $03
	.word ObjInit_CoinLock	; Object $04
	.word ObjInit_DoNothing	; Object $05
	.word ObjInit_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjInit_Brick	; Object $07 - OBJ_BRICK
	.word ObjInit_Coin	; Object $08 - OBJ_COIN
	.word ObjInit_Bubble	; Object $09 - OBJ_BUBBLE
	.word ObjInit_ModifyPointers	; Object $0A - OBJ_BULLY
	.word ObjInit_PowerUp	; Object $0B - OBJ_POWERUP
	.word ObjInit_PUp1; Object $0C - OBJ_POWERUP_INIT1
	.word ObjInit_PUp2	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjInit_HardIce	; Object $0E - OBJ_HARDICE
	.word ObjInit_Weather	; Object $0F - OBJ_RAIN
	.word ObjInit_IceFireFly; Object $10 - OBJ_PIXIE
	.word ObjInit_Key	; Object $11 OBJ_KEY
	.word ObjInit_Spring	; Object $12 OBJ_SPRING
	.word ObjInit_KeyPieces	; Object $13 OBJ_KEYPIECES
	.word ObjInit_GiantChomp	; Object $14 OBJ_GIANTCHOMP
	.word ObjInit_DoNothing	; Object $15 
	.word ObjInit_DoNothing	; Object $16 OBJ_KEYPIECE
	.word ObjInit_DoNothing; Object $17 - OBJ_NEGASTAR
	.word ObjInit_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjNorm_DoNothing; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjInit_BubbleGenerator	; Object $1A that is a l
	.word ObjInit_DoNothing	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjInit_SendBack	; Object $1C
	.word ObjInit_Timer	; Object $1D
	.word ObjInit_DoNothing	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjInit_DoNothing	; Object $1F - OBJ_GROWINGVINE
	.word ObjInit_DoNothing	; Object $20
	.word ObjNorm_DoNothing	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjInit_DoNothing	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjInit_DoNothing	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup00_NormalJumpTable:
	.word ObjNorm_DoNothing	; Object $00
	.word ObjNorm_BowserFireBall	; Object $01
	.word ObjNorm_SnowBall	; Object $02
	.word ObjNorm_EaterBlock	; Object $03
	.word ObjNorm_CoinLock	; Object $04
	.word ObjNorm_SpikeBall	; Object $05
	.word ObjNorm_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjNorm_Brick	; Object $07 - OBJ_BRICK
	.word ObjNorm_Coin	; Object $08 - OBJ_COIN
	.word ObjNorm_Bubble	; Object $09 - OBJ_BUBBLE
	.word ObjNorm_DoNothing	; Object $0A OBJ_BULLY
	.word ObjNorm_PowerUp; Object $0B - OBJ_POWERUP
	.word ObjInit_DoNothing; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjInit_DoNothing	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjNorm_HardIce	; Object $0E - OBJ_HARDICE
	.word ObjNorm_Weather	; Object $0F
	.word ObjNorm_IceFireFly	; Object $10 - OBJ_PIXIE
	.word ObjNorm_Key	; Object $11
	.word ObjNorm_Spring	; Object $12
	.word ObjNorm_KeyPieces	; Object $13 
	.word ObjNorm_GiantChomp	; Object $14 OBJ_GIANTCHOMP
	.word ObjNorm_Boss	; Object $15 OBJ_BOSS
	.word ObjNormal_KeyPiece	; Object $16 OBJ_KEYPIECE
	.word ObjNorm_NegaStar; Object $17 - OBJ_NEGASTAR
	.word ObjNorm_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjNorm_DoNothing; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjNorm_Bubble	; Object $1A
	.word ObjNorm_StarPiece	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjNorm_SendBack	; Object $1C
	.word ObjNorm_Timer	; Object $1D
	.word ObjInit_DoNothing	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjInit_DoNothing	; Object $1F - OBJ_GROWINGVINE
	.word ObjNorm_Clock	; Object $20
	.word ObjInit_DoNothing	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjInit_DoNothing	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjInit_DoNothing	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) Collision routine jump table (if calling Object_InteractWithPlayer;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup00_CollideJumpTable:
	.word Player_GetHurt	; Object $00
	.word ObjHit_DoNothing	; Object $01
	.word ObjHit_SnowBall	; Object $02
	.word ObjHit_SolidBlock	; Object $03
	.word ObjHit_DoNothing	; Object $04
	.word Player_GetHurt	; Object $05
	.word ObjHit_DoNothing	; Object $06 - OBJ_BOUNCEDOWNUP
	.word Player_GetHurt	; Object $07 - OBJ_BRICK
	.word ObjHit_Coin	; Object $08 - OBJ_COIN
	.word BubblePop	; Object $09 - OBJ_BUBBLE
	.word ObjHit_DoNothing	; Object $0A
	.word PUp_Collect	; Object $0B - OBJ_POWERUP
	.word ObjInit_DoNothing	; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjInit_DoNothing	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjHit_HardIce	; Object $0E - OBJ_HARDICE
	.word ObjHit_DoNothing	; Object $0F
	.word Player_GetHurt	; Object $10 OBJ_PIXIE
	.word Object_Hold	; Object $11
	.word Object_Hold	; Object $12
	.word ObjHit_DoNothing	; Object $13
	.word ObjHit_DoNothing	; Object $14 OBJ_GIANTCHOMP
	.word ObjHit_DoNothing	; Object $15
	.word ObjHit_KeyPiece	; Object $16
	.word ObjHit_DoNothing	; Object $17 - OBJ_NEGASTAR
	.word OCSPECIAL_HIGHSCORE; Object $18 - OBJ_BOSS_BOWSER
	.word ObjNorm_DoNothing	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word BubblePop	; Object $1A
	.word Object_SetDeadEmpty	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjHit_DoNothing	; Object $1C
	.word ObjHit_DoNothing	; Object $1D
	.word ObjHit_DoNothing	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjHit_DoNothing	; Object $1F - OBJ_GROWINGVINE
	.word ObjHit_Clock	; Object $20
	.word ObjHit_IceFlower	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjHit_Pumpkin	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjHit_FoxLeaf    ; Object $23 - OBJ_POWERUP_FOXLEAF

	
	; Object group $00 (i.e. objects starting at ID $00) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup00_Attributes:
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $00
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $01
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $02
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $03
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $04
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $05
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $07 - OBJ_BRICK
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $08 - OBJ_COIN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $09 - OBJ_BUBBLE
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0A- OBJ_BULLY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0B - OBJ_POWERUP
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0E - OBJ_HARDICE
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0F - 
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $10 OBJ_PIXIE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $11 OBJ_KEY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $12 OBJ_REDPRING
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $13 OBJ_GREENSPRING
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $14 OBJ_GIANTCHOMP
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $15
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $16
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $17 - OBJ_NEGASTAR
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1A
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1C
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_HEIGHT16	; Object $1D
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1F - OBJ_GROWINGVINE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $20
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $21 - OBJ_POWERUP_ICEFLOWER #DAHRKDAIZ
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup00_Attributes2:
	.byte OA2_TDOGRP0	; Object $00
	.byte OA2_TDOGRP1	; Object $01
	.byte OA2_TDOGRP1	; Object $02
	.byte OA2_TDOGRP1	; Object $03
	.byte OA2_TDOGRP2	; Object $04
	.byte OA2_TDOGRP1	; Object $05
	.byte OA2_TDOGRP1	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA2_TDOGRP1	; Object $07 - OBJ_BRICK
	.byte OA2_TDOGRP1	; Object $08 - OBJ_COIN
	.byte OA2_TDOGRP1	; Object $09 - OBJ_BUBBLE
	.byte OA2_TDOGRP1	; Object $0A
	.byte OA2_TDOGRP1	; Object $0B - OBJ_POWERUP
	.byte OA2_TDOGRP1	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA2_TDOGRP1	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA2_TDOGRP1	; Object $0E - OBJ_HARDICE
	.byte OA2_TDOGRP1	; Object $0F
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $10 OBJ_PIXIE
	.byte OA2_TDOGRP1	; Object $11
	.byte OA2_TDOGRP1	; Object $12
	.byte OA2_TDOGRP1	; Object $13
	.byte OA2_TDOGRP0	; Object $14
	.byte OA2_TDOGRP0	; Object $15
	.byte  OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $16
	.byte OA2_TDOGRP1	; Object $17 - OBJ_NEGASTAR
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP12	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA2_TDOGRP1	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA2_TDOGRP1	; Object $1A
	.byte OA2_TDOGRP1	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA2_TDOGRP1	; Object $1C
	.byte OA2_TDOGRP2	; Object $1D
	.byte OA2_TDOGRP1	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA2_TDOGRP1	; Object $1F - OBJ_GROWINGVINE
	.byte OA2_TDOGRP1	; Object $20
	.byte OA2_TDOGRP1	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OA2_TDOGRP1	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA2_TDOGRP1	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) third set attribute bits

	; Attribute bits for objects:
	;	Bits 0-3: Determines what to do when gameplay halted (see Object_DoHaltedAction, most common is 5 / 0101)
	
	;	Bit 5: Object is NOT stompable (e.g. a spikey enemy, HURTS PLAYER, not same as attr 2 bit 2 which is just indifferent)
	;	Bit 6: The CollideJumpTable entry MAY contain the "special" entry; see CollideJumpTable; also "dies" into "shell" (state 3) (i.e. object "bumps" into shell when hit from beneath)
	;	Bit 7: If set, object cannot be tail attacked

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup00_Attributes3:
	.byte OA3_HALT_NORMALONLY 	; Object $00
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $01
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE	; Object $02
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $03
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $04
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE 	; Object $05
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $07 - OBJ_BRICK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $08 - OBJ_COIN
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE |OA3_NOTSTOMPABLE 	; Object $09 - OBJ_BUBBLE
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $0A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0B - OBJ_POWERUP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $0E - OBJ_HARDICE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $0F
	.byte OA3_HALT_NORMALONLY 	; Object $10 OBJ_PIXIE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_SHELL 	; Object $11
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE  	; Object $12
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE  	; Object $13
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE  	; Object $14
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $15
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $16
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $17 - OBJ_NEGASTAR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE |OA3_NOTSTOMPABLE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA3_HALT_JUSTDRAW 	; Object $1A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $1C
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $1D
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $1F - OBJ_GROWINGVINE
	.byte  OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $20
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup00_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $00
	.byte OPTS_NOCHANGE; Object $01
	.byte OPTS_NOCHANGE	; Object $02
	.byte OPTS_NOCHANGE	; Object $03
	.byte OPTS_NOCHANGE	; Object $04
	.byte OPTS_SETPT5 | $0E	; Object $05
	.byte OPTS_NOCHANGE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OPTS_NOCHANGE	; Object $07 - OBJ_BRICK
	.byte OPTS_NOCHANGE	; Object $08 - OBJ_COIN
	.byte OPTS_NOCHANGE	; Object $09 - OBJ_BUBBLE
	.byte OPTS_NOCHANGE	; Object $0A - OBJ_BULLY
	.byte OPTS_NOCHANGE	; Object $0B - OBJ_POWERUP
	.byte OPTS_NOCHANGE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OPTS_NOCHANGE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OPTS_SETPT5 | $0F	; Object $0E - OBJ_HARDICE
	.byte OPTS_NOCHANGE	; Object $0F
	.byte OPTS_NOCHANGE | $33	; Object $10 OBJ_PIXIE
	.byte OPTS_NOCHANGE	; Object $11
	.byte OPTS_SETPT6 | $4F		; Object $12
	.byte OPTS_NOCHANGE	; Object $13
	.byte OPTS_SETPT5 | $0E	; Object $14
	.byte OPTS_NOCHANGE	; Object $15
	.byte OPTS_NOCHANGE	; Object $16
	.byte OPTS_SETPT5 | $4D	; Object $17 - OBJ_NEGASTAR
	.byte OPTS_SETPT5 | $3A	; Object $18 - OBJ_BOSS_BOWSER
	.byte OPTS_NOCHANGE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OPTS_SETPT5 | $1A	; Object $1A
	.byte OPTS_NOCHANGE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OPTS_NOCHANGE	; Object $1C
	.byte OPTS_NOCHANGE	; Object $1D
	.byte OPTS_NOCHANGE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OPTS_NOCHANGE	; Object $1F - OBJ_GROWINGVINE
	.byte OPTS_NOCHANGE 	; Object $20
	.byte OPTS_NOCHANGE	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OPTS_NOCHANGE	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OPTS_NOCHANGE	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup00_KillAction:
	.byte KILLACT_STANDARD	; Object $00
	.byte KILLACT_STANDARD	; Object $01
	.byte KILLACT_STANDARD	; Object $02
	.byte KILLACT_STANDARD	; Object $03
	.byte KILLACT_POOFDEATH	; Object $04
	.byte KILLACT_POOFDEATH	; Object $05
	.byte KILLACT_STANDARD	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte KILLACT_STANDARD	; Object $07 - OBJ_BRICK
	.byte KILLACT_STANDARD	; Object $08 - OBJ_COIN
	.byte KILLACT_STANDARD	; Object $09 - OBJ_BUBBLE
	.byte KILLACT_STANDARD	; Object $0A
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0B - OBJ_POWERUP
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0C - OBJ_POWERUP_STARMAN
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte KILLACT_NORMALANDKILLED	; Object $0E - OBJ_HARDICE
	.byte KILLACT_STANDARD	; Object $0F
	.byte KILLACT_NORMALANDKILLED	; Object $10
	.byte KILLACT_STANDARD	; Object $11
	.byte KILLACT_STANDARD	; Object $12
	.byte KILLACT_STANDARD	; Object $13
	.byte KILLACT_STANDARD	; Object $14
	.byte KILLACT_NORMALSTATE	; Object $15
	.byte KILLACT_STANDARD	; Object $16
	.byte KILLACT_POOFDEATH	; Object $17 - OBJ_NEGASTAR
	.byte KILLACT_NORMALSTATE	; Object $18 - OBJ_BOSS_BOWSER
	.byte KILLACT_JUSTDRAWMIRROR	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte KILLACT_STANDARD	; Object $1A
	.byte KILLACT_STANDARD	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte KILLACT_STANDARD	; Object $1C
	.byte KILLACT_STANDARD	; Object $1D
	.byte KILLACT_STANDARD	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte KILLACT_STANDARD	; Object $1F - OBJ_GROWINGVINE
	.byte KILLACT_STANDARD	; Object $20
	.byte KILLACT_STANDARD	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte KILLACT_STANDARD	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte KILLACT_STANDARD	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) pattern index starts
	; These are used for all states except "normal"

OG0_POff .func (\1 - ObjectGroup00_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup00_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG0_POff(ObjP00), OG0_POff(ObjP01), OG0_POff(ObjP02), OG0_POff(ObjP03)
	.byte OG0_POff(ObjP04), OG0_POff(ObjP05), OG0_POff(ObjP06), OG0_POff(ObjP07)
	.byte OG0_POff(ObjP08), OG0_POff(ObjP09), OG0_POff(ObjP0A), OG0_POff(ObjP0B)
	.byte OG0_POff(ObjP0C), OG0_POff(ObjP0D), OG0_POff(ObjP0E), OG0_POff(ObjP0F)
	.byte OG0_POff(ObjP10), OG0_POff(ObjP11), OG0_POff(ObjP12), OG0_POff(ObjP13)
	.byte OG0_POff(ObjP14), OG0_POff(ObjP15), OG0_POff(ObjP16), OG0_POff(ObjP17)
	.byte OG0_POff(ObjP18), OG0_POff(ObjP19), OG0_POff(ObjP1A), OG0_POff(ObjP1B)
	.byte OG0_POff(ObjP1C), OG0_POff(ObjP1D), OG0_POff(ObjP1E), OG0_POff(ObjP1F)
	.byte OG0_POff(ObjP20), OG0_POff(ObjP21), OG0_POff(ObjP22), OG0_POff(ObjP23)

	; Object group $00 (i.e. objects starting at ID $00) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup00_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup00_PatternSets:
	; (End restricted alignment space)
ObjP00:
ObjP03:
	.byte $77, $77

ObjP07:
	.byte $67, $67, $97, $99

ObjP0E:
	.byte $99, $9B

ObjP0F:
ObjP10:
	.byte $91, $93, $95, $97, $99, $9B, $95, $97

ObjP11:
	.byte $69, $7D

ObjP12:
	.byte $D7, $D7, $ED, $ED, $FF, $FF, $ED, $ED

ObjP13:
ObjP16:
	.byte $81, $83, $85, $87, $89, $89, $87, $85, $C1, $C3, $C5, $C7, $C9, $C9, $C7, $C5
ObjP14:
ObjP15:
ObjP17:
	.byte $9F, $9F

ObjP18:	
ObjP1D:
ObjP20:
	.byte $97, $99, $9B, $9D, $A1, $AB, $A3, $A1, $A3, $AB, $A5, $A1, $A5, $AB, $A7, $A1
	.byte $D7, $D9, $DB, $DD, $E1, $EB, $E3, $E1, $E3, $EB, $E5, $E1, $E5, $EB, $E7, $E1

ObjP01:	.byte $F3, $F5, $F3, $F5, $BB, $BD, $BB, $BF
ObjP02:	.byte $95, $97, $8D, $8F
ObjP04:	.byte $F5, $F7, $B5, $B7
ObjP05:	.byte $95, $95, $97, $97
ObjP06:	
ObjP1B:	.byte $8B, $8D, $8F, $91, $89, $89, $91, $8F, $CB, $CD, $CF, $D1, $C9, $C9, $D1, $CF	; RAS: Not actually used, see BounceBlock_Tile
ObjP09:	
ObjP1A: .byte $8D, $8D, $8F, $8F, $91, $91, $A7, $A7, $A9, $A9, $AB, $AB
ObjP0A:	.byte $A9, $AB, $BD, $BF
ObjP0C:	.byte $51, $53, $51, $53, $51, $53, $51, $53
ObjP0B:	.byte $51, $53	; #DAHRKDAIZ changed 1Up to use a "Ninja Mushroom" sprite instead, separate from regular mushroom
ObjP0D:	.byte $51, $53
ObjP19:	.byte $51, $53
ObjP1C:	
ObjP1E:	.byte $51, $53
ObjP1F:	.byte $51, $53	; #DAHRKDAIZ - VINE
ObjP21:	.byte $51, $53
ObjP22:	.byte $51, $53 ; #DAHRKDAIZ - PUMPKIN
ObjP23:	.byte $51, $53	; #DAHRKDAIZ - GOLD LEAF
ObjP08:	.byte $BB, $BB, $FB, $F9, $FB, $F9, $FF, $FD, $DA, $DA

SpringPals: .byte SPR_PAL1, SPR_PAL2, SPR_PAL3

ObjInit_Spring:
	; difficult strengths of spring 0 = normal, 1 = stronger, 2 = strongest
	LDY Objects_Property, X
	LDA SpringPals, Y
	STA Objects_SpriteAttributes,X
	RTS

Spring_Jump_Height:
	.byte $C0, $B4, $A8

Spring_Player_YOffsets:
	.byte $20, $1C, $17, $1C

Spring_CurrentFrame = Objects_Data5

ObjNorm_Spring:
	LDA <Player_HaltGameZ
	BNE Spring_RTS

	JSR Object_DeleteOffScreen
	JSR Object_Move
	
	LDA Spring_CurrentFrame, X
	BNE SpringAnim

	JSR Object_InteractWithPlayer
	BCC Spring_2

	LDA Object_BeingHeld, X
	BNE Spring_RTS

	LDA Objects_PlayerHitStat, X
	AND #$01
	BEQ Spring_2

	LDA <Player_YVel
	BMI Spring_2

	LDA #$02
	STA Objects_Timer, X
	
	LDA #$03
	STA Spring_CurrentFrame, X

	BEQ SpringAnim

Spring_2:
	JSR Object_DampenVelocity
	JSR Object_InteractWithTiles

Spring_RTS:
	JMP Object_ShakeAndDrawMirrored

SpringAnim:
	LDY Spring_CurrentFrame, X
	LDA Objects_YZ, X
	SUB Spring_Player_YOffsets, Y
	STA <Player_Y
	
	LDA <Objects_YHiZ, X
	SBC #$00
	STA <Player_YHi
	
	LDA #$00
	STA <Player_YVel
	STA <Player_InAir

	LDA Objects_Timer, X
	BNE SpringAnimRTS
	
	LDA #$02
	STA Objects_Timer, X
	DEC Spring_CurrentFrame, X
	BNE SpringAnimRTS

	; once the spring's animation is done, throw the player in the air
	LDY Objects_Property, X
	LDA Spring_Jump_Height, Y
	STA <Player_YVel
	STA <Player_InAir
	
	LDA #$E0
	STA <Objects_YVelZ, X

SpringAnimRTS:
	LDA Spring_CurrentFrame, X
	STA Objects_Frame, X
	JMP Object_ShakeAndDrawMirrored

ObjInit_Key:
	RTS

ObjNorm_Key:
	LDA <Player_HaltGameZ
	BNE ObjNorm_KeyDraw

	JSR Object_Move
	JSR Object_InteractWithPlayer

	LDA Object_BeingHeld, X
	BNE ObjNorm_Key1

	JSR Object_DampenVelocity
	JSR Object_InteractWithTiles

ObjNorm_Key1:
	JSR CheckKeyAgainstLock
	
ObjNorm_KeyDraw:
	JSR Object_ShakeAndDraw
	RTS


CheckKeyAgainstLock:
	
	LDA Objects_LastProp,X
	CMP #TILE_PROP_SOLID_TOP
	BCS RemainLocked

	AND #$0F
	CMP #TILE_PROP_LOCK
	BNE RemainLocked

	LDA Block_NeedsUpdate
	BNE RemainLocked

	LDA Objects_LastTile, X
	EOR #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate
	
	JSR SetObjectTileCoordAlignObj

	LDA #OBJSTATE_POOFDEATH
	LDX <CurrentObjectIndexZ
	STA Objects_State, X

	LDA #$20
	STA Objects_Timer,X
	PLA
	PLA

RemainLocked:
	RTS

ObjInit_NegaStar:
	; Objects_Data4 is just a timer for taking stars
	LDA #$FF
	STA Objects_Data4,X
	RTS

ObjNorm_NegaStar:

	; Up to 8 Negastars are possible, each with different star costs, the NegaStars are prefilled at game initialization
	; see GAME START comment
	LDY Objects_Property, X
	LDA NegaStars, Y
	BNE ObjNorm_NegaStar0
	JMP Coin_Unlock

ObjNorm_NegaStar0:
	JSR Object_DeleteOffScreen
	LDA <Player_HaltGameZ
	BNE ObjNorm_NegaStar01
	LDA #$91
	BEQ ObjNorm_NegaStar01
	JSR TakeMagic_Star

ObjNorm_NegaStar01:
	JSR Object_ShakeAndDrawMirrored

	LDA Objects_SpritesHorizontallyOffScreen,X 
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE NegaStarRTS

	LDY Objects_Property, X

	LDA NegaStars, Y
	STA DigitsParam

	JSR BytesTo2Digits

	LDY Object_SpriteRAM_Offset, X

	LDA Sprite_RAM, Y
	ADD #$10
	STA Sprite_RAM+8, Y
	STA Sprite_RAM+12, Y

	LDA Sprite_RAM+3, Y
	STA Sprite_RAM+11, Y
	ADD #$08
	STA Sprite_RAM+15, Y

	LDA #SPR_PAL1
	STA Sprite_RAM+10,Y
	STA Sprite_RAM+14,Y

	LDA <DigitsResult
	ASL A
	ADD #$A1
	STA Sprite_RAM + 9, Y

	LDA <DigitsResult + 1
	ASL A
	ADD #$A1
	STA Sprite_RAM + 13, Y

NegaStarRTS:
	RTS

TakeMagic_Star:
	LDA Objects_Data4, X
	BEQ TakeMagic_Star0
	DEC Objects_Data4, X
	RTS

TakeMagic_Star0:
	INC Objects_Data5, X
	LDA Objects_Data5, X
	CMP #$20
	BEQ TakeMagic_Star1

	LDY Objects_Property, X
	LDA <Player_SpriteX
	STA Sprite_RAM+11,Y
	ADD #$08
	STA Sprite_RAM+15,Y

	LDA <Player_SpriteY
	SUB Objects_Data5, X
	STA Sprite_RAM+8,Y
	STA Sprite_RAM+12,Y

	LDA #$7F
	STA Sprite_RAM+9,Y
	STA Sprite_RAM+13,Y

	LDA #SPR_PAL1
	STA Sprite_RAM+10,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+14,Y
	RTS

TakeMagic_Star1:
	DEC Magic_Stars
	LDY Objects_Property, X
	LDA NegaStars, Y
	SUB #$01
	STA NegaStars, Y
	LDA Sound_QLevel1
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap
	LDA #40
	STA Objects_Data4,X
	LDA #$00
	STA Objects_Data5,X
	RTS

ObjInit_BounceDU: 
	LDA Level_BlkFinish
	STA Objects_Data5,X	 ; Store Player's bounce into var 2
	LDA Player_BounceDir
	STA Objects_Data3,X
	LDA #$00
	STA Level_BlkFinish

PRG001_A4C6:
	LDA Player_Bounce
	STA Objects_Data4,X	; Store Player_Bounce -> var1

	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 ; Shift right 4
	STA Objects_Frame,X	 ; Store into Objects_Frame 
 
	LDA #$00
	STA Player_Bounce	 ; Clear Player_Bounce
	STA Player_BounceObj	 ; Clear Player_BounceObj
	STA Objects_Orientation,X	 ; Force left/right flag to zero
	STA Objects_SpritesVerticallyOffScreen,X	 ; Clear flags 2
	STA Objects_SpritesHorizontallyOffScreen,X	 ; Clear flags 1

	LDA #10
	STA Level_BlkBump_Pos-6,X ; Block bump position = 10

	JMP BounceBlock_Update	 ; Jump to BounceBlock_Update

	; Power-up which may emerge from different types of bounce blocks

Bouncer_PUp:
	.byte $00, $00, OBJ_POWERUP_FIREFLOWER, OBJ_POWERUP_SUPERLEAF, OBJ_POWERUP_STARMAN, OBJ_POWERUP_MUSHROOM, OBJ_GROWINGVINE, OBJ_POWERUP, OBJ_POWERUP_ICEFLOWER, OBJ_POWERUP_PUMPKIN, OBJ_POWERUP_FOXLEAF; #DAHRKDAIZ added OBJ_POWERUP_ICE

	; Power-up X or Y velocity upon emerging from the bounce block
Bouncer_PUpVel:	.byte $00, -$40, -$40, -$30, -$20, -$10, $00, $10, $20, $30, $40


ObjNorm_BounceDU:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_A56F	 ; If the block bump position > 0, jump to PRG001_A56F

	; Block bump complete
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	; Set state to dead/empty
	LDA Objects_Data4,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Var1 >> 4 -> 'Y'

	LDA Objects_Data5,X

PRG001_A527:
	STA <Temp_Var12  ; -> Temp_Var12

	; Temp_Var15 = bumper X Hi
	LDA <Objects_XHiZ,X
	STA <Temp_Var15	 

	; Temp_Var16 = bumper X
	LDA <Objects_XZ,X
	STA <Temp_Var16	 

	; Temp_Var13 = bumper Y Hi
	LDA <Objects_YHiZ,X
	STA <Temp_Var13

	; Temp_Var14 = bumper Y, grid aligned
	LDA <Objects_YZ,X
	AND #$f0	
	STA <Temp_Var14	

	JSR BlockBump_Init

	LDA Objects_Data3,X
	BNE PRG001_A56E	 ; If Var 2 <> 0, jump to PRG001_A56E (RTS)

	LDA #-$38
	STA <Player_YVel	 ; Set Player bounce
	STA Player_mGoomba	 

	LDA Objects_Timer2,X
	BEQ PRG001_A56E	 ; If timer 2 expired, jump to PRG001_A56E (RTS)

	LDA #-$70
	STA <Player_YVel	; Larger Player bounce

	LDA Objects_Data4,X
	AND #$f0
	CMP #$10
	BNE PRG001_A56E	 ; If var 1 upper 4 bits <> $10, jump to PRG001_A56E (RTS)

	LDA Player_InWater
	BNE PRG001_A56E	 ; If Player is in water, jump to PRG001_A56E (RTS)

	; Flag to go to coin heaven
	LDA #$80
	STA Level_CoinHeav

	; Bounce into coin heaven sound
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

PRG001_A56E:
	RTS		 ; Return


PRG001_A56F:
	LDA Level_BlkBump_Pos-6,X
	CMP #10
	BNE PRG001_A5D5	 ; If Block bump position <> 10, jump to PRG001_A5D5

	; Block bump position is 10...

	LDA Objects_Data4,X
	AND #$0f
	TAY		 ; Y = 0 to 15, based on var 1

	LDA Bouncer_PUp,Y
	BEQ PRG001_A5BB	 ; If value is zero (no power up), jump to PRG001_A5BB

	LDY #$05	 ; Y = 5 (power-up always in slot 5)
	STA Objects_ID,Y

	; Set X
	LDA <Objects_XZ,X
	STA Objects_XZ,Y
	LDA <Objects_XHiZ,X
	STA Objects_XHiZ,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set Y Hi
	LDA <Objects_YHiZ,X
	STA <Temp_Var1

	LDA #$08	 ; A = 8

	STY <Temp_Var2		 ; Backup 'Y' -> Temp_Var2

	LDY Objects_Data5,X
	BEQ PRG001_A5AA	 ; If var2 = 0, jump to PRG001_A5AA

	DEC <Temp_Var1	 ; Temp_Var1-- (Y Hi)
	LDA #-1		 ; A = -1

PRG001_A5AA:
	LDY <Temp_Var2	 ; Restore 'Y'

	ADD <Objects_YZ,X ; Apply Y offset
	STA Objects_YZ,Y	 ; -> Object's Y
 
	BCC PRG001_A5B6	 ; If no carry, jump to PRG001_A5B6

	INC <Temp_Var1	 ; Apply carry

PRG001_A5B6:
	; Set Y Hi
	LDA <Temp_Var1
	STA Objects_YHiZ,Y

PRG001_A5BB:
	; Backup Y Hi -> Temp_Var13 
	LDA <Objects_YHiZ,X
	STA <Temp_Var13

	; Backup Y -> Temp_Var14
	LDA <Objects_YZ,X
	STA <Temp_Var14

	; Backup X Hi -> Temp_Var15
	LDA <Objects_XHiZ,X
	STA <Temp_Var15

	; Backup X -> Temp_Var16
	LDA <Objects_XZ,X
	STA <Temp_Var16

	LDA Objects_Data5,X
	BEQ PRG001_A5D5	 ; If Var2 = 0, jump to PRG001_A5D5



PRG001_A5D5:
	JSR Object_ApplyYVel	 ; Apply Y velocity
	JSR BounceBlock_Update

	LDY Level_BlkBump_Pos-6,X	; Y = block bump pos

	LDA Bouncer_PUpVel,Y

	LDY Objects_Data3,X	 ; Y = var2
	BEQ PRG001_A5EE	 ; If Var2 = 0, jump to PRG001_A5EE

	JSR Negate	 ; Negate retrieved Y Velocity

	STA <Objects_YVelZ,X	; Set Y Velocity 

	JMP PRG001_A5FD	 ; Jump to PRG001_A5FD

PRG001_A5EE:
	STA <Objects_YVelZ,X	 ; Set Y Velocity 
	STA <Player_YVel	 ; ... of Player too

	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG001_A5FD	 ; If Player is not pressing A, jump to PRG001_A5FD

	; Otherwise, Timer 2 = 11
	LDA #$0b
	STA Objects_Timer2,X

PRG001_A5FD:
	DEC Level_BlkBump_Pos-6,X	; Block bump pos--
	RTS		 ; Return

	; The following block bounces are referenced by PRG008's LATR_BlockResult
	; Type 7 is for the UNUSED breakable pipeworks tile!

	; Palette select for a bounce block
BounceBlock_Pal:
	.byte SPR_PAL1	; 0 (possibly unused / Note Block)
	.byte SPR_PAL2	; 1 (coin heaven Note Block)
	.byte SPR_PAL3	; 2 ("Metal plate" post-? block hit)
	.byte SPR_PAL3	; 3 (used for empty brick)
	.byte SPR_PAL3	; 4 (typical Note Block)
	.byte SPR_PAL3	; 5 (wood)
	.byte SPR_PAL3	; 6 (used for brick with coins)
	.byte SPR_PAL1	; 7 (UNUSED, would be for desert's breakable pipeworks tile!)

	; Offset into Sprite_RAM based on which block bounce slot
BounceBlock_SprOff:
	.byte $08, $10

	; Tile for block bounce sprite (if same, mirrors)
BounceBlock_Tile:
	.byte $79, $79	; 0 (possibly unused / Note Block)
	.byte $79, $79	; 1 (coin heaven Note Block)
	.byte $6B, $6B	; 2 ("Metal plate" post-? block hit)
	.byte $67, $67	; 3 (used for empty brick)
	.byte $77, $77	; 4 (typical Note Block)
	.byte $7F, $7F	; 5 (wood)
	.byte $67, $69	; 6 (used for brick with coins)

BounceBlock_Update:
	LDA Objects_Data4,X	; Player_Bounce
	LSR A
	LSR A
	LSR A
	LSR A		; Get kind of block that is getting bounced
	TAY		; -> Y

	; Temp_Var1 stores palette of object
	LDA BounceBlock_Pal,Y	
	STA <Temp_Var1

	; Y *= 2
	TYA
	ASL A
	TAY

	; Temp_Var2/3 store the tiles that make up the sprites of the bounce block
	LDA BounceBlock_Tile,Y
	STA <Temp_Var2		
	LDA BounceBlock_Tile+1,Y
	STA <Temp_Var3		

	LDA #$00	 ; A = 0 (do not flip second sprite)

	LDY <Temp_Var2
	CPY <Temp_Var3
	BNE PRG001_A63F	 ; If tiles are NOT the same, jump to PRG001_A63F

	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (flip second sprite)

PRG001_A63F:
	STA <Temp_Var4	 ; Store the selected sprite attribute

	; Select own range of sprite area
	LDA #$05
	ADD Counter_7to0
	TAY		 ; Y = 5 + (0 to 7)

	LDA SprRamOffsets,Y
	PHA		 ; Save this value

	; Block bouncers always appear in object slot 6 or 7, so this makes it relative to 0 or 1
	TXA		 
	SUB #$06	 
	TAY		 ; Y = 0 or 1
 
	PLA		 ; Restore the value

	ADD BounceBlock_SprOff,Y
	TAY		 ; Y is now offset into Sprite_RAM

	; Screen-relative X position for sprite position
	LDA <Objects_XZ,X
	SUB Horz_Scroll	
	STA <Objects_SpriteX,X

	; Store two pieces of bounce block sprite X
	STA Sprite_RAM+3,Y
	ADD #$08	 
	STA Sprite_RAM+7,Y

	; Screen-relative Y position for sprite position
	LDA <Objects_YZ,X
	SUB Level_VertScroll
	SUB #$01
	STA <Objects_SpriteY,X

	; Store two pieces of bounce block sprite Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Build the other parts of sprites
	LDA <Temp_Var2
	STA Sprite_RAM+1,Y

	LDA <Temp_Var3
	STA Sprite_RAM+5,Y

	LDA <Temp_Var1
	STA Sprite_RAM+2,Y

	ORA <Temp_Var4
	STA Sprite_RAM+6,Y

	RTS		 ; Return

ObjInit_BubbleGenerator:
	LDA #$01
	STA <Objects_Data1, X

ObjInit_Bubble:
	LDA #$01
	STA ObjSplash_DisTimer, X
	LDA #$03
	STA Objects_Data4, X
	LDA Objects_Property, X
	BEQ ObjInit_BubbleRTS

	LDA #$1A
	STA PatTable_BankSel + 4
	LDA #$00
	STA Objects_Data4, X
	LDA #$08
	STA Objects_SlowTimer, X

ObjInit_BubbleRTS:
	LDA <Objects_YZ, X
	STA Objects_Data5, X
	LDA <Objects_YHiZ, X
	STA Objects_Data3, X
	RTS		 ; Return


ObjNorm_Bubble:
	JSR Object_DeleteOffScreen

	LDA Objects_SlowTimer, X
	BNE BubbleRTS

	LDA Objects_Data4, X
	CMP #$03
	BEQ BubbleNorm
	BCS BubblePop

	LDA <Player_HaltGameZ
	BNE BubbleDraw
	
	LDA <Counter_1
	AND #$07
	BNE ObjNorm_Bubble1
	INC Objects_Data4, X

ObjNorm_Bubble1:
	LDA Objects_Data4, X
	STA Objects_Frame, X
	JMP Object_ShakeAndDrawMirrored

BubbleNorm:
	JSR Object_DetectTiles
	LDA  <Objects_CollisionDetectionZ, X
	AND #HIT_CEILING
	BNE BubbleNorm2
	LDA Objects_YVelZ, X
	CMP #$F8
	BEQ BubbleNorm1

	DEC Objects_YVelZ, X

BubbleNorm1:
	JSR Object_ApplyYVel

BubbleNorm2:
	LDA #$03
	STA Objects_Frame, X
	JSR Object_InteractWithPlayer

BubbleDraw:
	JSR Object_ShakeAndDrawMirrored
	LDY Object_SpriteRAM_Offset,X
	LDA Sprite_RAM +6, Y
	ORA #SPR_VFLIP
	STA Sprite_RAM +6, Y

BubbleRTS:
	RTS		 ; Return

BubblePop:
	LDA Objects_Data4, X
	STA Objects_Frame, X
	CMP #$05
	BEQ BubblePopped
	LDA <Counter_1
	AND #$07
	BEQ BubblePopRTS
	INC Objects_Data4, X
	LDA #$40
	STA Air_Time

BubblePopRTS:
	BNE  BubbleDraw
	RTS

BubblePopped:
	LDA <Objects_Data1, X
	BEQ DestroyBubble
	LDA Objects_Data5, X
	STA Objects_YZ, X
	LDA Objects_Data3, X
	STA Objects_YHiZ, X
	LDA #$00
	STA Objects_Data4, X
	LDA #$40
	STA Objects_SlowTimer, X
	RTS

DestroyBubble:
	JMP Object_SetDeadAndNotSpawned

POWERUP_MUSHROOM	= 0
POWERUP_FIREFLOWER	= 1
POWERUP_SUPERLEAF	= 2
POWERUP_FROGSUIT	= 3
POWERUP_SHELL		= 4
POWERUP_HAMMERSUIT	= 5
POWERUP_ICEFLOWER	= 6
POWERUP_FOXLEAF		= 7
POWERUP_NINJASHROOM = 8
POWERUP_STAR		= 9
POWERUP_VINE		= 10

PowerUp_Palette:
	.byte SPR_PAL1, SPR_PAL2, SPR_PAL1, SPR_PAL2, SPR_PAL2, SPR_PAL3, SPR_PAL2, SPR_PAL3, SPR_PAL1, SPR_PAL1, SPR_PAL2

PowerUp_YVelocities:
	.byte $FF, $FF, $FF, $01, $01, $01, $01, $01, $01, $01, $F0

PowerUp_AnimOff:
	.byte $00, $04, $08, $0C, $10, $14, $18, $24, $20, $28, $2C


ObjInit_PUp1:
	LDA #OBJ_POWERUP
	STA Objects_ID, X

	LDA Objects_Property, X
	STA PowerUp_Type, X
	JMP ObjInit_PowerUp

ObjInit_PUp2:
	LDA Objects_Property, X
	ADD #$07
	STA PowerUp_Type, X
	JMP ObjInit_PowerUp

ObjInit_PowerUp:
	CPX #$05
	BEQ ObjInit_PowerUp1

	STX TempX

	LDX #$05
	JSR Level_PrepareNewObject
	
	LDX TempX

	LDA #OBJ_POWERUP
	STA Objects_ID + 5

	LDA PowerUp_Type, X
	STA PowerUp_Type + 5
	
	LDA <Objects_XZ, X
	STA <Objects_XZ + 5

	LDA <Objects_XHiZ, X
	STA <Objects_XHiZ + 5

	LDA <Objects_YZ, X
	STA <Objects_YZ + 5

	LDA <Objects_YHiZ, X
	STA <Objects_YHiZ + 5

	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State, X

	LDA #OBJSTATE_INIT
	STA Objects_State + 5
	RTS

ObjInit_PowerUp1:
	LDY PowerUp_Type, X

	LDA PowerUp_Palette, Y
	STA Objects_SpriteAttributes, X

	LDA PowerUp_YVelocities, Y
	STA <Objects_YVelZ, X

	LDA PowerUp_AnimOff, Y
	STA SprAnimOffset

	JSR Object_MoveTowardsPlayer
	LDA <Objects_XVelZ, X
	EOR #$FF
	ADD #$01
	STA <Objects_XVelZ, X

	RTS

PowerUp_Type = Objects_Data1

ObjNorm_PowerUp:
	LDA <Player_HaltGameZ, X
	BNE ObjNorm_PowerUp0

	LDA Objects_Timer, X
	BEQ ObjNorm_PowerUp1

	JSR Object_ApplyYVel_NoGravity
	JSR PUp_DrawMaskSprite
	JSR Object_ShakeAndDraw

ObjNorm_PowerUp0:
	RTS

ObjNorm_PowerUp1:

	LDA PowerUp_Type, X
	JSR DynJump

	.word PUp_Mushroom
	.word PUp_Flower
	.word PUp_Leaf
	.word PUp_Bouncer
	.word PUp_Mushroom
	.word PUp_Bouncer
	.word PUp_Flower
	.word PUp_Leaf
	.word PUp_Mushroom
	.word PUp_Bouncer
	.word PUp_Vine


PUp_DrawMaskSprite:
	LDA Objects_SpritesHorizontallyOffScreen,X
	ORA Objects_SpritesVerticallyOffScreen,X
	BNE PUp_DrawMaskSprite1	 ; If any sprite is off-screen, jump to PRG001_A937 (no masking sprite)

	LDA Object_SpriteRAM_Offset, X
	ADD #$08
	TAY

	LDA <Objects_YZ,X
	AND #$f0	 	; Align object Y to tile
	ADD #$0f	 	; +15
	SUB Level_VertScroll	; Calc relative to vertical scroll

	; Set for both sprite halves Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Masking tile
	LDA #$67
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+5,Y

	; Set sprite priority
	LDA #%00100000
	STA Sprite_RAM+2,Y
	STA Sprite_RAM+6,Y

	; Set sprite X's side by side
	LDA Objects_SpriteX,X
	STA Sprite_RAM+3,Y
	ADD #$08
	STA Sprite_RAM+7,Y

PUp_DrawMaskSprite1:
	RTS

PUp_Compare:
	.byte $01, $02, $03, $04, $05, $06, $07, $08, $0B, $FF

PUp_Queue:
	.byte $02, $03, $04, $05, $06, $07, $08, $09, $0C, $00

PUp_Collect:
	LDA #OBJSTATE_DEADEMPTY
	LDX <CurrentObjectIndexZ
	STA Objects_State, X

	LDA PowerUp_Type, X
	CMP #$01
	BNE PUp_Collect2

	LDA Effective_Suit, X
	CMP #$01
	BCS PUp_Collect1

PUp_Collect1:
	
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	RTS

PUp_Collect2:
	TAY
	LDA Effective_Suit
	CMP PUp_Compare, Y
	BEQ PUp_Collect1

PUp_Collect3:
	LDA PUp_Queue, Y
	STA Player_QueueSuit

	LDA PowerUp_Type, X

	JSR DynJump

	.word PUp_Grow
	.word PUp_Rainbow
	.word PUp_Poof
	.word PUp_Poof
	.word PUp_Poof
	.word PUp_Poof
	.word PUp_Rainbow
	.word PUp_Poof
	.word PUp_Poof
	.word PUp_Star

PUp_Grow:
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1

	LDA #$2f
	STA Player_Grow
	RTS

PUp_Rainbow:
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1

	LDA #$1f
	STA Player_StarOff
	RTS

PUp_Poof:
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	LDA #$17
	STA Player_SuitLost
	RTS

PUp_Mushroom:

	;JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_InteractWithPlayer
	BCS PUp_Mushroom2

	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

PUp_Mushroom2:
	JMP Object_ShakeAndDraw

PUp_Flower:
	LDA #$00
	STA <Objects_XVelZ, X
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_InteractWithPlayer
	BCS PUp_Flower2

	JSR Object_DetectTiles
	JSR Object_InteractWithTiles

PUp_Flower2:
	JMP Object_ShakeAndDraw

PUp_Bouncer:
	JSR Object_Move
	JSR Object_CalcBoundBox
	JSR Object_InteractWithPlayer
	BCS PUp_Bouncer1

	JSR Object_DetectTiles
	JSR Object_InteractWithTiles
	LDA <Objects_CollisionDetectionZ,X
	AND #HITTEST_BOTTOM
	BEQ PUp_Bouncer1

	LDA #$C0
	STA <Objects_YVelZ, X

PUp_Bouncer1:
	JMP Object_ShakeAndDraw
	; Values used by the leaf based on bounce direction

Leaf_XVelByOsc:	.byte $02, -$02
Leaf_XVelLimit:	.byte $20, -$20

PRG001_ABD1:
	.byte $0A, -$0A, $08

Leaf_OscData = Objects_Data5

PUp_Leaf:
	JSR Object_CalcBoundBox
	JSR Object_InteractWithPlayer
	BCS PRG001_AC22

	LDA Leaf_OscData,X
	AND #$01
	TAY		 ; Y = 0 or 1 (which oscillation direction)

	; Add appropriate X velocity for oscillation direction
	LDA <Objects_XVelZ,X
	ADD Leaf_XVelByOsc,Y
	STA <Objects_XVelZ,X

	CMP Leaf_XVelLimit,Y
	BNE PRG001_AC02	 ; If leaf has not hit X Vel limit, jump to PRG001_AC02

	INC Leaf_OscData,X	 ; Switch oscillation direction

PRG001_AC02:
	LDA <Objects_XVelZ,X
	BPL PRG001_AC07	 ; If leaf is moving to the right, jump to PRG001_AC07

	INY		 ; Otherwise, Y++ (makes Y = 2)

PRG001_AC07:
	LDA PRG001_ABD1,Y
	ADD #$06	 	; Value +6
	STA <Objects_YVelZ,X	; -> Y Velocity

	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoGravity	 ; Apply Y Velocity

PRG001_AC15:
	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (horizontal flip)

	LDY <Objects_XVelZ,X
	BEQ PRG001_AC22	 ; If leaf X Vel = 0, jump to PRG001_AC22 (don't change flip at midpoint)
	BPL PRG001_AC1F	 ; If leaf X Vel > 0, jump to PRG001_AC1F

	LDA #$00	 ; A = 0 (not horizontally flipped)

PRG001_AC1F:
	STA Objects_Orientation,X	 ; Set flip

PRG001_AC22:
	JMP Object_ShakeAndDraw	; Draw object and "shake awake" 

PUp_Star:
	LDA Level_PSwitchCnt
	BNE PRG001_A810	 ; If P-Switch is active, jump to PRG001_A810

	; Otherwise, play invincibility theme!
	LDA Sound_QMusic2
	ORA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2

PRG001_A810:

	; Player_StarInv = $E0
	LDA #$e0
	STA Player_StarInv
	RTS

PUp_Vine:
	JSR Object_ApplyYVel_NoGravity

	LDA <Objects_YZ, X
	AND #$0F
	BNE PUp_VineDraw

	LDA Block_NeedsUpdate
	BEQ PUp_Detect

	LDA #$00
	STA <Objects_YVelZ, X
	BEQ PUp_VineDraw

PUp_Detect:
	STA Debug_Snap
	JSR Object_DetectTileOn
	LDA Object_TileProp
	CMP #TILE_PROP_SOLID_ALL
	BCC PUp_VineBlock

	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State, X
	RTS

PUp_VineBlock:
	LDA Object_LevelTile
	EOR #$01
	JSR Object_ChangeBlock
	LDA #$F0
	STA <Objects_YVelZ, X

PUp_VineDraw:
	JMP Object_ShakeAndDraw	; Draw object and "shake awake" 
	

	; Basically this bumps the object up by 1 pixel...
ObjInit_Coin:
	LDA #$00
	STA PowerUp_NoRaise
 	RTS		 ; Return

ObjInit_WarpHide:
	LDA Map_Got13Warp
	BEQ PRG001_AD37	 ; If Player didn't already get the 1-3 warp whistle, jump to PRG001_AD37

	; Otherwise, kill it!
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

PRG001_AD37:
	RTS		 ; Return


ObjNorm_Coin:
	LDA <Player_HaltGameZ
	BNE DrawCoin

	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_DetectTiles
	JSR Object_InteractWithPlayer

	LDA <Objects_CollisionDetectionZ,X
	AND #$04
	BEQ DrawCoin
	JSR Object_HitGround

DrawCoin:
	LDA Objects_SpritesHorizontallyOffScreen, X
	ORA Objects_SpritesVerticallyOffScreen, X
	BNE Coin_RTS

	JSR Object_ShakeAndCalcSprite
	LDX <CurrentObjectIndexZ
	LDY Object_SpriteRAM_Offset, X
	LDA #$49
	STA Sprite_RAM + 1, Y
	LDA #SPR_PAL3
	STA Sprite_RAM + 2, Y
	LDA <Objects_SpriteY, X
	STA Sprite_RAM, Y
	LDA <Objects_SpriteX, X
	STA Sprite_RAM + 3, Y
	
Coin_RTS:
	RTS

ObjHit_Coin:
	INC Coins_Earned
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State, X
	RTS

ObjHit_IceFlower:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$07 
	BNE Do_Ice_Power
	JMP PUp_GeneralCollect

Do_Ice_Power:

	LDA #$08
	JMP Do_PUp_Pallete_Collect

ObjHit_Pumpkin:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$0A
	BNE Do_Boo_Power
	JMP PUp_GeneralCollect

Do_Boo_Power:
	LDA #$0B
	JMP Do_PUp_Poof_Collect

ObjHit_FoxLeaf:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$08
	BNE Do_Fox_Power
	JMP PUp_GeneralCollect

Do_Fox_Power:
	LDA #$09
	JMP Do_PUp_Poof_Collect

	; This is a fairly general "march" function, but it is only 
	; applied to one object here, the unused collectable card...

PRG001_ADE2:
	RTS

	; Aligns object that impacts the ground onto the floor
Object_HitGroundAlign:
	LDA <Objects_CollisionDetectionZ,X 
	AND #$04
	BEQ PRG001_ADE2	 ; If object did not hit ground, jump to PRG001_ADE2 (RTS)
 
	JMP Object_HitGround	 ; Otherwise, jump to Object_HitGround

Koopaling_Palettes:

ObjInit_Koopaling:

ObjHit_Koopaling:

ObjInit_Bowser:

	; Bowser takes 34 fireball hits!
	LDA #$01
	STA Objects_HitCount,X

	RTS		 ; Return


	; X Velocity applied to Player when bouncing off Bowser's head
Bowser_HeadBounceXVel:	.byte $10, -$10

ObjNorm_Bowser:

	; Set Bowser's pattern table selections
	LDA #$3a
	STA PatTable_BankSel+4
	LDA #$3b
	STA PatTable_BankSel+5

	LDA <Player_HaltGameZ
	BNE PRG001_B8D3	 ; If gameplay is halted, jump to PRG001_B8D3

	LDA Bowser_Counter1
	BEQ PRG001_B8A1	 ; If Bowser_Counter1 = 0, jump to PRG001_B8A1

	DEC Bowser_Counter1	 ; Bowser_Counter1--

PRG001_B8A1:
	LDA Bowser_Counter2
	AND #%00011111	 
	BEQ PRG001_B8AB	 ; Every 32 ticks of Bowser's second counter, jump to PRG001_B8AB

	DEC Bowser_Counter2	 ; Bowser_Counter2--

PRG001_B8AB:
	JSR Bowser_DoVar5Action	; Do Bowser's internal state action
	JSR Bowser_HopAndBreatheFire	; Bowser hops and breathes fireballs
	JSR Object_AttackOrDefeat	 	; Do hit detection

	LDA Objects_PlayerHitStat,X
	BEQ PRG001_B8D3		; If Player hasn't hit Bowser, jump to PRG001_B8D3

	; Player hit Bowser...

	; Set timer 2 to 8
	LDA #$08
	STA Objects_Timer2,X

	LDA <Player_YVel
	BMI PRG001_B8D3	 ; If Player is moving upward, jump to PRG001_B8D3

	; Player bounces off Bowser's head!
	LDA #-$30
	STA <Player_YVel

	JSR Bowser_CalcPlayersSide	 ; Calculate the side of his head Player bounced off of

	; Apply an X Velocity when bouncing off Bowser's head
	LDA Bowser_HeadBounceXVel,Y
	STA <Player_XVel

	; Bounce sound
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

PRG001_B8D3:
	LDA <Objects_Data2,X
	BEQ PRG001_B8E0	 ; If the internal state = 0 (waiting to meet Player), jump to PRG001_B8E0

	JSR Bowser_Draw	 ; Draw Bowser!

	LDA <Objects_Data2,X	
	CMP #$01	 
	BEQ PRG001_B8E5	 ; If internal state = 1, jump to PRG001_B8E5 (RTS)

PRG001_B8E0:

	; Otherwise, mark Bowser as totally invisible horizontally (??)
	LDA #$ff
	STA Objects_SpritesHorizontallyOffScreen,X

PRG001_B8E5:
	RTS		 ; Return

Bowser_DoVar5Action:
	LDA <Objects_Data2,X
	JSR DynJump	 ; Jump dynamically by Objects_Data2

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_WaitForPlayer	; Internal state 0: Bowser waiting for Mario/Luigi to show up...
	.word Bowser_DoMovements	; Internal state 1: Bowser movements (jumping, busting floor, etc.)
	.word Bowser_FallAndSplat	; Internal state 2: Bowser fall (until he hits bottom, ba-bam! Only if dead, though)
	.word Bowser_WaitAndVictory	; Internal state 3: Wait until timer expires, then play victory song
	.word Bowser_DoTimeBonus	; Internal state 4: Convert remaining time to score
	.word Bowser_DoorAppear		; Internal state 5: Final door appears

Bowser_WaitForPlayer:
	LDA Objects_SpritesHorizontallyOffScreen,X
	BNE PRG001_B928	 ; If any of Bowser's sprites are horizontally off-screen, jump to PRG001_B928 (RTS)

	LDA <Horz_Scroll
	CMP #$07
	BGE PRG001_B928	 ; If Horz_Scroll >= 7, jump to PRG001_B928 (RTS)

	; Player got close enough; lock horizontal scroll and stop Player from moving
	LDA #$00
	STA <Horz_Scroll
	STA <Player_XVel

	; Player must land first
	LDA <Player_InAir
	BNE PRG001_B928	 ; If Player is midair, jump to PRG001_B928 (RTS)

	; Vert_Scroll = $EF (lowest scroll point)
	LDA #$ef
	STA <Vert_Scroll

	; Play Bowser's Theme
	LDA #MUS2B_BOWSER
	STA Sound_QMusic2

	INC LevelVertJct	 ; LevelVertJct = 1 (set like in a Big Question block area, i.e. no horizontal scrolling)

	; Lock vertical scroll
	LDA #$02
	STA Level_FreeVertScroll

	; Var4 = 3
	LDA #$03
	STA <Objects_Data1,X

	; Timer 3 = $30
	LDA #$30	 
	STA Objects_Timer3,X

	; Internal state = 1
	INC <Objects_Data2,X

PRG001_B928:
	RTS		 ; Return


Bowser_DoMovements:
	JSR Bowser_HandleIfDead	 ; Handle Bowser if he got killed

	LDA GameCounter
	AND #%00011111
	ORA Bowser_Counter1
	BNE PRG001_B948	 ; If Bowser Counter 1 > 0 and except every 32nd tick, jump to PRG001_B948

	; Only when Bowser Counter 1 is expired and every 32 ticks of the no stop counter...

	LDA Objects_Orientation,X

	PHA		 ; Save Bowser's flip bits

	JSR Bowser_FacePlayer	 ; Bowser face Player

	PLA		 ; Restore Bowser's flip bits

	CMP Objects_Orientation,X
	BEQ PRG001_B948	 ; If Bowser has NOT changed facing direction, jump to PRG001_B948

	; Bowser changed facing direction

	; Set some bits on Bowser's Counter 2
	ORA #$13
	STA Bowser_Counter2

PRG001_B948:
	LDA <Objects_Data1,X
	JSR DynJump	 ; Jump dynamically by var 4

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_FallToFloor	; 0: Fall to floor
	.word Bowser_JumpAndLandOnFloor	; 1: Jump and land on floor
	.word Bowser_AlignAndFall	; 2: Align to tile on the way down (will also use part of Bowser_JumpAndLandOnFloor)
	.word Bowser_BustFloorLookAround; 3: Bowser busts floor and looks around

PRG001_B955:	.byte $08, $05, $04, $05, $08
PRG001_B95A:	.byte $40, $40, $00, $00, $00


Bowser_FallToFloor:
	JSR Bowser_Counter3Do	 ; Update Bowser_Counter3

	LDA Bowser_Counter2
	AND #$1f	 
	BEQ PRG001_B97C	 ; Every 32 ticks of Bowser_Counter2, jump to PRG001_B97C

	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, slower rate than Bowser_Counter2

	LDA Bowser_Counter2
	AND #SPR_HFLIP
	EOR PRG001_B95A,Y
	STA Objects_Orientation,X

	LDA PRG001_B955,Y

PRG001_B97C:
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BNE PRG001_B9B5	 ; If timer is not expired, jump to PRG001_B9B5

	JSR Bowser_DetectTiles	 ; Detect the tiles under Bowser

	; Bowser fall up to $40 Y Velocity...
	LDA <Objects_YVelZ,X
	CMP #$40	 
	BGS PRG001_B98F	 ; If Bowser's Y Velocity >= $40, jump to PRG001_B98F

	INC <Objects_YVelZ,X	 ; Bowser's gravity

PRG001_B98F:
	LDA <Objects_CollisionDetectionZ,X
	AND #$04
	BEQ PRG001_B9A4	 ; If Bowser has NOT hit floor, jump to PRG001_B9A4 (RTS)

	JSR Object_HitGround	 ; Align to floor

	LDA #$10	; A = $10

	LDY Objects_Timer3,X
	BNE PRG001_B9A1	 ; If Timer 3 is not expired, jump to PRG001_B9A1

	LDA #$b0	 ; A = $B0

PRG001_B9A1:
	; Set Timer as appropriate
	STA Objects_Timer,X

PRG001_B9A4:
	RTS		 ; Return

	; Base X velocities by Player's distance away from Bowser when he attempts to jump and land on you
Bowser_XVelByDist:
	.byte $08, $10, $18, $20, $28, $30, $38, $40, $48, $50, $50, $50, $50, $50, $50, $50

PRG001_B9B5:
	LDA Bowser_Counter2 
	AND #$1f 
	BNE PRG001_B9BF	 ; Only continue 1:32 ticks, otherwise jump to PRG001_B9BF
 
	INC Objects_Frame,X	 ; Bowser's frame++

PRG001_B9BF:
	LDA Objects_Timer,X 
	CMP #$01 
	BEQ PRG001_B9F3	 ; If timer expired, jump to PRG001_B9F3

	CMP #$80 
	BNE PRG001_B9F2	 ; If timer <> $80, jump to PRG001_B9F2 (RTS) 

	; Jump and land on floor mode
	LDA #$01 
	STA <Objects_Data1,X
 
	; Bowser jump!
	LDA #-$60 
	STA <Objects_YVelZ,X
 
	JSR Bowser_CalcPlayersSide 
	STY <Temp_Var1		 ; Temp_Var1 = 0 or 1, depending on side Player is on
 
	; Get absolute value of X difference
	LDA <Temp_Var16 
	BPL PRG001_B9DE 
	JSR Negate 
PRG001_B9DE:

	LSR A 
	LSR A 
	LSR A 
	LSR A 
	AND #$0f 
	TAY		 ; Y = 0 to 15, number of tiles away Player is
 
 
	; Calculate Bowser's X velocity to target Player!
	LDA Bowser_XVelByDist,Y
	LDY <Temp_Var1 
	DEY	
	BNE PRG001_B9F0 
	JSR Negate
PRG001_B9F0: 
	STA <Objects_XVelZ,X 

PRG001_B9F2:
	RTS		 ; Return

PRG001_B9F3:
	; Little hop
	LDA #-$10 
	STA <Objects_YVelZ,X
 
	RTS		 ; Return

	; Used as a bit 7 invert to determine if Bowser is moving 
	; away from or towards the Player
Bowser_VsPlayerXVelNegBit:
	.byte $00, $80


Bowser_JumpAndLandOnFloor:
	LDA <Objects_YVelZ,X	 
	BPL PRG001_BA01	 ; If Bowser is on floor or falling, jump to PRG001_BA01

	JSR Bowser_Counter3Do	 ; Update Bowser's Counter 3

PRG001_BA01:

	; Bowser frame 0
	LDA #$00
	STA Objects_Frame,X

	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser's feet

	LDA <Objects_YVelZ,X
	BMI PRG001_BA11	 ; If Bowser is moving upward (jumping), jump to PRG001_BA11

	CMP #$50	 
	BGE PRG001_BA17	 ; If Bowser Y velocity >= $50, jump to PRG001_BA17

PRG001_BA11:

	; Bowser fall rate Y Vel += 3
	INC <Objects_YVelZ,X
	INC <Objects_YVelZ,X
	INC <Objects_YVelZ,X

PRG001_BA17:

	LDA <Objects_YVelZ,X
	BPL PRG001_BA1F	 ; If Bowser is not moving upward, jump to PRG001_BA1F

	CMP #-$20
	BLT PRG001_BA4B	 ; If Bowser is moving upward faster than -$20, jump to PRG001_BA4B

PRG001_BA1F:

	; Bowser not moving upward... or not moving upward fast enough

	JSR Bowser_CalcPlayersSide	 ; Figure out which side Player is on

	LDA Bowser_VsPlayerXVelNegBit,Y
	EOR <Objects_XVelZ,X
	BPL PRG001_BA4B	 ; If Bowser's velocity is moving away from Player, jump to PRG001_BA4B

	JSR Object_QuickYDistanceFromPlayer	 

	DEY		 ; Y--
	BEQ PRG001_BA4B	 ; If Y was 1, jump to PRG001_BA4B

	; Var4 = 2
	LDA #$02
	STA <Objects_Data1,X

	; Timer = $0A
	LDA #$0a
	STA Objects_Timer,X

	; Calculate an X position that targets Player and aligned to tile
	LDA <Objects_XZ,X
	ADD #$08
	AND #$f0
	STA Objects_TargetingXVal,X

	; Bowser jump!
	LDA #-$20
	STA <Objects_YVelZ,X

	; Stop Bowser's horizontal movement
	LDA #$00
	STA <Objects_XVelZ,X

	RTS		 ; Return

PRG001_BA4B:
	LDA <Objects_CollisionDetectionZ,X
	AND #$04
	BEQ PRG001_BA76	 ; If Bowser has NOT hit floor, jump to PRG001_BA76

	; Bowser has hit floor...

	JSR Object_HitGround	 ; Align to floor ('A' = 0 at the end of this, hence the following assignment)

	STA <Objects_XVelZ,X	 ; Stop Bowser's horizontal movement

	; Vibrate floor from impact
	LDA #$2c
	STA Level_Vibration

	; Ba-bam sound!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Object timer = $35
	LDA #$35
	STA Objects_Timer,X

	LDA RandomN,X
	AND #$1f	
	ADC #$67	
	STA Objects_Timer3,X	 ; Timer 3 = Random $67 to $86
	STA Objects_Data3,X	 ; -> Var7

	; Var4 = 3
	LDA #$03
	STA <Objects_Data1,X

PRG001_BA76:
	RTS		 ; Return


Bowser_AlignAndFall:
	; Reset Bowser Counter 1
	LDA #$00
	STA Bowser_Counter1

	; Set Bowser to frame 6 (Bowser's falling frame)
	LDA #$06
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ PRG001_BA96	; If timer expired, jump to PRG001_BA96

	LDA <Objects_XZ,X
	CMP Objects_TargetingXVal,X
	BEQ PRG001_BA95	; If Bowser reached the alignment X, jump to PRG001_BA95

	; Bowser moves towards the tile alignment
	INC <Objects_XZ,X
	BCC PRG001_BA95	; If carry clear, jump to PRG001_BA95

	; Don't let Bowser's X wrap around!
	DEC <Objects_XZ,X
	DEC <Objects_XZ,X

PRG001_BA95:
	RTS		 ; Return

PRG001_BA96:
	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser

	LDA <Objects_YVelZ,X
	BMI PRG001_BAA1	 ; If Bowser is moving upward, jump to PRG001_BAA1

	CMP #$70
	BGE PRG001_BAA6	 ; If Bowser's Y Velocity >= $70, jump to PRG001_BAA6 (RTS)

PRG001_BAA1:

	; Bowser's rapid stomp fall!
	ADD #$06
	STA <Objects_YVelZ,X

PRG001_BAA6:
	JMP PRG001_BA4B	 ; Jump to PRG001_BA4B 


Bowser_BustFloorLookAround:
	JSR Bowser_DetectTiles	  ; Detect tiles under Bowser's feet

	LDA <Objects_YVelZ,X
	CMP #$40
	BGS PRG001_BAB6	 ; If Bowser's Y Velocity >= $40, jump to PRG001_BAB6

	INC <Objects_YVelZ,X
	INC <Objects_YVelZ,X

PRG001_BAB6:
	JSR Bowser_BustFloor	 ; Bust any bricks Bowser has hit

	LDA <Objects_CollisionDetectionZ,X
	AND #$04
	BEQ PRG001_BAC2	 ; If Bowser has not hit floor, jump to PRG001_BAC2

	JSR Object_HitGround	 ; Align to floor

PRG001_BAC2;
	LDA Objects_Timer,X
	BEQ PRG001_BACD		; If timer expired, jump to PRG001_BACD

	; Bowser slam frame
	LDA #$07
	STA Objects_Frame,X

	RTS		 ; Return

PRG001_BACD:
	LDA Objects_Timer3,X
	BNE PRG001_BAF1	 ; If timer 3 is not expired, jump to PRG001_BAF1

	; Var 4 back to zero
	LDA #$00
	STA <Objects_Data1,X

	LDA RandomN,X
	AND #$7f
	ORA #$80
	STA Objects_Timer3,X	 ; Timer 3 = $7F to $FF

	RTS		 ; Return

	; Bowser look around frame
Bowser_LookAroundFrames:	.byte $04, $05, $05, $05, $04, $05, $05, $05

	; Bowser look around flip bits
Bowser_LookAroundFlipBits:	.byte $00, $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP

PRG001_BAF1:
	CMP #$20
	BLT PRG001_BB0B	 ; If timer 3 < $20, jump to PRG001_BB0B

	; When Bowser lands, he looks around a bit for a second

	LSR A
	LSR A
	ADD Objects_Data3,X	; ?? Not used in anything else Bowser does?
	AND #$07
	TAY		 ; Y = 0 to 7 

	; Set frame
	LDA Bowser_LookAroundFrames,Y
	STA Objects_Frame,X

	; Set flip bits
	LDA Bowser_LookAroundFlipBits,Y
	STA Objects_Orientation,X

	RTS		 ; Return

PRG001_BB0B:
	CMP #$0c
	LDA #$05	 ; A = 5
	BGE PRG001_BB13	 ; If timer 3 >= 5, jump to PRG001_BB13

	LDA #$08	 ; Otherwise, A = 8

PRG001_BB13:
	STA Objects_Frame,X	 ; Set Bowser frame

Bowser_FacePlayer:
	JSR Bowser_CalcPlayersSide

	; Bowser face Player!
	LDA Bowser_FlipToFace,Y
	STA Objects_Orientation,X

	RTS		 ; Return


	; Set proper flip bit for Bowser to face Player
Bowser_FlipToFace:
	.byte SPR_HFLIP, $00

Bowser_HoppingFrames:
	.byte $00, $00, $03, $02, $00, $00, $00, $00

Bowser_HopAndBreatheFire:
	LDA Bowser_Counter1
	BEQ PRG001_BB46	 ; If Bowser_Counter1 = 0, jump to PRG001_BB46 (RTS)

	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	; Bowser's little hopping animation
	LDA Bowser_HoppingFrames,Y
	STA Objects_Frame,X

	LDA Bowser_Counter1
	CMP #$10	 
	BNE PRG001_BB46	 ; If Bowser_Counter1 <> $10, jump to PRG001_BB46 (RTS)

	JSR Bowser_BreatheFire	 ; Bowser breathe's a fireball!

PRG001_BB46:
	RTS		 ; Return

	; Bowser's fireball X velocity and offset by direction
Bowser_FireballXVel:	.byte -$10, $10
Bowser_FireballXOff:	.byte -$08, $18

PRG001_BB4B:	.byte $00, $08, $10, $18, $08, $00, $00, $10
	
Bowser_BreatheFire:
	LDY #$04	; Y = 4
PRG001_BB55:
	LDA Objects_State,Y
	BEQ PRG001_BB5E	 ; If object is dead/empty, jump to PRG001_BB5E

	DEY		 ; Y--
	BPL PRG001_BB55	 ; While Y >= 0, loop

	RTS		 ; Return

PRG001_BB5E:
	TYA
	TAX		 ; X = new object's index

	JSR Level_PrepareNewObject	 ; Set up the new flame to be spawned 

	; Set object state to normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser's fireball
	LDA #$01
	STA Objects_ID,X

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Data2,X

	; Bowser fall
	LDA #$10
	STA Objects_YVelZ,Y

	LDX <CurrentObjectIndexZ	 ; Restore 'X' to Bowser's object slot index

	; Set fireball Y to Bowser's +16
	LDA <Objects_YZ,X
	ADD #16
	STA Objects_YZ,Y
	LDA <Objects_YHiZ,X
	ADC #$00
	STA Objects_YHiZ,Y

	LDA Objects_Orientation,X
	STA Objects_Orientation, Y
	ASL A
	ASL A
	ROL A
	AND #$01
	TAX	
	STX <Temp_Var1		; X = 0 or 1, depending on if Bowser's horizontally flipped

	; Set X Velocity as appropriate
	LDA Bowser_FireballXVel,X
	STA Objects_XVelZ,Y

	LDX <CurrentObjectIndexZ	 ; Restore 'X' to Bowser's object slot index

	; X Hi is just copied
	LDA <Objects_XHiZ,X
	STA Objects_XHiZ,Y

	; Set X appropriately offset from Bowser
	LDA <Objects_XZ,X
	LDX <Temp_Var1		
	ADD Bowser_FireballXOff,X
	STA Objects_XZ,Y	
	LDA #$00
	STA Objects_YVelZ, Y

	;LDA RandomN,Y
	;AND #$07	
	;TAX		 ; X = random 0 to 7
	;
	;; A bit random how the fireball moves
	;LDA PRG001_BB4B,X
	;STA Objects_TargetingYVal,Y

	; Set fireball palette
	LDA #SPR_PAL1
	STA Objects_SpriteAttributes,Y

	; Reset timer
	ASL A			; A = 0
	STA Objects_Timer,Y	

	; Fire breathing sound
	LDA #SND_LEVELFLAME
	STA Sound_QLevel2

	LDX <CurrentObjectIndexZ	; Restore 'X' to Bowser's object slot index

	RTS		 ; Return


Bowser_Counter3Do:
	; If Bowser_Counter3 > 0, just decrement it.  Otherwise,
	; set it to some value $60 to $9F and set Bowser_Counter1 to $3F

	LDA Bowser_Counter3	  
	BNE PRG001_BBDC	 ; If Bowser_Counter3 <> 0, jump to PRG001_BBDC

	LDA RandomN,X
	AND #$3f
	ADC #$60
	STA Bowser_Counter3	 ; Bowser_Counter3 = $60 + (Random $00 to $3F)

	; Bowser Counter 1 = $3F
	LDA #$3f
	STA Bowser_Counter1

	RTS		 ; Return

PRG001_BBDC:
	DEC Bowser_Counter3	; Bowser_Counter3--
	RTS		 ; Return


	; Detect the left and right tiles underneath Bowser
Bowser_DetectTiles:
	; Apply Bowser's X and Y Velocities
	JSR Object_ApplyXVel	 
	JSR Object_ApplyYVel_NoGravity

	LDY <Objects_XZ,X	 ; Y = Bowser's X

	LDA <Objects_XVelZ,X
	BEQ PRG001_BBFC	 ; If Bowser is stopped horizontally, jump to PRG001_BBFC
	BMI PRG001_BBF4	 ; If Bowser is moving to the left, jump to PRG001_BBF4

	; Bowser moving to the right...

	; Prevent Bowser from moving off the right edge
	CPY #224
	BGE PRG001_BBF8	 ; If Bowser's X >= 224, jump to PRG001_BBF8
	BLT PRG001_BBFC	 ; Otherwise, jump to PRG001_BBFC

PRG001_BBF4:

	; Bowser moving to the left...

	; Prevent Bowser from moving off the left edge
	CPY #8
	BGE PRG001_BBFC	 ; If Bowser's X >= 8, jump to PRG001_BBFC

PRG001_BBF8:

	; Bowser could move off left or right edge, so stop him!
	LDA #$00
	STA <Objects_XVelZ,X

PRG001_BBFC:
	
	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_Data1,X
	CMP #$02
	BNE PRG001_BC0B	; If var 4 <> 2, jump to PRG001_BC0B

	; Store tile detected under Bowser's left
	LDA Object_TileFeetValue
	STA Bowser_TileValues	 ; Store detected tile -> Bowser_TileValues
	LDA Object_TileFeetProp
	STA Bowser_TileProps

PRG001_BC0B:
	LDA <Objects_CollisionDetectionZ,X	; Get Bowser's detection status bits
	PHA		 	; Save them

	LDA <Objects_XZ,X	; Get Bowser's X
	PHA		 	; Save it

	; Detect the right tile under Bowser's feet
	ADD #16
	STA <Objects_XZ,X
	JSR Object_WorldDetectN1

	; Restore Bowser's X
	PLA
	STA <Objects_XZ,X

	PLA		 ; Restore Bowser's detection bits
	ORA <Objects_CollisionDetectionZ,X	 ; OR in the ones detected by the right tile check
	STA <Objects_CollisionDetectionZ,X	 ; Save the unified set (in case only one foot is actually on the floor)

	LDA <Objects_Data1,X
	CMP #$02
	BNE PRG001_BC2D	; If var 4 <> 2, jump to PRG001_BC2D

	; Store tile detected under Bowser's right
	LDA Object_TileFeetValue
	STA Bowser_TileValues+1
	LDA Object_TileFeetProp
	STA Bowser_TileProps+1

PRG001_BC2D:
	RTS		 ; Return


	; X offsets to Bowser's tile under each side of him
Bowser_TileOffsets:	.byte 8, 24


	; Busts any breakable floor that Bowser has hit
Bowser_BustFloor:
	LDY #$01	 ; Y = 1 (two tiles to potentially smash)
PRG001_BC32:

	LDA Bowser_TileProps,Y	; Get this tile
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_STONE)
	BEQ PRG001_BC33

	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_STONE)
	BNE PRG001_BC69	 	; If this tile is not the solid brick tile, jump to PRG001_BC69

PRG001_BC33:
	; Bowser hit brick!
	LDA #$00
	STA Bowser_TileProps,Y	; Clear this tile

	; Queue a block change to erase to background!
	LDA Bowser_TileValues,Y
	EOR #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate

	; Aligned Bowser impact Y
	LDA <Objects_YZ,X
	ADD #$30
	AND #$f0
	STA Block_ChangeY
	LDA <Objects_YHiZ,X
	ADC #$00
	STA Block_ChangeYHi

	; Aligned Bowser impact X
	LDA <Objects_XZ,X
	ADD Bowser_TileOffsets, Y
	AND #$f0
	STA Block_ChangeX
	LDA <Objects_XHiZ,X
	ADC #$00
	STA Block_ChangeXHi

	JMP PRG001_BC6D	 ; Jump to PRG001_BC6D

PRG001_BC69:
	DEY		; Y--
	BPL PRG001_BC32	; While Y >= 0, loop!

	RTS		 ; Return


PRG001_BC6D:
	; Smash block sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA Block_ChangeY
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA Block_ChangeX
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

	RTS		 ; Return


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
	; These are the patterns for every column of every row, by frame 
	; (12 sprites total per frame, last four values for padding?)
Bowser_SprPats:
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 0
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $97, $99, $9B, $9D, $00, $00, $00, $00 ; Bowser frame 1
	.byte $9F, $A1, $A3, $A5, $A7, $A9, $AB, $AD, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 2
	.byte $9F, $A1, $B1, $A5, $B3, $B5, $B7, $AD, $B9, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 3
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $C9, $CB, $CB, $C9, $00, $00, $00, $FF ; Bowser frame 4
	.byte $71, $CF, $D1, $71, $D3, $D5, $F7, $D9, $DB, $DD, $DF, $E1, $00, $00, $00, $00 ; Bowser frame 5
	.byte $E3, $E5, $E5, $E3, $E7, $E9, $E9, $E7, $EB, $ED, $ED, $EB, $00, $00, $00, $FF ; Bowser frame 6
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $EF, $F1, $F1, $EF, $00, $00, $00, $FF ; Bowser frame 7
	.byte $71, $CF, $D1, $71, $D3, $D5, $C1, $CD, $F9, $FB, $FD, $FF, $00, $00, $00, $00 ; Bowser frame 8

	; Sprite X offsets per sprite, horizontally flipped or not horizontally flipped
Bowser_SprXNotHFlipped:	.byte $00, $08, $10, $18, $00, $08, $10, $18, $00, $08, $10, $18
Bowser_SprXHFlipped:	.byte $18, $10, $08, $00, $18, $10, $08, $00, $18, $10, $08, $00

	; Sprite Y offsets per sprite, vertically flipped or not vertically flipped
Bowser_SprYNotVFlipped:	.byte $00, $00, $00, $00, $10, $10, $10, $10, $20, $20, $20, $20
Bowser_SprYVFlipped:	.byte $20, $20, $20, $20, $10, $10, $10, $10, $00, $00, $00, $00

	; Similar to Bowser_SprVVisLUT, marks sprite that should be
	; invisible if marked horizontally invisible
Bowser_SprHVisLUT:
	.byte $80, $40, $20, $10

	; Bowser's sprites are drawn straight through; this marks the
	; ones that should not be handled if vertically invisible
Bowser_SprVVisLUT:
	.byte $01, $01, $01, $01	; Top sprites
	.byte $02, $02, $02, $02	; Middle sprites
	.byte $04, $04, $04, $04	; Bottom sprites

	; Bowser uses fixed Sprite_RAM offsets, alternating which set he used every other tick
Bowser_SprRAMOff:
	.byte $50, $54, $58, $5C	; Top sprites
	.byte $60, $64, $68, $6C	; Middle sprites
	.byte $70, $74, $78, $7C	; Bottom sprites

	.byte $00, $00, $00, $00	; Unused, for alignment only (switches between these sets via 4 ASLs)

	.byte $DC, $D8, $D4, $D0	; Top sprites
	.byte $EC, $E8, $E4, $E0	; Middle sprites
	.byte $FC, $F8, $F4, $F0	; Bottom sprites


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
Bowser_Draw:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the Sprite X and Y Low parts	 

	; Temp_Var1 = Bowser's Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Temp_Var2 = Bowser's Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	; Temp_Var3 and Temp_Var4 = Bowser's FlipBits
	LDA Objects_Orientation,X
	STA <Temp_Var3		
	STA <Temp_Var4		

	; Temp_Var5 = Bowser's horizontal visibility flags
	LDA Objects_SpritesHorizontallyOffScreen,X
	STA <Temp_Var5	

	; Temp_Var6 = Bowser's vertical visibility flags
	LDA Objects_SpritesVerticallyOffScreen,X
	STA <Temp_Var6

	LDY Objects_Frame,X
	CPY #$01
	BEQ PRG001_BDB4		; If Bowser's frame = 1, jump to PRG001_BDB4

	CPY #$07
	BNE PRG001_BDBB	 	; If Bowser's frame <> 7, jump to PRG001_BDBB

PRG001_BDB4:

	; Frame 7 is slightly lower than the others

	LDA <Temp_Var1
	ADD #$04
	STA <Temp_Var1

PRG001_BDBB:
	CPY #$08
	BEQ PRG001_BDD2	 ; If Bowser's frame = 8, jump to PRG001_BDD2

	CPY #$04
	BEQ PRG001_BDC7	 ; If Bowser's frame = 4, jump to PRG001_BDC7

	CPY #$06	 
	BLT PRG001_BDD2	 ; If Bowser's frame < 6, jump to PRG001_BDD2

PRG001_BDC7:

	; Bowser frame 4

	LDA Objects_Orientation,X
	AND #SPR_VFLIP
	STA <Temp_Var3	 ; Temp_Var3 = $00 or SPR_VFLIP, depending whether Bowser is flipped vertically

	ORA #SPR_HFLIP
	STA <Temp_Var4	 ; Always set horizontal flip in Temp_Var4

PRG001_BDD2:
	LDA Objects_Frame,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var15	 ; Temp_Var15 = frame * 16

	LDA #$00
	STA <Temp_Var16

PRG001_BDDF:

	; This determines which Sprite_RAM offset table set we use.
	; Either 0 or 16, alternating every other frame.
	LDA <Counter_1
	AND #$01
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ADD <Temp_Var16	 ; Temp_Var16 = current sprite we're on
	TAY		 ; -> 'Y'

	LDA Bowser_SprRAMOff,Y
	TAY		 ; Index -> 'Y'

	LDX <Temp_Var16	 ; X = current sprite

	LDA <Temp_Var6	 	; Get Bowser's vertical visibility flags
	AND Bowser_SprVVisLUT,X	
	BNE PRG001_BE49	 	; If this sprite should not be drawn due to vertically being off-screen, jump to PRG001_BE49

	; Sprites are 0 through 12, so each horizontal sprite is by modulus 4
	TXA
	AND #$03	; Essentially mod 4
	TAX
	LDA <Temp_Var5	 ; Temp_Var5 = 0 to 3 based on which horizontal sprite we're doing

	AND Bowser_SprHVisLUT,X
	BNE PRG001_BE49	 ; If this sprite should not be drawn due to beging horizontally off-screen, jump to PRG001_BE49

	LDA <Temp_Var15	
	ADD <Temp_Var16	 ; Temp_Var16 = (Bowser's frame * 16 [Temp_Var15]) + (which sprite we're on)
	TAX		 ; -> 'X'

	; Store pattern of this Bowser sprite
	LDA Bowser_SprPats,X
	STA Sprite_RAM+1,Y

	LDX <Temp_Var16	 ; X = Temp_Var16

	LDA <Temp_Var3
	BPL PRG001_BE1A	 ; If Bowser is not vertically flipped, jump to PRG001_BE1A

	; Otherwise, use the vertically flipped lookups
	TXA
	ADD #(Bowser_SprYVFlipped - Bowser_SprYNotVFlipped)
	TAX

PRG001_BE1A:
	LDA <Temp_Var1	 	; A = Temp_Var1 (Bowser's Sprite Y)
	ADD Bowser_SprYNotVFlipped,X	; Offset Y as appropriate for this sprite
	STA Sprite_RAM,Y	; Set sprite Y

	LDX <Temp_Var16		; X = Temp_Var16
	TXA		 	
	AND #$03	 	; Get which horizontal sprite (of 4) we're on
	CMP #$02	 	; Horizontal sprite 2 would be the beginning of the "right half" of Bowser

	LDA <Temp_Var3		; A = Temp_Var3 (Bowser's flip bits)
	BLT PRG001_BE30	 	; If we are on the left half of Bowser, jump to PRG001_BE30

	LDA <Temp_Var4		; A = Temp_Var4 (Bowser's flip bits alternate)

PRG001_BE30:
	ORA #SPR_PAL3	 	; Lock in palette 3
	STA Sprite_RAM+2,Y	; Store sprite attributes

	LDA <Temp_Var3
	AND #SPR_HFLIP
	BEQ PRG001_BE40	 ; If Bowser is not horizontally flipped, jump to PRG001_BE40

	; Otherwise, use the horizontally flipped lookups
	TXA		 
	ADD #(Bowser_SprXHFlipped - Bowser_SprXNotHFlipped)
	TAX

PRG001_BE40:
	LDA <Temp_Var2		 ; A = Temp_Var2 (Bowser's Sprite X)
	ADD Bowser_SprXNotHFlipped,X	 ; Offset X as appropriate for this sprite
	STA Sprite_RAM+3,Y	 ; Set sprite X

PRG001_BE49:
	INC <Temp_Var16		 ; Temp_Var16++ (next sprite)

	; Bowser is made of a total of 12 sprites (4x3)
	LDA <Temp_Var16
	CMP #12	 
	BNE PRG001_BDDF	 ; If Temp_Var16 <> 12, loop!

	LDX <CurrentObjectIndexZ	 ; Restore 'X' as Bowser's object slot index

	RTS		 ; Return

Bowser_CalcPlayersSide:

	; Backup Bowser's X
	LDA <Objects_XZ,X
	PHA

	; +8 Bowser's X; calculation of which side the Player is on is offset
	ADD #$08
	STA <Objects_XZ,X
	JSR Object_QuickXDistanceFromPlayer

	; Restore Bowser's X
	PLA
	STA <Objects_XZ,X

	RTS		 ; Return


Bowser_HandleIfDead:
	; Handle Bowser if he's dead either from falling or weapon

	LDA <Objects_YHiZ,X	 
	CMP #$01
	BLS PRG001_BE6F	 ; If Bowser is way up high, jump to PRG001_BE6F

	; Bowser's not too high...

	LDA <Objects_SpriteY,X
	CMP #$88
	BGE PRG001_BE7F	 ; If Bowser's Y >= $88, jump to PRG001_BE7F

	; Bowser's not too low yet

PRG001_BE6F:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG001_BE98	 ; If Bowser's state is Normal, jump to PRG001_BE98 (RTS)

	; Bowser's state not Normal, now set it to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser got killed by weapon, set Bowser's Y velocity to -$30
	LDA #-$30
	STA <Objects_YVelZ,X

PRG001_BE7F:

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Data2,X

	LDY #$04	 ; Y = 4
PRG001_BE80:

	LDA Objects_State,Y
	BEQ PRG001_BE81	 ; If this object slot is dead/empty, jump to PRG004_AE35

	DEY		 ; Y--
	BPL PRG001_BE80	 ; While

PRG001_BE81:
	LDA #OBJ_KEY
	STA Objects_ID, Y

	LDA #OBJSTATE_INIT
	STA Objects_State, Y
	
	LDA <Objects_XZ, X
	STA Objects_XZ, Y

	LDA <Objects_YZ, X
	STA Objects_YZ, Y

	LDA <Objects_XHiZ, X
	STA Objects_XHiZ, Y

	LDA <Objects_YHiZ, X
	STA Objects_YHiZ, Y


	; Set Bowser's frame to 6
	LDA #$06
	STA Objects_Frame,X

	; Clear Bowser's X Velocity and counter 1
	LDA #$00
	STA <Objects_XVelZ,X
	STA Bowser_Counter1

	; Set timer 3 to $30 (Delay until dramatic drop "song" begins)
	LDA #$30
	STA Objects_Timer3,X

PRG001_BE98:
	RTS		 ; Return


Bowser_FallAndSplat:
	LDY Objects_Timer3,X
	DEY		 ; Y--
	BNE PRG001_BEA4	 ; If timer 3 not expired, jump to PRG001_BEA4

	; Play dramatic Bowser fall
	LDA #MUS1_BOWSERFALL
	STA Sound_QMusic1

PRG001_BEA4:
	LDA Objects_HitCount,X
	CMP #$01
	BGS PRG001_BEB2	 ; If Bowser has at least one hit left, jump to PRG001_BEB2

	ASL Objects_Orientation,X
	SEC
	ROR Objects_Orientation,X

PRG001_BEB2:
	JSR Object_ApplyYVel_NoGravity	 ; Apply Y velocity

	LDA <Objects_YVelZ,X
	CMP #$25
	BGS PRG001_BEBD	 ; If Y velocity >= $25, jump to PRG001_BEBD

	INC <Objects_YVelZ,X	 ; Gravity while falling 

PRG001_BEBD:
	LDA <Objects_YHiZ,X
	CMP #$04	 
	BLS PRG001_BEDE	 ; If Bowser hasn't fallen down about 4 screens yet, jump to PRG001_BEDE

	; Bowser hits bottom...

	INC <Objects_Data2,X	 ; Objects_Data2 = 3

	; Set timer to $D0
	LDA #$d0
	STA Objects_Timer,X

	; Vibrate the floor 
	LDA #$80
	STA Level_Vibration

	; Ba-bam!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA <Player_InAir
	BNE PRG001_BEDE		; If Player is mid-air, jump to PRG001_BEDE

	; Bounce Player if he's on the ground
	LDA #-$40
	STA <Player_YVel

	; Mark Player as mid-air
	INC <Player_InAir

PRG001_BEDE:
	LDA <Objects_YZ,X	; Get Bowser's Y
	PHA			; Save it
	ADD #16			; +16
	STA <Objects_YZ,X	; -> Bowser's Y

	LDA <Objects_YHiZ,X	; Get Bowser's Y Hi
	PHA		 	; Save it
	ADC #$00	 	; Apply carry
	STA <Objects_YHiZ,X	; -> Bowser's Y Hi

	JSR Object_DetermineVerticallyOffScreen	; Check if Bowser is vertically invisible

	; Restore Y and Y Hi
	PLA
	STA <Objects_YHiZ,X
	PLA
	STA <Objects_YZ,X

	RTS		 ; Return

DoorAppear_YUpr:	.byte $60, $70
DoorAppear_X:	.byte $E8, $E8

PRG001_BEFB:	.byte $80, $88

Bowser_WaitAndVictory:
	LDA Objects_Timer,X	  
	BNE PRG001_BF09	 ; If timer hasn't expired, jump to PRG001_BF09 (RTS)

	; Play victory fanfare
	LDA #MUS1_WORLDVICTORY
	STA Sound_QMusic1

	INC <Objects_Data2,X	 ; Objects_Data2 = 3

PRG001_BF09:
	RTS		 ; Return

Bowser_DoTimeBonus:

PRG001_BF16:
	RTS		 ; Return


Bowser_DoorAppear:

	RTS		 ; Return

; Rest of ROM bank was empty

Try_PUp_Reserve:
	LDA Player_Equip
	CMP #$07
	BNE Cant_Reserve
	LDA Effective_Suit
	STA PowerUp_Reserve
Cant_Reserve:
	RTS

Do_PUp_Poof_Collect:
	STA Player_QueueSuit
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1
	LDA #$17
	STA Player_SuitLost
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State + 5
	RTS

Do_PUp_Pallete_Collect:
	STA Player_QueueSuit
	LDA #$1f
	STA Player_StarOff
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State + 5
	RTS

Weather_Patterns: .byte $7B, $7B, $55, $5F, $5D, $5D 
Rain_XVel: .byte $04, $05, $06, $07, $04, $05, $06, $06
Snow_XVel: .byte $01, $01, $01, $01, $01, $01, $01, $01
Sand_XVel: .byte $06, $07, $0A, $09, $06, $08, $08, $08
Rain_YVel: .byte $03, $04, $03, $04, $03, $04, $03, $04
Snow_YVel: .byte $01, $01, $01, $01, $02, $02, $02, $02
Sand_YVel: .byte $03, $04, $03, $04, $03, $04, $03, $04


DeleteWeather:
	LDA Objects_State, Y
	CMP #OBJSTATE_NORMAL
	BNE ObjInit_Weather2
	JMP Object_Delete

ObjInit_Weather:
	LDA Objects_Property, X
	STA Objects_Data4, X
	STX TempX
	LDY #$04

ObjInit_Weather1:
	CPY TempX
	BEQ ObjInit_Weather2
	LDA Objects_ID, Y
	CMP #$0F
	BEQ DeleteWeather

ObjInit_Weather2:
	DEY
	BPL ObjInit_Weather1

	LDY #$05

KeepRandomizing:
	LDA Objects_YZ, X
	LSR A
	LSR A
	LSR A
	LSR A
	STA TempA
	LDA Objects_XZ, X
	AND #$10
	BNE DontReverseWind
	LDA TempA
	EOR #$FF
	ADD #$01
	STA TempA
	
DontReverseWind:
	LDA TempA
	STA Wind
	LDA #$01
	STA WeatherActive
	JSR Randomize_Weather
	LDA RandomN
	STA Weather_YPos, Y
	DEY
	BPL KeepRandomizing

DontReverseWind1:
	RTS

ObjNorm_Weather:
	LDA Weather_Disabled
	BNE DontReverseWind1

	LDA <Vert_Scroll
	STA <Temp_Var7
	LDA <Horz_Scroll
	STA <Temp_Var8

	LDA Objects_Property, X
	CMP #$02
	BNE DoNextParticle0

	INC Objects_Data5, X
	LDA Objects_Data5, X
	AND #$01
	BNE DoNextParticle0
	LDA <Temp_Var7
	ADD #$80
	STA <Temp_Var7
	LDA <Temp_Var8
	ADD #$80
	STA <Temp_Var8


DoNextParticle0:
	LDA Object_SpriteRAM_Offset, X
	STA TempX
	LDY #$05

DoNextParticle:
	JSR MoveSingleParticle
	LDX TempX
	JSR DrawSingleParticle
	LDA TempX
	ADD #$04
	STA TempX
	DEY
	BPL DoNextParticle
	LDX <CurrentObjectIndexZ
	RTS

MoveSingleParticle:	
	LDA Weather_XPos, Y
	ADD Weather_XVel, Y
	STA Weather_XPos, Y

	LDA Weather_YPos, Y
	ADD Weather_YVel, Y
	STA Weather_YPos, Y

	CMP #$F0
	BCC MoveSingleParticle1

	JSR Randomize_Weather

MoveSingleParticle1:
	RTS

Randomize_Weather:
	STY TempY
	JSR Randomize
	LDY TempY
	LDX <CurrentObjectIndexZ
	LDA RandomN
	STA Weather_XPos, Y
	LDA #$00
	STA Weather_YPos, Y
	LDA RandomN + 1
	AND #$07
	STA TempA
	LDA Objects_Data4, X
	ASL A
	ASL A
	ASL A
	ORA TempA

RainVel1:
	TAY
	LDA Rain_XVel, Y
	LDY TempY
	STA Weather_XVel, Y
	LDA RandomN + 2
	AND #$07
	STA TempA
	LDA Objects_Data4, X
	ASL A
	ASL A
	ASL A
	ORA TempA

RainVel2:
	TAY
	LDA Rain_YVel, Y
	LDY TempY
	STA Weather_YVel, Y
	LDA Objects_XZ, X
	AND #$10
	BNE DoNotReverse

	LDA Weather_XVel, Y
	EOR #$FF
	ADD #$01
	STA Weather_XVel, Y

DoNotReverse: 

	LDA RandomN + 3
	AND #$01
	STA TempA
	LDA Objects_Data4, X
	ASL A
	ORA TempA

RainPattern:
	TAY
	LDA Weather_Patterns, Y
	LDY TempY
	STA Weather_Pattern, Y
	RTS

DrawSingleParticle:

	LDA Weather_YPos, Y
	SUB <Temp_Var7
	STA Sprite_RAM, X

	LDA Weather_XPos, Y
	SUB <Temp_Var8
	STA Sprite_RAM + 3, X

	LDA Weather_Pattern, Y
	STA Sprite_RAM + 1, X

	LDA #$02
	STA TempA
	LDA Weather_XVel, Y
	BMI DontFlipParticle
	LDA #SPR_HFLIP
	ORA TempA
	STA TempA

DontFlipParticle:
	LDA TempA
	STA Sprite_RAM + 2, X
	RTS
	
ChompPal: .byte SPR_PAL1, SPR_PAL0

ObjInit_GiantChomp:
	LDA #$00
	STA Objects_Data4, X
	STA Objects_Data5, X

	LDA #$D0
	STA Objects_YVelZ, X
	RTS

ObjNorm_GiantChomp:
	LDA <Player_HaltGameZ
	BNE DrawChomp

	LDA #SND_BOOMERANG
	STA Sound_QLevel2

	LDA <Counter_1
	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame, X

	LDA Objects_Property, X
	BEQ NoChompFlash

	LDA <Counter_1
	AND #$01
	TAY
	LDA ChompPal, Y
	STA Objects_SpriteAttributes,X

NoChompFlash:
	LDA Objects_Property, X
	CMP #$02
	BEQ ChompNoDelete

	JSR Object_DeleteOffScreen

ChompNoDelete:
	LDA Objects_Data5, X
	BNE GiantChompStuff

	JSR Object_ApplyYVel_NoGravity
	LDA Objects_SpritesVerticallyOffScreen,X
	BEQ DrawMiniChomp

	JSR Object_QuickYDistanceFromPlayer
	CPY #$01
	BEQ ChompRTS

	INC Objects_Data5, X

	LDA Objects_Property, X
	BEQ ChompRTS

	JSR GCTargetPlayer
ChompRTS:
	RTS

GiantChompStuff:
	JSR Object_AttackOrDefeat
	JSR Object_Move

DoGCRoutine:
	LDY #(SuperGiantOffsets1 - Object_TileDetectOffsets)
	JSR Object_DetectTile
	CMP #TILE_PROP_SOLID_ALL
	BCC TryEatRightBlock
	JSR ChompEatBlock
	JMP ChompDoneEating

TryEatRightBlock:
	LDY #(SuperGiantOffsets1  - Object_TileDetectOffsets)
	INY
	INY
	JSR Object_DetectTile
	CMP #TILE_PROP_SOLID_ALL
	BCC ChompDoneEating 
	JSR ChompEatBlock

ChompDoneEating:
DrawChomp:
	LDA Objects_Data5, X
	BEQ DrawMiniChomp
	LDA #LOW(GiantChompFrames)
	STA <Temp_Var10
	LDA #HIGH(GiantChompFrames)
	STA <Temp_Var11
	JSR DrawGiantObject

	LDA Objects_Property, X
	CMP #$02
	BCC DoneGC

	JSR Object_QuickYDistanceFromPlayer
	CPY #$00
	BEQ DoneGC

	LDA Objects_SpritesVerticallyOffScreen, X
	CMP #$03
	BCC DoneGC
	
	JSR GCTargetPlayer
	LDA #$D0
	STA Objects_YVelZ, X
	DEC Objects_Data5, X

DoneGC:
	RTS

DrawMiniChomp:
	JSR Object_ShakeAndCalcSprite
	LDX <CurrentObjectIndexZ
	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #$60
	BNE DrawMiniChompRTS
	LDA <Temp_Var1
	STA Sprite_RAM , Y
	LDA <Temp_Var2
	ADD #$0C
	STA Sprite_RAM + $03, Y
	LDA Objects_SpriteAttributes,X
	ORA #SPR_BEHINDBG
	STA Sprite_RAM + $02, Y
	LDA Objects_Frame, X
	ASL A
	ADD #$99
	STA Sprite_RAM + $01, Y

DrawMiniChompRTS:
	RTS

GiantChompFrames:
	.byte $81, $83, $85, $87, $A1, $A3, $A5, $A7
	.byte $89, $8B, $8D, $8F, $A9, $AB, $AD, $AF

	
ChompEatBlock:
	LDA #$00
	STA <Objects_YVelZ, X
	LDA #$81
	STA Block_UpdateValue
	INC Block_NeedsUpdate
	LDA ObjTile_DetYLo
	AND #$F0
	STA Block_ChangeY
	LDA ObjTile_DetYHi
	STA Block_ChangeYHi
	
	LDA ObjTile_DetXLo
	AND #$F0
	STA Block_ChangeX
	LDA ObjTile_DetXHi
	STA Block_ChangeXHi

	LDA Objects_SpritesHorizontallyOffScreen, X
	AND #$C0
	BNE ChompEatBlockRTS

	LDA Objects_SpritesVerticallyOffScreen, X
	AND #$03
	BNE ChompEatBlockRTS
	JSR PRG001_BC6D
	 
ChompEatBlockRTS:
	RTS


GCTargets: .byte $00, $20, $40, $60, $80, $A0, $C0, $E0

GCTargetPlayer:
	LDA <Player_XVel
	BPL GCTargetPlayerRight
	JSR Negate
	
	AND #$38
	LSR A
	LSR A
	LSR A
	TAY
	LDA <Player_X
	SUB GCTargets, Y
	AND #$F0
	STA <Objects_XZ, X

	LDA <Player_XHi
	SBC #$00
	STA <Objects_XHiZ, X

	RTS

GCTargetPlayerRight:
	AND #$31
	LSR A
	LSR A
	LSR A
	TAY
	LDA <Player_X
	ADD GCTargets, Y
	AND #$F0
	STA <Objects_XZ, X

	LDA <Player_XHi
	ADC #$00
	STA <Objects_XHiZ, X
	RTS

ObjInit_Brick:
	RTS

ObjNorm_Brick:
	LDA <Player_HaltGameZ
	BNE ObjNorm_BrickDraw

	JSR Object_Move
	JSR Object_InteractWithPlayer
	JSR Object_DetectTiles

	LDA <Objects_CollisionDetectionZ,X
	BEQ ObjNorm_BrickDraw

Object_ToBrickBust:
	LDA #OBJ_STONEBLOCK
	STA Objects_ID, X

	RTS

ObjNorm_BrickDraw:
	LDA Objects_Frame, X
	BNE ObjNorm_BrickDraw1
	JMP Object_ShakeAndDrawMirrored

ObjNorm_BrickDraw1:
	JMP Object_ShakeAndDraw

ObjNorm_Boss:
	JSR DoBossFights
	RTS

KeyPieceGet:
	.byte $01, $02, $04, $08, $10

KeyPieceXOffset:
	.byte $10, $18, $20, $28, $30

ObjInit_KeyPieces:
	LDA #$FF
	STA Objects_YHiZ, X
	LDA #$13
	STA Global_Object
	RTS

ObjNorm_KeyPieces:
	LDA #$93
	STA <Temp_Var1
	LDA #$95
	STA <Temp_Var2
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ ObjNorm_KeyPieces1

	LDA <Temp_Var1
	ADD #$40
	STA <Temp_Var1
	LDA <Temp_Var2
	ADD #$40
	STA <Temp_Var2

ObjNorm_KeyPieces1:
	LDY Object_SpriteRAM_Offset, X
	LDA Objects_Data4, X
	STA <Temp_Var5
	LDA Objects_Property, X
	STA <Temp_Var6
	TAX

CheckNextPiece:
	
	LDA #$08
	STA Sprite_RAM, Y
	LDA #SPR_PAL3
	STA Sprite_RAM + 2, Y
	LDA <Temp_Var5
	AND KeyPieceGet, X
	BNE UseFilledKey

	LDA <Temp_Var2
	BNE DrawKeyPiece

UseFilledKey:
	DEC <Temp_Var6

UseFilledKey1:
	LDA <Temp_Var1

DrawKeyPiece:
	STA Sprite_RAM + 1, Y
	LDA KeyPieceXOffset, X
	STA Sprite_RAM + 3, Y
	INY
	INY
	INY
	INY

NextCheck:
	DEX
	BPL CheckNextPiece
	LDA <Temp_Var6
	BPL KeyPieceRTS

	JSR Object_FindEmpty
	LDA #OBJ_KEY
	STA Objects_ID, X
	STA Global_Object
	LDA #OBJSTATE_INIT
	STA Objects_State, X
	LDY <CurrentObjectIndexZ
	LDA Objects_XZ, Y
	STA Objects_XZ, X
	LDA Objects_XHiZ, Y
	STA Objects_XHiZ, X
	LDA Objects_YZ, Y
	STA Objects_YZ, X
	LDA Objects_YHiZ, Y
	STA Objects_YHiZ, X
	LDX <CurrentObjectIndexZ
	JMP Object_PoofDie
	

KeyPieceRTS:
	RTS

KPFrames:
	.byte $00, $04

KPFlips1:
	.byte $00, $00, $00, SPR_HFLIP

KPFlips2:
	.byte $00, $00, SPR_HFLIP, SPR_HFLIP

ObjNormal_KeyPiece:
	LDA <Player_HaltGameZ
	BNE DrawKeyPieceAnim

	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	LDA KPFrames, Y
	STA Objects_Frame, X

	JSR Object_DeleteOffScreen
	JSR Object_GetAttrAndMoveTiles
	JSR Object_InteractWithPlayer
	INC Objects_Data2, X
	LDA Objects_Data2, X
	LSR A
	LSR A 
	LSR A
	AND #$03
	ORA Objects_Frame, X
	STA Objects_Frame, X

DrawKeyPieceAnim:
	JSR Object_ShakeAndDraw
	LDA Objects_Frame, X
	AND #$03
	TAX
	LDA KPFlips1, X
	ORA Sprite_RAM + 2, Y
	STA Sprite_RAM + 2, Y
	LDA KPFlips2, X
	ORA Sprite_RAM + 6, Y
	STA Sprite_RAM + 6, Y
	RTS

ObjHit_KeyPiece:
	LDY #$04

FindKeyTracker:
	LDA Objects_ID,Y
	CMP #OBJ_KEYPIECES
	BEQ SetKeyField
	DEY
	BPL FindKeyTracker
	RTS

SetKeyField:
	LDA Objects_Property, X
	TAX
	LDA Objects_Data4, Y
	ORA KeyPieceGet, X
	STA Objects_Data4, Y
	LDA #SND_MAPINVENTORYFLIP	 
	STA Sound_QMap	
	LDX <CurrentObjectIndexZ
	LDA Objects_XZ, X
	STA Objects_XZ, Y
	LDA Objects_XHiZ, X
	STA Objects_XHiZ, Y
	LDA Objects_YZ, X
	STA Objects_YZ, Y
	LDA Objects_YHiZ, X
	STA Objects_YHiZ, Y
	JMP Object_SetDeadEmpty

ObjInit_SpikeBall:
	
	RTS

ObjNorm_SpikeBall:
	
	JSR Object_ShakeAndDrawMirrored
	LDA <Player_HaltGameZ
	BNE ObjNorm_SpikeBallRTS

	JSR Object_DeleteOffScreen
	JSR Object_AttackOrDefeat
	JSR Object_KillOthers

	LDX <CurrentObjectIndexZ

	INC Objects_Data4, X
	LDA Objects_Data4, X
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X
	JSR Object_Move

	LDA <Objects_CollisionDetectionZ,X
	AND #$04
	BEQ SpikeNoBounce1

	JSR Object_HitGround

	LDA #$E0
	STA Objects_YVelZ, X

	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

SpikeNoBounce1:
	
	LDA <Objects_CollisionDetectionZ, x
	AND #$04
	BEQ TrySideBlock

SpikeNoBounce2:
	LDA Object_TileFeetProp
	CMP #TILE_ITEM_BRICK
	BNE TrySideBlock

	LDA Object_TileFeetValue
	STA <Temp_Var3
	LDA #$08
	STA <Temp_Var1

	LDA #$10
	STA <Temp_Var2
	JMP SpikeBrickBust

TrySideBlock:
	LDA <Objects_CollisionDetectionZ, x
	AND #$03
	BEQ ObjNorm_SpikeBallRTS

	LDA Object_TileWallProp
	CMP #TILE_ITEM_BRICK
	BNE SpikeBusted

	LDA #$08
	STA <Temp_Var2

	LDA Object_TileWallValue
	STA <Temp_Var3

	LDA Objects_XVelZ, X
	BMI TrySideBlock1

	LDA #$10
	STA <Temp_Var1
	BNE TrySideBlock2

TrySideBlock1:	

	LDA #$00
	STA <Temp_Var1

TrySideBlock2:
	JMP SpikeBrickBust

SpikeBusted:
	LDA #$00
	STA Objects_Data2, X
	STA Objects_Frame, X
	JMP Object_ToBrickBust

ObjNorm_SpikeBallRTS:
	JMP Object_ShakeAndDrawMirrored

SpikeBrickBust:
	LDA Block_NeedsUpdate
	BNE SpikeBrickBustRTS

	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA <Objects_YZ, X
	ADD <Temp_Var2
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA <Objects_XZ, X
	ADD <Temp_Var1
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

	LDA <Temp_Var3
	AND #$C0
	ORA #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate

	LDA <Objects_YZ,X
	ADD <Temp_Var2
	AND #$f0
	STA Block_ChangeY
	LDA <Objects_YHiZ,X
	ADC #$00
	STA Block_ChangeYHi

	LDA <Objects_XZ,X
	ADD <Temp_Var1
	AND #$f0
	STA Block_ChangeX
	LDA <Objects_XHiZ,X
	ADC #$00
	STA Block_ChangeXHi

SpikeBrickBustRTS:
	RTS

ObjInit_SendBack:
	LDA #$C0
	STA Objects_SlowTimer, X
	RTS

ObjNorm_SendBack:
	LDA Objects_SlowTimer, X
	BNE ObjNorm_SendBackRTS

	INC Level_JctCtl
	INC Level_Redraw
	INC ForcedSwitch
	LDA #$00
	STA LevelVertJct
	STA <Player_XVel
	STA <Player_YVel
	LDA #$F0
	SUB <Player_X
	STA <Player_X
	LDA PreviousLevel
	STA LevelLoadPointer

ObjNorm_SendBackRTS:
	RTS

TimerStartTimes:
	.byte 05, 100

ObjInit_Timer:
	LDA Objects_Property, X
	TAY
	LDA TimerStartTimes, Y
	STA Objects_Data4, X
	LDA #$B0
	STA Objects_Data5, X
	LDA #$1D
	STA Global_Object
	RTS

ObjNorm_Timer:
	LDA Objects_Data2, X
	BNE ObjNorm_Timer0
	LDA #MUS1_TIMEWARNING	 
	STA Sound_QMusic1
	INC Objects_Data2, X

ObjNorm_Timer0:
	LDA <Player_HaltGameZ
	BNE ObjNorm_Timer1
	LDA Objects_Data4, X
	BEQ ObjNorm_Timer2

	DEC Objects_Data5, X
	BNE ObjNorm_Timer1
	DEC Objects_Data4, X
	LDA #$2D
	STA Objects_Data5, X

ObjNorm_Timer1:
	JSR DrawTimer
	RTS

ObjNorm_Timer2:
	JSR Player_Die
	RTS

DrawTimer:
	LDA #$00
	STA <Temp_Var10
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ DrawTimer0

	LDA #$40
	STA <Temp_Var10

DrawTimer0:
	LDA Objects_Data4, X
	STA DigitsParam

	JSR BytesTo2Digits

	LDX <CurrentObjectIndexZ
	LDY Object_SpriteRAM_Offset, X
	LDX #$00

DrawTimer1:
	LDA #$10
	STA Sprite_RAM, Y
	LDA #SPR_PAL2
	STA Sprite_RAM + 2, Y

	LDA KeyPieceXOffset, X
	STA Sprite_RAM + 3, Y

	LDA <DigitsResult, X
	ASL A
	ADD #$A1
	ADD <Temp_Var10
	STA Sprite_RAM + 1, Y
	INY
	INY
	INY
	INY
	INX
	CPX #$03
	BNE DrawTimer1

	LDX <CurrentObjectIndexZ
	RTS

ObjNorm_Clock:
	JSR Object_DeleteOffScreen
	LDA #$00
	STA <Temp_Var10
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ ObjNorm_Clock0

	LDA #$08
	STA <Temp_Var10

ObjNorm_Clock0:
	LDA Objects_Data5, X
	BNE ObjNorm_Clock2

	JSR Object_InteractWithPlayer
	LDA <Player_HaltGameZ
	BNE ObjNorm_Clock1

	INC Objects_Data4, X
	LDA Objects_Data4, X
	LSR A
	LSR A
	LSR A
	AND #$01
	ADD <Temp_Var10
	STA Objects_Frame, X
	
ObjNorm_Clock1:
	JMP Object_ShakeAndDraw

ObjNorm_Clock2:
	LDA <Player_HaltGameZ
	BNE ObjNorm_Clock3

	LDA Objects_Property, X
	ADD #$02
	ADD <Temp_Var10
	STA Objects_Frame, X
	JSR Object_ApplyYVel_NoGravity
	LDA Objects_Timer, X
	BEQ ObjNorm_Clock4

ObjNorm_Clock3:
	JMP Object_ShakeAndDraw

ObjNorm_Clock4:
	JMP Object_SetDeadEmpty

ClockTimes:
	.byte 5, 10, 15, 20, 25, 30

ObjHit_Clock:
	LDY #$04

ObjHit_Clock1:
	LDA Objects_ID, Y
	CMP #$1D
	BEQ ObjHit_Clock2
	DEY
	BPL ObjHit_Clock1
	RTS

ObjHit_Clock2:
	LDA Objects_Property, X
	TAX
	LDA ClockTimes, X
	ADD Objects_Data4, Y
	STA Objects_Data4, Y
	LDX <CurrentObjectIndexZ
	INC Objects_Data5, X
	LDA #$20
	STA Objects_Timer, X
	LDA #$F8
	STA Objects_YVelZ, X
	LDA #SPR_PAL2
	STA Objects_SpriteAttributes, X
	LDA Sound_QLevel1
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap
	RTS

BlockEater_StartX = Objects_Data1
BlockEater_StartXHi = Objects_Data2
BlockEater_StartY = Objects_Data3
BlockEater_StartYHi = Objects_Data4
BlockEater_DirectionIndex = Objects_Data5
BlockEater_TileDetectValue = Objects_Data6
BlockEater_BlockIndexCheck = Objects_Data7
BlockEater_XVelocity: .byte $00, $08, $00, $F8
BlockEater_YVelocity: .byte $F8, $00, $08, $00


BlockCheck_XOffsets:
	.byte $08, $18, $08, $F8
	.byte $00, $00, $00, $FF
	

BlockCheck_YOffsets:
	.byte $F8, $08, $18, $08
	.byte $FF, $00, $00, $00
	

ObjInit_EaterBlock:
	JSR Object_DetectTiles
	
	LDA Object_LevelTile
	STA BlockEater_TileDetectValue, X

	LDA <Objects_YZ, X
	SUB #$01
	STA <Objects_YZ, X
	STA BlockEater_StartY, X

	LDA <Objects_YHiZ, X
	SBC #$00
	STA <Objects_YHiZ, X
	STA BlockEater_StartYHi, X

	LDA <Objects_XZ, X
	STA BlockEater_StartX, X

	LDA <Objects_XHiZ, X
	STA BlockEater_StartXHi, X
	RTS

ObjNorm_EaterBlock:

	JSR Object_ShakeAndDrawMirrored

	LDA <Player_HaltGameZ
	BEQ EaterMaker

EaterMaker_RTS1:
	RTS
	
EaterMaker_Halt:
	LDA #$00
	STA <Objects_XVelZ, X
	STA <Objects_YVelZ, X
	RTS

EaterMaker:
	LDA <Objects_XZ, X
	CMP BlockEater_StartX, X
	BNE EaterMaker1

	LDA <Objects_XHiZ, X
	CMP BlockEater_StartXHi, X
	BNE EaterMaker1

	LDA <Objects_YZ, X
	CMP BlockEater_StartY, X
	BNE EaterMaker1

	LDA <Objects_YHiZ, X
	CMP BlockEater_StartYHi, X
	BNE EaterMaker1

	JSR Object_DeleteOffScreen

EaterMaker1:
	JSR Object_InteractWithPlayer	
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoGravity

	LDA <Objects_XZ, X
	AND #$0F
	BNE EaterMaker_RTS1

	LDA <Objects_YZ, X
	AND #$0F
	CMP #$0F
	BNE EaterMaker_RTS1

	LDA Block_NeedsUpdate
	BNE EaterMaker_Halt

	LDA <Objects_XZ, X
	ADD #$08
	STA Block_DetectX

	LDA <Objects_XHiZ, X
	ADC #$00
	STA Block_DetectXHi

	LDA <Objects_YZ, X
	ADD #$08
	STA Block_DetectY

	LDA <Objects_YHiZ, X
	ADC #$00
	STA Block_DetectYHi

	LDA BlockEater_TileDetectValue, X
	EOR #$01
	JSR Object_ChangeBlock
	
	LDA #$03
	STA BlockEater_BlockIndexCheck, X

EaterMaker_CheckBlocks:
	LDY BlockEater_BlockIndexCheck, X
	LDA BlockCheck_XOffsets, Y
	ADD <Objects_XZ, X
	STA Block_DetectX

	LDA BlockCheck_XOffsets + 4, Y
	ADC <Objects_XHiZ, X
	STA Block_DetectXHi

	LDA BlockCheck_YOffsets, Y
	ADD <Objects_YZ, X
	STA Block_DetectY

	LDA BlockCheck_YOffsets + 4, Y
	ADC <Objects_YHiZ, X
	STA Block_DetectYHi

	JSR Object_DetectTileDirect
	LDA Object_LevelTile
	CMP BlockEater_TileDetectValue, X
	BEQ EaterMaker_SetVel

	DEC BlockEater_BlockIndexCheck, X
	BPL EaterMaker_CheckBlocks

	LDA Objects_Property, X
	AND #$01
	BNE EaterMark_Reverse

	JMP Object_PoofDie

EaterMark_Reverse:
	LDA BlockEater_TileDetectValue, X
	EOR #$01
	STA BlockEater_TileDetectValue, X
	RTS

EaterMaker_SetVel:
	
	LDY BlockEater_BlockIndexCheck, X
	LDA BlockEater_XVelocity, Y
	STA <Objects_XVelZ, X

	LDA BlockEater_YVelocity, Y
	STA <Objects_YVelZ, X
	LDA Objects_Property, X
	AND #$02
	BEQ EaterMaker_NormalSpeed

	LDA <Objects_XVelZ, X
	AND #$80
	STA TempA
	LDA <Objects_XVelZ, X
	ASL A
	ORA TempA
	STA <Objects_XVelZ, X

	LDA <Objects_YVelZ, X
	AND #$80
	STA TempA
	LDA <Objects_YVelZ, X
	ASL A
	ORA TempA
	STA <Objects_YVelZ, X

EaterMaker_NormalSpeed:
	RTS

ObjNorm_StarPiece:
	LDA <Player_HaltGameZ
	BNE DrawStarPieceAnim

	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	LDA KPFrames, Y
	STA Objects_Frame, X

	JSR Object_InteractWithPlayer
	INC Objects_Data2, X
	LDA Objects_Data2, X
	LSR A
	LSR A 
	LSR A
	AND #$03
	ORA Objects_Frame, X
	STA Objects_Frame, X

DrawStarPieceAnim:
	JSR Object_ShakeAndDraw
	LDA Objects_Frame, X
	AND #$03
	TAX
	LDA KPFlips1, X
	ORA Sprite_RAM + 2, Y
	STA Sprite_RAM + 2, Y
	LDA KPFlips2, X
	ORA Sprite_RAM + 6, Y
	STA Sprite_RAM + 6, Y
	RTS

ObjInit_HardIce:
	LDA #$00
	STA Objects_XVelZ, X
	STA Objects_Orientation, X
	LDA Objects_XZ, X
	ADD #$08
	AND #$F0
	STA Objects_XZ, X
	LDA #$20
	STA Objects_Timer, X
	RTS

ObjNorm_HardIce:
	LDA <Player_HaltGameZ
	BNE ObjNorm_HardIce2

ObjNorm_HardIce_0:
	JSR Object_Move
	JSR Object_InteractWithTiles
	JSR Object_DeleteOffScreen
	JSR Object_InteractWithPlayer

	LDA  <Objects_CollisionDetectionZ, X
	AND #HIT_GROUND
	BEQ ObjNorm_HardIce2

	JSR Object_KillOthers
	LDA Objects_Data4, X
	BNE ObjNorm_HardIce1

	INC Objects_Data4, X
	LDA Object_TileProp
	CMP #TILE_PROP_ENEMY
	BEQ ObjNorm_HardIce1_0

ObjNorm_HardIce1_1:
	LDA #OBJ_ICEBLOCK
	STA Objects_ID, X
	RTS

ObjNorm_HardIce1_0:
	LDA #$F0
	STA Objects_YVelZ, X
	BNE ObjNorm_HardIce2

ObjNorm_HardIce1:
	LDA Block_NeedsUpdate
	BNE ObjNorm_HardIce2

	LDA Object_LevelTile
	EOR #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate
	
	JSR SetObjectTileCoordAlignObj
	JMP Object_SetDeadEmpty

ObjNorm_HardIce2:
	JMP Object_ShakeAndDraw 
	

ObjHit_HardIce:
	LDA Objects_Data4, X
	BNE ObjHit_HardIce1
	LDA #OBJ_ICEBLOCK
	STA Objects_ID, X

ObjHit_HardIce1:
	RTS

ObjNorm_SnowBall:
	LDA <Player_HaltGameZ
	BNE ObjNorm_SnowBall2

	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BEQ ObjNorm_SnowBall1
	JSR Object_Move
	JSR Object_InteractWithTiles
	JSR Object_DeleteOffScreen
	JSR Object_InteractWithPlayer

	LDA Object_TileWallProp
	CMP #TILE_PROP_SOLID_ALL
	BCC ObjNorm_SnowBall2

ObjNorm_SnowBall1:
	LDA #OBJ_ICEBLOCK
	STA Objects_ID, X

ObjNorm_SnowBall2:
	INC Objects_Data4, X
	LDA Objects_Data4, X
	AND #$04
	LSR A
	LSR A
	STA Objects_Frame, X
	JMP Object_ShakeAndDraw 

SnowThrowPlayerX:
	.byte $20, $E0

ObjHit_SnowBall:
	JSR SetPlayerFrozen
	JSR Object_QuickXDistanceFromPlayer
	LDA SnowThrowPlayerX, Y
	STA <Player_XVel
	LDA #$A0
	STA <Player_YVel
	STA <Player_InAir
	LDA #OBJ_ICEBLOCK
	STA Objects_ID, X
	RTS

IceFireFlyColors:
	.byte SPR_PAL1, SPR_PAL2

IceFireFlyProjectiles:
	.byte SOBJ_FIREBALL, SOBJ_ICEBALL

IceFlyRotationX:
	.byte 24, 24, 24, 23, 22, 21, 20, 19, 17, 15, 13, 11, 9, 7, 5, 2, 0

IceFlyRotationY:
	.byte -2, -5, -7, -9, -11, -13, -15, -17, -19, -20, -21, -22, -23, -24, -24, -24, -24, -24, -24, -23, -22, -21, -20, -19, -17, -15, -13, -11, -9, -7, -5, -2, 0, 2, 5, 7, 9, 11, 13, 15, 17, 19, 20, 21, 22, 23, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 17, 15, 13, 11, 9, 7, 5, 2, 0

IceFlyRotationVel:
   .byte -$20, $20

ObjInit_IceFireFly:
	LDY Objects_Property, X
	LDA IceFireFlyProjectiles, Y
	STA Objects_Data3, X
	LDA IceFireFlyColors, Y
	STA Objects_SpriteAttributes, X
	LDA #$00
	STA Objects_SpritesHorizontallyOffScreen, X
	STA Objects_SpritesVerticallyOffScreen, X
	JSR SpecialObject_FindEmptyAbort
	TYA
	STA Objects_Data5, X
	LDA Objects_Data3, X
	STA SpecialObj_ID,Y
	LDA #$02
	STA SpecialObj_YHi, Y
	RTS

ObjNorm_IceFireFly:
	LDA <Player_HaltGameZ
	BEQ ObjNorm_IceFireFly00
	JMP ObjNorm_IceFireFly0

ObjNorm_IceFireFly00:
	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE ObjNorm_IceFireFly01

	LDA Objects_Data5, X
	TAY
	LDA SpecialObj_ID, Y
	BNE ObjNorm_IceFireFly02

	JMP ObjNorm_IceFireFly4

ObjNorm_IceFireFly02:
	LDX <CurrentObjectIndexZ
	LDA Objects_Data4, X
	AND #$20
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAX
	LDA IceFlyRotationVel, X
	STA <Temp_Var1
	LDX <CurrentObjectIndexZ
	LDA Objects_Data5, X
	TAY
	LDA <Temp_Var1
	STA SpecialObj_XVel, Y
	JMP ObjNorm_IceFireFly4

ObjNorm_IceFireFly01:
	
	INC Objects_Data4, X
	LDA Objects_Data4, X
	AND #$0C
	LSR A
	LSR A
	STA Objects_Frame, X

	JSR Object_DeleteOffScreen
	JSR Object_AttackOrDefeat

	LDA Objects_Data4, X
	AND #$01
	BEQ ObjNorm_IceFireFly0
	JSR Chase

ObjNorm_IceFireFly0:
	LDA Objects_XZ, X
	ADD #$04
	STA <Temp_Var13
	LDA Objects_XHiZ, X
	ADC #$00
	STA <Temp_Var14
	LDA Objects_YZ, X
	STA <Temp_Var15
	LDA Objects_YHiZ, X
	STA <Temp_Var16

	LDA Objects_Data5, X
	TAY
	LDA Objects_Data4, X
	AND #$3F
	TAX
	LDA IceFlyRotationX, X
	BPL ObjNorm_IceFireFly1

	EOR #$FF
	ADD #$01
	STA <Temp_Var12
	LDA <Temp_Var13
	SUB <Temp_Var12
	STA SpecialObj_XLo, Y
	LDA <Temp_Var14
	SBC #$00
	STA <Temp_Var14
	JMP ObjNorm_IceFireFly2

ObjNorm_IceFireFly1:
	ADD <Temp_Var13
	STA SpecialObj_XLo, Y
	LDA <Temp_Var14
	ADC #$00
	STA <Temp_Var14

ObjNorm_IceFireFly2:
	LDA SpecialObj_XLo, Y
	CMP <Horz_Scroll
	LDA <Temp_Var14
	SBC <Horz_Scroll_Hi
	BNE ObjNorm_IceFireFly2_1

	LDA SpecialObj_XLo, Y
	CMP <Horz_Scroll
	LDA <Temp_Var14
	SBC <Horz_Scroll_Hi
	BEQ ObjNorm_IceFireFly2_2

ObjNorm_IceFireFly2_1
	LDA #$C0
	STA SpecialObj_YLo, Y
	LDA #$01
	STA SpecialObj_YHi, Y
	BNE ObjNorm_IceFireFly4
	
ObjNorm_IceFireFly2_2:
	LDA IceFlyRotationY, X
	BPL ObjNorm_IceFireFly3

	EOR #$FF
	ADD #$01
	STA <Temp_Var12
	LDA <Temp_Var15
	SUB <Temp_Var12
	STA SpecialObj_YLo, Y

	LDA <Temp_Var16
	SBC #$00
	STA SpecialObj_YHi, Y
	JMP ObjNorm_IceFireFly3_1

ObjNorm_IceFireFly3:
	ADD <Temp_Var15
	STA SpecialObj_YLo, Y

	LDA #$00
	STA SpecialObj_XVel, Y
	STA SpecialObj_YVel, Y

	LDA <Temp_Var16
	ADC #$00
	STA SpecialObj_YHi, Y

ObjNorm_IceFireFly3_1:
	LDX <CurrentObjectIndexZ
	LDA Objects_Data3, X
	STA SpecialObj_ID,Y
	STA SpecialObj_Data, Y

ObjNorm_IceFireFly4:
	LDX <CurrentObjectIndexZ
	JMP Object_ShakeAndDraw

Fireball_Flips:
	.byte $00, SPR_VFLIP

ObjNorm_BowserFireBall:
	LDA <Player_HaltGameZ
	BNE ObjNorm_BowserFireBall1

	JSR Object_DeleteOffScreen
	INC Objects_Data4, X
	LDA Objects_Data4, X
	LSR A
	AND #$01
	TAY
	LDA Objects_Orientation, X
	AND #~SPR_VFLIP
	ORA Fireball_Flips, Y
	STA Objects_Orientation, X
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoGravity	 ; Apply Y Velocity
	JSR Object_InteractWithPlayer

ObjNorm_BowserFireBall1:
	JMP Object_ShakeAndDraw
CoinLock_CoinsRemaining = Objects_Data4
CoinLock_BlocksRemaining = Objects_Data5

CoinLocks:
	.byte $0A, $19, $32, $32, $32, $32, $32, $63

ObjInit_CoinLock:
	LDA <Objects_YZ, X
	ADD #$04
	STA <Objects_YZ, X
	
	LDA <Objects_YHiZ, X
	ADC #$00
	STA <Objects_YHiZ, X
	
	LDY Objects_Property, X
	LDA CoinLocks,  Y
	STA CoinLock_CoinsRemaining, X
	RTS

Coin_Unlock:
	LDA Block_NeedsUpdate
	BNE Coin_UnlockRTS

	JSR SpecialObject_FindEmpty
	CPY #$FF
	BEQ Coin_UnlockRTS

	STY <Temp_Var15
	JSR Object_DetectTileOn
	
	LDA Object_LevelTile
	EOR #$01
	STA Block_UpdateValue
	INC Block_NeedsUpdate
	
	JSR SetObjectTileCoordAlignObj
	
	LDA Objects_SpritesHorizontallyOffScreen, X
	BNE Coin_Unlock0

	LDY <Temp_Var15
	LDA #SOBJ_POOF
	STA SpecialObj_ID, Y
	
	LDA #$20	 
	STA SpecialObj_Data, Y
	
	LDA Objects_XZ, X
	STA SpecialObj_XLo, Y
	
	LDA Objects_YHiZ, X
	STA SpecialObj_YHi, Y
	
	LDA Objects_YZ, X
	STA SpecialObj_YLo, Y

Coin_Unlock0:
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	LDA Objects_YZ, X
	ADD #$10
	STA Objects_YZ, X
	
	LDA Objects_YHiZ, X
	ADC #$00
	STA Objects_YHiZ, X

	INC CoinLock_BlocksRemaining, X
	LDA CoinLock_BlocksRemaining, X
	CMP #$03
	BNE Coin_UnlockRTS

	LDA Objects_YZ, X
	SUB #$38
	STA Objects_YZ, X
	LDA Objects_YHiZ, X
	SBC #$00
	STA Objects_YHiZ, X
	JMP ObjectKill_NoScore

Coin_UnlockRTS:	
	RTS
	
ObjNorm_CoinLock:
	LDA CoinLock_CoinsRemaining, X
	BEQ Coin_Unlock

	LDY Objects_Property, X
	LDA CoinLock_CoinsRemaining, X
	SUB Coins_Earned
	ADD Coins_Lost
	CMP CoinLocks, Y
	BEQ ObjNorm_CoinLock0
	BCS ObjNorm_CoinLock1

ObjNorm_CoinLock0:
	STA CoinLock_CoinsRemaining, X

ObjNorm_CoinLock1:
	LDA #$00
	STA Coins_Lost
	STA Coins_Earned

	LDA LastPatTab_Sel
	AND #$01
	STA Objects_Frame, X
	LDA #$00
	STA <Temp_Var10
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ DrawCoinLock0

	LDA #$40
	STA <Temp_Var10

DrawCoinLock0:
	JSR Object_ShakeAndDraw
	LDA Objects_SpritesHorizontallyOffScreen,X 
	ORA Objects_SpritesVerticallyOffScreen,X
	BEQ DrawCoinLock1

	LDA #$08
	STA Sprite_RAM, Y
	STA Sprite_RAM+3, Y
	STA Sprite_RAM+4, Y
	LDA #$10
	STA Sprite_RAM+7, Y


DrawCoinLock1:

	LDA CoinLock_CoinsRemaining, X
	STA DigitsParam

	JSR BytesTo2Digits

	LDA Sprite_RAM, Y
	ADD #$10
	STA Sprite_RAM+8, Y
	STA Sprite_RAM+12, Y

	LDA Sprite_RAM+3, Y
	STA Sprite_RAM+11, Y
	ADD #$08
	STA Sprite_RAM+15, Y

	LDA #SPR_PAL1
	STA Sprite_RAM+10,Y
	STA Sprite_RAM+14,Y

	LDA <DigitsResult
	ASL A
	ADD #$A1
	ADD <Temp_Var10
	STA Sprite_RAM + 9, Y
	LDA <DigitsResult + 1
	ASL A
	ADD #$A1
	ADD <Temp_Var10
	STA Sprite_RAM + 13, Y
	RTS

ObjInit_ForcePowerUp:
	LDA #$01
	STA Player_QueueSuit
	RTS

PointerDataOffset:
	.byte 0, 6, 12, 18, 24

ObjInit_ModifyPointers:
	LDA Objects_Property, X
	TAY
	LDA BossLevelData, Y
	TAY
	LDA PointerDataOffset, Y
	TAY
	LDA Pointers, Y
	STA Pointers
	RTS

PUp_GeneralCollect:
	RTS