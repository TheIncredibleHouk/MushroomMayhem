; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-19 22:50:51.409583184 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

	; CAUTION!! ObjectGroup00 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $00 (i.e. objects starting at ID $00) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup00_InitJumpTable:
	.word ObjInit_DoNothing	; Object $00
	.word ObjInit_DoNothing	; Object $01
	.word ObjInit_DoNothing	; Object $02
	.word ObjInit_EaterBlock	; Object $03
	.word ObjInit_CoinLock	; Object $04
	.word ObjInit_DoNothing	; Object $05
	.word ObjInit_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjInit_Brick	; Object $07 - OBJ_BRICK
	.word ObjInit_Coin	; Object $08 - OBJ_COIN
	.word ObjInit_Bubble	; Object $09 - OBJ_BUBBLE
	.word ObjInit_ForcePowerUp	; Object $0A - OBJ_BULLY
	.word ObjInit_PUpMush	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.word ObjInit_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjInit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjInit_HardIce	; Object $0E - OBJ_HARDICE
	.word ObjInit_Rain	; Object $0F - OBJ_RAIN
	.word ObjInit_IceFireFly; Object $10 - OBJ_PIXIE
	.word ObjInit_Key	; Object $11 OBJ_KEY
	.word ObjInit_Spring	; Object $12 OBJ_SPRING
	.word ObjInit_KeyPieces	; Object $13 OBJ_KEYPIECES
	.word ObjInit_GiantChomp	; Object $14 OBJ_GIANTCHOMP
	.word ObjInit_DoNothing	; Object $15 
	.word ObjInit_DoNothing	; Object $16 OBJ_KEYPIECE
	.word ObjInit_DoNothing; Object $17 - OBJ_SPINYCHEEP
	.word ObjInit_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjInit_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjInit_BubbleGenerator	; Object $1A that is a l
	.word ObjInit_DoNothing	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjInit_SendBack	; Object $1C
	.word ObjInit_Timer	; Object $1D
	.word ObjInit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjInit_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjInit_DoNothing	; Object $20
	.word ObjInit_FireFlower	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjInit_StarOrSuit	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjInit_SuperLeaf	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup00_NormalJumpTable:
	.word ObjNorm_DoNothing	; Object $00
	.word ObjNorm_BowserFireBall	; Object $01
	.word ObjNorm_SnowBall	; Object $02
	.word ObjNorm_EaterBlock	; Object $03
	.word ObjNorm_CoinLock	; Object $04
	.word ObjNorm_SpikeBall	; Object $05
	.word ObjNorm_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjNorm_Brick	; Object $07 - OBJ_BRICK
	.word ObjNorm_Coin	; Object $08 - OBJ_COIN
	.word ObjNorm_Bubble	; Object $09 - OBJ_BUBBLE
	.word ObjNorm_DoNothing	; Object $0A OBJ_BULLY
	.word ObjNorm_PUpNinjaShroom; Object $0B - OBJ_POWERUP_NINJASHROOM
	.word ObjNorm_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjNorm_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjNorm_HardIce	; Object $0E - OBJ_HARDICE
	.word ObjNorm_Weather	; Object $0F
	.word ObjNorm_IceFireFly	; Object $10 - OBJ_PIXIE
	.word ObjNorm_Key	; Object $11
	.word ObjNorm_Spring	; Object $12
	.word ObjNorm_KeyPieces	; Object $13 
	.word ObjNorm_GiantChomp	; Object $14 OBJ_GIANTCHOMP
	.word ObjNorm_Boss	; Object $15 OBJ_BOSS
	.word ObjNormal_KeyPiece	; Object $16 OBJ_KEYPIECE
	.word ObjNorm_PoisonClear; Object $17 - OBJ_SPINYCHEEP
	.word ObjNorm_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjNorm_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjNorm_Bubble	; Object $1A
	.word ObjNorm_StarPiece	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjNorm_SendBack	; Object $1C
	.word ObjNorm_Timer	; Object $1D
	.word ObjNorm_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjNorm_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjNorm_Clock	; Object $20
	.word ObjNorm_IceFlower	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjNorm_StarOrSuit	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjNorm_FoxLeaf	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup00_CollideJumpTable:
	.word Player_GetHurt	; Object $00
	.word ObjHit_DoNothing	; Object $01
	.word ObjHit_SnowBall	; Object $02
	.word ObjHit_SolidBlock	; Object $03
	.word ObjHit_DoNothing	; Object $04
	.word Player_GetHurt	; Object $05
	.word ObjHit_DoNothing	; Object $06 - OBJ_BOUNCEDOWNUP
	.word Player_GetHurt	; Object $07 - OBJ_BRICK
	.word ObjHit_Coin	; Object $08 - OBJ_COIN
	.word BubblePop	; Object $09 - OBJ_BUBBLE
	.word ObjHit_DoNothing	; Object $0A
	.word ObjHit_NinjaShroom	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.word ObjHit_StarOrSuit	; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjHit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjHit_HardIce	; Object $0E - OBJ_HARDICE
	.word ObjHit_DoNothing	; Object $0F
	.word Player_GetHurt	; Object $10 OBJ_PIXIE
	.word ObjHit_DoNothing	; Object $11
	.word ObjHit_DoNothing	; Object $12
	.word ObjHit_DoNothing	; Object $13
	.word ObjHit_DoNothing	; Object $14 OBJ_GIANTCHOMP
	.word ObjHit_DoNothing	; Object $15
	.word ObjHit_KeyPiece	; Object $16
	.word ObjHit_DoNothing	; Object $17 - OBJ_SPINYCHEEP
	.word OCSPECIAL_HIGHSCORE; Object $18 - OBJ_BOSS_BOWSER
	.word ObjHit_FireFlower	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word BubblePop	; Object $1A
	.word Object_SetDeadEmpty	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjHit_DoNothing	; Object $1C
	.word ObjHit_DoNothing	; Object $1D
	.word ObjHit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjHit_DoNothing	; Object $1F - OBJ_GROWINGVINE
	.word ObjHit_Clock	; Object $20
	.word ObjHit_IceFlower	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjHit_Pumpkin	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjHit_FoxLeaf    ; Object $23 - OBJ_POWERUP_FOXLEAF

	
	; Object group $00 (i.e. objects starting at ID $00) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup00_Attributes:
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $00
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $01
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $02
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $03
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $04
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $05
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $07 - OBJ_BRICK
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $08 - OBJ_COIN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $09 - OBJ_BUBBLE
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0A- OBJ_BULLY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0E - OBJ_HARDICE
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0F - 
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $10 OBJ_PIXIE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $11 OBJ_KEY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $12 OBJ_REDPRING
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $13 OBJ_GREENSPRING
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $14 OBJ_GIANTCHOMP
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $15
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $16
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $17 - OBJ_SPINYCHEEP
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1A
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1C
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_HEIGHT16	; Object $1D
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1F - OBJ_GROWINGVINE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $20
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $21 - OBJ_POWERUP_ICEFLOWER #DAHRKDAIZ
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup00_Attributes2:
	.byte OA2_TDOGRP0	; Object $00
	.byte OA2_TDOGRP1	; Object $01
	.byte OA2_TDOGRP1	; Object $02
	.byte OA2_TDOGRP1	; Object $03
	.byte OA2_TDOGRP2	; Object $04
	.byte OA2_TDOGRP1	; Object $05
	.byte OA2_TDOGRP1	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA2_TDOGRP1	; Object $07 - OBJ_BRICK
	.byte OA2_TDOGRP1	; Object $08 - OBJ_COIN
	.byte OA2_TDOGRP1	; Object $09 - OBJ_BUBBLE
	.byte OA2_TDOGRP1	; Object $0A
	.byte OA2_TDOGRP1	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OA2_TDOGRP1	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA2_TDOGRP1	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA2_TDOGRP1	; Object $0E - OBJ_HARDICE
	.byte OA2_TDOGRP1	; Object $0F
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $10 OBJ_PIXIE
	.byte OA2_TDOGRP1	; Object $11
	.byte OA2_TDOGRP1	; Object $12
	.byte OA2_TDOGRP1	; Object $13
	.byte OA2_TDOGRP0	; Object $14
	.byte OA2_TDOGRP0	; Object $15
	.byte  OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $16
	.byte OA2_TDOGRP1	; Object $17 - OBJ_SPINYCHEEP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP12	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA2_TDOGRP1	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA2_TDOGRP1	; Object $1A
	.byte OA2_TDOGRP1	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA2_TDOGRP1	; Object $1C
	.byte OA2_TDOGRP2	; Object $1D
	.byte OA2_TDOGRP1	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA2_TDOGRP1	; Object $1F - OBJ_GROWINGVINE
	.byte OA2_TDOGRP1	; Object $20
	.byte OA2_TDOGRP1	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OA2_TDOGRP1	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA2_TDOGRP1	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) third set attribute bits

	; Attribute bits for objects:
	;	Bits 0-3: Determines what to do when gameplay halted (see Object_DoHaltedAction, most common is 5 / 0101)
	
	;	Bit 5: Object is NOT stompable (e.g. a spikey enemy, HURTS PLAYER, not same as attr 2 bit 2 which is just indifferent)
	;	Bit 6: The CollideJumpTable entry MAY contain the "special" entry; see CollideJumpTable; also "dies" into "shell" (state 3) (i.e. object "bumps" into shell when hit from beneath)
	;	Bit 7: If set, object cannot be tail attacked

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup00_Attributes3:
	.byte OA3_HALT_NORMALONLY 	; Object $00
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $01
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE	; Object $02
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $03
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $04
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE 	; Object $05
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $07 - OBJ_BRICK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $08 - OBJ_COIN
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE |OA3_NOTSTOMPABLE 	; Object $09 - OBJ_BUBBLE
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $0A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $0E - OBJ_HARDICE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $0F
	.byte OA3_HALT_NORMALONLY 	; Object $10 OBJ_PIXIE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_DIESHELLED 	; Object $11
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE  	; Object $12
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE  	; Object $13
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE  	; Object $14
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $15
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $16
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $17 - OBJ_SPINYCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE |OA3_NOTSTOMPABLE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA3_HALT_JUSTDRAW 	; Object $1A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $1C
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $1D
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $1F - OBJ_GROWINGVINE
	.byte  OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $20
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup00_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $00
	.byte OPTS_NOCHANGE; Object $01
	.byte OPTS_NOCHANGE	; Object $02
	.byte OPTS_NOCHANGE	; Object $03
	.byte OPTS_NOCHANGE	; Object $04
	.byte OPTS_SETPT5 | $0E	; Object $05
	.byte OPTS_NOCHANGE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OPTS_NOCHANGE	; Object $07 - OBJ_BRICK
	.byte OPTS_NOCHANGE	; Object $08 - OBJ_COIN
	.byte OPTS_NOCHANGE	; Object $09 - OBJ_BUBBLE
	.byte OPTS_SETPT5 | $0B	; Object $0A - OBJ_BULLY
	.byte OPTS_NOCHANGE	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OPTS_NOCHANGE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OPTS_NOCHANGE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OPTS_SETPT5 | $0F	; Object $0E - OBJ_HARDICE
	.byte OPTS_NOCHANGE	; Object $0F
	.byte OPTS_NOCHANGE | $33	; Object $10 OBJ_PIXIE
	.byte OPTS_NOCHANGE	; Object $11
	.byte OPTS_SETPT6 | $4F		; Object $12
	.byte OPTS_NOCHANGE	; Object $13
	.byte OPTS_SETPT5 | $0E	; Object $14
	.byte OPTS_NOCHANGE	; Object $15
	.byte OPTS_NOCHANGE	; Object $16
	.byte OPTS_SETPT5 | $1A	; Object $17 - OBJ_SPINYCHEEP
	.byte OPTS_SETPT5 | $3A	; Object $18 - OBJ_BOSS_BOWSER
	.byte OPTS_NOCHANGE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OPTS_SETPT5 | $1A	; Object $1A
	.byte OPTS_NOCHANGE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OPTS_NOCHANGE	; Object $1C
	.byte OPTS_NOCHANGE	; Object $1D
	.byte OPTS_NOCHANGE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OPTS_NOCHANGE	; Object $1F - OBJ_GROWINGVINE
	.byte OPTS_NOCHANGE 	; Object $20
	.byte OPTS_NOCHANGE	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OPTS_NOCHANGE	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OPTS_NOCHANGE	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup00_KillAction:
	.byte KILLACT_STANDARD	; Object $00
	.byte KILLACT_STANDARD	; Object $01
	.byte KILLACT_STANDARD	; Object $02
	.byte KILLACT_STANDARD	; Object $03
	.byte KILLACT_POOFDEATH	; Object $04
	.byte KILLACT_POOFDEATH	; Object $05
	.byte KILLACT_STANDARD	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte KILLACT_STANDARD	; Object $07 - OBJ_BRICK
	.byte KILLACT_STANDARD	; Object $08 - OBJ_COIN
	.byte KILLACT_STANDARD	; Object $09 - OBJ_BUBBLE
	.byte KILLACT_STANDARD	; Object $0A
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0C - OBJ_POWERUP_STARMAN
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte KILLACT_NORMALANDKILLED	; Object $0E - OBJ_HARDICE
	.byte KILLACT_STANDARD	; Object $0F
	.byte KILLACT_NORMALANDKILLED	; Object $10
	.byte KILLACT_STANDARD	; Object $11
	.byte KILLACT_STANDARD	; Object $12
	.byte KILLACT_STANDARD	; Object $13
	.byte KILLACT_STANDARD	; Object $14
	.byte KILLACT_NORMALSTATE	; Object $15
	.byte KILLACT_STANDARD	; Object $16
	.byte KILLACT_JUSTDRAW16X16	; Object $17 - OBJ_SPINYCHEEP
	.byte KILLACT_NORMALSTATE	; Object $18 - OBJ_BOSS_BOWSER
	.byte KILLACT_JUSTDRAWMIRROR	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte KILLACT_STANDARD	; Object $1A
	.byte KILLACT_STANDARD	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte KILLACT_STANDARD	; Object $1C
	.byte KILLACT_STANDARD	; Object $1D
	.byte KILLACT_STANDARD	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte KILLACT_STANDARD	; Object $1F - OBJ_GROWINGVINE
	.byte KILLACT_STANDARD	; Object $20
	.byte KILLACT_STANDARD	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte KILLACT_STANDARD	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte KILLACT_STANDARD	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) pattern index starts
	; These are used for all states except "normal"

OG0_POff .func (\1 - ObjectGroup00_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup00_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG0_POff(ObjP00), OG0_POff(ObjP01), OG0_POff(ObjP02), OG0_POff(ObjP03)
	.byte OG0_POff(ObjP04), OG0_POff(ObjP05), OG0_POff(ObjP06), OG0_POff(ObjP07)
	.byte OG0_POff(ObjP08), OG0_POff(ObjP09), OG0_POff(ObjP0A), OG0_POff(ObjP0B)
	.byte OG0_POff(ObjP0C), OG0_POff(ObjP0D), OG0_POff(ObjP0E), OG0_POff(ObjP0F)
	.byte OG0_POff(ObjP10), OG0_POff(ObjP11), OG0_POff(ObjP12), OG0_POff(ObjP13)
	.byte OG0_POff(ObjP14), OG0_POff(ObjP15), OG0_POff(ObjP16), OG0_POff(ObjP17)
	.byte OG0_POff(ObjP18), OG0_POff(ObjP19), OG0_POff(ObjP1A), OG0_POff(ObjP1B)
	.byte OG0_POff(ObjP1C), OG0_POff(ObjP1D), OG0_POff(ObjP1E), OG0_POff(ObjP1F)
	.byte OG0_POff(ObjP20), OG0_POff(ObjP21), OG0_POff(ObjP22), OG0_POff(ObjP23)

	; Object group $00 (i.e. objects starting at ID $00) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup00_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup00_PatternSets:
	; (End restricted alignment space)
ObjP00:
ObjP03:
	.byte $77, $77

ObjP07:
	.byte $67, $67, $97, $99

ObjP0E:
	.byte $99, $9B

ObjP0F:
ObjP10:
	.byte $91, $93, $95, $97, $99, $9B, $95, $97

ObjP11:
	.byte $69, $7D, $69, $7D, $69, $7D
ObjP12:
	.byte $D7, $D7, $ED, $ED, $FF, $FF
ObjP13:
ObjP16:
	.byte $81, $83, $85, $87, $89, $89, $87, $85, $C1, $C3, $C5, $C7, $C9, $C9, $C7, $C5
ObjP14:
ObjP15:
ObjP17:
ObjP18:	
ObjP1D:
ObjP20:
	.byte $97, $99, $9B, $9D, $A1, $AB, $A3, $A1, $A3, $AB, $A5, $A1, $A5, $AB, $A7, $A1
	.byte $D7, $D9, $DB, $DD, $E1, $EB, $E3, $E1, $E3, $EB, $E5, $E1, $E5, $EB, $E7, $E1

ObjP01:	.byte $F3, $F5, $F3, $F5, $BB, $BD, $BB, $BF
ObjP02:	.byte $95, $97, $8D, $8F
ObjP04:	.byte $F5, $F7, $B5, $B7
ObjP05:	.byte $95, $95, $97, $97
ObjP06:	
ObjP1B:	.byte $8B, $8D, $8F, $91, $89, $89, $91, $8F, $CB, $CD, $CF, $D1, $C9, $C9, $D1, $CF	; RAS: Not actually used, see BounceBlock_Tile
ObjP09:	
ObjP1A: .byte $8D, $8D, $8F, $8F, $91, $91, $A7, $A7, $A9, $A9, $AB, $AB
ObjP0A:	.byte $A9, $AB, $BD, $BF
ObjP0C:	.byte $51, $53, $51, $53, $51, $53, $51, $53
ObjP0B:	.byte $51, $53	; #DAHRKDAIZ changed 1Up to use a "Ninja Mushroom" sprite instead, separate from regular mushroom
ObjP0D:	.byte $51, $53
ObjP19:	.byte $51, $53
ObjP1C:	
ObjP1E:	.byte $51, $53
ObjP1F:	.byte $51, $53	; #DAHRKDAIZ - VINE
ObjP21:	.byte $51, $53
ObjP22:	.byte $51, $53 ; #DAHRKDAIZ - PUMPKIN
ObjP23:	.byte $51, $53	; #DAHRKDAIZ - GOLD LEAF
ObjP08:	.byte $BB, $BB, $FB, $F9, $FB, $F9, $FF, $FD, $DA, $DA

SpringPals: .byte SPR_PAL1, SPR_PAL2, SPR_PAL3
ObjInit_Spring:
	LDY Objects_Property, X
	LDA SpringPals, Y
	STA Objects_SprAttr,X
	RTS

Spring_Jump_Height:
	.byte $C0, $B4, $A8

Spring_Frames:
	.byte $00, $01, $02, $01

Spring_Player_YOffsets:
	.byte $20, $1C, $17, $1C

ObjNorm_Spring:
	JSR Object_ShakeAndDrawMirrored
	LDA <Player_HaltGame
	BNE Spring_RTS
	JSR Object_DeleteOffScreen
	JSR ObjectCarry
	LDY Objects_Var2, X
	LDA Spring_Frames, Y
	STA Objects_Frame, X
	
	JSR Object_Move
	LDA <Objects_DetStat,X
	AND #$04
	BEQ DontMoveSpring
	JSR Object_HitGround
	LDA #$00
	STA Objects_XVel, X

DontMoveSpring:
	LDA Objects_Var2, X
	BNE SpringAnim

	LDA <Player_YVel
	BEQ Spring_RTS
	BMI Spring_RTS

	JSR Object_HitTest
	BCC Spring_RTS
	LDA #$02
	STA Objects_Timer, X
	LDA #$03
	STA Objects_Var2, X
	LDA #$00
	STA Objects_Var3, X
	BEQ SpringAnim

Spring_RTS:
	RTS

SpringAnim:
	LDY Objects_Var2, X
	LDA Objects_Y, X
	SUB Spring_Player_YOffsets, Y
	STA <Player_Y
	LDA <Objects_YHi, X
	SBC #$00
	STA <Player_YHi
	LDA #$00
	STA <Player_YVel
	STA <Player_InAir

	LDA Objects_Timer, X
	BNE SpringAnimRTS
	LDA #$02
	STA Objects_Timer, X
	DEC Objects_Var2, X
	BNE SpringAnimRTS
	LDY Objects_Property, X
	LDA Spring_Jump_Height, Y
	STA <Player_YVel
	STA <Player_InAir
	LDA #$E0
	STA <Objects_YVel, X

SpringAnimRTS:
	RTS

ObjInit_Key:
	LDA #OBJSTATE_SHELLED
	STA Objects_State,X
	LDA #$E0
	STA <Objects_YVel, X
	RTS

ObjNorm_Key:
	
	RTS

PC_MemoryPoints:
	.word $6000
	.word $62F7
	.word $6307
	.word $6317
	.word $6327
	.word $6337
	.word $6347
	.word $7000
	.word $7000
	.word $7000

WorldDoorTiles:
	.byte $00, $1E

ObjNorm_PoisonClear:
	LDX World_Num
	LDA Mushrooms_Defeated, X
	BEQ ObjNorm_PoisonClearRTS
	STA <Temp_Var3

BlankTileOut:
	LDA <Temp_Var3
	ASL A
	TAX
	LDA PC_MemoryPoints, X
	STA <Temp_Var1
	LDA PC_MemoryPoints + 1, X
	STA <Temp_Var2
	LDY #$00
	LDX World_Num
	LDA WorldDoorTiles, X
	STA [Temp_Var1], Y
	INY
	STA [Temp_Var1], Y
	INY
	STA [Temp_Var1], Y
	INY
	STA [Temp_Var1], Y
	DEC <Temp_Var3
	BNE BlankTileOut

	
ObjNorm_PoisonClearRTS:
	LDX <SlotIndexBackup
	JMP Object_Delete

ObjInit_BounceDU: 
	LDA Level_BlkFinish
	STA Objects_Var2,X	 ; Store Player's bounce into var 2
	LDA Player_BounceDir
	STA Objects_Var3,X
	LDA #$00
	STA Level_BlkFinish

PRG001_A4C6:
	LDA Player_Bounce
	STA Objects_Var1,X	; Store Player_Bounce -> var1

	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 ; Shift right 4
	STA Objects_Frame,X	 ; Store into Objects_Frame 
 
	LDA #$00
	STA Player_Bounce	 ; Clear Player_Bounce
	STA Player_BounceObj	 ; Clear Player_BounceObj
	STA Objects_FlipBits,X	 ; Force left/right flag to zero
	STA Objects_SprVVis,X	 ; Clear flags 2
	STA Objects_SprHVis,X	 ; Clear flags 1

	LDA #10
	STA Level_BlkBump_Pos-6,X ; Block bump position = 10

	JMP BounceBlock_Update	 ; Jump to BounceBlock_Update

	; Power-up which may emerge from different types of bounce blocks

Bouncer_PUp:
	.byte $00, $00, OBJ_POWERUP_FIREFLOWER, OBJ_POWERUP_SUPERLEAF, OBJ_POWERUP_STARMAN, OBJ_POWERUP_MUSHROOM, OBJ_GROWINGVINE, OBJ_POWERUP_NINJASHROOM, OBJ_POWERUP_ICEFLOWER, OBJ_POWERUP_PUMPKIN, OBJ_POWERUP_FOXLEAF; #DAHRKDAIZ added OBJ_POWERUP_ICE

	; Power-up X or Y velocity upon emerging from the bounce block
Bouncer_PUpVel:	.byte $00, -$40, -$40, -$30, -$20, -$10, $00, $10, $20, $30, $40


ObjNorm_BounceDU:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_A56F	 ; If the block bump position > 0, jump to PRG001_A56F

	; Block bump complete
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	; Set state to dead/empty
	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Var1 >> 4 -> 'Y'

	LDA Objects_Var2,X

PRG001_A527:
	STA <Temp_Var12  ; -> Temp_Var12

	; Temp_Var15 = bumper X Hi
	LDA <Objects_XHi,X
	STA <Temp_Var15	 

	; Temp_Var16 = bumper X
	LDA <Objects_X,X
	STA <Temp_Var16	 

	; Temp_Var13 = bumper Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Temp_Var14 = bumper Y, grid aligned
	LDA <Objects_Y,X
	AND #$f0	
	STA <Temp_Var14	

	JSR BlockBump_Init

	LDA Objects_Var3,X
	BNE PRG001_A56E	 ; If Var 2 <> 0, jump to PRG001_A56E (RTS)

	LDA #-$38
	STA <Player_YVel	 ; Set Player bounce
	STA Player_mGoomba	 

	LDA Objects_Timer2,X
	BEQ PRG001_A56E	 ; If timer 2 expired, jump to PRG001_A56E (RTS)

	LDA #-$70
	STA <Player_YVel	; Larger Player bounce

	LDA Objects_Var1,X
	AND #$f0
	CMP #$10
	BNE PRG001_A56E	 ; If var 1 upper 4 bits <> $10, jump to PRG001_A56E (RTS)

	LDA Player_InWater
	BNE PRG001_A56E	 ; If Player is in water, jump to PRG001_A56E (RTS)

	; Flag to go to coin heaven
	LDA #$80
	STA Level_CoinHeav

	; Bounce into coin heaven sound
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

PRG001_A56E:
	RTS		 ; Return


PRG001_A56F:
	LDA Level_BlkBump_Pos-6,X
	CMP #10
	BNE PRG001_A5D5	 ; If Block bump position <> 10, jump to PRG001_A5D5

	; Block bump position is 10...

	LDA Objects_Var1,X
	AND #$0f
	TAY		 ; Y = 0 to 15, based on var 1

	LDA Bouncer_PUp,Y
	BEQ PRG001_A5BB	 ; If value is zero (no power up), jump to PRG001_A5BB

	LDY #$05	 ; Y = 5 (power-up always in slot 5)
	STA Level_ObjectID,Y

	; Set X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var1

	LDA #$08	 ; A = 8

	STY <Temp_Var2		 ; Backup 'Y' -> Temp_Var2

	LDY Objects_Var2,X
	BEQ PRG001_A5AA	 ; If var2 = 0, jump to PRG001_A5AA

	DEC <Temp_Var1	 ; Temp_Var1-- (Y Hi)
	LDA #-1		 ; A = -1

PRG001_A5AA:
	LDY <Temp_Var2	 ; Restore 'Y'

	ADD <Objects_Y,X ; Apply Y offset
	STA Objects_Y,Y	 ; -> Object's Y
 
	BCC PRG001_A5B6	 ; If no carry, jump to PRG001_A5B6

	INC <Temp_Var1	 ; Apply carry

PRG001_A5B6:
	; Set Y Hi
	LDA <Temp_Var1
	STA Objects_YHi,Y

PRG001_A5BB:
	; Backup Y Hi -> Temp_Var13 
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Backup Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14

	; Backup X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15

	; Backup X -> Temp_Var16
	LDA <Objects_X,X
	STA <Temp_Var16

	LDA Objects_Var2,X
	BEQ PRG001_A5D5	 ; If Var2 = 0, jump to PRG001_A5D5



PRG001_A5D5:
	JSR Object_ApplyYVel	 ; Apply Y velocity
	JSR BounceBlock_Update

	LDY Level_BlkBump_Pos-6,X	; Y = block bump pos

	LDA Bouncer_PUpVel,Y

	LDY Objects_Var3,X	 ; Y = var2
	BEQ PRG001_A5EE	 ; If Var2 = 0, jump to PRG001_A5EE

	JSR Negate	 ; Negate retrieved Y Velocity

	STA <Objects_YVel,X	; Set Y Velocity 

	JMP PRG001_A5FD	 ; Jump to PRG001_A5FD

PRG001_A5EE:
	STA <Objects_YVel,X	 ; Set Y Velocity 
	STA <Player_YVel	 ; ... of Player too

	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG001_A5FD	 ; If Player is not pressing A, jump to PRG001_A5FD

	; Otherwise, Timer 2 = 11
	LDA #$0b
	STA Objects_Timer2,X

PRG001_A5FD:
	DEC Level_BlkBump_Pos-6,X	; Block bump pos--
	RTS		 ; Return

	; The following block bounces are referenced by PRG008's LATR_BlockResult
	; Type 7 is for the UNUSED breakable pipeworks tile!

	; Palette select for a bounce block
BounceBlock_Pal:
	.byte SPR_PAL1	; 0 (possibly unused / Note Block)
	.byte SPR_PAL2	; 1 (coin heaven Note Block)
	.byte SPR_PAL3	; 2 ("Metal plate" post-? block hit)
	.byte SPR_PAL3	; 3 (used for empty brick)
	.byte SPR_PAL3	; 4 (typical Note Block)
	.byte SPR_PAL3	; 5 (wood)
	.byte SPR_PAL3	; 6 (used for brick with coins)
	.byte SPR_PAL1	; 7 (UNUSED, would be for desert's breakable pipeworks tile!)

	; Offset into Sprite_RAM based on which block bounce slot
BounceBlock_SprOff:
	.byte $08, $10

	; Tile for block bounce sprite (if same, mirrors)
BounceBlock_Tile:
	.byte $79, $79	; 0 (possibly unused / Note Block)
	.byte $79, $79	; 1 (coin heaven Note Block)
	.byte $6B, $6B	; 2 ("Metal plate" post-? block hit)
	.byte $67, $67	; 3 (used for empty brick)
	.byte $77, $77	; 4 (typical Note Block)
	.byte $7F, $7F	; 5 (wood)
	.byte $67, $69	; 6 (used for brick with coins)

BounceBlock_Update:
	LDA Objects_Var1,X	; Player_Bounce
	LSR A
	LSR A
	LSR A
	LSR A		; Get kind of block that is getting bounced
	TAY		; -> Y

	; Temp_Var1 stores palette of object
	LDA BounceBlock_Pal,Y	
	STA <Temp_Var1

	; Y *= 2
	TYA
	ASL A
	TAY

	; Temp_Var2/3 store the tiles that make up the sprites of the bounce block
	LDA BounceBlock_Tile,Y
	STA <Temp_Var2		
	LDA BounceBlock_Tile+1,Y
	STA <Temp_Var3		

	LDA #$00	 ; A = 0 (do not flip second sprite)

	LDY <Temp_Var2
	CPY <Temp_Var3
	BNE PRG001_A63F	 ; If tiles are NOT the same, jump to PRG001_A63F

	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (flip second sprite)

PRG001_A63F:
	STA <Temp_Var4	 ; Store the selected sprite attribute

	; Select own range of sprite area
	LDA #$05
	ADD Counter_7to0
	TAY		 ; Y = 5 + (0 to 7)

	LDA SprRamOffsets,Y
	PHA		 ; Save this value

	; Block bouncers always appear in object slot 6 or 7, so this makes it relative to 0 or 1
	TXA		 
	SUB #$06	 
	TAY		 ; Y = 0 or 1
 
	PLA		 ; Restore the value

	ADD BounceBlock_SprOff,Y
	TAY		 ; Y is now offset into Sprite_RAM

	; Screen-relative X position for sprite position
	LDA <Objects_X,X
	SUB Horz_Scroll	
	STA <Objects_SpriteX,X

	; Store two pieces of bounce block sprite X
	STA Sprite_RAM+3,Y
	ADD #$08	 
	STA Sprite_RAM+7,Y

	; Screen-relative Y position for sprite position
	LDA <Objects_Y,X
	SUB Level_VertScroll
	SUB #$01
	STA <Objects_SpriteY,X

	; Store two pieces of bounce block sprite Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Build the other parts of sprites
	LDA <Temp_Var2
	STA Sprite_RAM+1,Y

	LDA <Temp_Var3
	STA Sprite_RAM+5,Y

	LDA <Temp_Var1
	STA Sprite_RAM+2,Y

	ORA <Temp_Var4
	STA Sprite_RAM+6,Y

	RTS		 ; Return

ObjInit_BubbleGenerator:
	LDA #$01
	STA Objects_Var4, X

ObjInit_Bubble:
	LDA #$01
	STA ObjSplash_DisTimer, X
	LDA #$03
	STA Objects_Var1, X
	LDA Objects_Property, X
	BEQ ObjInit_BubbleRTS

	LDA #$1A
	STA PatTable_BankSel + 4
	LDA #$00
	STA Objects_Var1, X
	LDA #$08
	STA Objects_SlowTimer, X

ObjInit_BubbleRTS:
	LDA <Objects_Y, X
	STA Objects_Var2, X
	LDA <Objects_YHi, X
	STA Objects_Var3, X
	RTS		 ; Return


ObjNorm_Bubble:
	JSR Object_DeleteOffScreen

	LDA Objects_SlowTimer, X
	BNE BubbleRTS

	LDA Objects_Var1, X
	CMP #$03
	BEQ BubbleNorm
	BCS BubblePop

	LDA <Player_HaltGame
	BNE BubbleDraw
	
	LDA <Counter_1
	AND #$07
	BNE ObjNorm_Bubble1
	INC Objects_Var1, X

ObjNorm_Bubble1:
	LDA Objects_Var1, X
	STA Objects_Frame, X
	JMP Object_ShakeAndDrawMirrored

BubbleNorm:
	JSR Object_WorldDetect4
	LDA Objects_DetStat, X
	AND #HIT_DET_CEIL
	BNE BubbleNorm2
	LDA Objects_YVel, X
	CMP #$F8
	BEQ BubbleNorm1

	DEC Objects_YVel, X

BubbleNorm1:
	JSR Object_ApplyYVel

BubbleNorm2:
	LDA #$03
	STA Objects_Frame, X
	JSR Object_HitTestRespond

BubbleDraw:
	JSR Object_ShakeAndDrawMirrored
	LDY Object_SprRAM,X
	LDA Sprite_RAM +6, Y
	ORA #SPR_VFLIP
	STA Sprite_RAM +6, Y

BubbleRTS:
	RTS		 ; Return

BubblePop:
	LDA Objects_Var1, X
	STA Objects_Frame, X
	CMP #$05
	BEQ BubblePopped
	LDA <Counter_1
	AND #$07
	BEQ BubblePopRTS
	INC Objects_Var1, X
	LDA #$40
	STA Air_Time

BubblePopRTS:
	BNE  BubbleDraw
	RTS

BubblePopped:
	LDA Objects_Var4, X
	BEQ DestroyBubble
	LDA Objects_Var2, X
	STA Objects_Y, X
	LDA Objects_Var3, X
	STA Objects_YHi, X
	LDA #$00
	STA Objects_Var1, X
	LDA #$40
	STA Objects_SlowTimer, X
	RTS

DestroyBubble:
	JMP Object_SetDeadAndNotSpawned

ObjNorm_PUpNinjaShroom:
	LDA #$20
	STA SprAnimOffset
	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A78E	 	; If mushroom has not hit ground, jump to PRG001_A78E

	LDA <Objects_XVel,X
	BNE PRG001_A78E	 	; If mushroom is moving horizontally, jump to PRG001_A78E

	JSR PowerUp_BounceXVel	 ; Bounce off wall

PRG001_A78E:
	JSR Object_InteractWithWorld	 	; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen 		; Delete object if it falls off screen
	JMP PowerUp_DoHitTest	 		; Do hit test and don't come back!


ObjHit_NinjaShroom:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$0B
	BNE Do_Ninja_Power
	JMP PUp_GeneralCollect

Do_Ninja_Power:

	LDA #$0C
	JMP Do_PUp_Poof_Collect


Star_Palettes:
	.byte SPR_PAL0, SPR_PAL2, SPR_PAL2, SPR_PAL3

ObjInit_StarOrSuit:
	LDA Objects_Property, X
	BEQ ObjInit_StarOrSuit1
	STA From_Reserve

ObjInit_StarOrSuit1:
	LDA From_Reserve
	BEQ Do_Star_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	BNE Do_Star_Init2

Do_Star_Init:
	JSR Mushroom_SetFall	 ; Figure the way that the star should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ PRG001_A7BF	 
	LDY #-$38

	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X	 ; Set object's timer to $3d

PRG001_A7BF:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?

	JSR PowerUp_BounceXVel	 ; Bounce off wall

Do_Star_Init2:
	LDA PUp_StarManFlash
	AND #$03	 
	STA Objects_Frame,X
	TAY
	BEQ Star_RTS

	; Set a start palette
	LDA Star_Palettes,Y
	STA Objects_SprAttr,X
Star_RTS:
	RTS		 ; Return

SprStarAnimOffset: .byte $28, $0C, $10, $14

ObjNorm_StarOrSuit:

	LDA PUp_StarManFlash
	BNE PRG001_A7E0	 ; If flashing is not active, jump to PRG001_A7E0

	; Store counter into cycler
	LDA <Counter_1	
	STA Objects_ColorCycle,X

PRG001_A7E0:
	LDA PUp_StarManFlash
	AND #$03
	TAY
	LDA SprStarAnimOffset, Y
	STA SprAnimOffset

	LDA Objects_Property, X
	BNE PRG001_A7F1

	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world

	LDA <Objects_DetStat,X
	TAY		 ; Detection status -> 'Y'

	AND #$04
	BEQ PRG001_A7F1	 ; If star hasn't touched the ground, jump to PRG001_A7F1

	LDA #-$40
	STA <Objects_YVel,X	; Star bounce off ground!

PRG001_A7F1:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!

	; Different "frames" of the "Starman" power up include the super
	; suits; Tanooki, Frog, and Hammer, in order

ObjHit_StarOrSuit:
	LDA Objects_Frame,X
	BNE PRG001_A818	 ; If frame <> 0, jump to PRG001_A818

	LDA Level_PSwitchCnt
	BNE PRG001_A810	 ; If P-Switch is active, jump to PRG001_A810

	; Otherwise, play invincibility theme!
	LDA Sound_QMusic2
	ORA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2

PRG001_A810:

	; Player_StarInv = $E0
	LDA #$e0
	STA Player_StarInv

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect

PRG001_A818:

	LDA PUp_StarManFlash
	CLC
	ADC #$03	 ; Frame -> 'Y' (index)
	STA DAIZ_TEMP1
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP DAIZ_TEMP1
	BNE Do_Suit_Power
	JMP PUp_GeneralCollect

Do_Suit_Power:
	INC DAIZ_TEMP1
	LDA DAIZ_TEMP1
	JMP Do_PUp_Poof_Collect


ObjInit_PUpMush:
	LDA From_Reserve
	BEQ Do_Shroom_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	RTS

Do_Shroom_Init:
	JSR Mushroom_SetFall	 ; Figure the way that the mushroom should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; RAS: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A852	 ; If flashing is NOT active, jump to PRG001_A852

	JSR Mushroom_SetXVel	 ; Set's X velocity appropriately by Player's 

	LDY #-$38
	JSR Mushroom_SetUpVel	 ; Set vertical velocity and mid air flag
	JMP PRG001_A859		; Jump to PRG001_A859

PRG001_A852:

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ Mushroom_SetUpVel

PRG001_A859:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X

	RTS		 ; Return


Mushroom_SetUpVel:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return


Mushroom_SetXVel:
	LDY #$10	 ; Y = $10

	LDA <Player_X
	AND #$10	 ; determine if Player is on even/odd tile
	BNE PRG001_A86E	 ; Jump to PRG001_A86E if odd
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A86E:
	STY <Objects_XVel,X	 ; Set X velocity appropriately
	RTS		 ; Return


ObjNorm_PUpMush:
	LDA #$00
	STA SprAnimOffset
	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A881	 ; If mushroom has NOT hit the ground, jump to PRG001_A881

	LDA <Objects_XVel,X
	BNE PRG001_A881	 ; If mushroom hasn't hit a wall, jump to PRG001_A881

	JSR PowerUp_BounceXVel	 ; Otherwise, bounce off wall!

PRG001_A881:
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PowerUp_DoHitTest:
	; Cannot collect power up while it's "raising"
	LDA Objects_Timer2,X
	BNE PRG001_A892	 ; If the timer is still active, jump to PRG001_A892 (RTS)

	JSR Object_HitTestRespond	 ; Otherwise, perform hit testing

PRG001_A892:
	RTS		 ; Return

ObjHit_PUpMush:

	; Temp_Var = 1
	LDA #$01
	STA <Temp_Var1

PRG001_A897:
	LDA <Player_Suit
	BEQ Do_Grow
	LDA Player_Equip
	CMP #$07
	BNE Just_Collect
	LDA #$01
	STA PowerUp_Reserve
Just_Collect:
	JMP PUp_GeneralCollect	; If Player is not small, jump to PUp_GeneralCollect

Do_Grow:
	LDA #$02
	STA Player_QueueSuit

PRG001_A8AB:

	; Do "growing" animation
	LDA #$2f
	STA Player_Grow

PUp_GeneralCollect:
	JSR PowerUp_PlaySound	 ; Play Power Up sound
	LDA #OBJSTATE_DEADEMPTY
	LDX <SlotIndexBackup
	STA Objects_State, X	 ; Set power-up to dead/empty

	RTS		 ; Return

PowerUp_PlaySound:
	; Play the standard "Power Up" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	RTS		 ; Return

PowerUp_DoRaise:
	LDA PowerUp_NoRaise
	BEQ PowerUp_DoRaise1
	LDA #$00
	STA PowerUp_NoRaise
	STA Objects_Timer, X

PowerUp_DoRaise1:
	LDA Objects_Timer,X
	BEQ PRG001_A940	 ; If timer expired, jump to PRG001_A940 (will NOT return here if game is halted)

	CMP #$2d
	BNE PRG001_A8D5	 ; If object timer <> $2D, jump to PRG001_A8D5

	; Play powerup rising sound
	LDA Sound_QLevel1
	ORA #SND_LEVELRISE
	STA Sound_QLevel1

PRG001_A8D5:
	BGE PRG001_A93D	 ; If timer is >= $2D, jump to PRG001_A93D

	; ObjSplash_DisTimer = 8
	LDA #$08
	STA ObjSplash_DisTimer,X

	DEC Objects_Var1,X	 ; Objects_Var1--
	BPL PRG001_A8F7	 ; If Objects_Var1 >= 0, jump to PRG001_A8F7

	; When var 1 falls below 0, reset to 2
	LDA #$02
	STA Objects_Var1,X

	LDA <Player_HaltGame
	BNE PRG001_A8F7	 ; If game is halted, jump to PRG001_A8F7


	; Game not halted...

	; Move powerup up 1 pixel
	LDA <Objects_Y,X
	SUB #$01
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

PRG001_A8F7:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	LDA Level_PipeMove
	BNE PRG001_A937	 ; If starman flashing or Player in pipe, jump to PRG001_A937 (no masking sprite)

	LDY #$00	 ; Y = 0

	JSR Object_AnySprOffscreen
	BNE PRG001_A937	 ; If any sprite is off-screen, jump to PRG001_A937 (no masking sprite)

	; This puts on the masking sprite over the raising powerup

	LDA <Objects_Y,X
	AND #$f0	 	; Align object Y to tile
	ADD #$0f	 	; +15
	SUB Level_VertScroll	; Calc relative to vertical scroll

	; Set for both sprite halves Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Masking tile
	LDA #$67
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+5,Y

	; Set sprite priority
	LDA #%00100000
	STA Sprite_RAM+2,Y
	STA Sprite_RAM+6,Y

	; Set sprite X's side by side
	LDA Objects_SpriteX,X
	STA Sprite_RAM+3,Y
	ADD #$08
	STA Sprite_RAM+7,Y

PRG001_A937:
	JSR PowerUp_DoHitTest	 ; Hit test power up when it has emerged from the box
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PRG001_A93D:

	; Do NOT return to caller!
	PLA
	PLA

	RTS		 ; Return

PRG001_A940:
	LDA <Player_HaltGame
	BEQ PRG001_A949	 ; If game is NOT halted by Player, jump to PRG001_A949

	; Draw mushroom if game halted
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	; Do NOT return to caller!! (JSR could've been a JMP?)
	PLA
	PLA

PRG001_A949:
	RTS		 ; Return

	; Determines which way a mushroom should fall based on Player's position
Mushroom_SetFall:
	LDY #$00	 ; Y = 0 (mushroom falls to the left)

	LDA <Objects_X,X
	SUB <Horz_Scroll	; Make X relative to screen
	CMP <Player_SpriteX	
	BLT PRG001_A956	 	; If object X is less than Player's X, jump to PRG001_A956

	INY		 	; Otherwise, Y = 1 (mushroom falls to the right)

PRG001_A956:
	STY Player_MushFall	; Set direction of mushroom fall
	RTS		 ; Return

PowerUp_BounceXVel:
	LDY #$10	 ; Y = $10

	LDA Player_MushFall	
	BNE PRG001_A963	 ; If falling to right, jump to PRG001_A963
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A963:
	STY <Objects_XVel,X	 ; Set X velocity appropriately


	RTS		 ; Return

ObjInit_FireFlower:
	LDA From_Reserve
	BEQ Do_Fire_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	RTS

Do_Fire_Init:
	LDA #$10
	STA Objects_Timer2,X	 ; Fire flower's timer 2 = $10

	; RAS: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A9C8	 ; If flashing is NOT active, jump to PRG001_A852

	; Strangely, the Big ? flower will "move over"; probably a partially developed idea??
	; Or they just accidentally leftover stuff from mushroom
	JSR Mushroom_SetXVel
	JMP PRG001_A9CF	 ; Jump to PRG001_A9CF

PRG001_A9C8:

	; This will make flower drop downward if it was "knocked out" downward
	LDY #$10
	LDA Player_BounceDir
	BEQ PRG001_A9D5	

PRG001_A9CF:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X
	RTS		 ; Return

PRG001_A9D5:
	; Knock flower downward
	STY <Objects_YVel,X	; Y Vel = $10
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return

ObjNorm_FireFlower:
	LDA #$04
	STA SprAnimOffset
	BNE ObjNorm_FireFlower1

ObjNorm_IceFlower:
	LDA #$18
	STA SprAnimOffset

ObjNorm_FireFlower1:
	LDA PUp_StarManFlash
	BPL PRG001_A9E4	 ; If there's no star man flash going on, jump to PRG001_A9E4

	; Otherwise, color cycle (?)
	LDA <Counter_1
	STA Objects_ColorCycle,X

PRG001_A9E4:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA <Objects_YVel,X
	BNE PRG001_A9F6	 ; If Y Velocity <> 0, jump to PRG001_A9F6

	STA <Objects_XVel,X	 ; Otherwise, halt horizontal movement too

PRG001_A9F6:
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!


ObjHit_FireFlower:

	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$02
	BNE Do_Fire_Power
	JMP PUp_GeneralCollect

Do_Fire_Power:
	LDA #$03
	JMP Do_PUp_Pallete_Collect

PRG001_AA41:
	.byte $1C, $0E, $1C, $14, $18, $0A, $18, $17



	; Values used by the leaf based on bounce direction
Leaf_YVels:	.byte $04, $E0, $E0, $E0
Leaf_TimerVals:	.byte $08, $FF, $FF, $FF

ObjInit_SuperLeaf:
	LDA From_Reserve
	BEQ Do_Leaf_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	LDA #$14
	STA Objects_Timer + 5
	RTS

Do_Leaf_Init:
	LDA #$00
	STA <Objects_XVel,X	 ; Halt X velocity
	STA Objects_Var2,X	 ; Var2 = 0

	LDA #$0c	; A = $C (top spawn offset)

	LDY Player_BounceDir
	BEQ PRG001_ABA9	 ; If Player bounce down, jump to PRG001_ABA9

	LDA #-$0d	; A = -$D (bottom spawn offset)

	DEC <Objects_YHi,X	

PRG001_ABA9:
	ADD <Objects_Y,X
	STA <Objects_Y,X	 ; Set object Y

	BCC PRG001_ABB2	 	; If there's no carry, jump to PRG001_ABB2

	INC <Objects_YHi,X	 ; Otherwise, apply carry

PRG001_ABB2:
	; Set appropriate timer value (used to figure how far up the leaf needs to go)
	LDA Leaf_TimerVals,Y
	STA Objects_Timer,X

	; Set Y velocity
	LDA Leaf_YVels,Y
	STA <Objects_YVel,X

	; Timer2 = $10
	LDA #$10
	STA Objects_Timer2,X

	LDA PUp_StarManFlash
	BEQ PRG001_ABCC	; If leaf did not come from big ? block, jump to PRG001_ABCC

	; Otherwise, be green!!  (What IS this about anyway?)
	LDA #$02
	STA Objects_SprAttr,X

PRG001_ABCC:
	RTS		 ; Return

Leaf_XVelByOsc:	.byte $02, -$02
Leaf_XVelLimit:	.byte $20, -$20

PRG001_ABD1:
	.byte $0A, -$0A, $08

ObjNorm_FoxLeaf:
	LDA #$24
	STA SprAnimOffset
	BNE ObjNorm_SuperLeaf1

ObjNorm_SuperLeaf:
	LDA #$08
	STA SprAnimOffset

ObjNorm_SuperLeaf1:
	LDA Objects_Timer,X
	BEQ PRG001_ABEC	 ; If timer expired, jump to PRG001_ABEC

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity
	INC <Objects_YVel,X	 ; YVel ++

	LDA <Objects_YVel,X
	CMP #$00
	BEQ PRG001_ABE7	 ; If Super Leaf Y Vel = 0, jump to PRG001_ABE7

	JMP PRG001_AC15	 ; Jump to PRG001_AC15

PRG001_ABE7:

	; Reset timer
	LDA #$00
	STA Objects_Timer,X

PRG001_ABEC:
	LDA Objects_Var2,X
	AND #$01
	TAY		 ; Y = 0 or 1 (which oscillation direction)

	; Add appropriate X velocity for oscillation direction
	LDA <Objects_XVel,X
	ADD Leaf_XVelByOsc,Y
	STA <Objects_XVel,X

	CMP Leaf_XVelLimit,Y
	BNE PRG001_AC02	 ; If leaf has not hit X Vel limit, jump to PRG001_AC02

	INC Objects_Var2,X	 ; Switch oscillation direction

PRG001_AC02:
	LDA <Objects_XVel,X
	BPL PRG001_AC07	 ; If leaf is moving to the right, jump to PRG001_AC07

	INY		 ; Otherwise, Y++ (makes Y = 2)

PRG001_AC07:
	LDA PRG001_ABD1,Y
	ADD #$06	 	; Value +6
	STA <Objects_YVel,X	; -> Y Velocity

	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

PRG001_AC15:
	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (horizontal flip)

	LDY <Objects_XVel,X
	BEQ PRG001_AC22	 ; If leaf X Vel = 0, jump to PRG001_AC22 (don't change flip at midpoint)
	BPL PRG001_AC1F	 ; If leaf X Vel > 0, jump to PRG001_AC1F

	LDA #$00	 ; A = 0 (not horizontally flipped)

PRG001_AC1F:
	STA Objects_FlipBits,X	 ; Set flip

PRG001_AC22:
	JSR Object_ShakeAndDraw	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!



ObjHit_SuperLeaf:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$03
	BNE Do_Leaf_Power
	JMP PUp_GeneralCollect

Do_Leaf_Power:
	LDA #$04
	
	JMP Do_PUp_Poof_Collect
	
ObjInit_Vine:
	LDA #SPR_BEHINDBG
	STA Objects_FlipBits,X
	LDA #$00
	STA PUp_StarManFlash
	LDA Objects_X, X
	AND #$F0
	STA Objects_X, X
	RTS		 ; Return

	; Stores the high byte of the VRAM address
Vine_NTHigh:	.byte $20, $28

ObjNorm_Vine:
	LDA #$2C
	STA SprAnimOffset
	; Vine moves at Y Vel = -$10
	LDA #-$10
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	; Apply Y Velocity

	LDA <Objects_YHi,X
	BMI PRG001_AC80	 ; If vine goes off absolute top, jump to PRG001_AC80

	JSR Object_WorldDetectN1 ; Detect against world

	LDA Object_TileFeetProp
	AND #$C0
	BEQ PRG001_AC86	 ; If vine is not within the solid tiles, jump to PRG001_AC86

PRG001_AC80:

	; Set vine to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

PRG001_AC86:
	LDA <Objects_Y,X
	AND #$0f
	BNE PRG001_AC92	 ; If vine has NOT covered a new tile, jump to PRG001_AC92
 
	STA Objects_FlipBits,X	; Clears flip bits
	JSR Vine_Set8x8s	; Instant graphics update while vine moves

PRG001_AC92:
	JMP Object_ShakeAndDrawMirrored	 ; Draw sprite and don't come back!

Vine_Set8x8s:
	LDA <Objects_XHi,X
	ASL A		 ; Convert X Hi into 2 byte index
	TAY		 ; -> 'Y'

	; Get address of screen Vine is on (NOTE: Non-vertical level only!)
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var2	

	LDA <Objects_YHi,X
	BEQ PRG001_ACA9	 ; If vine is not on lower area of screen, jump to PRG001_ACA9

	INC <Temp_Var2	 ; Select address of lower tiles

PRG001_ACA9:
	LDA <Objects_Y,X
	AND #$f0	 ; Get current "row" of vine object
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA <Objects_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3	 ; Merge column into lower 4 bits

	TAY		 ; -> 'Y'

	; Change tile to vine tile
	
	LDA VineGrowthTile
	STA [Temp_Var1],Y

	LDA Objects_SprHVis,X
	CMP #$03
	BGE PRG001_AD23	; If vine object is off-screen horizontally, jump to PRG001_AD23 (RTS)

	LDA <Objects_Y,X	 ; A = Objects_Y

	LDY <Objects_YHi,X
	BNE PRG001_ACCE	 ; If the vine is on the low part of the screen, jump to PRG001_ACCE

	CMP #240
	BLT PRG001_ACD1	 ; If Y < 240, jump to PRG001_ACD1

	INY		 ; Y = 1 (uses the next nametable address in Vine_NTHigh)

PRG001_ACCE:
	ADD #16	 	; Next row

PRG001_ACD1:
	ASL A	
	ADC #$00
	ASL A	
	ADC #$00

	PHA		 ; Save VRAM column offset

	AND #$03	; Keep address from going out of range
	ORA Vine_NTHigh,Y	 ; Set the high bits

	LDY Graphics_BufCnt	 ; Y = current graphics buffer count

	; Set two rounds of high byte 
	STA Graphics_Buffer,Y	 
	STA Graphics_Buffer+5,Y	

	PLA		 ; Restore VRAM column offset
 
	AND #$c0
	STA <Temp_Var1

	; Store left column update
	LDA <Objects_X,X
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var1
	STA Graphics_Buffer+1,Y

	; Store right column update
	ADD #$01
	STA Graphics_Buffer+6,Y

	LDA #$82
	STA Graphics_Buffer+2,Y
	STA Graphics_Buffer+7,Y

	; Vine left 8x8 tiles
	LDA VineTiles
	STA Graphics_Buffer+3,Y
	LDA VineTiles + 2
	STA Graphics_Buffer+4,Y

	; Vine right 8x8 tiles
	LDA VineTiles + 1
	STA Graphics_Buffer+8,Y
	LDA VineTiles + 3
	STA Graphics_Buffer+9,Y

	LDA #$00
	STA Graphics_Buffer+10,Y

	; Update run count
	TYA
	ADD #$0a	 ; Count += 10
	STA Graphics_BufCnt

PRG001_AD23:
	RTS		 ; Return

	; Basically this bumps the object up by 1 pixel...
ObjInit_Coin:
	LDA #$00
	STA PowerUp_NoRaise
 	RTS		 ; Return

ObjInit_WarpHide:
	LDA Map_Got13Warp
	BEQ PRG001_AD37	 ; If Player didn't already get the 1-3 warp whistle, jump to PRG001_AD37

	; Otherwise, kill it!
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

PRG001_AD37:
	RTS		 ; Return


ObjNorm_Coin:
	LDA <Player_HaltGame
	BNE DrawCoin

	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_WorldDetect4
	JSR Object_HitTestRespond

	LDA <Objects_DetStat,X
	AND #$04
	BEQ DrawCoin
	JSR Object_HitGround

DrawCoin:
	LDA Objects_SprHVis, X
	ORA Objects_SprVVis, X
	BNE Coin_RTS

	JSR Object_ShakeAndCalcSprite
	LDX <SlotIndexBackup
	LDY Object_SprRAM, X
	LDA #$49
	STA Sprite_RAM + 1, Y
	LDA #SPR_PAL3
	STA Sprite_RAM + 2, Y
	LDA <Objects_SpriteY, X
	STA Sprite_RAM, Y
	LDA <Objects_SpriteX, X
	STA Sprite_RAM + 3, Y
	
Coin_RTS:
	RTS

ObjHit_Coin:
	INC Coins_Earned
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State, X
	RTS

ObjHit_IceFlower:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$07 
	BNE Do_Ice_Power
	JMP PUp_GeneralCollect

Do_Ice_Power:

	LDA #$08
	JMP Do_PUp_Pallete_Collect

ObjHit_Pumpkin:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$0A
	BNE Do_Boo_Power
	JMP PUp_GeneralCollect

Do_Boo_Power:
	LDA #$0B
	JMP Do_PUp_Poof_Collect

ObjHit_FoxLeaf:
	JSR Try_PUp_Reserve
	LDA Effective_Suit
	CMP #$08
	BNE Do_Fox_Power
	JMP PUp_GeneralCollect

Do_Fox_Power:
	LDA #$09
	JMP Do_PUp_Poof_Collect

	; This is a fairly general "march" function, but it is only 
	; applied to one object here, the unused collectable card...

PRG001_ADE2:
	RTS

	; Aligns object that impacts the ground onto the floor
Object_HitGroundAlign:
	LDA <Objects_DetStat,X 
	AND #$04
	BEQ PRG001_ADE2	 ; If object did not hit ground, jump to PRG001_ADE2 (RTS)
 
	JMP Object_HitGround	 ; Otherwise, jump to Object_HitGround

Koopaling_Palettes:

ObjInit_Koopaling:

ObjHit_Koopaling:

ObjInit_Bowser:

	; Bowser takes 34 fireball hits!
	LDA #$01
	STA Objects_HitCount,X

	; Bowser is giant!
	INC Objects_IsGiant,X

	RTS		 ; Return


	; X Velocity applied to Player when bouncing off Bowser's head
Bowser_HeadBounceXVel:	.byte $10, -$10

ObjNorm_Bowser:

	; Set Bowser's pattern table selections
	LDA #$3a
	STA PatTable_BankSel+4
	LDA #$3b
	STA PatTable_BankSel+5

	LDA <Player_HaltGame
	BNE PRG001_B8D3	 ; If gameplay is halted, jump to PRG001_B8D3

	LDA Bowser_Counter1
	BEQ PRG001_B8A1	 ; If Bowser_Counter1 = 0, jump to PRG001_B8A1

	DEC Bowser_Counter1	 ; Bowser_Counter1--

PRG001_B8A1:
	LDA Bowser_Counter2
	AND #%00011111	 
	BEQ PRG001_B8AB	 ; Every 32 ticks of Bowser's second counter, jump to PRG001_B8AB

	DEC Bowser_Counter2	 ; Bowser_Counter2--

PRG001_B8AB:
	JSR Bowser_DoVar5Action	; Do Bowser's internal state action
	JSR Bowser_HopAndBreatheFire	; Bowser hops and breathes fireballs
	JSR Player_HitEnemy	 	; Do hit detection

	LDA Objects_PlayerHitStat,X
	BEQ PRG001_B8D3		; If Player hasn't hit Bowser, jump to PRG001_B8D3

	; Player hit Bowser...

	; Set timer 2 to 8
	LDA #$08
	STA Objects_Timer2,X

	LDA <Player_YVel
	BMI PRG001_B8D3	 ; If Player is moving upward, jump to PRG001_B8D3

	; Player bounces off Bowser's head!
	LDA #-$30
	STA <Player_YVel

	JSR Bowser_CalcPlayersSide	 ; Calculate the side of his head Player bounced off of

	; Apply an X Velocity when bouncing off Bowser's head
	LDA Bowser_HeadBounceXVel,Y
	STA <Player_XVel

	; Bounce sound
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

PRG001_B8D3:
	LDA <Objects_Var5,X
	BEQ PRG001_B8E0	 ; If the internal state = 0 (waiting to meet Player), jump to PRG001_B8E0

	JSR Bowser_Draw	 ; Draw Bowser!

	LDA <Objects_Var5,X	
	CMP #$01	 
	BEQ PRG001_B8E5	 ; If internal state = 1, jump to PRG001_B8E5 (RTS)

PRG001_B8E0:

	; Otherwise, mark Bowser as totally invisible horizontally (??)
	LDA #$ff
	STA Objects_SprHVis,X

PRG001_B8E5:
	RTS		 ; Return

Bowser_DoVar5Action:
	LDA <Objects_Var5,X
	JSR DynJump	 ; Jump dynamically by Objects_Var5

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_WaitForPlayer	; Internal state 0: Bowser waiting for Mario/Luigi to show up...
	.word Bowser_DoMovements	; Internal state 1: Bowser movements (jumping, busting floor, etc.)
	.word Bowser_FallAndSplat	; Internal state 2: Bowser fall (until he hits bottom, ba-bam! Only if dead, though)
	.word Bowser_WaitAndVictory	; Internal state 3: Wait until timer expires, then play victory song
	.word Bowser_DoTimeBonus	; Internal state 4: Convert remaining time to score
	.word Bowser_DoorAppear		; Internal state 5: Final door appears

Bowser_WaitForPlayer:
	LDA Objects_SprHVis,X
	BNE PRG001_B928	 ; If any of Bowser's sprites are horizontally off-screen, jump to PRG001_B928 (RTS)

	LDA <Horz_Scroll
	CMP #$07
	BGE PRG001_B928	 ; If Horz_Scroll >= 7, jump to PRG001_B928 (RTS)

	; Player got close enough; lock horizontal scroll and stop Player from moving
	LDA #$00
	STA <Horz_Scroll
	STA <Player_XVel

	; Player must land first
	LDA <Player_InAir
	BNE PRG001_B928	 ; If Player is midair, jump to PRG001_B928 (RTS)

	; Vert_Scroll = $EF (lowest scroll point)
	LDA #$ef
	STA <Vert_Scroll

	; Play Bowser's Theme
	LDA #MUS2B_BOWSER
	STA Sound_QMusic2

	INC LevelVertJct	 ; LevelVertJct = 1 (set like in a Big Question block area, i.e. no horizontal scrolling)

	; Lock vertical scroll
	LDA #$02
	STA Level_FreeVertScroll

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

	; Timer 3 = $30
	LDA #$30	 
	STA Objects_Timer3,X

	; Internal state = 1
	INC <Objects_Var5,X

PRG001_B928:
	RTS		 ; Return


Bowser_DoMovements:
	JSR Bowser_HandleIfDead	 ; Handle Bowser if he got killed

	LDA Level_NoStopCnt
	AND #%00011111
	ORA Bowser_Counter1
	BNE PRG001_B948	 ; If Bowser Counter 1 > 0 and except every 32nd tick, jump to PRG001_B948

	; Only when Bowser Counter 1 is expired and every 32 ticks of the no stop counter...

	LDA Objects_FlipBits,X

	PHA		 ; Save Bowser's flip bits

	JSR Bowser_FacePlayer	 ; Bowser face Player

	PLA		 ; Restore Bowser's flip bits

	CMP Objects_FlipBits,X
	BEQ PRG001_B948	 ; If Bowser has NOT changed facing direction, jump to PRG001_B948

	; Bowser changed facing direction

	; Set some bits on Bowser's Counter 2
	ORA #$13
	STA Bowser_Counter2

PRG001_B948:
	LDA <Objects_Var4,X
	JSR DynJump	 ; Jump dynamically by var 4

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_FallToFloor	; 0: Fall to floor
	.word Bowser_JumpAndLandOnFloor	; 1: Jump and land on floor
	.word Bowser_AlignAndFall	; 2: Align to tile on the way down (will also use part of Bowser_JumpAndLandOnFloor)
	.word Bowser_BustFloorLookAround; 3: Bowser busts floor and looks around

PRG001_B955:	.byte $08, $05, $04, $05, $08
PRG001_B95A:	.byte $40, $40, $00, $00, $00


Bowser_FallToFloor:
	JSR Bowser_Counter3Do	 ; Update Bowser_Counter3

	LDA Bowser_Counter2
	AND #$1f	 
	BEQ PRG001_B97C	 ; Every 32 ticks of Bowser_Counter2, jump to PRG001_B97C

	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, slower rate than Bowser_Counter2

	LDA Bowser_Counter2
	AND #SPR_HFLIP
	EOR PRG001_B95A,Y
	STA Objects_FlipBits,X

	LDA PRG001_B955,Y

PRG001_B97C:
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BNE PRG001_B9B5	 ; If timer is not expired, jump to PRG001_B9B5

	JSR Bowser_DetectTiles	 ; Detect the tiles under Bowser

	; Bowser fall up to $40 Y Velocity...
	LDA <Objects_YVel,X
	CMP #$40	 
	BGS PRG001_B98F	 ; If Bowser's Y Velocity >= $40, jump to PRG001_B98F

	INC <Objects_YVel,X	 ; Bowser's gravity

PRG001_B98F:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_B9A4	 ; If Bowser has NOT hit floor, jump to PRG001_B9A4 (RTS)

	JSR Object_HitGround	 ; Align to floor

	LDA #$10	; A = $10

	LDY Objects_Timer3,X
	BNE PRG001_B9A1	 ; If Timer 3 is not expired, jump to PRG001_B9A1

	LDA #$b0	 ; A = $B0

PRG001_B9A1:
	; Set Timer as appropriate
	STA Objects_Timer,X

PRG001_B9A4:
	RTS		 ; Return

	; Base X velocities by Player's distance away from Bowser when he attempts to jump and land on you
Bowser_XVelByDist:
	.byte $08, $10, $18, $20, $28, $30, $38, $40, $48, $50, $50, $50, $50, $50, $50, $50

PRG001_B9B5:
	LDA Bowser_Counter2 
	AND #$1f 
	BNE PRG001_B9BF	 ; Only continue 1:32 ticks, otherwise jump to PRG001_B9BF
 
	INC Objects_Frame,X	 ; Bowser's frame++

PRG001_B9BF:
	LDA Objects_Timer,X 
	CMP #$01 
	BEQ PRG001_B9F3	 ; If timer expired, jump to PRG001_B9F3

	CMP #$80 
	BNE PRG001_B9F2	 ; If timer <> $80, jump to PRG001_B9F2 (RTS) 

	; Jump and land on floor mode
	LDA #$01 
	STA <Objects_Var4,X
 
	; Bowser jump!
	LDA #-$60 
	STA <Objects_YVel,X
 
	JSR Bowser_CalcPlayersSide 
	STY <Temp_Var1		 ; Temp_Var1 = 0 or 1, depending on side Player is on
 
	; Get absolute value of X difference
	LDA <Temp_Var16 
	BPL PRG001_B9DE 
	JSR Negate 
PRG001_B9DE:

	LSR A 
	LSR A 
	LSR A 
	LSR A 
	AND #$0f 
	TAY		 ; Y = 0 to 15, number of tiles away Player is
 
 
	; Calculate Bowser's X velocity to target Player!
	LDA Bowser_XVelByDist,Y
	LDY <Temp_Var1 
	DEY	
	BNE PRG001_B9F0 
	JSR Negate
PRG001_B9F0: 
	STA <Objects_XVel,X 

PRG001_B9F2:
	RTS		 ; Return

PRG001_B9F3:
	; Little hop
	LDA #-$10 
	STA <Objects_YVel,X
 
	RTS		 ; Return

	; Used as a bit 7 invert to determine if Bowser is moving 
	; away from or towards the Player
Bowser_VsPlayerXVelNegBit:
	.byte $00, $80


Bowser_JumpAndLandOnFloor:
	LDA <Objects_YVel,X	 
	BPL PRG001_BA01	 ; If Bowser is on floor or falling, jump to PRG001_BA01

	JSR Bowser_Counter3Do	 ; Update Bowser's Counter 3

PRG001_BA01:

	; Bowser frame 0
	LDA #$00
	STA Objects_Frame,X

	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	BMI PRG001_BA11	 ; If Bowser is moving upward (jumping), jump to PRG001_BA11

	CMP #$50	 
	BGE PRG001_BA17	 ; If Bowser Y velocity >= $50, jump to PRG001_BA17

PRG001_BA11:

	; Bowser fall rate Y Vel += 3
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BA17:

	LDA <Objects_YVel,X
	BPL PRG001_BA1F	 ; If Bowser is not moving upward, jump to PRG001_BA1F

	CMP #-$20
	BLT PRG001_BA4B	 ; If Bowser is moving upward faster than -$20, jump to PRG001_BA4B

PRG001_BA1F:

	; Bowser not moving upward... or not moving upward fast enough

	JSR Bowser_CalcPlayersSide	 ; Figure out which side Player is on

	LDA Bowser_VsPlayerXVelNegBit,Y
	EOR <Objects_XVel,X
	BPL PRG001_BA4B	 ; If Bowser's velocity is moving away from Player, jump to PRG001_BA4B

	JSR Level_ObjCalcYDiffs	 

	DEY		 ; Y--
	BEQ PRG001_BA4B	 ; If Y was 1, jump to PRG001_BA4B

	; Var4 = 2
	LDA #$02
	STA <Objects_Var4,X

	; Timer = $0A
	LDA #$0a
	STA Objects_Timer,X

	; Calculate an X position that targets Player and aligned to tile
	LDA <Objects_X,X
	ADD #$08
	AND #$f0
	STA Objects_TargetingXVal,X

	; Bowser jump!
	LDA #-$20
	STA <Objects_YVel,X

	; Stop Bowser's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG001_BA4B:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BA76	 ; If Bowser has NOT hit floor, jump to PRG001_BA76

	; Bowser has hit floor...

	JSR Object_HitGround	 ; Align to floor ('A' = 0 at the end of this, hence the following assignment)

	STA <Objects_XVel,X	 ; Stop Bowser's horizontal movement

	; Vibrate floor from impact
	LDA #$2c
	STA Level_Vibration

	; Ba-bam sound!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Object timer = $35
	LDA #$35
	STA Objects_Timer,X

	LDA RandomN,X
	AND #$1f	
	ADC #$67	
	STA Objects_Timer3,X	 ; Timer 3 = Random $67 to $86
	STA Objects_Var7,X	 ; -> Var7

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

PRG001_BA76:
	RTS		 ; Return


Bowser_AlignAndFall:
	; Reset Bowser Counter 1
	LDA #$00
	STA Bowser_Counter1

	; Set Bowser to frame 6 (Bowser's falling frame)
	LDA #$06
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ PRG001_BA96	; If timer expired, jump to PRG001_BA96

	LDA <Objects_X,X
	CMP Objects_TargetingXVal,X
	BEQ PRG001_BA95	; If Bowser reached the alignment X, jump to PRG001_BA95

	; Bowser moves towards the tile alignment
	INC <Objects_X,X
	BCC PRG001_BA95	; If carry clear, jump to PRG001_BA95

	; Don't let Bowser's X wrap around!
	DEC <Objects_X,X
	DEC <Objects_X,X

PRG001_BA95:
	RTS		 ; Return

PRG001_BA96:
	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser

	LDA <Objects_YVel,X
	BMI PRG001_BAA1	 ; If Bowser is moving upward, jump to PRG001_BAA1

	CMP #$70
	BGE PRG001_BAA6	 ; If Bowser's Y Velocity >= $70, jump to PRG001_BAA6 (RTS)

PRG001_BAA1:

	; Bowser's rapid stomp fall!
	ADD #$06
	STA <Objects_YVel,X

PRG001_BAA6:
	JMP PRG001_BA4B	 ; Jump to PRG001_BA4B 


Bowser_BustFloorLookAround:
	JSR Bowser_DetectTiles	  ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	CMP #$40
	BGS PRG001_BAB6	 ; If Bowser's Y Velocity >= $40, jump to PRG001_BAB6

	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BAB6:
	JSR Bowser_BustFloor	 ; Bust any bricks Bowser has hit

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BAC2	 ; If Bowser has not hit floor, jump to PRG001_BAC2

	JSR Object_HitGround	 ; Align to floor

PRG001_BAC2;
	LDA Objects_Timer,X
	BEQ PRG001_BACD		; If timer expired, jump to PRG001_BACD

	; Bowser slam frame
	LDA #$07
	STA Objects_Frame,X

	RTS		 ; Return

PRG001_BACD:
	LDA Objects_Timer3,X
	BNE PRG001_BAF1	 ; If timer 3 is not expired, jump to PRG001_BAF1

	; Var 4 back to zero
	LDA #$00
	STA <Objects_Var4,X

	LDA RandomN,X
	AND #$7f
	ORA #$80
	STA Objects_Timer3,X	 ; Timer 3 = $7F to $FF

	RTS		 ; Return

	; Bowser look around frame
Bowser_LookAroundFrames:	.byte $04, $05, $05, $05, $04, $05, $05, $05

	; Bowser look around flip bits
Bowser_LookAroundFlipBits:	.byte $00, $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP

PRG001_BAF1:
	CMP #$20
	BLT PRG001_BB0B	 ; If timer 3 < $20, jump to PRG001_BB0B

	; When Bowser lands, he looks around a bit for a second

	LSR A
	LSR A
	ADD Objects_Var7,X	; ?? Not used in anything else Bowser does?
	AND #$07
	TAY		 ; Y = 0 to 7 

	; Set frame
	LDA Bowser_LookAroundFrames,Y
	STA Objects_Frame,X

	; Set flip bits
	LDA Bowser_LookAroundFlipBits,Y
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG001_BB0B:
	CMP #$0c
	LDA #$05	 ; A = 5
	BGE PRG001_BB13	 ; If timer 3 >= 5, jump to PRG001_BB13

	LDA #$08	 ; Otherwise, A = 8

PRG001_BB13:
	STA Objects_Frame,X	 ; Set Bowser frame

Bowser_FacePlayer:
	JSR Bowser_CalcPlayersSide

	; Bowser face Player!
	LDA Bowser_FlipToFace,Y
	STA Objects_FlipBits,X

	RTS		 ; Return


	; Set proper flip bit for Bowser to face Player
Bowser_FlipToFace:
	.byte SPR_HFLIP, $00

Bowser_HoppingFrames:
	.byte $00, $00, $03, $02, $00, $00, $00, $00

Bowser_HopAndBreatheFire:
	LDA Bowser_Counter1
	BEQ PRG001_BB46	 ; If Bowser_Counter1 = 0, jump to PRG001_BB46 (RTS)

	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	; Bowser's little hopping animation
	LDA Bowser_HoppingFrames,Y
	STA Objects_Frame,X

	LDA Bowser_Counter1
	CMP #$10	 
	BNE PRG001_BB46	 ; If Bowser_Counter1 <> $10, jump to PRG001_BB46 (RTS)

	JSR Bowser_BreatheFire	 ; Bowser breathe's a fireball!

PRG001_BB46:
	RTS		 ; Return

	; Bowser's fireball X velocity and offset by direction
Bowser_FireballXVel:	.byte -$10, $10
Bowser_FireballXOff:	.byte -$08, $18

PRG001_BB4B:	.byte $00, $08, $10, $18, $08, $00, $00, $10
	
Bowser_BreatheFire:
	LDY #$04	; Y = 4
PRG001_BB55:
	LDA Objects_State,Y
	BEQ PRG001_BB5E	 ; If object is dead/empty, jump to PRG001_BB5E

	DEY		 ; Y--
	BPL PRG001_BB55	 ; While Y >= 0, loop

	RTS		 ; Return

PRG001_BB5E:
	TYA
	TAX		 ; X = new object's index

	JSR Level_PrepareNewObject	 ; Set up the new flame to be spawned 

	; Set object state to normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser's fireball
	LDA #$01
	STA Level_ObjectID,X

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Bowser fall
	LDA #$10
	STA Objects_YVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; Set fireball Y to Bowser's +16
	LDA <Objects_Y,X
	ADD #16
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA Objects_YHi,Y

	LDA Objects_FlipBits,X
	STA Objects_FlipBits, Y
	ASL A
	ASL A
	ROL A
	AND #$01
	TAX	
	STX <Temp_Var1		; X = 0 or 1, depending on if Bowser's horizontally flipped

	; Set X Velocity as appropriate
	LDA Bowser_FireballXVel,X
	STA Objects_XVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; X Hi is just copied
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set X appropriately offset from Bowser
	LDA <Objects_X,X
	LDX <Temp_Var1		
	ADD Bowser_FireballXOff,X
	STA Objects_X,Y	
	LDA #$00
	STA Objects_YVel, Y

	;LDA RandomN,Y
	;AND #$07	
	;TAX		 ; X = random 0 to 7
	;
	;; A bit random how the fireball moves
	;LDA PRG001_BB4B,X
	;STA Objects_TargetingYVal,Y

	; Set fireball palette
	LDA #SPR_PAL1
	STA Objects_SprAttr,Y

	; Reset timer
	ASL A			; A = 0
	STA Objects_Timer,Y	

	; Fire breathing sound
	LDA #SND_LEVELFLAME
	STA Sound_QLevel2

	LDX <SlotIndexBackup	; Restore 'X' to Bowser's object slot index

	RTS		 ; Return


Bowser_Counter3Do:
	; If Bowser_Counter3 > 0, just decrement it.  Otherwise,
	; set it to some value $60 to $9F and set Bowser_Counter1 to $3F

	LDA Bowser_Counter3	  
	BNE PRG001_BBDC	 ; If Bowser_Counter3 <> 0, jump to PRG001_BBDC

	LDA RandomN,X
	AND #$3f
	ADC #$60
	STA Bowser_Counter3	 ; Bowser_Counter3 = $60 + (Random $00 to $3F)

	; Bowser Counter 1 = $3F
	LDA #$3f
	STA Bowser_Counter1

	RTS		 ; Return

PRG001_BBDC:
	DEC Bowser_Counter3	; Bowser_Counter3--
	RTS		 ; Return


	; Detect the left and right tiles underneath Bowser
Bowser_DetectTiles:
	; Apply Bowser's X and Y Velocities
	JSR Object_ApplyXVel	 
	JSR Object_ApplyYVel_NoLimit

	LDY <Objects_X,X	 ; Y = Bowser's X

	LDA <Objects_XVel,X
	BEQ PRG001_BBFC	 ; If Bowser is stopped horizontally, jump to PRG001_BBFC
	BMI PRG001_BBF4	 ; If Bowser is moving to the left, jump to PRG001_BBF4

	; Bowser moving to the right...

	; Prevent Bowser from moving off the right edge
	CPY #224
	BGE PRG001_BBF8	 ; If Bowser's X >= 224, jump to PRG001_BBF8
	BLT PRG001_BBFC	 ; Otherwise, jump to PRG001_BBFC

PRG001_BBF4:

	; Bowser moving to the left...

	; Prevent Bowser from moving off the left edge
	CPY #8
	BGE PRG001_BBFC	 ; If Bowser's X >= 8, jump to PRG001_BBFC

PRG001_BBF8:

	; Bowser could move off left or right edge, so stop him!
	LDA #$00
	STA <Objects_XVel,X

PRG001_BBFC:
	
	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC0B	; If var 4 <> 2, jump to PRG001_BC0B

	; Store tile detected under Bowser's left
	LDA Object_TileFeetValue
	STA Bowser_TileValues	 ; Store detected tile -> Bowser_TileValues
	LDA Object_TileFeetProp
	STA Bowser_TileProps

PRG001_BC0B:
	LDA <Objects_DetStat,X	; Get Bowser's detection status bits
	PHA		 	; Save them

	LDA <Objects_X,X	; Get Bowser's X
	PHA		 	; Save it

	; Detect the right tile under Bowser's feet
	ADD #16
	STA <Objects_X,X
	JSR Object_WorldDetectN1

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	PLA		 ; Restore Bowser's detection bits
	ORA <Objects_DetStat,X	 ; OR in the ones detected by the right tile check
	STA <Objects_DetStat,X	 ; Save the unified set (in case only one foot is actually on the floor)

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC2D	; If var 4 <> 2, jump to PRG001_BC2D

	; Store tile detected under Bowser's right
	LDA Object_TileFeetValue
	STA Bowser_TileValues+1
	LDA Object_TileFeetProp
	STA Bowser_TileProps+1

PRG001_BC2D:
	RTS		 ; Return


	; X offsets to Bowser's tile under each side of him
Bowser_TileOffsets:	.byte 8, 24


	; Busts any breakable floor that Bowser has hit
Bowser_BustFloor:
	LDY #$01	 ; Y = 1 (two tiles to potentially smash)
PRG001_BC32:

	LDA Bowser_TileProps,Y	; Get this tile
	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_STONE)
	BEQ PRG001_BC33

	CMP #(TILE_PROP_SOLID_ALL | TILE_PROP_STONE)
	BNE PRG001_BC69	 	; If this tile is not the solid brick tile, jump to PRG001_BC69

PRG001_BC33:
	; Bowser hit brick!
	LDA #$00
	STA Bowser_TileProps,Y	; Clear this tile

	; Queue a block change to erase to background!
	LDA Bowser_TileValues,Y
	EOR #$01
	STA Level_ChgTileEvent

	; Aligned Bowser impact Y
	LDA <Objects_Y,X
	ADD #$30
	AND #$f0
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	; Aligned Bowser impact X
	LDA <Objects_X,X
	ADD Bowser_TileOffsets, Y
	AND #$f0
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	ADC #$00
	STA Level_BlockChgXHi

	JMP PRG001_BC6D	 ; Jump to PRG001_BC6D

PRG001_BC69:
	DEY		; Y--
	BPL PRG001_BC32	; While Y >= 0, loop!

	RTS		 ; Return


PRG001_BC6D:
	; Smash block sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA Level_BlockChgYLo
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA Level_BlockChgXLo
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

	RTS		 ; Return


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
	; These are the patterns for every column of every row, by frame 
	; (12 sprites total per frame, last four values for padding?)
Bowser_SprPats:
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 0
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $97, $99, $9B, $9D, $00, $00, $00, $00 ; Bowser frame 1
	.byte $9F, $A1, $A3, $A5, $A7, $A9, $AB, $AD, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 2
	.byte $9F, $A1, $B1, $A5, $B3, $B5, $B7, $AD, $B9, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 3
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $C9, $CB, $CB, $C9, $00, $00, $00, $FF ; Bowser frame 4
	.byte $71, $CF, $D1, $71, $D3, $D5, $F7, $D9, $DB, $DD, $DF, $E1, $00, $00, $00, $00 ; Bowser frame 5
	.byte $E3, $E5, $E5, $E3, $E7, $E9, $E9, $E7, $EB, $ED, $ED, $EB, $00, $00, $00, $FF ; Bowser frame 6
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $EF, $F1, $F1, $EF, $00, $00, $00, $FF ; Bowser frame 7
	.byte $71, $CF, $D1, $71, $D3, $D5, $C1, $CD, $F9, $FB, $FD, $FF, $00, $00, $00, $00 ; Bowser frame 8

	; Sprite X offsets per sprite, horizontally flipped or not horizontally flipped
Bowser_SprXNotHFlipped:	.byte $00, $08, $10, $18, $00, $08, $10, $18, $00, $08, $10, $18
Bowser_SprXHFlipped:	.byte $18, $10, $08, $00, $18, $10, $08, $00, $18, $10, $08, $00

	; Sprite Y offsets per sprite, vertically flipped or not vertically flipped
Bowser_SprYNotVFlipped:	.byte $00, $00, $00, $00, $10, $10, $10, $10, $20, $20, $20, $20
Bowser_SprYVFlipped:	.byte $20, $20, $20, $20, $10, $10, $10, $10, $00, $00, $00, $00

	; Similar to Bowser_SprVVisLUT, marks sprite that should be
	; invisible if marked horizontally invisible
Bowser_SprHVisLUT:
	.byte $80, $40, $20, $10

	; Bowser's sprites are drawn straight through; this marks the
	; ones that should not be handled if vertically invisible
Bowser_SprVVisLUT:
	.byte $01, $01, $01, $01	; Top sprites
	.byte $02, $02, $02, $02	; Middle sprites
	.byte $04, $04, $04, $04	; Bottom sprites

	; Bowser uses fixed Sprite_RAM offsets, alternating which set he used every other tick
Bowser_SprRAMOff:
	.byte $50, $54, $58, $5C	; Top sprites
	.byte $60, $64, $68, $6C	; Middle sprites
	.byte $70, $74, $78, $7C	; Bottom sprites

	.byte $00, $00, $00, $00	; Unused, for alignment only (switches between these sets via 4 ASLs)

	.byte $DC, $D8, $D4, $D0	; Top sprites
	.byte $EC, $E8, $E4, $E0	; Middle sprites
	.byte $FC, $F8, $F4, $F0	; Bottom sprites


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
Bowser_Draw:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the Sprite X and Y Low parts	 

	; Temp_Var1 = Bowser's Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Temp_Var2 = Bowser's Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	; Temp_Var3 and Temp_Var4 = Bowser's FlipBits
	LDA Objects_FlipBits,X
	STA <Temp_Var3		
	STA <Temp_Var4		

	; Temp_Var5 = Bowser's horizontal visibility flags
	LDA Objects_SprHVis,X
	STA <Temp_Var5	

	; Temp_Var6 = Bowser's vertical visibility flags
	LDA Objects_SprVVis,X
	STA <Temp_Var6

	LDY Objects_Frame,X
	CPY #$01
	BEQ PRG001_BDB4		; If Bowser's frame = 1, jump to PRG001_BDB4

	CPY #$07
	BNE PRG001_BDBB	 	; If Bowser's frame <> 7, jump to PRG001_BDBB

PRG001_BDB4:

	; Frame 7 is slightly lower than the others

	LDA <Temp_Var1
	ADD #$04
	STA <Temp_Var1

PRG001_BDBB:
	CPY #$08
	BEQ PRG001_BDD2	 ; If Bowser's frame = 8, jump to PRG001_BDD2

	CPY #$04
	BEQ PRG001_BDC7	 ; If Bowser's frame = 4, jump to PRG001_BDC7

	CPY #$06	 
	BLT PRG001_BDD2	 ; If Bowser's frame < 6, jump to PRG001_BDD2

PRG001_BDC7:

	; Bowser frame 4

	LDA Objects_FlipBits,X
	AND #SPR_VFLIP
	STA <Temp_Var3	 ; Temp_Var3 = $00 or SPR_VFLIP, depending whether Bowser is flipped vertically

	ORA #SPR_HFLIP
	STA <Temp_Var4	 ; Always set horizontal flip in Temp_Var4

PRG001_BDD2:
	LDA Objects_Frame,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var15	 ; Temp_Var15 = frame * 16

	LDA #$00
	STA <Temp_Var16

PRG001_BDDF:

	; This determines which Sprite_RAM offset table set we use.
	; Either 0 or 16, alternating every other frame.
	LDA <Counter_1
	AND #$01
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ADD <Temp_Var16	 ; Temp_Var16 = current sprite we're on
	TAY		 ; -> 'Y'

	LDA Bowser_SprRAMOff,Y
	TAY		 ; Index -> 'Y'

	LDX <Temp_Var16	 ; X = current sprite

	LDA <Temp_Var6	 	; Get Bowser's vertical visibility flags
	AND Bowser_SprVVisLUT,X	
	BNE PRG001_BE49	 	; If this sprite should not be drawn due to vertically being off-screen, jump to PRG001_BE49

	; Sprites are 0 through 12, so each horizontal sprite is by modulus 4
	TXA
	AND #$03	; Essentially mod 4
	TAX
	LDA <Temp_Var5	 ; Temp_Var5 = 0 to 3 based on which horizontal sprite we're doing

	AND Bowser_SprHVisLUT,X
	BNE PRG001_BE49	 ; If this sprite should not be drawn due to beging horizontally off-screen, jump to PRG001_BE49

	LDA <Temp_Var15	
	ADD <Temp_Var16	 ; Temp_Var16 = (Bowser's frame * 16 [Temp_Var15]) + (which sprite we're on)
	TAX		 ; -> 'X'

	; Store pattern of this Bowser sprite
	LDA Bowser_SprPats,X
	STA Sprite_RAM+1,Y

	LDX <Temp_Var16	 ; X = Temp_Var16

	LDA <Temp_Var3
	BPL PRG001_BE1A	 ; If Bowser is not vertically flipped, jump to PRG001_BE1A

	; Otherwise, use the vertically flipped lookups
	TXA
	ADD #(Bowser_SprYVFlipped - Bowser_SprYNotVFlipped)
	TAX

PRG001_BE1A:
	LDA <Temp_Var1	 	; A = Temp_Var1 (Bowser's Sprite Y)
	ADD Bowser_SprYNotVFlipped,X	; Offset Y as appropriate for this sprite
	STA Sprite_RAM,Y	; Set sprite Y

	LDX <Temp_Var16		; X = Temp_Var16
	TXA		 	
	AND #$03	 	; Get which horizontal sprite (of 4) we're on
	CMP #$02	 	; Horizontal sprite 2 would be the beginning of the "right half" of Bowser

	LDA <Temp_Var3		; A = Temp_Var3 (Bowser's flip bits)
	BLT PRG001_BE30	 	; If we are on the left half of Bowser, jump to PRG001_BE30

	LDA <Temp_Var4		; A = Temp_Var4 (Bowser's flip bits alternate)

PRG001_BE30:
	ORA #SPR_PAL3	 	; Lock in palette 3
	STA Sprite_RAM+2,Y	; Store sprite attributes

	LDA <Temp_Var3
	AND #SPR_HFLIP
	BEQ PRG001_BE40	 ; If Bowser is not horizontally flipped, jump to PRG001_BE40

	; Otherwise, use the horizontally flipped lookups
	TXA		 
	ADD #(Bowser_SprXHFlipped - Bowser_SprXNotHFlipped)
	TAX

PRG001_BE40:
	LDA <Temp_Var2		 ; A = Temp_Var2 (Bowser's Sprite X)
	ADD Bowser_SprXNotHFlipped,X	 ; Offset X as appropriate for this sprite
	STA Sprite_RAM+3,Y	 ; Set sprite X

PRG001_BE49:
	INC <Temp_Var16		 ; Temp_Var16++ (next sprite)

	; Bowser is made of a total of 12 sprites (4x3)
	LDA <Temp_Var16
	CMP #12	 
	BNE PRG001_BDDF	 ; If Temp_Var16 <> 12, loop!

	LDX <SlotIndexBackup	 ; Restore 'X' as Bowser's object slot index

	RTS		 ; Return

Bowser_CalcPlayersSide:

	; Backup Bowser's X
	LDA <Objects_X,X
	PHA

	; +8 Bowser's X; calculation of which side the Player is on is offset
	ADD #$08
	STA <Objects_X,X
	JSR Level_ObjCalcXDiffs

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	RTS		 ; Return


Bowser_HandleIfDead:
	; Handle Bowser if he's dead either from falling or weapon

	LDA <Objects_YHi,X	 
	CMP #$01
	BLS PRG001_BE6F	 ; If Bowser is way up high, jump to PRG001_BE6F

	; Bowser's not too high...

	LDA <Objects_SpriteY,X
	CMP #$88
	BGE PRG001_BE7F	 ; If Bowser's Y >= $88, jump to PRG001_BE7F

	; Bowser's not too low yet

PRG001_BE6F:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG001_BE98	 ; If Bowser's state is Normal, jump to PRG001_BE98 (RTS)

	; Bowser's state not Normal, now set it to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser got killed by weapon, set Bowser's Y velocity to -$30
	LDA #-$30
	STA <Objects_YVel,X

PRG001_BE7F:

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	LDY #$04	 ; Y = 4
PRG001_BE80:

	LDA Objects_State,Y
	BEQ PRG001_BE81	 ; If this object slot is dead/empty, jump to PRG004_AE35

	DEY		 ; Y--
	BPL PRG001_BE80	 ; While

PRG001_BE81:
	LDA #OBJ_KEY
	STA Level_ObjectID, Y

	LDA #OBJSTATE_INIT
	STA Objects_State, Y
	
	LDA <Objects_X, X
	STA Objects_X, Y

	LDA <Objects_Y, X
	STA Objects_Y, Y

	LDA <Objects_XHi, X
	STA Objects_XHi, Y

	LDA <Objects_YHi, X
	STA Objects_YHi, Y


	; Set Bowser's frame to 6
	LDA #$06
	STA Objects_Frame,X

	; Clear Bowser's X Velocity and counter 1
	LDA #$00
	STA <Objects_XVel,X
	STA Bowser_Counter1

	; Set timer 3 to $30 (Delay until dramatic drop "song" begins)
	LDA #$30
	STA Objects_Timer3,X

PRG001_BE98:
	RTS		 ; Return


Bowser_FallAndSplat:
	LDY Objects_Timer3,X
	DEY		 ; Y--
	BNE PRG001_BEA4	 ; If timer 3 not expired, jump to PRG001_BEA4

	; Play dramatic Bowser fall
	LDA #MUS1_BOWSERFALL
	STA Sound_QMusic1

PRG001_BEA4:
	LDA Objects_HitCount,X
	CMP #$01
	BGS PRG001_BEB2	 ; If Bowser has at least one hit left, jump to PRG001_BEB2

	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

PRG001_BEB2:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	CMP #$25
	BGS PRG001_BEBD	 ; If Y velocity >= $25, jump to PRG001_BEBD

	INC <Objects_YVel,X	 ; Gravity while falling 

PRG001_BEBD:
	LDA <Objects_YHi,X
	CMP #$04	 
	BLS PRG001_BEDE	 ; If Bowser hasn't fallen down about 4 screens yet, jump to PRG001_BEDE

	; Bowser hits bottom...

	INC <Objects_Var5,X	 ; Objects_Var5 = 3

	; Set timer to $D0
	LDA #$d0
	STA Objects_Timer,X

	; Vibrate the floor 
	LDA #$80
	STA Level_Vibration

	; Ba-bam!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA <Player_InAir
	BNE PRG001_BEDE		; If Player is mid-air, jump to PRG001_BEDE

	; Bounce Player if he's on the ground
	LDA #-$40
	STA <Player_YVel

	; Mark Player as mid-air
	INC <Player_InAir

PRG001_BEDE:
	LDA <Objects_Y,X	; Get Bowser's Y
	PHA			; Save it
	ADD #16			; +16
	STA <Objects_Y,X	; -> Bowser's Y

	LDA <Objects_YHi,X	; Get Bowser's Y Hi
	PHA		 	; Save it
	ADC #$00	 	; Apply carry
	STA <Objects_YHi,X	; -> Bowser's Y Hi

	JSR Object_DetermineVertVis	; Check if Bowser is vertically invisible

	; Restore Y and Y Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	RTS		 ; Return

DoorAppear_YUpr:	.byte $60, $70
DoorAppear_X:	.byte $E8, $E8

PRG001_BEFB:	.byte $80, $88

Bowser_WaitAndVictory:
	LDA Objects_Timer,X	  
	BNE PRG001_BF09	 ; If timer hasn't expired, jump to PRG001_BF09 (RTS)

	; Play victory fanfare
	LDA #MUS1_WORLDVICTORY
	STA Sound_QMusic1

	INC <Objects_Var5,X	 ; Objects_Var5 = 3

PRG001_BF09:
	RTS		 ; Return

Bowser_DoTimeBonus:

PRG001_BF16:
	RTS		 ; Return


Bowser_DoorAppear:

	RTS		 ; Return

; Rest of ROM bank was empty

Try_PUp_Reserve:
	LDA Player_Equip
	CMP #$07
	BNE Cant_Reserve
	LDA Effective_Suit
	STA PowerUp_Reserve
Cant_Reserve:
	RTS

Do_PUp_Poof_Collect:
	STA Player_QueueSuit
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1
	LDA #$17
	STA Player_SuitLost
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State + 5
	RTS

Do_PUp_Pallete_Collect:
	STA Player_QueueSuit
	LDA #$1f
	STA Player_StarOff
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State + 5
	RTS


DeleteWeather:
	JMP Object_Delete

ObjInit_Rain:
	LDA Objects_Property, X
	STA Objects_Var1, X
	STX TempX
	LDY #$04

ObjInit_Rain1:
	CPY TempX
	BEQ ObjInit_Rain2
	LDA Level_ObjectID, Y
	CMP #$0F
	BEQ DeleteWeather
	CMP #$10
	BEQ DeleteWeather

ObjInit_Rain2:
	DEY
	BPL ObjInit_Rain1

	LDY #$05

KeepRandomizing:
	LDA Objects_Y, X
	LSR A
	LSR A
	LSR A
	LSR A
	STA TempA
	LDA Objects_X, X
	AND #$10
	BNE DontReverseWind
	LDA TempA
	EOR #$FF
	ADD #$01
	STA TempA
	
DontReverseWind:
	LDA TempA
	STA Wind
	LDA #$01
	STA WeatherActive
	JSR Randomize_Weather
	LDA RandomN
	STA Weather_YPos, Y
	DEY
	BPL KeepRandomizing

DontReverseWind1:
	RTS

ObjNorm_Weather:
	LDA Weather_Disabled
	BNE DontReverseWind1

	LDA <Vert_Scroll
	STA <Temp_Var7
	LDA <Horz_Scroll
	STA <Temp_Var8

	;INC Objects_Var2, X
	;LDA Objects_Var2, X
	;AND #$01
	;BNE DoNextParticle0
	;LDA <Temp_Var7
	;ADD #$80
	;STA <Temp_Var7
	;LDA <Temp_Var8
	;ADD #$80
	;STA <Temp_Var8


DoNextParticle0:
	LDA Object_SprRAM, X
	STA TempX
	LDY #$05

DoNextParticle:
	JSR MoveSingleParticle
	LDX TempX
	JSR DrawSingleParticle
	LDA TempX
	ADD #$04
	STA TempX
	DEY
	BPL DoNextParticle
	LDX <SlotIndexBackup
	RTS

MoveSingleParticle:
	LDA Weather_YPos, Y
	ADD Weather_YVel, Y
	STA Weather_YPos, Y
	LDA Weather_XPos, Y
	ADD Weather_XVel, Y
	STA Weather_XPos, Y
	RTS

Randomize_Weather:
	STY TempY
	JSR Randomize
	LDY TempY
	LDX <SlotIndexBackup
	LDA RandomN
	STA Weather_XPos, Y
	LDA #$00
	STA Weather_YPos, Y
	LDA RandomN + 1
	AND #$07
	LDY Objects_Var1, X
	BEQ RainVel1
	ORA #$08

RainVel1:
	TAY
	LDA Rain_XVel, Y
	LDY TempY
	STA Weather_XVel, Y
	LDA RandomN + 2
	AND #$07
	LDY Objects_Var1, X
	BEQ RainVel2
	ORA #$08

RainVel2:
	TAY
	LDA Rain_YVel, Y
	LDY TempY
	STA Weather_YVel, Y
	LDA Objects_X, X
	AND #$10
	BNE DoNotReverse

	LDA Weather_XVel, Y
	EOR #$FF
	ADD #$01
	STA Weather_XVel, Y

DoNotReverse: 
	LDA RandomN + 3
	AND #$01
	LDY Objects_Var1, X
	BEQ RainPattern
	ORA #$02

RainPattern:
	TAY
	LDA Weather_Patterns, Y
	LDY TempY
	STA Weather_Pattern, Y
	RTS

DrawSingleParticle:

	LDA Weather_YPos, Y
	SUB <Temp_Var7
	STA Sprite_RAM, X
	LDA Weather_XPos, Y
	SUB <Temp_Var8
	STA Sprite_RAM + 3, X
	LDA Weather_Pattern, Y
	STA Sprite_RAM + 1, X
	LDA #$02
	STA TempA
	LDA Weather_XVel, Y
	BMI DontFlipParticle
	LDA #SPR_HFLIP
	ORA TempA
	STA TempA

DontFlipParticle:
	LDA TempA
	STA Sprite_RAM + 2, X
	RTS
	
Weather_Patterns: .byte $7B, $7B, $55, $5F
Rain_XVel: .byte $04, $05, $06, $07, $04, $05, $06, $06
Snow_XVel: .byte $01, $01, $01, $01, $01, $01, $01, $01
Rain_YVel: .byte $03, $04, $03, $04, $03, $04, $03, $04
Snow_YVel: .byte $01, $01, $01, $01, $02, $02, $02, $02


ChompPal: .byte SPR_PAL1, SPR_PAL0

ObjInit_GiantChomp:
	LDA #$00
	STA Objects_Var1, X
	STA Objects_Var2, X

	LDA #$D0
	STA Objects_YVel, X
	RTS

ObjNorm_GiantChomp:
	LDA <Player_HaltGame
	BNE DrawChomp

	LDA #SND_BOOMERANG
	STA Sound_QLevel2

	LDA <Counter_1
	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame, X

	LDA Objects_Property, X
	BEQ NoChompFlash

	LDA <Counter_1
	AND #$01
	TAY
	LDA ChompPal, Y
	STA Objects_SprAttr,X

NoChompFlash:
	LDA Objects_Property, X
	CMP #$02
	BEQ ChompNoDelete

	JSR Object_DeleteOffScreen

ChompNoDelete:
	LDA Objects_Var2, X
	BNE GiantChompStuff

	JSR Object_ApplyYVel_NoLimit
	LDA Objects_SprVVis,X
	BEQ DrawMiniChomp

	JSR Level_ObjCalcYDiffs
	CPY #$01
	BEQ ChompRTS

	INC Objects_Var2, X

	LDA Objects_Property, X
	BEQ ChompRTS

	JSR GCTargetPlayer
ChompRTS:
	RTS

GiantChompStuff:
	JSR Player_HitEnemy
	JSR Object_Move

DoGCRoutine:
	LDY #(SuperGiantOffsets1 - Object_TileDetectOffsets)
	JSR Object_DetectTile
	CMP #TILE_PROP_SOLID_ALL
	BCC TryEatRightBlock
	JSR ChompEatBlock
	JMP ChompDoneEating

TryEatRightBlock:
	LDY #(SuperGiantOffsets1  - Object_TileDetectOffsets)
	INY
	INY
	JSR Object_DetectTile
	CMP #TILE_PROP_SOLID_ALL
	BCC ChompDoneEating 
	JSR ChompEatBlock

ChompDoneEating:
DrawChomp:
	LDA Objects_Var2, X
	BEQ DrawMiniChomp
	LDA #LOW(GiantChompFrames)
	STA <Temp_Var10
	LDA #HIGH(GiantChompFrames)
	STA <Temp_Var11
	JSR DrawGiantObject

	LDA Objects_Property, X
	CMP #$02
	BCC DoneGC

	JSR Level_ObjCalcYDiffs
	CPY #$00
	BEQ DoneGC

	LDA Objects_SprVVis, X
	CMP #$03
	BCC DoneGC
	
	JSR GCTargetPlayer
	LDA #$D0
	STA Objects_YVel, X
	DEC Objects_Var2, X

DoneGC:
	RTS

DrawMiniChomp:
	JSR Object_ShakeAndCalcSprite
	LDX <SlotIndexBackup
	LDA Objects_SprHVis, X
	AND #$60
	BNE DrawMiniChompRTS
	LDA <Temp_Var1
	STA Sprite_RAM , Y
	LDA <Temp_Var2
	ADD #$0C
	STA Sprite_RAM + $03, Y
	LDA Objects_SprAttr,X
	ORA #SPR_BEHINDBG
	STA Sprite_RAM + $02, Y
	LDA Objects_Frame, X
	ASL A
	ADD #$99
	STA Sprite_RAM + $01, Y

DrawMiniChompRTS:
	RTS

GiantChompFrames:
	.byte $81, $83, $85, $87, $A1, $A3, $A5, $A7
	.byte $89, $8B, $8D, $8F, $A9, $AB, $AD, $AF

	
ChompEatBlock:
	LDA #$00
	STA <Objects_YVel, X
	LDA #$81
	STA Level_ChgTileEvent
	LDA ObjTile_DetYLo
	AND #$F0
	STA Level_BlockChgYLo
	LDA ObjTile_DetYHi
	STA Level_BlockChgYHi
	
	LDA ObjTile_DetXLo
	AND #$F0
	STA Level_BlockChgXLo
	LDA ObjTile_DetXHi
	STA Level_BlockChgXHi

	LDA Objects_SprHVis, X
	AND #$C0
	BNE ChompEatBlockRTS

	LDA Objects_SprVVis, X
	AND #$03
	BNE ChompEatBlockRTS
	JSR PRG001_BC6D
	 
ChompEatBlockRTS:
	RTS


GCTargets: .byte $00, $20, $40, $60, $80, $A0, $C0, $E0

GCTargetPlayer:
	LDA <Player_XVel
	BPL GCTargetPlayerRight
	JSR Negate
	
	AND #$38
	LSR A
	LSR A
	LSR A
	TAY
	LDA <Player_X
	SUB GCTargets, Y
	AND #$F0
	STA <Objects_X, X

	LDA <Player_XHi
	SBC #$00
	STA <Objects_XHi, X

	RTS

GCTargetPlayerRight:
	AND #$31
	LSR A
	LSR A
	LSR A
	TAY
	LDA <Player_X
	ADD GCTargets, Y
	AND #$F0
	STA <Objects_X, X

	LDA <Player_XHi
	ADC #$00
	STA <Objects_XHi, X
	RTS

ObjInit_Brick:
	RTS

ObjNorm_Brick:
	LDA <Player_HaltGame
	BNE ObjNorm_BrickDraw

	JSR Object_Move
	JSR Object_HitTestRespond
	JSR Object_WorldDetect4

	LDA <Objects_DetStat,X
	BEQ ObjNorm_BrickDraw

Object_ToBrickBust:
	LDA #OBJ_STONEBLOCK
	STA Level_ObjectID, X

	RTS

ObjNorm_BrickDraw:
	LDA Objects_Frame, X
	BNE ObjNorm_BrickDraw1
	JMP Object_ShakeAndDrawMirrored

ObjNorm_BrickDraw1:
	JMP Object_ShakeAndDraw

ObjNorm_Boss:
	JSR DoBossFights
	RTS

KeyPieceGet:
	.byte $01, $02, $04, $08, $10

KeyPieceXOffset:
	.byte $10, $18, $20, $28, $30

ObjInit_KeyPieces:
	LDA #$FF
	STA Objects_YHi, X
	LDA #$13
	STA Global_Object
	RTS

ObjNorm_KeyPieces:
	LDA #$93
	STA <Temp_Var1
	LDA #$95
	STA <Temp_Var2
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ ObjNorm_KeyPieces1

	LDA <Temp_Var1
	ADD #$40
	STA <Temp_Var1
	LDA <Temp_Var2
	ADD #$40
	STA <Temp_Var2

ObjNorm_KeyPieces1:
	LDY Object_SprRAM, X
	LDA Objects_Var1, X
	STA <Temp_Var5
	LDA Objects_Property, X
	STA <Temp_Var6
	TAX

CheckNextPiece:
	
	LDA #$08
	STA Sprite_RAM, Y
	LDA #SPR_PAL3
	STA Sprite_RAM + 2, Y
	LDA <Temp_Var5
	AND KeyPieceGet, X
	BNE UseFilledKey

	LDA <Temp_Var2
	BNE DrawKeyPiece

UseFilledKey:
	DEC <Temp_Var6

UseFilledKey1:
	LDA <Temp_Var1

DrawKeyPiece:
	STA Sprite_RAM + 1, Y
	LDA KeyPieceXOffset, X
	STA Sprite_RAM + 3, Y
	INY
	INY
	INY
	INY

NextCheck:
	DEX
	BPL CheckNextPiece
	LDA <Temp_Var6
	BPL KeyPieceRTS

	JSR FindEmptyEnemySlot
	LDA #OBJ_KEY
	STA Level_ObjectID, X
	STA Global_Object
	LDA #OBJSTATE_INIT
	STA Objects_State, X
	LDY <SlotIndexBackup
	LDA Objects_X, Y
	STA Objects_X, X
	LDA Objects_XHi, Y
	STA Objects_XHi, X
	LDA Objects_Y, Y
	STA Objects_Y, X
	LDA Objects_YHi, Y
	STA Objects_YHi, X
	LDX <SlotIndexBackup
	JMP Object_PoofDie
	

KeyPieceRTS:
	RTS

KPFrames:
	.byte $00, $04

KPFlips1:
	.byte $00, $00, $00, SPR_HFLIP

KPFlips2:
	.byte $00, $00, SPR_HFLIP, SPR_HFLIP

ObjNormal_KeyPiece:
	LDA <Player_HaltGame
	BNE DrawKeyPieceAnim

	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	LDA KPFrames, Y
	STA Objects_Frame, X

	JSR Object_DeleteOffScreen
	JSR Object_GetAttrAndMoveTiles
	JSR Object_HitTestRespond
	INC Objects_Var5, X
	LDA Objects_Var5, X
	LSR A
	LSR A 
	LSR A
	AND #$03
	ORA Objects_Frame, X
	STA Objects_Frame, X

DrawKeyPieceAnim:
	JSR Object_ShakeAndDraw
	LDA Objects_Frame, X
	AND #$03
	TAX
	LDA KPFlips1, X
	ORA Sprite_RAM + 2, Y
	STA Sprite_RAM + 2, Y
	LDA KPFlips2, X
	ORA Sprite_RAM + 6, Y
	STA Sprite_RAM + 6, Y
	RTS

ObjHit_KeyPiece:
	LDY #$04

FindKeyTracker:
	LDA Level_ObjectID,Y
	CMP #OBJ_KEYPIECES
	BEQ SetKeyField
	DEY
	BPL FindKeyTracker
	RTS

SetKeyField:
	LDA Objects_Property, X
	TAX
	LDA Objects_Var1, Y
	ORA KeyPieceGet, X
	STA Objects_Var1, Y
	LDA #SND_MAPINVENTORYFLIP	 
	STA Sound_QMap	
	LDX <SlotIndexBackup
	LDA Objects_X, X
	STA Objects_X, Y
	LDA Objects_XHi, X
	STA Objects_XHi, Y
	LDA Objects_Y, X
	STA Objects_Y, Y
	LDA Objects_YHi, X
	STA Objects_YHi, Y
	JMP Object_SetDeadEmpty

CheckKeyAgainstLock:
	LDA Objects_LastProp,X
	CMP #TILE_PROP_SOLID_TOP
	BCS RemainLocked

	AND #$0F
	CMP #TILE_PROP_LOCK
	BNE RemainLocked

	LDA Level_ChgTileEvent
	BNE RemainLocked

	LDA Objects_LastTile, X
	EOR #$01
	STA Level_ChgTileEvent
	
	JSR SetObjectTileCoordAlignObj

	LDA #OBJSTATE_POOFDEATH
	LDX <SlotIndexBackup
	STA Objects_State, X

	LDA #$20
	STA Objects_Timer,X
	PLA
	PLA

RemainLocked:
	RTS

ObjInit_SpikeBall:
	
	RTS

ObjNorm_SpikeBall:
	
	JSR Object_ShakeAndDrawMirrored
	LDA <Player_HaltGame
	BNE ObjNorm_SpikeBallRTS

	JSR Object_DeleteOffScreen
	JSR Player_HitEnemy
	JSR ObjectKill_Others

	LDX <SlotIndexBackup

	INC Objects_Var1, X
	LDA Objects_Var1, X
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame, X
	JSR Object_Move

	LDA <Objects_DetStat,X
	AND #$04
	BEQ SpikeNoBounce1

	JSR Object_HitGround

	LDA #$E0
	STA Objects_YVel, X

	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

SpikeNoBounce1:
	
	LDA <Objects_DetStat, x
	AND #$04
	BEQ TrySideBlock

SpikeNoBounce2:
	LDA Object_TileFeetProp
	CMP #TILE_ITEM_BRICK
	BNE TrySideBlock

	LDA Object_TileFeetValue
	STA <Temp_Var3
	LDA #$08
	STA <Temp_Var1

	LDA #$10
	STA <Temp_Var2
	JMP SpikeBrickBust

TrySideBlock:
	LDA <Objects_DetStat, x
	AND #$03
	BEQ ObjNorm_SpikeBallRTS

	LDA Object_TileWallProp
	CMP #TILE_ITEM_BRICK
	BNE SpikeBusted

	LDA #$08
	STA <Temp_Var2

	LDA Object_TileWallValue
	STA <Temp_Var3

	LDA Objects_XVel, X
	BMI TrySideBlock1

	LDA #$10
	STA <Temp_Var1
	BNE TrySideBlock2

TrySideBlock1:	

	LDA #$00
	STA <Temp_Var1

TrySideBlock2:
	JMP SpikeBrickBust

SpikeBusted:
	LDA #$00
	STA Objects_Var5, X
	STA Objects_Frame, X
	JMP Object_ToBrickBust

ObjNorm_SpikeBallRTS:
	JMP Object_ShakeAndDrawMirrored

SpikeBrickBust:
	LDA Level_ChgTileEvent
	BNE SpikeBrickBustRTS

	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA <Objects_Y, X
	ADD <Temp_Var2
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA <Objects_X, X
	ADD <Temp_Var1
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

	LDA <Temp_Var3
	AND #$C0
	ORA #$01
	STA Level_ChgTileEvent

	LDA <Objects_Y,X
	ADD <Temp_Var2
	AND #$f0
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	LDA <Objects_X,X
	ADD <Temp_Var1
	AND #$f0
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	ADC #$00
	STA Level_BlockChgXHi

SpikeBrickBustRTS:
	RTS

ObjInit_SendBack:
	LDA #$C0
	STA Objects_SlowTimer, X
	RTS

ObjNorm_SendBack:
	LDA Objects_SlowTimer, X
	BNE ObjNorm_SendBackRTS

	INC Level_JctCtl
	INC Level_Redraw
	INC ForcedSwitch
	LDA #$00
	STA LevelVertJct
	STA <Player_XVel
	STA <Player_YVel
	LDA #$F0
	SUB <Player_X
	STA <Player_X
	LDA PreviousLevel
	STA LevelLoadPointer

ObjNorm_SendBackRTS:
	RTS

TimerStartTimes:
	.byte 05, 100

ObjInit_Timer:
	LDA Objects_Property, X
	TAY
	LDA TimerStartTimes, Y
	STA Objects_Var1, X
	LDA #$B0
	STA Objects_Var2, X
	LDA #$1D
	STA Global_Object
	RTS

ObjNorm_Timer:
	LDA Objects_Var5, X
	BNE ObjNorm_Timer0
	LDA #MUS1_TIMEWARNING	 
	STA Sound_QMusic1
	INC Objects_Var5, X

ObjNorm_Timer0:
	LDA <Player_HaltGame
	BNE ObjNorm_Timer1
	LDA Objects_Var1, X
	BEQ ObjNorm_Timer2

	DEC Objects_Var2, X
	BNE ObjNorm_Timer1
	DEC Objects_Var1, X
	LDA #$2D
	STA Objects_Var2, X

ObjNorm_Timer1:
	JSR DrawTimer
	RTS

ObjNorm_Timer2:
	JSR Player_Die
	RTS

DrawTimer:
	LDA #$00
	STA <Temp_Var10
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ DrawTimer0

	LDA #$40
	STA <Temp_Var10

DrawTimer0:
	LDA Objects_Var1, X
	JSR ToThreeDigits
	LDX <SlotIndexBackup
	LDY Object_SprRAM, X
	LDX #$00

DrawTimer1:
	LDA #$10
	STA Sprite_RAM, Y
	LDA #SPR_PAL2
	STA Sprite_RAM + 2, Y

	LDA KeyPieceXOffset, X
	STA Sprite_RAM + 3, Y

	LDA <Temp_Var1, X
	ASL A
	ADD #$A1
	ADD <Temp_Var10
	STA Sprite_RAM + 1, Y
	INY
	INY
	INY
	INY
	INX
	CPX #$03
	BNE DrawTimer1

	LDX <SlotIndexBackup
	RTS

ObjNorm_Clock:
	JSR Object_DeleteOffScreen
	LDA #$00
	STA <Temp_Var10
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ ObjNorm_Clock0

	LDA #$08
	STA <Temp_Var10

ObjNorm_Clock0:
	LDA Objects_Var2, X
	BNE ObjNorm_Clock2

	JSR Object_HitTestRespond
	LDA <Player_HaltGame
	BNE ObjNorm_Clock1

	INC Objects_Var1, X
	LDA Objects_Var1, X
	LSR A
	LSR A
	LSR A
	AND #$01
	ADD <Temp_Var10
	STA Objects_Frame, X
	
ObjNorm_Clock1:
	JMP Object_ShakeAndDraw

ObjNorm_Clock2:
	LDA <Player_HaltGame
	BNE ObjNorm_Clock3

	LDA Objects_Property, X
	ADD #$02
	ADD <Temp_Var10
	STA Objects_Frame, X
	JSR Object_ApplyYVel_NoLimit
	LDA Objects_Timer, X
	BEQ ObjNorm_Clock4

ObjNorm_Clock3:
	JMP Object_ShakeAndDraw

ObjNorm_Clock4:
	JMP Object_SetDeadEmpty

ClockTimes:
	.byte 5, 10, 15, 20, 25, 30

ObjHit_Clock:
	LDY #$04

ObjHit_Clock1:
	LDA Level_ObjectID, Y
	CMP #$1D
	BEQ ObjHit_Clock2
	DEY
	BPL ObjHit_Clock1
	RTS

ObjHit_Clock2:
	LDA Objects_Property, X
	TAX
	LDA ClockTimes, X
	ADD Objects_Var1, Y
	STA Objects_Var1, Y
	LDX <SlotIndexBackup
	INC Objects_Var2, X
	LDA #$20
	STA Objects_Timer, X
	LDA #$F8
	STA Objects_YVel, X
	LDA #SPR_PAL2
	STA Objects_SprAttr, X
	LDA Sound_QLevel1
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap
	RTS

BlockEaterYVel:
	.byte $F8, $00, $08, $00, $00, $F0, $00, $10, $00

BlockEaterXVel
	.byte $00, $08, $00, $F8, $00, $00, $10, $00, $F0

BlockEaterVelOffset:
	.byte $00, $05

BlockEaterChecks:
	.byte (TILE_PROP_SOLID_ALL | TILE_PROP_ENEMYSOLID), TILE_PROP_ENEMY

ObjInit_EaterBlock:
	LDA Objects_Property, X
	AND #$01
	TAY
	LDA BlockEaterChecks, Y
	STA Objects_Var1, X
	LDA Objects_Property, X
	AND #$02
	STA Objects_Var2, X
	LDA Objects_Property, X
	AND #$04
	LSR A
	LSR A
	TAY
	LDA BlockEaterVelOffset, Y
	STA Objects_Var3, X

	LDA Objects_X, X
	STA Objects_Var5, X
	LDA Objects_XHi, X
	STA Objects_Var6, X
	LDA Objects_Y, X
	STA Objects_Var7, X
	LDA Objects_YHi, X
	STA Objects_Var10, X
	RTS

ObjNorm_EaterBlock:
	
	LDA <Player_HaltGame
	BEQ ObjNormal_EaterBlock3

	JMP Object_ShakeAndDrawMirroredAligned

ObjNormal_EaterBlock3:
	
	LDA <Objects_X, X
	ORA <Objects_Y, X
	AND #$0F
	BEQ ObjNormal_EaterBlock31
	JMP ObjNormal_EaterBlock2

ObjNormal_EaterBlock31:
	LDA Objects_X, X
	CMP Objects_Var5, X
	BNE ObjNormal_EaterBlock32
	LDA Objects_XHi, X
	CMP Objects_Var6, X
	BNE ObjNormal_EaterBlock32
	LDA Objects_Y, X
	CMP Objects_Var7, X
	BNE ObjNormal_EaterBlock32
	LDA Objects_YHi, X
	CMP Objects_Var10, X
	BNE ObjNormal_EaterBlock32

	JSR Object_DeleteOffScreen

ObjNormal_EaterBlock32:
	LDA #$04
	STA <Temp_Var13
	LDA Level_ChgTileEvent
	BNE ObjNormal_EaterBlock1

	JSR Object_GetAttrJustTile
	LDA Objects_LastProp, X
	CMP Objects_Var1, X
	BNE ObjNorm_EaterBlock0
	LDA Object_LevelTile
	EOR #$01
	STA Level_ChgTileEvent
	
	JSR SetObjectTileCoordAlignObj

ObjNorm_EaterBlock0:
	LDA #$00
	STA <Temp_Var13
	JSR CheckBlockAbove
	CMP Objects_Var1, X
	BEQ ObjNormal_EaterBlock1

	INC <Temp_Var13
	JSR CheckBlockRight
	CMP Objects_Var1, X
	BEQ ObjNormal_EaterBlock1

	INC <Temp_Var13
	JSR CheckBlockBelow
	CMP Objects_Var1, X
	BEQ ObjNormal_EaterBlock1
	
	INC <Temp_Var13
	JSR CheckBlockLeft
	CMP Objects_Var1, X
	BEQ ObjNormal_EaterBlock1
	
	LDA Objects_Var2, X
	BNE ObjNormal_EaterBlock1A
	JMP Object_PoofDie

ObjNormal_EaterBlock1A:
	INC Objects_Var4, X
	LDA Objects_Var4, X
	AND #$01
	TAY
	LDA BlockEaterChecks, Y
	STA Objects_Var1, X
	JMP Object_ShakeAndDrawMirroredAligned

ObjNormal_EaterBlock1:
	LDA <Temp_Var13
	ADD Objects_Var3, X
	TAY
	LDA BlockEaterYVel, Y
	STA <Objects_YVel, X
	LDA BlockEaterXVel, Y
	STA <Objects_XVel, X

ObjNormal_EaterBlock2:	
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoLimit	
	JSR Object_HitTestRespond
	
	JMP Object_ShakeAndDrawMirroredAligned

GetBlock:
	LDY #(OTDO_Water - Object_TileDetectOffsets)
	JSR Object_DetectTile
	RTS

CheckBlockAbove:
	LDA <Objects_Y, X
	STA <Temp_Var14
	SUB #$10
	STA <Objects_Y, X
	LDA <Objects_YHi, X
	STA <Temp_Var15
	SBC #$00
	STA <Objects_YHi, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_Y, X
	LDA <Temp_Var15
	STA <Objects_YHi, X
	PLA
	RTS

CheckBlockBelow:
	LDA <Objects_Y, X
	STA <Temp_Var14
	ADD #$10
	STA <Objects_Y, X
	LDA <Objects_YHi, X
	STA <Temp_Var15
	ADC #$00
	STA <Objects_YHi, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_Y, X
	LDA <Temp_Var15
	STA <Objects_YHi, X
	PLA
	RTS

CheckBlockRight:
	LDA <Objects_X, X
	STA <Temp_Var14
	ADD #$10
	STA <Objects_X, X
	LDA <Objects_XHi, X
	STA <Temp_Var15
	ADC #$00
	STA <Objects_XHi, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_X, X
	LDA <Temp_Var15
	STA <Objects_XHi, X
	PLA
	RTS

CheckBlockLeft:
	LDA <Objects_X, X
	STA <Temp_Var14
	SUB #$10
	STA <Objects_X, X
	LDA <Objects_XHi, X
	STA <Temp_Var15
	SBC #$00
	STA <Objects_XHi, X
	JSR GetBlock
	PHA
	LDA <Temp_Var14
	STA <Objects_X, X
	LDA <Temp_Var15
	STA <Objects_XHi, X
	PLA
	RTS

Player_Heights:
	.byte $06, $11

ObjHit_SolidBlock:
	LDA <Player_Y
	ADC #32
	SUB <Objects_Y, X
	STA <Temp_Var1
	CMP #$F4
	BCS ObjHit_SolidBlock_0

	CMP #$05
	BCS ObjHit_SolidBlock1

	LDA <Player_YVel
	BMI ObjHit_SolidBlock0

ObjHit_SolidBlock_0:
	LDA #$00
	STA <Player_YVel
	LDA <Objects_Y, X
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi, X
	SBC #$00
	STA <Player_YHi
	LDA #$00
	STA <Player_YVel
	STA Player_InAir

ObjHit_SolidBlock0:
	RTS

ObjHit_SolidBlock1:
	LDA #$07
	STA <Temp_Var1
	LDA <Player_Suit
	BEQ ObjHit_SolidBlock2
	LDA Player_IsDucking
	BEQ ObjHit_SolidBlock3

ObjHit_SolidBlock2:
	LDA #$13
	STA <Temp_Var1

ObjHit_SolidBlock3:
	LDA <Objects_Y, X
	ADD #$0E
	STA <Temp_Var2
	LDA <Player_Y
	ADD <Temp_Var1
	SUB <Temp_Var2
	CMP #$04
	BCS ObjHit_SolidBlock4

	LDY <Player_YVel
	BPL ObjHit_SolidBlock3_1

	LDA #$01
	STA <Player_YVel
	STA Player_HitCeiling
	
ObjHit_SolidBlock3_1:
	RTS

ObjHit_SolidBlock4:
	LDA #$00
	STA <Player_XVel
	LDA <Objects_X, X
	ADD #$08
	STA <Temp_Var1
	SUB <Player_X
	BMI ObjHit_SolidBlock5

	LDA <Objects_X, X
	SUB #$0D
	STA <Player_X
	LDA <Objects_XHi,X
	SBC #$00
	STA <Player_XHi
	RTS

ObjHit_SolidBlock5:
	LDA <Objects_X, X
	ADD #$0E
	STA <Player_X
	LDA <Objects_XHi,X
	ADC #$00
	STA <Player_XHi
	RTS

ObjNorm_StarPiece:
	LDA <Player_HaltGame
	BNE DrawStarPieceAnim

	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	LDA KPFrames, Y
	STA Objects_Frame, X

	JSR Object_HitTestRespond
	INC Objects_Var5, X
	LDA Objects_Var5, X
	LSR A
	LSR A 
	LSR A
	AND #$03
	ORA Objects_Frame, X
	STA Objects_Frame, X

DrawStarPieceAnim:
	JSR Object_ShakeAndDraw
	LDA Objects_Frame, X
	AND #$03
	TAX
	LDA KPFlips1, X
	ORA Sprite_RAM + 2, Y
	STA Sprite_RAM + 2, Y
	LDA KPFlips2, X
	ORA Sprite_RAM + 6, Y
	STA Sprite_RAM + 6, Y
	RTS

ObjInit_HardIce:
	LDA #$00
	STA Objects_XVel, X
	STA Objects_FlipBits, X
	LDA Objects_X, X
	ADD #$08
	AND #$F0
	STA Objects_X, X
	LDA #$20
	STA Objects_Timer, X
	RTS

ObjNorm_HardIce:
	LDA <Player_HaltGame
	BNE ObjNorm_HardIce2

ObjNorm_HardIce_0:
	JSR Object_InteractWithWorld
	JSR Object_DeleteOffScreen
	JSR Object_HitTestRespond

	LDA Objects_DetStat, X
	AND #HIT_DET_GRND
	BEQ ObjNorm_HardIce2

	JSR ObjectKill_Others
	LDA Objects_Var1, X
	BNE ObjNorm_HardIce1

	INC Objects_Var1, X
	LDA Object_TileProp
	CMP #TILE_PROP_ENEMY
	BEQ ObjNorm_HardIce1_0

ObjNorm_HardIce1_1:
	LDA #OBJ_ICEBLOCK
	STA Level_ObjectID, X
	RTS

ObjNorm_HardIce1_0:
	LDA #$F0
	STA Objects_YVel, X
	BNE ObjNorm_HardIce2

ObjNorm_HardIce1:
	LDA Level_ChgTileEvent
	BNE ObjNorm_HardIce2

	LDA Object_LevelTile
	EOR #$01
	STA Level_ChgTileEvent
	
	JSR SetObjectTileCoordAlignObj
	JMP Object_SetDeadEmpty

ObjNorm_HardIce2:
	JMP Object_ShakeAndDraw 
	

ObjHit_HardIce:
	LDA Objects_Var1, X
	BNE ObjHit_HardIce1
	LDA #OBJ_ICEBLOCK
	STA Level_ObjectID, X

ObjHit_HardIce1:
	RTS

ObjNorm_SnowBall:
	LDA <Player_HaltGame
	BNE ObjNorm_SnowBall2

	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BEQ ObjNorm_SnowBall1
	JSR Object_InteractWithWorld
	JSR Object_DeleteOffScreen
	JSR Object_HitTestRespond

	LDA Object_TileWallProp
	CMP #TILE_PROP_SOLID_ALL
	BCC ObjNorm_SnowBall2

ObjNorm_SnowBall1:
	LDA #OBJ_ICEBLOCK
	STA Level_ObjectID, X

ObjNorm_SnowBall2:
	INC Objects_Var1, X
	LDA Objects_Var1, X
	AND #$04
	LSR A
	LSR A
	STA Objects_Frame, X
	JMP Object_ShakeAndDraw 

SnowThrowPlayerX:
	.byte $20, $E0

ObjHit_SnowBall:
	JSR SetPlayerFrozen
	JSR Level_ObjCalcXDiffs
	LDA SnowThrowPlayerX, Y
	STA <Player_XVel
	LDA #$A0
	STA <Player_YVel
	STA <Player_InAir
	LDA #OBJ_ICEBLOCK
	STA Level_ObjectID, X
	RTS

IceFireFlyColors:
	.byte SPR_PAL1, SPR_PAL2

IceFireFlyProjectiles:
	.byte SOBJ_FIREBROFIREBALL, SOBJ_ICEBALL

IceFlyRotationX:
	.byte 24, 24, 24, 23, 22, 21, 20, 19, 17, 15, 13, 11, 9, 7, 5, 2, 0

IceFlyRotationY:
	.byte -2, -5, -7, -9, -11, -13, -15, -17, -19, -20, -21, -22, -23, -24, -24, -24, -24, -24, -24, -23, -22, -21, -20, -19, -17, -15, -13, -11, -9, -7, -5, -2, 0, 2, 5, 7, 9, 11, 13, 15, 17, 19, 20, 21, 22, 23, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 17, 15, 13, 11, 9, 7, 5, 2, 0

IceFlyRotationVel:
   .byte -$20, $20

ObjInit_IceFireFly:
	LDY Objects_Property, X
	LDA IceFireFlyProjectiles, Y
	STA Objects_Var3, X
	LDA IceFireFlyColors, Y
	STA Objects_SprAttr, X
	LDA #$00
	STA Objects_SprHVis, X
	STA Objects_SprVVis, X
	JSR SpecialObj_FindEmptyAbort
	TYA
	STA Objects_Var2, X
	LDA Objects_Var3, X
	STA SpecialObj_ID,Y
	LDA #$02
	STA SpecialObj_YHi, Y
	RTS

ObjNorm_IceFireFly:
	LDA <Player_HaltGame
	BEQ ObjNorm_IceFireFly00
	JMP ObjNorm_IceFireFly0

ObjNorm_IceFireFly00:
	LDA Objects_State, X
	CMP #OBJSTATE_KILLED
	BNE ObjNorm_IceFireFly01

	LDA Objects_Var2, X
	TAY
	LDA SpecialObj_ID, Y
	BNE ObjNorm_IceFireFly02

	JMP ObjNorm_IceFireFly4

ObjNorm_IceFireFly02:
	LDX <SlotIndexBackup
	LDA Objects_Var1, X
	AND #$20
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAX
	LDA IceFlyRotationVel, X
	STA <Temp_Var1
	LDX <SlotIndexBackup
	LDA Objects_Var2, X
	TAY
	LDA <Temp_Var1
	STA SpecialObj_XVel, Y
	JMP ObjNorm_IceFireFly4

ObjNorm_IceFireFly01:
	
	INC Objects_Var1, X
	LDA Objects_Var1, X
	AND #$0C
	LSR A
	LSR A
	STA Objects_Frame, X

	JSR Object_DeleteOffScreen
	JSR Player_HitEnemy

	LDA Objects_Var1, X
	AND #$01
	BEQ ObjNorm_IceFireFly0
	JSR Chase

ObjNorm_IceFireFly0:
	LDA Objects_X, X
	ADD #$04
	STA <Temp_Var13
	LDA Objects_XHi, X
	ADC #$00
	STA <Temp_Var14
	LDA Objects_Y, X
	STA <Temp_Var15
	LDA Objects_YHi, X
	STA <Temp_Var16

	LDA Objects_Var2, X
	TAY
	LDA Objects_Var1, X
	AND #$3F
	TAX
	LDA IceFlyRotationX, X
	BPL ObjNorm_IceFireFly1

	EOR #$FF
	ADD #$01
	STA <Temp_Var12
	LDA <Temp_Var13
	SUB <Temp_Var12
	STA SpecialObj_XLo, Y
	LDA <Temp_Var14
	SBC #$00
	STA <Temp_Var14
	JMP ObjNorm_IceFireFly2

ObjNorm_IceFireFly1:
	ADD <Temp_Var13
	STA SpecialObj_XLo, Y
	LDA <Temp_Var14
	ADC #$00
	STA <Temp_Var14

ObjNorm_IceFireFly2:
	LDA SpecialObj_XLo, Y
	CMP <Horz_Scroll
	LDA <Temp_Var14
	SBC <Horz_Scroll_Hi
	BNE ObjNorm_IceFireFly2_1

	LDA SpecialObj_XLo, Y
	CMP <Horz_Scroll
	LDA <Temp_Var14
	SBC <Horz_Scroll_Hi
	BEQ ObjNorm_IceFireFly2_2

ObjNorm_IceFireFly2_1
	LDA #$C0
	STA SpecialObj_YLo, Y
	LDA #$01
	STA SpecialObj_YHi, Y
	BNE ObjNorm_IceFireFly4
	
ObjNorm_IceFireFly2_2:
	LDA IceFlyRotationY, X
	BPL ObjNorm_IceFireFly3

	EOR #$FF
	ADD #$01
	STA <Temp_Var12
	LDA <Temp_Var15
	SUB <Temp_Var12
	STA SpecialObj_YLo, Y

	LDA <Temp_Var16
	SBC #$00
	STA SpecialObj_YHi, Y
	JMP ObjNorm_IceFireFly3_1

ObjNorm_IceFireFly3:
	ADD <Temp_Var15
	STA SpecialObj_YLo, Y

	LDA #$00
	STA SpecialObj_XVel, Y
	STA SpecialObj_YVel, Y

	LDA <Temp_Var16
	ADC #$00
	STA SpecialObj_YHi, Y

ObjNorm_IceFireFly3_1:
	LDX <SlotIndexBackup
	LDA Objects_Var3, X
	STA SpecialObj_ID,Y
	STA SpecialObj_Data, Y

ObjNorm_IceFireFly4:
	LDX <SlotIndexBackup
	JMP Object_ShakeAndDraw

Fireball_Flips:
	.byte $00, SPR_VFLIP

ObjNorm_BowserFireBall:
	LDA <Player_HaltGame
	BNE ObjNorm_BowserFireBall1

	JSR Object_DeleteOffScreen
	INC Objects_Var1, X
	LDA Objects_Var1, X
	LSR A
	AND #$01
	TAY
	LDA Objects_FlipBits, X
	AND #~SPR_VFLIP
	ORA Fireball_Flips, Y
	STA Objects_FlipBits, X
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity
	JSR Object_HitTestRespond

ObjNorm_BowserFireBall1:
	JMP Object_ShakeAndDraw

CoinLocks:
	.byte $0A, $19, $32, $32, $32, $32, $32, $63

ObjInit_CoinLock:
	LDA <Objects_Y, X
	ADD #$04
	STA <Objects_Y, X
	LDA <Objects_YHi, X
	ADC #$00
	STA <Objects_YHi, X
	LDY Objects_Property, X
	LDA CoinLocks,  Y
	STA Objects_Var1, X
	RTS

Coin_Unlock:
	LDA Level_ChgTileEvent
	BNE Coin_UnlockRTS

	JSR SpecialObj_FindEmpty
	CPY #$FF
	BEQ Coin_UnlockRTS

	STY <Temp_Var15
	JSR Object_GetAttrJustTile
	LDA Object_LevelTile
	EOR #$01
	STA Level_ChgTileEvent
	
	JSR SetObjectTileCoordAlignObj
	
	LDA Objects_SprHVis, X
	BNE Coin_Unlock0

	LDY <Temp_Var15
	LDA #SOBJ_POOF
	STA SpecialObj_ID, Y
	LDA #$20	 
	STA SpecialObj_Data, Y
	
	LDA Objects_X, X
	STA SpecialObj_XLo, Y
	LDA Objects_YHi, X
	STA SpecialObj_YHi, Y
	LDA Objects_Y, X
	STA SpecialObj_YLo, Y

Coin_Unlock0:
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	LDA Objects_Y, X
	ADD #$10
	STA Objects_Y, X
	LDA Objects_YHi, X
	ADC #$00
	STA Objects_YHi, X

	INC Objects_Var2, X
	LDA Objects_Var2, X
	CMP #$03
	BNE Coin_UnlockRTS

	LDA Objects_Y, X
	SUB #$38
	STA Objects_Y, X
	LDA Objects_YHi, X
	SBC #$00
	STA Objects_YHi, X
	JMP ObjectKill_NoScore

Coin_UnlockRTS:	
	RTS
	
ObjNorm_CoinLock:
	LDA Objects_Var1, X
	BEQ Coin_Unlock

	LDY Objects_Property, X
	LDA Objects_Var1, X
	SUB Coins_Earned
	ADD Coins_Lost
	CMP CoinLocks, Y
	BEQ ObjNorm_CoinLock0
	BCS ObjNorm_CoinLock1

ObjNorm_CoinLock0:
	STA Objects_Var1, X

ObjNorm_CoinLock1:
	LDA #$00
	STA Coins_Lost
	STA Coins_Earned

	LDA LastPatTab_Sel
	AND #$01
	STA Objects_Frame, X
	LDA #$00
	STA <Temp_Var10
	LDA LastPatTab_Sel
	EOR #$01
	TAY
	LDA #$4D
	STA PatTable_BankSel + 4, Y
	CPY #$00
	BEQ DrawCoinLock0

	LDA #$40
	STA <Temp_Var10

DrawCoinLock0:
	JSR Object_ShakeAndDraw
	LDA Objects_SprHVis,X 
	ORA Objects_SprVVis,X
	BEQ DrawCoinLock1

	LDA #$08
	STA Sprite_RAM, Y
	STA Sprite_RAM+3, Y
	STA Sprite_RAM+4, Y
	LDA #$10
	STA Sprite_RAM+7, Y


DrawCoinLock1:

	LDA Objects_Var1, X
	JSR ToThreeDigits

	LDA Sprite_RAM, Y
	ADD #$10
	STA Sprite_RAM+8, Y
	STA Sprite_RAM+12, Y

	LDA Sprite_RAM+3, Y
	STA Sprite_RAM+11, Y
	ADD #$08
	STA Sprite_RAM+15, Y

	LDA #SPR_PAL1
	STA Sprite_RAM+10,Y
	STA Sprite_RAM+14,Y

	LDA <Temp_Var2
	ASL A
	ADD #$A1
	ADD <Temp_Var10
	STA Sprite_RAM + 9, Y
	LDA <Temp_Var3
	ASL A
	ADD #$A1
	ADD <Temp_Var10
	STA Sprite_RAM + 13, Y
	RTS

ObjInit_ForcePowerUp:
	LDA #$01
	STA Player_QueueSuit
	RTS