; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-19 22:50:51.409583184 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

	; CAUTION!! ObjectGroup00 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $00 (i.e. objects starting at ID $00) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup00_InitJumpTable:
	.word ObjInit_DoNothing	; Object $00
	.word ObjInit_DoNothing	; Object $01
	.word ObjInit_DoNothing	; Object $02
	.word ObjInit_DoNothing	; Object $03
	.word ObjInit_DoNothing	; Object $04
	.word ObjInit_DoNothing	; Object $05
	.word ObjInit_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjInit_Brick	; Object $07 - OBJ_BRICK
	.word ObjInit_Coin	; Object $08 - OBJ_COIN
	.word ObjInit_Bubble	; Object $09 - OBJ_BUBBLE
	.word ObjInit_Bully	; Object $0A - OBJ_BULLY
	.word ObjInit_PUpMush	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.word ObjInit_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjInit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjInit_Koopaling	; Object $0E - OBJ_BOSS_KOOPALING
	.word ObjInit_Rain	; Object $0F - OBJ_RAIN
	.word ObjInit_Snow	; Object $10 - OBJ_SNOW
	.word ObjInit_Key	; Object $11 OBJ_KEY
	.word ObjInit_Spring	; Object $12 OBJ_SPRING
	.word ObjInit_DoNothing	; Object $13 OBJ_KEYPIECES
	.word ObjInit_GiantChomp	; Object $14 OBJ_GIANTCHOMP
	.word ObjInit_DoNothing	; Object $15 
	.word ObjInit_DoNothing	; Object $16 OBJ_KEYPIECE
	.word ObjInit_DoNothing; Object $17 - OBJ_SPINYCHEEP
	.word ObjInit_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjInit_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjInit_Bubble	; Object $1A that is a l
	.word ObjInit_BounceLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjInit_Obj1C	; Object $1C
	.word ObjInit_DoNothing	; Object $1D
	.word ObjInit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjInit_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjInit_DoNothing	; Object $20
	.word ObjInit_FireFlower	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjInit_StarOrSuit	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjInit_SuperLeaf	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup00_NormalJumpTable:
	.word ObjNorm_DoNothing	; Object $00
	.word ObjNorm_DoNothing	; Object $01
	.word ObjNorm_DoNothing	; Object $02
	.word ObjNorm_DoNothing	; Object $03
	.word ObjNorm_DoNothing	; Object $04
	.word ObjNorm_DoNothing	; Object $05
	.word ObjNorm_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjNorm_Brick	; Object $07 - OBJ_BRICK
	.word ObjNorm_Coin	; Object $08 - OBJ_COIN
	.word ObjNorm_Bubble	; Object $09 - OBJ_BUBBLE
	.word ObjNorm_Bully	; Object $0A OBJ_BULLY
	.word ObjNorm_PUpNinjaShroom; Object $0B - OBJ_POWERUP_NINJASHROOM
	.word ObjNorm_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjNorm_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjNorm_Koopaling	; Object $0E - OBJ_BOSS_KOOPALING
	.word ObjNorm_Weather	; Object $0F
	.word ObjNorm_Weather	; Object $10
	.word ObjNorm_Key	; Object $11
	.word ObjNorm_Spring	; Object $12
	.word ObjNorm_KeyPieces	; Object $13 
	.word ObjNorm_GiantChomp	; Object $14 OBJ_GIANTCHOMP
	.word ObjNorm_Boss	; Object $15 OBJ_BOSS
	.word ObjNormal_KeyPiece	; Object $16 OBJ_KEYPIECE
	.word ObjNorm_PoisonClear; Object $17 - OBJ_SPINYCHEEP
	.word ObjNorm_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjNorm_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjNorm_Bubble	; Object $1A
	.word ObjNorm_BounceLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjNorm_Obj1C	; Object $1C
	.word ObjNorm_DoNothing	; Object $1D
	.word ObjNorm_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjNorm_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjNorm_DoNothing	; Object $20
	.word ObjNorm_FireFlower	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjNorm_StarOrSuit	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjNorm_SuperLeaf	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup00_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $00
	.word ObjHit_DoNothing	; Object $01
	.word ObjHit_DoNothing	; Object $02
	.word ObjHit_DoNothing	; Object $03
	.word ObjHit_DoNothing	; Object $04
	.word ObjHit_DoNothing	; Object $05
	.word ObjHit_DoNothing	; Object $06 - OBJ_BOUNCEDOWNUP
	.word Player_GetHurt	; Object $07 - OBJ_BRICK
	.word ObjHit_Coin	; Object $08 - OBJ_COIN
	.word BubblePop	; Object $09 - OBJ_BUBBLE
	.word ObjHit_Bully	; Object $0A
	.word ObjHit_NinjaShroom	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.word ObjHit_StarOrSuit	; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjHit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjHit_Koopaling	; Object $0E - OBJ_BOSS_KOOPALING
	.word ObjHit_DoNothing	; Object $0F
	.word ObjHit_DoNothing	; Object $10
	.word ObjHit_DoNothing	; Object $11
	.word ObjHit_DoNothing	; Object $12
	.word ObjHit_DoNothing	; Object $13
	.word ObjHit_DoNothing	; Object $14 OBJ_GIANTCHOMP
	.word ObjHit_DoNothing	; Object $15
	.word ObjHit_KeyPiece	; Object $16
	.word ObjHit_DoNothing	; Object $17 - OBJ_SPINYCHEEP
	.word OCSPECIAL_HIGHSCORE; Object $18 - OBJ_BOSS_BOWSER
	.word ObjHit_FireFlower	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word BubblePop	; Object $1A
	.word ObjHit_BoundLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjHit_DoNothing	; Object $1C
	.word ObjHit_DoNothing	; Object $1D
	.word ObjHit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjHit_DoNothing	; Object $1F - OBJ_GROWINGVINE
	.word ObjHit_DoNothing	; Object $20
	.word ObjHit_IceFlower	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.word ObjHit_Pumpkin	; Object $22 - OBJ_POWERUP_PUMPKIN
	.word ObjHit_FoxLeaf    ; Object $23 - OBJ_POWERUP_FOXLEAF

	
	; Object group $00 (i.e. objects starting at ID $00) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup00_Attributes:
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $00
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $01
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $02
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $03
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $04
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $05
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $07 - OBJ_BRICK
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $08 - OBJ_COIN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $09 - OBJ_BUBBLE
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0A- OBJ_BULLY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0F - 
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $10
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $11 OBJ_KEY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $12 OBJ_REDPRING
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $13 OBJ_GREENSPRING
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $14 OBJ_GIANTCHOMP
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $15
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $16
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $17 - OBJ_SPINYCHEEP
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1A
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1C
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $1D
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1F - OBJ_GROWINGVINE
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $20
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $21 - OBJ_POWERUP_ICEFLOWER #DAHRKDAIZ
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup00_Attributes2:
	.byte OA2_TDOGRP0	; Object $00
	.byte OA2_TDOGRP1	; Object $01
	.byte OA2_TDOGRP1	; Object $02
	.byte OA2_TDOGRP5	; Object $03
	.byte OA2_TDOGRP2	; Object $04
	.byte OA2_TDOGRP1	; Object $05
	.byte OA2_TDOGRP1	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA2_TDOGRP1	; Object $07 - OBJ_BRICK
	.byte OA2_TDOGRP1	; Object $08 - OBJ_COIN
	.byte OA2_TDOGRP1	; Object $09 - OBJ_BUBBLE
	.byte OA2_TDOGRP1	; Object $0A
	.byte OA2_TDOGRP1	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OA2_TDOGRP1	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA2_TDOGRP1	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA2_TDOGRP6	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OA2_TDOGRP1	; Object $0F
	.byte OA2_TDOGRP0	; Object $10
	.byte OA2_TDOGRP1	; Object $11
	.byte OA2_TDOGRP1	; Object $12
	.byte OA2_TDOGRP1	; Object $13
	.byte OA2_TDOGRP0	; Object $14
	.byte OA2_TDOGRP0	; Object $15
	.byte  OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $16
	.byte OA2_TDOGRP1	; Object $17 - OBJ_SPINYCHEEP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP12	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA2_TDOGRP1	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA2_TDOGRP1	; Object $1A
	.byte OA2_TDOGRP1	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA2_TDOGRP1	; Object $1C
	.byte OA2_TDOGRP2	; Object $1D
	.byte OA2_TDOGRP1	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA2_TDOGRP1	; Object $1F - OBJ_GROWINGVINE
	.byte OA2_TDOGRP0	; Object $20
	.byte OA2_TDOGRP1	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OA2_TDOGRP1	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA2_TDOGRP1	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) third set attribute bits

	; Attribute bits for objects:
	;	Bits 0-3: Determines what to do when gameplay halted (see Object_DoHaltedAction, most common is 5 / 0101)
	
	;	Bit 5: Object is NOT stompable (e.g. a spikey enemy, HURTS PLAYER, not same as attr 2 bit 2 which is just indifferent)
	;	Bit 6: The CollideJumpTable entry MAY contain the "special" entry; see CollideJumpTable; also "dies" into "shell" (state 3) (i.e. object "bumps" into shell when hit from beneath)
	;	Bit 7: If set, object cannot be tail attacked

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup00_Attributes3:
	.byte OA3_HALT_NORMALONLY 	; Object $00
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $01
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $02
	.byte OA3_HALT_JUSTDRAWWIDE 	; Object $03
	.byte OA3_HALT_JUSTDRAWTALL 	; Object $04
	.byte OA3_HALT_JUSTDRAW 	; Object $05
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $07 - OBJ_BRICK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $08 - OBJ_COIN
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE |OA3_NOTSTOMPABLE 	; Object $09 - OBJ_BUBBLE
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $0A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $0F
	.byte OA3_HALT_NORMALONLY 	; Object $10
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_DIESHELLED 	; Object $11
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE  	; Object $12
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE  	; Object $13
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE  	; Object $14
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $15
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $16
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $17 - OBJ_SPINYCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE |OA3_NOTSTOMPABLE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA3_HALT_JUSTDRAW 	; Object $1A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $1C
	.byte OA3_HALT_DONOTHING 	; Object $1D
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $1F - OBJ_GROWINGVINE
	.byte OA3_HALT_NORMALONLY 	; Object $20
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup00_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $00
	.byte OPTS_SETPT5 | $48	; Object $01
	.byte OPTS_SETPT5 | $4C	; Object $02
	.byte OPTS_SETPT5 | $48	; Object $03
	.byte OPTS_SETPT5 | $48	; Object $04
	.byte OPTS_SETPT5 | $48	; Object $05
	.byte OPTS_NOCHANGE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OPTS_NOCHANGE	; Object $07 - OBJ_BRICK
	.byte OPTS_NOCHANGE	; Object $08 - OBJ_COIN
	.byte OPTS_NOCHANGE	; Object $09 - OBJ_BUBBLE
	.byte OPTS_SETPT5 | $0B	; Object $0A - OBJ_BULLY
	.byte OPTS_NOCHANGE	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte OPTS_NOCHANGE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OPTS_NOCHANGE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OPTS_NOCHANGE	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OPTS_NOCHANGE	; Object $0F
	.byte OPTS_NOCHANGE	; Object $10
	.byte OPTS_NOCHANGE	; Object $11
	.byte OPTS_SETPT6 | $4F		; Object $12
	.byte OPTS_NOCHANGE		; Object $13
	.byte OPTS_SETPT5 | $0E	; Object $14
	.byte OPTS_NOCHANGE	; Object $15
	.byte OPTS_NOCHANGE	; Object $16
	.byte OPTS_SETPT5 | $1A	; Object $17 - OBJ_SPINYCHEEP
	.byte OPTS_SETPT5 | $3A	; Object $18 - OBJ_BOSS_BOWSER
	.byte OPTS_NOCHANGE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OPTS_SETPT5 | $1A	; Object $1A
	.byte OPTS_NOCHANGE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OPTS_NOCHANGE	; Object $1C
	.byte OPTS_SETPT5 | $48	; Object $1D
	.byte OPTS_NOCHANGE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OPTS_NOCHANGE	; Object $1F - OBJ_GROWINGVINE
	.byte OPTS_SETPT5 | $0A	; Object $20
	.byte OPTS_NOCHANGE	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte OPTS_NOCHANGE	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte OPTS_NOCHANGE	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup00_KillAction:
	.byte KILLACT_STANDARD	; Object $00
	.byte KILLACT_STANDARD	; Object $01
	.byte KILLACT_STANDARD	; Object $02
	.byte KILLACT_STANDARD	; Object $03
	.byte KILLACT_STANDARD	; Object $04
	.byte KILLACT_STANDARD	; Object $05
	.byte KILLACT_STANDARD	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte KILLACT_STANDARD	; Object $07 - OBJ_BRICK
	.byte KILLACT_STANDARD	; Object $08 - OBJ_COIN
	.byte KILLACT_STANDARD	; Object $09 - OBJ_BUBBLE
	.byte KILLACT_STANDARD	; Object $0A
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0B - OBJ_POWERUP_NINJASHROOM
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0C - OBJ_POWERUP_STARMAN
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte KILLACT_NORMALANDKILLED	; Object $0E - OBJ_BOSS_KOOPALING
	.byte KILLACT_STANDARD	; Object $0F
	.byte KILLACT_STANDARD	; Object $10
	.byte KILLACT_STANDARD	; Object $11
	.byte KILLACT_STANDARD	; Object $12
	.byte KILLACT_STANDARD	; Object $13
	.byte KILLACT_STANDARD	; Object $14
	.byte KILLACT_NORMALSTATE	; Object $15
	.byte KILLACT_STANDARD	; Object $16
	.byte KILLACT_JUSTDRAW16X16	; Object $17 - OBJ_SPINYCHEEP
	.byte KILLACT_NORMALSTATE	; Object $18 - OBJ_BOSS_BOWSER
	.byte KILLACT_JUSTDRAWMIRROR	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte KILLACT_STANDARD	; Object $1A
	.byte KILLACT_STANDARD	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte KILLACT_STANDARD	; Object $1C
	.byte KILLACT_STANDARD	; Object $1D
	.byte KILLACT_STANDARD	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte KILLACT_STANDARD	; Object $1F - OBJ_GROWINGVINE
	.byte KILLACT_STANDARD	; Object $20
	.byte KILLACT_STANDARD	; Object $21 - OBJ_POWERUP_ICEFLOWER
	.byte KILLACT_STANDARD	; Object $22 - OBJ_POWERUP_PUMPKIN
	.byte KILLACT_STANDARD	; Object $23 - OBJ_POWERUP_FOXLEAF


	; Object group $00 (i.e. objects starting at ID $00) pattern index starts
	; These are used for all states except "normal"

OG0_POff .func (\1 - ObjectGroup00_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup00_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG0_POff(ObjP00), OG0_POff(ObjP01), OG0_POff(ObjP02), OG0_POff(ObjP03)
	.byte OG0_POff(ObjP04), OG0_POff(ObjP05), OG0_POff(ObjP06), OG0_POff(ObjP07)
	.byte OG0_POff(ObjP08), OG0_POff(ObjP09), OG0_POff(ObjP0A), OG0_POff(ObjP0B)
	.byte OG0_POff(ObjP0C), OG0_POff(ObjP0D), OG0_POff(ObjP0E), OG0_POff(ObjP0F)
	.byte OG0_POff(ObjP10), OG0_POff(ObjP11), OG0_POff(ObjP12), OG0_POff(ObjP13)
	.byte OG0_POff(ObjP14), OG0_POff(ObjP15), OG0_POff(ObjP16), OG0_POff(ObjP17)
	.byte OG0_POff(ObjP18), OG0_POff(ObjP19), OG0_POff(ObjP1A), OG0_POff(ObjP1B)
	.byte OG0_POff(ObjP1C), OG0_POff(ObjP1D), OG0_POff(ObjP1E), OG0_POff(ObjP1F)
	.byte OG0_POff(ObjP20), OG0_POff(ObjP21), OG0_POff(ObjP22), OG0_POff(ObjP23)

	; Object group $00 (i.e. objects starting at ID $00) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup00_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup00_PatternSets:
	; (End restricted alignment space)
ObjP00:
ObjP03:
ObjP07:
	.byte $67, $67

ObjP0E:
ObjP0F:
ObjP10:
ObjP11:
	.byte $69, $7D, $69, $7D, $69, $7D
ObjP12:
	.byte $D7, $D7, $ED, $ED, $FF, $FF
ObjP13:
ObjP16:
	.byte $69, $7D, $71, $71

ObjP14:
ObjP15:
ObjP17:
ObjP18:	
ObjP1D:
ObjP20:	.byte $AD, $AF, $B9, $BB, $B9, $BB
ObjP01:	.byte $81, $81
ObjP02:	.byte $8F, $8F, $99, $9B, $9D, $9F
ObjP04:	.byte $B1, $B3, $B5, $B7, $B9, $BB, $BD, $BF
ObjP05:	.byte $A5, $A7, $A1, $A3, $A1, $A3
ObjP06:	
ObjP1B:	.byte $79, $7B, $79, $7B, $77, $77, $75, $75	; RAS: Not actually used, see BounceBlock_Tile
ObjP09:	
ObjP1A: .byte $8D, $8D, $8F, $8F, $91, $91, $A7, $A7, $A9, $A9, $AB, $AB
ObjP0A:	.byte $A9, $AB, $BD, $BF
ObjP0C:	.byte $51, $53, $51, $53, $51, $53, $51, $53
ObjP0B:	.byte $51, $53	; #DAHRKDAIZ changed 1Up to use a "Ninja Mushroom" sprite instead, separate from regular mushroom
ObjP0D:	.byte $51, $53
ObjP19:	.byte $51, $53
ObjP1C:	.byte $75, $77
ObjP1E:	.byte $51, $53
ObjP1F:	.byte $51, $53	; #DAHRKDAIZ - VINE
ObjP21:	.byte $51, $53
ObjP22:	.byte $51, $53 ; #DAHRKDAIZ - PUMPKIN
ObjP23:	.byte $51, $53	; #DAHRKDAIZ - GOLD LEAF
ObjP08:	.byte $BB, $BB, $FB, $F9, $FB, $F9, $FF, $FD, $DA, $DA

SpringPals: .byte SPR_PAL1, SPR_PAL2, SPR_PAL3
ObjInit_Spring:
	LDY Objects_Property, X
	LDA SpringPals, Y
	STA Objects_SprAttr,X
	RTS

Spring_Jump_Height:
	.byte $C0, $B8, $B0

Spring_Frames:
	.byte $00, $01, $02, $01

Spring_Player_YOffsets:
	.byte $20, $1C, $17, $1C

ObjNorm_Spring:
	JSR Object_ShakeAndDrawMirrored
	LDA <Player_HaltGame
	BNE Spring_RTS
	JSR Object_DeleteOffScreen
	JSR ObjectCarry
	LDY Objects_Var2, X
	LDA Spring_Frames, Y
	STA Objects_Frame, X
	
	JSR Object_Move
	LDA <Objects_DetStat,X
	AND #$04
	BEQ DontMoveSpring
	JSR Object_HitGround
	LDA #$00
	STA Objects_XVel, X

DontMoveSpring:
	LDA Objects_Var2, X
	BNE SpringAnim

	LDA <Player_YVel
	BEQ Spring_RTS
	BMI Spring_RTS

	JSR Object_HitTest
	BCC Spring_RTS
	LDA #$02
	STA Objects_Timer, X
	LDA #$03
	STA Objects_Var2, X
	LDA #$00
	STA Objects_Var3, X
	BEQ SpringAnim

Spring_RTS:
	RTS

SpringAnim:
	LDY Objects_Var2, X
	LDA Objects_Y, X
	SUB Spring_Player_YOffsets, Y
	STA <Player_Y
	LDA <Objects_YHi, X
	SBC #$00
	STA <Player_YHi
	LDA #$00
	STA <Player_YVel
	STA <Player_InAir

	LDA Objects_Timer, X
	BNE SpringAnimRTS
	LDA #$02
	STA Objects_Timer, X
	DEC Objects_Var2, X
	BNE SpringAnimRTS
	LDY Objects_Property, X
	LDA Spring_Jump_Height, Y
	STA <Player_YVel
	STA <Player_InAir
	LDA #$E0
	STA <Objects_YVel, X

SpringAnimRTS:
	RTS

ObjInit_Key:
	LDA #OBJSTATE_SHELLED
	STA Objects_State,X
	LDA #$E0
	STA <Objects_YVel, X
	RTS

ObjNorm_Key:
	
	RTS

PC_MemoryPoints:
	.word $6000
	.word $62F7
	.word $6307
	.word $6317
	.word $6327
	.word $6337
	.word $6347
	.word $7000
	.word $7000
	.word $7000

WorldDoorTiles:
	.byte $00, $1E

ObjNorm_PoisonClear:
	LDX World_Num
	LDA Mushrooms_Defeated, X
	BEQ ObjNorm_PoisonClearRTS
	STA <Temp_Var3

BlankTileOut:
	LDA <Temp_Var3
	ASL A
	TAX
	LDA PC_MemoryPoints, X
	STA <Temp_Var1
	LDA PC_MemoryPoints + 1, X
	STA <Temp_Var2
	LDY #$00
	LDX World_Num
	LDA WorldDoorTiles, X
	STA [Temp_Var1], Y
	INY
	STA [Temp_Var1], Y
	INY
	STA [Temp_Var1], Y
	INY
	STA [Temp_Var1], Y
	DEC <Temp_Var3
	BNE BlankTileOut

	
ObjNorm_PoisonClearRTS:
	LDX <SlotIndexBackup
	JMP Object_Delete

ObjInit_BounceDU: 
	LDA Level_BlkFinish
	STA Objects_Var2,X	 ; Store Player's bounce into var 2
	LDA Player_BounceDir
	STA Objects_Var3,X
	LDA #$00
	STA Level_BlkFinish

PRG001_A4C6:
	LDA Player_Bounce
	STA Objects_Var1,X	; Store Player_Bounce -> var1

	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 ; Shift right 4
	STA Objects_Frame,X	 ; Store into Objects_Frame 
 
	LDA #$00
	STA Player_Bounce	 ; Clear Player_Bounce
	STA Player_BounceObj	 ; Clear Player_BounceObj
	STA Objects_FlipBits,X	 ; Force left/right flag to zero
	STA Objects_SprVVis,X	 ; Clear flags 2
	STA Objects_SprHVis,X	 ; Clear flags 1

	LDA #10
	STA Level_BlkBump_Pos-6,X ; Block bump position = 10

	JMP BounceBlock_Update	 ; Jump to BounceBlock_Update

	; Power-up which may emerge from different types of bounce blocks

Bouncer_PUp:
	.byte $00, $00, OBJ_POWERUP_FIREFLOWER, OBJ_POWERUP_SUPERLEAF, OBJ_POWERUP_STARMAN, OBJ_POWERUP_MUSHROOM, OBJ_GROWINGVINE, OBJ_POWERUP_NINJASHROOM, OBJ_POWERUP_ICEFLOWER, OBJ_POWERUP_PUMPKIN, OBJ_POWERUP_FOXLEAF; #DAHRKDAIZ added OBJ_POWERUP_ICE

	; Power-up X or Y velocity upon emerging from the bounce block
Bouncer_PUpVel:	.byte $00, -$40, -$40, -$30, -$20, -$10, $00, $10, $20, $30, $40


ObjNorm_BounceDU:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_A56F	 ; If the block bump position > 0, jump to PRG001_A56F

	; Block bump complete
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	; Set state to dead/empty
	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Var1 >> 4 -> 'Y'

	LDA Objects_Var2,X

PRG001_A527:
	STA <Temp_Var12  ; -> Temp_Var12

	; Temp_Var15 = bumper X Hi
	LDA <Objects_XHi,X
	STA <Temp_Var15	 

	; Temp_Var16 = bumper X
	LDA <Objects_X,X
	STA <Temp_Var16	 

	; Temp_Var13 = bumper Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Temp_Var14 = bumper Y, grid aligned
	LDA <Objects_Y,X
	AND #$f0	
	STA <Temp_Var14	

	JSR BlockBump_Init

	LDA Objects_Var3,X
	BNE PRG001_A56E	 ; If Var 2 <> 0, jump to PRG001_A56E (RTS)

	LDA #-$38
	STA <Player_YVel	 ; Set Player bounce
	STA Player_mGoomba	 

	LDA Objects_Timer2,X
	BEQ PRG001_A56E	 ; If timer 2 expired, jump to PRG001_A56E (RTS)

	LDA #-$70
	STA <Player_YVel	; Larger Player bounce

	LDA Objects_Var1,X
	AND #$f0
	CMP #$10
	BNE PRG001_A56E	 ; If var 1 upper 4 bits <> $10, jump to PRG001_A56E (RTS)

	LDA Player_InWater
	BNE PRG001_A56E	 ; If Player is in water, jump to PRG001_A56E (RTS)

	; Flag to go to coin heaven
	LDA #$80
	STA Level_CoinHeav

	; Bounce into coin heaven sound
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

PRG001_A56E:
	RTS		 ; Return


PRG001_A56F:
	LDA Level_BlkBump_Pos-6,X
	CMP #10
	BNE PRG001_A5D5	 ; If Block bump position <> 10, jump to PRG001_A5D5

	; Block bump position is 10...

	LDA Objects_Var1,X
	AND #$0f
	TAY		 ; Y = 0 to 15, based on var 1

	LDA Bouncer_PUp,Y
	BEQ PRG001_A5BB	 ; If value is zero (no power up), jump to PRG001_A5BB

	LDY #$05	 ; Y = 5 (power-up always in slot 5)
	STA Level_ObjectID,Y

	; Set X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var1

	LDA #$08	 ; A = 8

	STY <Temp_Var2		 ; Backup 'Y' -> Temp_Var2

	LDY Objects_Var2,X
	BEQ PRG001_A5AA	 ; If var2 = 0, jump to PRG001_A5AA

	DEC <Temp_Var1	 ; Temp_Var1-- (Y Hi)
	LDA #-1		 ; A = -1

PRG001_A5AA:
	LDY <Temp_Var2	 ; Restore 'Y'

	ADD <Objects_Y,X ; Apply Y offset
	STA Objects_Y,Y	 ; -> Object's Y
 
	BCC PRG001_A5B6	 ; If no carry, jump to PRG001_A5B6

	INC <Temp_Var1	 ; Apply carry

PRG001_A5B6:
	; Set Y Hi
	LDA <Temp_Var1
	STA Objects_YHi,Y

PRG001_A5BB:
	; Backup Y Hi -> Temp_Var13 
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Backup Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14

	; Backup X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15

	; Backup X -> Temp_Var16
	LDA <Objects_X,X
	STA <Temp_Var16

	LDA Objects_Var2,X
	BEQ PRG001_A5D5	 ; If Var2 = 0, jump to PRG001_A5D5



PRG001_A5D5:
	JSR Object_ApplyYVel	 ; Apply Y velocity
	JSR BounceBlock_Update

	LDY Level_BlkBump_Pos-6,X	; Y = block bump pos

	LDA Bouncer_PUpVel,Y

	LDY Objects_Var3,X	 ; Y = var2
	BEQ PRG001_A5EE	 ; If Var2 = 0, jump to PRG001_A5EE

	JSR Negate	 ; Negate retrieved Y Velocity

	STA <Objects_YVel,X	; Set Y Velocity 

	JMP PRG001_A5FD	 ; Jump to PRG001_A5FD

PRG001_A5EE:
	STA <Objects_YVel,X	 ; Set Y Velocity 
	STA <Player_YVel	 ; ... of Player too

	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG001_A5FD	 ; If Player is not pressing A, jump to PRG001_A5FD

	; Otherwise, Timer 2 = 11
	LDA #$0b
	STA Objects_Timer2,X

PRG001_A5FD:
	DEC Level_BlkBump_Pos-6,X	; Block bump pos--
	RTS		 ; Return

	; The following block bounces are referenced by PRG008's LATR_BlockResult
	; Type 7 is for the UNUSED breakable pipeworks tile!

	; Palette select for a bounce block
BounceBlock_Pal:
	.byte SPR_PAL1	; 0 (possibly unused / Note Block)
	.byte SPR_PAL2	; 1 (coin heaven Note Block)
	.byte SPR_PAL3	; 2 ("Metal plate" post-? block hit)
	.byte SPR_PAL3	; 3 (used for empty brick)
	.byte SPR_PAL3	; 4 (typical Note Block)
	.byte SPR_PAL3	; 5 (wood)
	.byte SPR_PAL3	; 6 (used for brick with coins)
	.byte SPR_PAL1	; 7 (UNUSED, would be for desert's breakable pipeworks tile!)

	; Offset into Sprite_RAM based on which block bounce slot
BounceBlock_SprOff:
	.byte $08, $10

	; Tile for block bounce sprite (if same, mirrors)
BounceBlock_Tile:
	.byte $79, $79	; 0 (possibly unused / Note Block)
	.byte $79, $79	; 1 (coin heaven Note Block)
	.byte $6B, $6B	; 2 ("Metal plate" post-? block hit)
	.byte $67, $67	; 3 (used for empty brick)
	.byte $77, $77	; 4 (typical Note Block)
	.byte $7F, $7F	; 5 (wood)
	.byte $67, $69	; 6 (used for brick with coins)

BounceBlock_Update:
	LDA Objects_Var1,X	; Player_Bounce
	LSR A
	LSR A
	LSR A
	LSR A		; Get kind of block that is getting bounced
	TAY		; -> Y

	; Temp_Var1 stores palette of object
	LDA BounceBlock_Pal,Y	
	STA <Temp_Var1

	; Y *= 2
	TYA
	ASL A
	TAY

	; Temp_Var2/3 store the tiles that make up the sprites of the bounce block
	LDA BounceBlock_Tile,Y
	STA <Temp_Var2		
	LDA BounceBlock_Tile+1,Y
	STA <Temp_Var3		

	LDA #$00	 ; A = 0 (do not flip second sprite)

	LDY <Temp_Var2
	CPY <Temp_Var3
	BNE PRG001_A63F	 ; If tiles are NOT the same, jump to PRG001_A63F

	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (flip second sprite)

PRG001_A63F:
	STA <Temp_Var4	 ; Store the selected sprite attribute

	; Select own range of sprite area
	LDA #$05
	ADD Counter_7to0
	TAY		 ; Y = 5 + (0 to 7)

	LDA SprRamOffsets,Y
	PHA		 ; Save this value

	; Block bouncers always appear in object slot 6 or 7, so this makes it relative to 0 or 1
	TXA		 
	SUB #$06	 
	TAY		 ; Y = 0 or 1
 
	PLA		 ; Restore the value

	ADD BounceBlock_SprOff,Y
	TAY		 ; Y is now offset into Sprite_RAM

	; Screen-relative X position for sprite position
	LDA <Objects_X,X
	SUB Horz_Scroll	
	STA <Objects_SpriteX,X

	; Store two pieces of bounce block sprite X
	STA Sprite_RAM+3,Y
	ADD #$08	 
	STA Sprite_RAM+7,Y

	; Screen-relative Y position for sprite position
	LDA <Objects_Y,X
	SUB Level_VertScroll
	SUB #$01
	STA <Objects_SpriteY,X

	; Store two pieces of bounce block sprite Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Build the other parts of sprites
	LDA <Temp_Var2
	STA Sprite_RAM+1,Y

	LDA <Temp_Var3
	STA Sprite_RAM+5,Y

	LDA <Temp_Var1
	STA Sprite_RAM+2,Y

	ORA <Temp_Var4
	STA Sprite_RAM+6,Y

	RTS		 ; Return

	
ObjInit_Bubble:
	LDA #$01
	STA ObjSplash_DisTimer, X
	LDA #$03
	STA Objects_Var1, X
	LDA Objects_Property, X
	BEQ ObjInit_BubbleRTS

	LDA #$1A
	STA PatTable_BankSel + 4
	LDA #$00
	STA Objects_Var1, X
	LDA #$08
	STA Objects_SlowTimer, X

ObjInit_BubbleRTS:
	LDA <Objects_Y, X
	STA Objects_Var2, X
	LDA <Objects_YHi, X
	STA Objects_Var3, X
	RTS		 ; Return


ObjNorm_Bubble:
	JSR Object_DeleteOffScreen

	LDA Objects_SlowTimer, X
	BNE BubbleRTS

	LDA Objects_Var1, X
	CMP #$03
	BEQ BubbleNorm
	BCS BubblePop

	LDA <Player_HaltGame
	BNE BubbleDraw
	
	LDA <Counter_1
	AND #$07
	BNE ObjNorm_Bubble1
	INC Objects_Var1, X

ObjNorm_Bubble1:
	LDA Objects_Var1, X
	STA Objects_Frame, X
	JMP Object_ShakeAndDrawMirrored

BubbleNorm:
	JSR Object_WorldDetect4
	LDA Objects_DetStat, X
	AND #HIT_DET_CEIL
	BNE BubbleNorm2
	LDA Objects_YVel, X
	CMP #$F8
	BEQ BubbleNorm1

	DEC Objects_YVel, X

BubbleNorm1:
	JSR Object_ApplyYVel

BubbleNorm2:
	LDA #$03
	STA Objects_Frame, X
	JSR Object_HitTestRespond

BubbleDraw:
	JSR Object_ShakeAndDrawMirrored
	LDY Object_SprRAM,X
	LDA Sprite_RAM +6, Y
	ORA #SPR_VFLIP
	STA Sprite_RAM +6, Y

BubbleRTS:
	RTS		 ; Return

BubblePop:
	LDA Objects_Var1, X
	STA Objects_Frame, X
	CMP #$05
	BEQ BubblePopped
	LDA <Counter_1
	AND #$07
	BEQ BubblePopRTS
	INC Objects_Var1, X
	LDA #$40
	STA Air_Time

BubblePopRTS:
	BNE  BubbleDraw
	RTS

BubblePopped:
	LDA Objects_Property, X
	BEQ DestroyBubble
	LDA Objects_Var2, X
	STA Objects_Y, X
	LDA Objects_Var3, X
	STA Objects_YHi, X
	LDA #$00
	STA Objects_Var1, X
	STA Objects_Var4, X
	LDA #$80
	STA Objects_SlowTimer, X
	RTS

DestroyBubble:
	JMP Object_SetDeadAndNotSpawned

ObjInit_Bully:
	LDA #$40
	STA Objects_Var1, X	; Var1 = march timer
	LDA #$00
	STA Objects_Var2, X	; Var2 = about to charge timer
	STA Objects_Var3, X ; Var3 = charging timer
	JSR Level_ObjCalcXDiffs
	LDA Bully_XVel, Y
	STA Objects_XVel, X
	RTS		 ; Return

Bully_XVel: .byte $08, $F8
Bully_XVelCharge: .byte $20, $E0

ObjNorm_Bully:
	
	JSR Object_MoveAndReboundOffWall	 ; Move, detect, interact with blocks of world
	JSR Level_ObjCalcXDiffs

	LDA Objects_Var1, X
	BEQ BullyNot_March

	DEC Objects_Var1, X
	BNE DontChargeYet
	LDA #$30
	STA Objects_Var2, X

DontChargeYet:
	JMP Bully_JustDraw

BullyNot_March:
	LDA Objects_Var2, X
	BEQ Bully_DoCharge
	LDA #$00
	STA Objects_XVel, X
	DEC Objects_Var2, X
	BNE Dont_Bully_Yet
	LDA #$60
	STA Objects_Var3, X
	LDA Bully_XVelCharge, Y
	STA Objects_XVel, X

Dont_Bully_Yet:
	JMP Bully_Draw_Fast

Bully_DoCharge:
	DEC Objects_Var3, X
	BNE Bully_Draw_Fast
	JSR ObjInit_Bully		; Reset bully parameters
	JMP Bully_JustDraw

Bully_Draw_Fast:
	LDA <Counter_1
	AND #$04
	LSR A	
	LSR A	
	JMP Do_Bully_Draw
	
Bully_JustDraw:
	LDA <Counter_1
	AND #$08
	LSR A	
	LSR A	
	LSR A	

Do_Bully_Draw:
	STA Objects_Frame,X	 ; Alternate between frame 0 and 1 every 8 ticks
	LDY #$00
	LDA Objects_XVel, X
	BMI BullyFlip
	LDY #SPR_HFLIP

BullyFlip:
	TYA
	STA Objects_FlipBits,X

	JSR Object_ShakeAndDraw	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
	JSR Object_HitTestRespond	 ; hit test

	RTS		 ; Return

ObjHit_Bully:
	LDA Player_StarInv
	ORA Boo_Mode_KillTimer
	ORA Fox_FireBall
	BEQ Do_Knock_Back	 ; If Player is NOT invincible, jump to PRG000_D922

	LDA #OBJSTATE_KILLED
	STA Objects_State,X	 ; Set object state to Killed

	LDA #-$38	
	STA <Objects_YVel,X	 ; Set Y Velocity to -$38

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; 100 points pop up
	INC Exp_Earned
	RTS 

Do_Knock_Back:
	LDA <Objects_XVel, X
	BPL Do_Knock
	JSR Negate
	ASL A
	JSR Negate

Do_Knock:
	ASL A
	STA <Player_XVel
	LDA #$C8
	STA <Player_YVel
	STA Player_InAir
	LDA Sound_QPlayer 
	ORA #SND_PLAYERBUMP 
	STA Sound_QPlayer
	;JSR ObjInit_Obj0A
	RTS		 ; Return

ObjNorm_PUpNinjaShroom:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A78E	 	; If mushroom has not hit ground, jump to PRG001_A78E

	LDA <Objects_XVel,X
	BNE PRG001_A78E	 	; If mushroom is moving horizontally, jump to PRG001_A78E

	JSR PowerUp_BounceXVel	 ; Bounce off wall

PRG001_A78E:
	JSR Object_InteractWithWorld	 	; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen 		; Delete object if it falls off screen
	JMP PowerUp_DoHitTest	 		; Do hit test and don't come back!


ObjHit_NinjaShroom:
	JSR Try_PUp_Reserve
	JSR Get_Normalized_Suit
	CMP #$0B
	BNE Do_Ninja_Power
	JMP PUp_GeneralCollect

Do_Ninja_Power:

	LDA #$0C
	JMP Do_PUp_Poof_Collect


Star_Palettes:
	.byte SPR_PAL0, SPR_PAL2, SPR_PAL2, SPR_PAL3

ObjInit_StarOrSuit:
	LDA From_Reserve
	BEQ Do_Star_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	BNE Do_Star_Init2

Do_Star_Init:
	JSR Mushroom_SetFall	 ; Figure the way that the star should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ PRG001_A7BF	 
	LDY #-$38

	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X	 ; Set object's timer to $3d

PRG001_A7BF:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?

	JSR PowerUp_BounceXVel	 ; Bounce off wall

Do_Star_Init2:
	LDA PUp_StarManFlash
	AND #$03	 
	STA Objects_Frame,X
	TAY
	BEQ Star_RTS

	; Set a start palette
	LDA Star_Palettes,Y
	STA Objects_SprAttr,X
Star_RTS:
	RTS		 ; Return


ObjNorm_StarOrSuit:
	LDA PUp_StarManFlash
	BPL PRG001_A7E0	 ; If flashing is not active, jump to PRG001_A7E0

	; Store counter into cycler
	LDA <Counter_1	
	STA Objects_ColorCycle,X

PRG001_A7E0:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world

	LDA <Objects_DetStat,X
	TAY		 ; Detection status -> 'Y'

	AND #$04
	BEQ PRG001_A7F1	 ; If star hasn't touched the ground, jump to PRG001_A7F1

	LDA #-$40
	STA <Objects_YVel,X	; Star bounce off ground!

PRG001_A7F1:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!

	; Different "frames" of the "Starman" power up include the super
	; suits; Tanooki, Frog, and Hammer, in order
PUp_StarOrSuitFrames:	.byte $00, $51, $51, $51	; Star, Tanooki, Frog, Hammer

ObjHit_StarOrSuit:
	LDA Objects_Frame,X
	BNE PRG001_A818	 ; If frame <> 0, jump to PRG001_A818

	LDA Level_PSwitchCnt
	BNE PRG001_A810	 ; If P-Switch is active, jump to PRG001_A810

	; Otherwise, play invincibility theme!
	LDA Sound_QMusic2
	ORA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2

PRG001_A810:

	; Player_StarInv = $E0
	LDA #$e0
	STA Player_StarInv

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect

PRG001_A818:

	LDA PUp_StarManFlash
	CLC
	ADC #$03	 ; Frame -> 'Y' (index)
	STA DAIZ_TEMP1
	JSR Try_PUp_Reserve
	JSR Get_Normalized_Suit
	CMP DAIZ_TEMP1
	BNE Do_Suit_Power
	JMP PUp_GeneralCollect

Do_Suit_Power:
	LDA DAIZ_TEMP1
	TAY		 ; Suit -> 'Y'
	INY		 ; Y++ (valid Player_QueueSuit value)
	TYA
	CMP #$05
	BNE Do_Suit_Power1
	LDA #AIR_INCREASE
	STA Air_Change
	LDA #$05

Do_Suit_Power1:
	JMP Do_PUp_Poof_Collect


ObjInit_PUpMush:
	LDA From_Reserve
	BEQ Do_Shroom_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	RTS

Do_Shroom_Init:
	JSR Mushroom_SetFall	 ; Figure the way that the mushroom should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; RAS: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A852	 ; If flashing is NOT active, jump to PRG001_A852

	JSR Mushroom_SetXVel	 ; Set's X velocity appropriately by Player's 

	LDY #-$38
	JSR Mushroom_SetUpVel	 ; Set vertical velocity and mid air flag
	JMP PRG001_A859		; Jump to PRG001_A859

PRG001_A852:

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ Mushroom_SetUpVel

PRG001_A859:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X

	RTS		 ; Return


Mushroom_SetUpVel:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return


Mushroom_SetXVel:
	LDY #$10	 ; Y = $10

	LDA <Player_X
	AND #$10	 ; determine if Player is on even/odd tile
	BNE PRG001_A86E	 ; Jump to PRG001_A86E if odd
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A86E:
	STY <Objects_XVel,X	 ; Set X velocity appropriately
	RTS		 ; Return


ObjNorm_PUpMush:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A881	 ; If mushroom has NOT hit the ground, jump to PRG001_A881

	LDA <Objects_XVel,X
	BNE PRG001_A881	 ; If mushroom hasn't hit a wall, jump to PRG001_A881

	JSR PowerUp_BounceXVel	 ; Otherwise, bounce off wall!

PRG001_A881:
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PowerUp_DoHitTest:
	; Cannot collect power up while it's "raising"
	LDA Objects_Timer2,X
	BNE PRG001_A892	 ; If the timer is still active, jump to PRG001_A892 (RTS)

	JSR Object_HitTestRespond	 ; Otherwise, perform hit testing

PRG001_A892:
	RTS		 ; Return

ObjHit_PUpMush:

	; Temp_Var = 1
	LDA #$01
	STA <Temp_Var1

PRG001_A897:
	LDA <Player_Suit
	BEQ Do_Grow
	LDA Player_Ability
	CMP #$07
	BNE Just_Collect
	LDA #$01
	STA PowerUp_Reserve
Just_Collect:
	JMP PUp_GeneralCollect	; If Player is not small, jump to PUp_GeneralCollect

Do_Grow:
	LDA #$02
	STA Player_QueueSuit

PRG001_A8AB:

	; Do "growing" animation
	LDA #$2f
	STA Player_Grow

PUp_GeneralCollect:
	JSR PowerUp_PlaySound	 ; Play Power Up sound
	LDA #OBJSTATE_DEADEMPTY
	LDX <SlotIndexBackup
	STA Objects_State, X	 ; Set power-up to dead/empty

	RTS		 ; Return

PowerUp_PlaySound:
	; Play the standard "Power Up" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	RTS		 ; Return

PowerUp_DoRaise:
	LDA PowerUp_NoRaise
	BEQ PowerUp_DoRaise1
	LDA #$00
	STA PowerUp_NoRaise
	STA Objects_Timer, X

PowerUp_DoRaise1:
	LDA Objects_Timer,X
	BEQ PRG001_A940	 ; If timer expired, jump to PRG001_A940 (will NOT return here if game is halted)

	CMP #$2d
	BNE PRG001_A8D5	 ; If object timer <> $2D, jump to PRG001_A8D5

	; Play powerup rising sound
	LDA Sound_QLevel1
	ORA #SND_LEVELRISE
	STA Sound_QLevel1

PRG001_A8D5:
	BGE PRG001_A93D	 ; If timer is >= $2D, jump to PRG001_A93D

	; ObjSplash_DisTimer = 8
	LDA #$08
	STA ObjSplash_DisTimer,X

	DEC Objects_Var1,X	 ; Objects_Var1--
	BPL PRG001_A8F7	 ; If Objects_Var1 >= 0, jump to PRG001_A8F7

	; When var 1 falls below 0, reset to 2
	LDA #$02
	STA Objects_Var1,X

	LDA <Player_HaltGame
	BNE PRG001_A8F7	 ; If game is halted, jump to PRG001_A8F7


	; Game not halted...

	; Move powerup up 1 pixel
	LDA <Objects_Y,X
	SUB #$01
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

PRG001_A8F7:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	LDA Level_PipeMove
	BNE PRG001_A937	 ; If starman flashing or Player in pipe, jump to PRG001_A937 (no masking sprite)

	LDY #$00	 ; Y = 0

	JSR Object_AnySprOffscreen
	BNE PRG001_A937	 ; If any sprite is off-screen, jump to PRG001_A937 (no masking sprite)

	; This puts on the masking sprite over the raising powerup

	LDA <Objects_Y,X
	AND #$f0	 	; Align object Y to tile
	ADD #$0f	 	; +15
	SUB Level_VertScroll	; Calc relative to vertical scroll

	; Set for both sprite halves Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Masking tile
	LDA #$67
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+5,Y

	; Set sprite priority
	LDA #%00100000
	STA Sprite_RAM+2,Y
	STA Sprite_RAM+6,Y

	; Set sprite X's side by side
	LDA Objects_SpriteX,X
	STA Sprite_RAM+3,Y
	ADD #$08
	STA Sprite_RAM+7,Y

PRG001_A937:
	JSR PowerUp_DoHitTest	 ; Hit test power up when it has emerged from the box
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PRG001_A93D:

	; Do NOT return to caller!
	PLA
	PLA

	RTS		 ; Return

PRG001_A940:
	LDA <Player_HaltGame
	BEQ PRG001_A949	 ; If game is NOT halted by Player, jump to PRG001_A949

	; Draw mushroom if game halted
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	; Do NOT return to caller!! (JSR could've been a JMP?)
	PLA
	PLA

PRG001_A949:
	RTS		 ; Return

	; Determines which way a mushroom should fall based on Player's position
Mushroom_SetFall:
	LDY #$00	 ; Y = 0 (mushroom falls to the left)

	LDA <Objects_X,X
	SUB <Horz_Scroll	; Make X relative to screen
	CMP <Player_SpriteX	
	BLT PRG001_A956	 	; If object X is less than Player's X, jump to PRG001_A956

	INY		 	; Otherwise, Y = 1 (mushroom falls to the right)

PRG001_A956:
	STY Player_MushFall	; Set direction of mushroom fall
	RTS		 ; Return

PowerUp_BounceXVel:
	LDY #$10	 ; Y = $10

	LDA Player_MushFall	
	BNE PRG001_A963	 ; If falling to right, jump to PRG001_A963
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A963:
	STY <Objects_XVel,X	 ; Set X velocity appropriately


	RTS		 ; Return

ObjInit_FireFlower:
	LDA From_Reserve
	BEQ Do_Fire_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	RTS

Do_Fire_Init:
	LDA #$10
	STA Objects_Timer2,X	 ; Fire flower's timer 2 = $10

	; RAS: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A9C8	 ; If flashing is NOT active, jump to PRG001_A852

	; Strangely, the Big ? flower will "move over"; probably a partially developed idea??
	; Or they just accidentally leftover stuff from mushroom
	JSR Mushroom_SetXVel
	JMP PRG001_A9CF	 ; Jump to PRG001_A9CF

PRG001_A9C8:

	; This will make flower drop downward if it was "knocked out" downward
	LDY #$10
	LDA Player_BounceDir
	BEQ PRG001_A9D5	

PRG001_A9CF:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X
	RTS		 ; Return

PRG001_A9D5:
	; Knock flower downward
	STY <Objects_YVel,X	; Y Vel = $10
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return

ObjNorm_FireFlower:
	LDA PUp_StarManFlash
	BPL PRG001_A9E4	 ; If there's no star man flash going on, jump to PRG001_A9E4

	; Otherwise, color cycle (?)
	LDA <Counter_1
	STA Objects_ColorCycle,X

PRG001_A9E4:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA <Objects_YVel,X
	BNE PRG001_A9F6	 ; If Y Velocity <> 0, jump to PRG001_A9F6

	STA <Objects_XVel,X	 ; Otherwise, halt horizontal movement too

PRG001_A9F6:
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!


ObjHit_FireFlower:

	JSR Try_PUp_Reserve
	JSR Get_Normalized_Suit
	CMP #$02
	BNE Do_Fire_Power
	JMP PUp_GeneralCollect

Do_Fire_Power:
	LDA #$03
	JMP Do_PUp_Pallete_Collect

PRG001_AA41:
	.byte $1C, $0E, $1C, $14, $18, $0A, $18, $17

ObjInit_BounceLR:
;	LDA Player_BounceDir
;	STA Objects_Var2,X	 ; Store Player's bounce into var 2
;
;	LDY #-$10	 ; Y = -$10 (bounce left)
;
;	CMP #$02	 
;	BEQ PRG001_AA57	 ; If bouncing to the left, jump to PRG001_AA57
;
;	LDY #$10	 ; Otherwise, Y = $10 (bounce right)
;
;PRG001_AA57:
;	STY <Player_XVel 	; Store appropriate X velocity
;
;	LDA Player_Bounce
;	STA Objects_Var1,X	; Store Player_Bounce -> var1
;
;	LDA #$00
;	STA Objects_SprVVis,X	 ; Clear flags 2
;	STA Objects_SprHVis,X	 ; Clear flags 1
;	STA Player_Bounce	 ; Clear Player_Bounce
;	STA Objects_FlipBits,X	 ; Force left/right flag to zero
;
;	LDA #10
;	STA Level_BlkBump_Pos-6,X ; Block bump position = 10
;
;	JSR BounceBlock_Update	 ; Do block bounce update
;
;	RTS		 ; Return


ObjNorm_BounceLR:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_AAB1	 ; If block bump pos <> 0, jump to PRG001_AAB1

	; Block bump pos = 0...

	; Set to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = var >> 4

	LDA Level_ChgTileValue
	STA <Temp_Var12

	; Temp_Var15 = Bouncer X Hi
	LDA <Objects_XHi,X
	STA <Temp_Var15

	; Temp_Var16 = Bouncer X
	LDA <Objects_X,X
	STA <Temp_Var16

	; Temp_Var13 = Bouncer Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Temp_Var14 = Bouncer Y
	LDA <Objects_Y,X
	STA <Temp_Var14

	JSR BlockBump_Init

	LDY #10		 ; Y = 10

	LDA <Objects_XVel,X
	BPL PRG001_AAA8	 ; If bouncer is moving to the right, jump to PRG001_AAA8

	LDY #-10	 ; Y = -10

PRG001_AAA8:
	TYA		 ; A = 10 or -10

	; SpriteX += 10 or -10
	ADD <Objects_SpriteX,X
	STA <Objects_SpriteX,X

	JMP Object_HitTestRespond	 ; Do hit test and don't come back


PRG001_AAB1:

	; Block bump pos <> 0...

	LDA Level_BlkBump_Pos-6,X
	CMP #$05
	BNE PRG001_AAC5	 ; If block bump pos <> 5, jump to PRG001_AAC5

	; Block bump pos = 5...

	; LRBounce_X = Sprite X
	LDA <Objects_SpriteX,X
	STA LRBounce_X

	; LRBounce_Y = Sprite Y
	LDA <Objects_SpriteY,X
	STA LRBounce_Y

	JMP PRG001_AAFE	 ; Jump to PRG001_AAFE

PRG001_AAC5:
	CMP #$0A
	BNE PRG001_AAFE	 ; If block bump pos <> 10, jump to PRG001_AAFE

	; Block bump pos = 10...

	LDA Objects_Var1,X
	AND #$0f
	TAY		 ; Y = lower 4 bits of Var1

	LDA Bouncer_PUp,Y ; Get power-up for this block
	BEQ PRG001_AAFE	 ; If no Power Up for this block, jump to PRG001_AAFE

	STA <Temp_Var1	 ; Power Up type -> Temp_Var1

	LDY #$05	 ; Y = 5 (power-up always in slot 5)

	; Set the ID
	LDA <Temp_Var1
	STA Level_ObjectID,Y

	; Set X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set Y
	LDA <Objects_Y,X
	SUB #$01
	STA Objects_Y,Y

	; Set Y Hi
	LDA <Objects_YHi,X
	SBC #$00
	STA Objects_YHi,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

PRG001_AAFE:
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR BounceBlock_Update	 ; Do block bounce update

	LDY Level_BlkBump_Pos-6,X ; Y = block bump pos

	LDA Bouncer_PUpVel,Y	 ; Get velocity

	LDY Objects_Var2,X
	CPY #$02
	BEQ PRG001_AB14	 ; If var2 = 2, jump to PRG001_AB14

	JSR Negate	 ; Otherwise, negate the velocity

PRG001_AB14:
	STA <Objects_XVel,X	 ; Set appropriate X velocity

	DEC Level_BlkBump_Pos-6,X ; Block bump pos--

	RTS		 ; Return


ObjHit_BoundLR:
	LDY #$10	 ; Y = $10

	LDA <Player_X
	CMP <Objects_X,X
	BGS PRG001_AB24	 ; If Player_X > Objects_X, jump to PRG001_AB24

	LDY #-$10	 ; Y = -$10

PRG001_AB24:
	STY <Player_XVel ; Set Player's X velocity as appropriate

	LDY #15		 ; Y = 15 (Player will be aligned to right side of bouncer)

	LDA <Player_X
	PHA		 ; Save Player_X

	AND #$0f	 ; Lower 4 bits only
	CMP #$08
	BGS PRG001_AB33	 ; If Player is to the right of the bouncer, jump to PRG001_AB33

	LDY #$00	 ; Y = 0 (Player will be aligned to left side of bouncer)

PRG001_AB33:
	STY <Temp_Var1	 ; Temp_Var1 = $00 or $0F
	PLA		 ; Restore Player_X


	AND #$f0	 ; Keep only upper 4 bits of Player's position
	ORA <Temp_Var1	 ; Apply the alignment
	STA <Player_X	 ; -> Player_X

	RTS		 ; Return


ObjInit_Obj1C:
	LDA #$40	 ; A = $40

	LDY <Objects_X,X
	CPY <Player_X	
	BGS PRG001_AB48	 ; If Object's X > Player_X, jump to PRG001_AB48

	JSR Negate	 ; A = -$40

PRG001_AB48:
	STA <Objects_XVel,X	 ; Set X Velocity

	LDA #-$80
	STA <Objects_YVel,X	 ; Y Velocity = -$80

	LDA #$05
	STA Objects_Timer,X	 ; Object's timer = 5

	LDY #$05	 ; Y = 5

	LDA #OBJSTATE_INIT
	STA Objects_State,Y	 ; Set object state to 1 (re-init)

	LDA #OBJ_POWERUP_MUSHROOM
	STA Level_ObjectID,Y	 ; ... as object OBJ_POWERUP_MUSHROOM

	; Copy this object's X to slot 5
	LDA <Objects_X,X
	STA Objects_X,Y	

	; Copy this object's X Hi to slot 5
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Copy this object's Y Hi to slot 5
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	; Copy this object's Y minus 8 to slot 5
	LDA <Objects_Y,X
	SUB #$08
	STA Objects_Y,Y

	BCS PRG001_AB7A	 ; If that didn't cause a borrow, jump to PRG001_AB7A

	DEC <Objects_YHi,X	 ; Otherwise, apply it

PRG001_AB7A:
	RTS		 ; Return


ObjNorm_Obj1C:
	JSR Object_ShakeAndDraw	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA Objects_Timer,X
	BNE PRG001_AB89	 ; If timer has not expired, jump to PRG001_AB89

	JMP Object_InteractWithWorld	 ; Interact with world and don't come back!

PRG001_AB89:
	JSR Object_ApplyYVel	 ; Apply Y velocity
	JMP Object_ApplyXVel	 ; Apply X velocity and don't come back!

	; Values used by the leaf based on bounce direction
Leaf_YVels:	.byte $04, $E0, $E0, $E0
Leaf_TimerVals:	.byte $08, $FF, $FF, $FF

ObjInit_SuperLeaf:
	LDA From_Reserve
	BEQ Do_Leaf_Init
	LDA #$00
	STA From_Reserve
	LDA #$A0
	STA <Objects_YVel + 5
	LDA #$14
	STA Objects_Timer + 5
	RTS

Do_Leaf_Init:
	LDA #$00
	STA <Objects_XVel,X	 ; Halt X velocity
	STA Objects_Var2,X	 ; Var2 = 0

	LDA #$0c	; A = $C (top spawn offset)

	LDY Player_BounceDir
	BEQ PRG001_ABA9	 ; If Player bounce down, jump to PRG001_ABA9

	LDA #-$0d	; A = -$D (bottom spawn offset)

	DEC <Objects_YHi,X	

PRG001_ABA9:
	ADD <Objects_Y,X
	STA <Objects_Y,X	 ; Set object Y

	BCC PRG001_ABB2	 	; If there's no carry, jump to PRG001_ABB2

	INC <Objects_YHi,X	 ; Otherwise, apply carry

PRG001_ABB2:
	; Set appropriate timer value (used to figure how far up the leaf needs to go)
	LDA Leaf_TimerVals,Y
	STA Objects_Timer,X

	; Set Y velocity
	LDA Leaf_YVels,Y
	STA <Objects_YVel,X

	; Timer2 = $10
	LDA #$10
	STA Objects_Timer2,X

	LDA PUp_StarManFlash
	BEQ PRG001_ABCC	; If leaf did not come from big ? block, jump to PRG001_ABCC

	; Otherwise, be green!!  (What IS this about anyway?)
	LDA #$02
	STA Objects_SprAttr,X

PRG001_ABCC:
	RTS		 ; Return

Leaf_XVelByOsc:	.byte $02, -$02
Leaf_XVelLimit:	.byte $20, -$20

PRG001_ABD1:
	.byte $0A, -$0A, $08

ObjNorm_SuperLeaf:
	LDA Objects_Timer,X
	BEQ PRG001_ABEC	 ; If timer expired, jump to PRG001_ABEC

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity
	INC <Objects_YVel,X	 ; YVel ++

	LDA <Objects_YVel,X
	CMP #$00
	BEQ PRG001_ABE7	 ; If Super Leaf Y Vel = 0, jump to PRG001_ABE7

	JMP PRG001_AC15	 ; Jump to PRG001_AC15

PRG001_ABE7:

	; Reset timer
	LDA #$00
	STA Objects_Timer,X

PRG001_ABEC:
	LDA Objects_Var2,X
	AND #$01
	TAY		 ; Y = 0 or 1 (which oscillation direction)

	; Add appropriate X velocity for oscillation direction
	LDA <Objects_XVel,X
	ADD Leaf_XVelByOsc,Y
	STA <Objects_XVel,X

	CMP Leaf_XVelLimit,Y
	BNE PRG001_AC02	 ; If leaf has not hit X Vel limit, jump to PRG001_AC02

	INC Objects_Var2,X	 ; Switch oscillation direction

PRG001_AC02:
	LDA <Objects_XVel,X
	BPL PRG001_AC07	 ; If leaf is moving to the right, jump to PRG001_AC07

	INY		 ; Otherwise, Y++ (makes Y = 2)

PRG001_AC07:
	LDA PRG001_ABD1,Y
	ADD #$06	 	; Value +6
	STA <Objects_YVel,X	; -> Y Velocity

	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

PRG001_AC15:
	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (horizontal flip)

	LDY <Objects_XVel,X
	BEQ PRG001_AC22	 ; If leaf X Vel = 0, jump to PRG001_AC22 (don't change flip at midpoint)
	BPL PRG001_AC1F	 ; If leaf X Vel > 0, jump to PRG001_AC1F

	LDA #$00	 ; A = 0 (not horizontally flipped)

PRG001_AC1F:
	STA Objects_FlipBits,X	 ; Set flip

PRG001_AC22:
	JSR Object_ShakeAndDraw	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!



ObjHit_SuperLeaf:
	JSR Try_PUp_Reserve
	JSR Get_Normalized_Suit
	CMP #$03
	BNE Do_Leaf_Power
	JMP PUp_GeneralCollect

Do_Leaf_Power:
	LDA #$04
	
	JMP Do_PUp_Poof_Collect
	
ObjInit_Vine:
	LDA #SPR_BEHINDBG
	STA Objects_FlipBits,X
	LDA #$00
	STA PUp_StarManFlash
	LDA Objects_X, X
	AND #$F0
	STA Objects_X, X
	RTS		 ; Return

	; Stores the high byte of the VRAM address
Vine_NTHigh:	.byte $20, $28

ObjNorm_Vine:

	; Vine moves at Y Vel = -$10
	LDA #-$10
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	; Apply Y Velocity

	LDA <Objects_YHi,X
	BMI PRG001_AC80	 ; If vine goes off absolute top, jump to PRG001_AC80

	JSR Object_WorldDetectN1 ; Detect against world

	LDA Object_TileFeet
	AND #$C0
	BEQ PRG001_AC86	 ; If vine is not within the solid tiles, jump to PRG001_AC86

PRG001_AC80:

	; Set vine to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

PRG001_AC86:
	LDA <Objects_Y,X
	AND #$0f
	BNE PRG001_AC92	 ; If vine has NOT covered a new tile, jump to PRG001_AC92
 
	STA Objects_FlipBits,X	; Clears flip bits
	JSR Vine_Set8x8s	; Instant graphics update while vine moves

PRG001_AC92:
	JMP Object_ShakeAndDrawMirrored	 ; Draw sprite and don't come back!

Vine_Set8x8s:
	LDA <Objects_XHi,X
	ASL A		 ; Convert X Hi into 2 byte index
	TAY		 ; -> 'Y'

	; Get address of screen Vine is on (NOTE: Non-vertical level only!)
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var2	

	LDA <Objects_YHi,X
	BEQ PRG001_ACA9	 ; If vine is not on lower area of screen, jump to PRG001_ACA9

	INC <Temp_Var2	 ; Select address of lower tiles

PRG001_ACA9:
	LDA <Objects_Y,X
	AND #$f0	 ; Get current "row" of vine object
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA <Objects_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3	 ; Merge column into lower 4 bits

	TAY		 ; -> 'Y'

	; Change tile to vine tile
	
	LDA VineGrowthTile
	STA [Temp_Var1],Y

	LDA Objects_SprHVis,X
	CMP #$03
	BGE PRG001_AD23	; If vine object is off-screen horizontally, jump to PRG001_AD23 (RTS)

	LDA <Objects_Y,X	 ; A = Objects_Y

	LDY <Objects_YHi,X
	BNE PRG001_ACCE	 ; If the vine is on the low part of the screen, jump to PRG001_ACCE

	CMP #240
	BLT PRG001_ACD1	 ; If Y < 240, jump to PRG001_ACD1

	INY		 ; Y = 1 (uses the next nametable address in Vine_NTHigh)

PRG001_ACCE:
	ADD #16	 	; Next row

PRG001_ACD1:
	ASL A	
	ADC #$00
	ASL A	
	ADC #$00

	PHA		 ; Save VRAM column offset

	AND #$03	; Keep address from going out of range
	ORA Vine_NTHigh,Y	 ; Set the high bits

	LDY Graphics_BufCnt	 ; Y = current graphics buffer count

	; Set two rounds of high byte 
	STA Graphics_Buffer,Y	 
	STA Graphics_Buffer+5,Y	

	PLA		 ; Restore VRAM column offset
 
	AND #$c0
	STA <Temp_Var1

	; Store left column update
	LDA <Objects_X,X
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var1
	STA Graphics_Buffer+1,Y

	; Store right column update
	ADD #$01
	STA Graphics_Buffer+6,Y

	LDA #$82
	STA Graphics_Buffer+2,Y
	STA Graphics_Buffer+7,Y

	; Vine left 8x8 tiles
	LDA VineTiles
	STA Graphics_Buffer+3,Y
	LDA VineTiles + 2
	STA Graphics_Buffer+4,Y

	; Vine right 8x8 tiles
	LDA VineTiles + 1
	STA Graphics_Buffer+8,Y
	LDA VineTiles + 3
	STA Graphics_Buffer+9,Y

	LDA #$00
	STA Graphics_Buffer+10,Y

	; Update run count
	TYA
	ADD #$0a	 ; Count += 10
	STA Graphics_BufCnt

PRG001_AD23:
	RTS		 ; Return

	; Basically this bumps the object up by 1 pixel...
ObjInit_Coin:
	LDA #$00
	STA PowerUp_NoRaise
 	RTS		 ; Return

ObjInit_WarpHide:
	LDA Map_Got13Warp
	BEQ PRG001_AD37	 ; If Player didn't already get the 1-3 warp whistle, jump to PRG001_AD37

	; Otherwise, kill it!
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

PRG001_AD37:
	RTS		 ; Return


ObjNorm_Coin:
	LDA <Player_HaltGame
	BNE DrawCoin

	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Object_WorldDetect4
	JSR Object_HitTestRespond

	LDA <Objects_DetStat,X
	AND #$04
	BEQ DrawCoin
	JSR Object_HitGround

DrawCoin:
	LDA Objects_SprHVis, X
	ORA Objects_SprVVis, X
	BNE Coin_RTS

	JSR Object_ShakeAndCalcSprite
	LDX <SlotIndexBackup
	LDY Object_SprRAM, X
	LDA #$49
	STA Sprite_RAM + 1, Y
	LDA #SPR_PAL3
	STA Sprite_RAM + 2, Y
	LDA <Objects_SpriteY, X
	STA Sprite_RAM, Y
	LDA <Objects_SpriteX, X
	STA Sprite_RAM + 3, Y
	
Coin_RTS:
	RTS

ObjHit_Coin:
	INC Coins_Earned
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State, X
	RTS

ObjHit_IceFlower:
	JSR Try_PUp_Reserve
	JSR Get_Normalized_Suit
	CMP #$07 
	BNE Do_Ice_Power
	JMP PUp_GeneralCollect

Do_Ice_Power:

	LDA #$08
	JMP Do_PUp_Pallete_Collect

ObjHit_Pumpkin:
	JSR Try_PUp_Reserve
	JSR Get_Normalized_Suit
	CMP #$0A
	BNE Do_Boo_Power
	JMP PUp_GeneralCollect

Do_Boo_Power:
	LDA #$0B
	JMP Do_PUp_Poof_Collect

ObjHit_FoxLeaf:
	JSR Try_PUp_Reserve
	JSR Get_Normalized_Suit
	CMP #$08
	BNE Do_Fox_Power
	JMP PUp_GeneralCollect

Do_Fox_Power:
	LDA #$09
	JMP Do_PUp_Poof_Collect

	; This is a fairly general "march" function, but it is only 
	; applied to one object here, the unused collectable card...

PRG001_ADE2:
	RTS

Object_MoveAndReboundOffWall:
	JSR Object_Move	 ; Do general movement code

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG001_ADEE	 ; If object hit ceiling, jump to PRG001_ADEE

	STA <Objects_YVel,X	 ; Otherwise, update Y Velocity

PRG001_ADEE:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ Object_HitGroundAlign ; If object has not hit a wall, jump to Object_HitGroundAlign

	LDA <Objects_XVel,X
	BEQ Object_HitGroundAlign ; If object not moving, jump to Object_HitGroundAlign

	JSR Object_AboutFace	 ; Otherwise, turn around

	; Aligns object that impacts the ground onto the floor
Object_HitGroundAlign:
	LDA <Objects_DetStat,X 
	AND #$04
	BEQ PRG001_ADE2	 ; If object did not hit ground, jump to PRG001_ADE2 (RTS)
 
	JMP Object_HitGround	 ; Otherwise, jump to Object_HitGround

Koopaling_Palettes:
	.byte $0F, $26, $30, $19	; World 1
	.byte $0F, $17, $30, $10	; World 2
	.byte $0F, $26, $30, $16	; World 3
	.byte $0F, $27, $30, $11	; World 4
	.byte $0F, $17, $30, $15	; World 5
	.byte $0F, $27, $30, $1A	; World 6
	.byte $0F, $18, $30, $1C	; World 7

ObjInit_Koopaling:
	LDA MiscValue1
	AND #$0F
	STA KoopaKidType
	ASL A		
	ASL A		 ; A = World_Num * 4
	PHA		 ; Save it
	TAY		 ; -> Y

	; X = current buffer counter
	LDX Graphics_BufCnt

	; Going to change the sprite palette
	LDA #$3f	 
	STA Graphics_Buffer,X
	LDA #$18	 
	STA Graphics_Buffer+1,X	

	; 4 bytes (full sprite palette)
	LDA #$04	 
	STA Graphics_Buffer+2,X	 

	; Copy Koopaling's palette into buffer
	STA <Temp_Var1		 ; Temp_Var1 = 4 (loop counter)
PRG001_AE3B:
	LDA Koopaling_Palettes,Y ; Get palette byte
	STA Graphics_Buffer+3,X	 ; Store into buffer
	INX		 ; X++
	INY		 ; Y++
	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG001_AE3B	 ; While Temp_Var1 > 0, loop!

	; Terminator
	LDA #$00	 
	STA Graphics_Buffer+3,X	

	INX
	INX
	INX	
	STX Graphics_BufCnt	; Graphics_BufCnt += 3

	PLA		 ; Restore World_Num * 4
	TAY		 ; -> Y

	LDX #$18	 ; X = $18

	; Copy Koopaling palette into Pal_Data and Palette_Buffer
PRG001_AE56:
	LDA Koopaling_Palettes,Y
	STA Pal_Data,X	 
	STA Palette_Buffer,X
	INY		 ; Y++
	INX		 ; X++
	CPX #$1c	 
	BLT PRG001_AE56	 ; If X < $1C (end of Pal_Data offset), loop!

	LDX <SlotIndexBackup	 ; X = current object slot index


	; 10 hits to take out a Koopaling
	LDA #$0a	
	STA Objects_HitCount,X

	; Set object variable 3 to $40
	LDA #$40	
	STA Objects_Var3,X

	RTS		 ; Return


	; Selects the pattern table index 4 for the respective world Koopaling
KoopalingPatSet4:
	.byte $48	; World 1
	.byte $49	; World 2
	.byte $4A	; World 3
	.byte $48	; World 4
	.byte $49	; World 5
	.byte $48	; World 6
	.byte $4A	; World 7

	; Selects the pattern table index 5 for the respective world Koopaling
KoopalingPatSet5:
	.byte $37	; World 1
	.byte $37	; World 2
	.byte $4A	; World 3
	.byte $37	; World 4
	.byte $37	; World 5
	.byte $48	; World 6
	.byte $37	; World 7


	; Speed Koopaling moves when in the air
Koopaling_XVelMidAir:	.byte $10, $F0

	; The world number is added to this value to produce an index into
	; the Koopaling_JumpChanceMask and Koopaling_JumpYVels tables
Koopaling_JumpYVelsBase:
	.byte $00, $07, $0E

PRG001_AE85:
	.byte $63, $63, $9F, $63, $63, $00, $3F, $63, $3F, $9F, $23, $63, $00
	.byte $33, $33, $33, $9F, $43, $63, $00, $23

	; Provides a bitmask placed against Counter_1 which if zero means
	; the Koopaling will jump; thus, less bits means greater chance
Koopaling_JumpChanceMask:
	.byte $BF, $BF, $41, $83, $FF, $00, $7F, $BF, $BF, $41, $83, $FF, $00, $7F, $DF, $DF
	.byte $41, $83, $7F, $00, $9F

	; Jump velocities
Koopaling_JumpYVels:
	.byte -$30, -$30, -$10, -$30, -$50,  $00, -$50, -$40, -$38, -$20, -$40, -$60,  $00, -$60, -$50, -$50
	.byte -$50, -$50, -$70,  $00, -$70

Koopaling_Projectiles:
	.byte SOBJ_ICEBALL, SOBJ_HAMMER, SOBJ_FIREBROFIREBALL, $00, $00, $00, $00, $00

ObjNorm_Koopaling:
	LDY KoopaKidType

	; Use the right graphics for the Koopaling	
	LDA KoopalingPatSet4,Y
	STA PatTable_BankSel+5

	;LDA KoopalingPatSet5,Y
	;STA PatTable_BankSel+5

	; Behavior based on Level_GetWandState...
	LDA Level_GetWandState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Koopaling_Normal		; Wand State 0: Normal operation
	.word Koopaling_FinalHit	; Wand State 1: when Koopa Kid gets last hit and flies off
	.word Koopaling_WandFall	; Wand State 2: Koopaling gone, wand drops down (do-nothing state)
	.word Koopaling_WandGrab	; Wand State 3: when wand grabbed (do flashy color effect)
	.word Koopaling_TimeBonus	; Wand State 4: run down time for bonus
	.word Koopaling_AirshipVanish	; Wand State 5: as airship vanishes
	.word Koopaling_DoPlayerFall	; Wand State 6: Player falling...
	.word Koopaling_FallOff		; Wand State 7: Player falls off-screen into king's room

Koopaling_FinalHit:
	JSR Koopaling_DrawAndAnimate

	LDA <Player_HaltGame		
	BNE PRG001_AF2A	 ; If gameplay is halted (Player dead, etc.), jump to PRG001_AF2A (RTS)

	LDA Objects_Timer2,X
	CMP #$08	 
	BLT PRG001_AF02	 ; If timer2 < 8, jump to PRG001_AF02
	BNE PRG001_AF2A	 ; If timer2 <> 8, jump to PRG001_AF2A (RTS)

	; Koopaling exit sound...
	LDA Sound_QLevel2
	ORA #SND_LEVELAIRSHIP	
	STA Sound_QLevel2

	RTS		 ; Return

PRG001_AF02:
	ORA #$04
	STA Objects_Timer2,X	 ; timer 2 |= 4

	; Unused comparison and jump!  (Goes nowhere)

	LDA Objects_SprVVis,X
	CMP #$03
	BNE PRG001_AF20

	LDA <Objects_X,X
	SBC #$78	 ; Koopaling flies off to the left!
	CMP #$10	
	BGE PRG001_AF20	 ; If Koopaling's X >= $10, jump to PRG001_AF20

	; After Koopaling has left...
	INC Level_GetWandState	 ; Level_GetWandState = 2

PRG001_AF20:
	JSR Object_ApplyXVel	 ; Apply X velocity

	LDA #-$60
	STA <Objects_YVel,X	 ; Y Velocity = -$60 (fly up and out!)
	JSR Object_ApplyYVel	 ; Apply Y velocity

PRG001_AF2A:
	RTS		 ; Return

Koopaling_Normal:
	LDA KoopaKidType
	CMP #$05
	BNE PRG001_AF35	 ; If World_Num <> 5 (World 6, Lemmy), jump to PRG001_AF35
	JMP PRG001_B671	 ; Jump to PRG001_B671

PRG001_AF35:

	; Variable 1 is used as a counter to indicate that the heavy Koopaling has jumped onto the floor

	LDA Objects_Var1,X
	BEQ PRG001_AF55	 	; If object variable 1 = 0 (no heavy jump shake occurring), jump to PRG001_AF55

	DEC Objects_Var1,X 	; Decrement variable 1

	LDA <Player_InAir
	BNE PRG001_AF55	 	; If Player is in the air, jump to PRG001_AF55

	INC <Player_InAir	; Set Player as in the air

	LDA #$20	 
	STA Player_VibeDisable	; "Vibrationally disable" Player!

	LDA #-$10
	STA <Player_YVel	; Player Y velocity = -$10 (bounce the Player a bit)

	; Player_Y/Hi -= 1
	DEC <Player_Y
	LDY <Player_Y
	INY		
	BNE PRG001_AF55	
	DEC <Player_YHi

PRG001_AF55:
	JSR Koopaling_DrawAndAnimate	; Draw and animate Koopaling!

	LDA <Player_HaltGame
	BNE PRG001_AF8F	 		; If gameplay is halted, jump to PRG001_AF8F (RTS)

	JSR Koopaling_DetectWorld	; Detect world and do floor vibration, if appropriate
	JSR Koopaling_DieByFire		; If hit by enough fireballs, battle ends
	JSR Object_HitTestRespond	; Respond to Player collision
	JSR Object_CalcCoarseXDiff	; Calculate "coarse" X difference value

	LDA Objects_Timer2,X	
	BEQ PRG001_AF90	 ; If timer 2 is zero, jump to PRG001_AF90

	CMP #$40
	BGE PRG001_AF8F	 ; If timer 2 >= $40, jump to PRG001_AF8F (RTS)

	LSR A	
	BNE PRG001_AF7D	 	; Every other tick, jump to PRG001_AF7D (Koopaling jump!)

	STA Objects_Frame,X	 ; Set object frame 0 - 31??

	LDA <Temp_Var16		 
	STA Objects_FlipBits,X	 ; Stores $00 or $40, depending on result of Object_CalcCoarseXDiff

	RTS		 ; Return


PRG001_AF7D:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_AF8F	 ; If Koopaling is not on the ground, jump to PRG001_AF8F (RTS)

	; Koopaling on ground; jump!

	JSR Level_ObjCalcXDiffs	  

	; Set appropriate X velocity based on direction
	LDA Koopaling_XVelMidAir,Y
	STA <Objects_XVel,X

	; Set Y velocity for jump
	LDA #-$48
	STA <Objects_YVel,X

PRG001_AF8F:
	RTS		 ; Return


PRG001_AF90:

	; Timer 2 expired...

	LDA Objects_Timer,X
	BEQ PRG001_AFAB	 ; If timer is zero, jump to PRG001_AFAB

	; This creates the wand firing repetition
	AND #$07
	BNE PRG001_AF8F	 ; Only proceed every 8 ticks

	LDA #$03
	STA Objects_Frame,X	; Koopaling frame 3 (wand fire!)

	LDA KoopaKidType
	CMP #$02
	BNE PRG001_AFA8	 ; If World_Num <> 2 (World 3, Wendy), jump to PRG001_AFA8

	JMP PRG001_B7EC	 ; Jump to PRG001_B7EC

PRG001_AFA8:
	JMP PRG001_B02E	 ; Otherwise, jump to PRG001_B02E

PRG001_AFAB:

	; Timer expired

	LDA <Objects_DetStat,X
	AND #$04	
	BEQ PRG001_B01F	 ; If Koopaling is not on the ground, jump to PRG001_B01F

	LDA <Counter_1
	AND #$07
	BNE PRG001_AFC5	 ; Every 7:8 ticks, jump to PRG001_AFC5

	; Once every 8 ticks, turn in the direction of the Player

	LDA <Temp_Var16		; Holds last checked direction towards Player
	STA Objects_FlipBits,X	 ; Objects_FlipBits = Temp_Var16 (face towards Player)

	; Set appropriate X velocity by facing direction
	LDY #$10
	ASL A		; If $40, now $80, thus BMI
	BMI PRG001_AFC3
	LDY #-$10

PRG001_AFC3:
	STY <Objects_XVel,X	 ; Set proper X velocity towards Player!

PRG001_AFC5:
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	; Set current walking frame 0/1

	; this basically selects a jump velocity from the Koopaling_JumpYVels
	; table with certain values only being reached by later world Koopalings
	; and making the overall height a bit variable
	LDY <Objects_Var4,X	 ; Get Koopaling's current hit count
	LDA Koopaling_JumpYVelsBase,Y
	ADD KoopaKidType
	TAY		; -> 'Y'

	; This determines the chance that they will actually jump
	LDA <Counter_1	
	AND Koopaling_JumpChanceMask,Y
	BNE PRG001_AFE6	; If not jumping, jump to PRG001_AFE6

	; Koopaling jumps!
	LDA Koopaling_JumpYVels,Y
	STA <Objects_YVel,X

	RTS		 ; Return


PRG001_AFE6:

	; If Koopaling is not jumping...

	LDA KoopaKidType
	CMP #$02	
	BNE PRG001_AFF9	 ; If World_Num <> 2 (World 3, Wendy), jump to PRG001_AFF9

	; Wendy only...

	LDA <Objects_Var4,X
	CMP Objects_Var6,X	 
	BLT PRG001_B01F	 ; If Objects_Var4 < Objects_Var6, jump to PRG001_B01F (RTS)

	INC Objects_Var6,X	 ; Objects_Var6++ 
	BNE PRG001_B000	 ; If Objects_Var6 <> 0, jump to PRG001_B000

PRG001_AFF9:
	LDA <Counter_1
	AND PRG001_AE85,Y
	BNE PRG001_B01F

PRG001_B000:
	; Face the Player
	LDA <Temp_Var16	
	STA Objects_FlipBits,X

	; Wand out frame
	LDA #$02
	STA Objects_Frame,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDA #$10	 ; A = $10

	LDY KoopaKidType
	CPY #$02	
	BEQ PRG001_B01C	 ; If World_Num = 2 (World 3, Wendy), jump to PRG001_B01C

	; Everybody but Wendy...

	JSR Object_CalcHomingVels

	LDA #$20	 ; A = $20
PRG001_B01C:
	STA Objects_Timer,X	; This timer kicks off the wand firing!

PRG001_B01F:
	RTS		 ; Return


Koopaling_DieByFire:
	LDA Objects_HitCount,X
	BNE PRG001_B01F	 ; If hits remain, jump to PRG001_B01F

	; Set hit count to 2 (will force the third and final hit after the jump!)
	LDA #$02	
	STA <Objects_Var4,X
	JMP PRG001_B17B	 ; Jump to PRG001_B17B (force third and final hit!)

PRG001_B02C:
	.byte -$0E, $1E

PRG001_B02E:

	; All Koopalings except Wendy and Lemmy...

	LDA Objects_FlipBits,X
	ASL A
	ROL A
	ROL A		 ; Effectively, shift bit 6 to bit 0 (i.e. if $40, now 1)
	AND #$01	 ; Capping value to be sure
	TAY		 ; Y = 0 or 1

	LDA PRG001_B02C,Y
	STA <Temp_Var1	 ; Temp_Var1 = -$0E or $1E

	; Find an empty special object slot -> 'Y' OR if none available, do not return here!
	JSR SpecialObj_FindEmptyAbort

	STX DAIZ_TEMP1
	LDX KoopaKidType

	; Special object: Koopaling wand blast!
	LDA Koopaling_Projectiles, X
	STA SpecialObj_ID,Y
	LDX DAIZ_TEMP1

	; Set wand blast X
	LDA <Objects_X,X
	ADD <Temp_Var1	
	STA SpecialObj_XLo,Y

	; Set wand blast Y
	LDA <Objects_Y,X
	ADD #$0a
	STA SpecialObj_YLo,Y

	; Set wand blast Y Hi
	LDA <Objects_YHi,X
	ADC #$00	
	STA SpecialObj_YHi,Y

	; Set wand Y velocity
	LDA Objects_TargetingYVal,X
	STA SpecialObj_YVel,Y

	; Set wand X velocity
	LDA Objects_TargetingXVal,X
	STA SpecialObj_XVel,Y

	; Timer = $FF
	LDA #$ff	 
	STA SpecialObj_Timer,Y


	; Play wand sound if it isn't playing already
	LDA SndCur_Level1
	AND #$80
	BNE PRG001_B07B

	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

PRG001_B07B:
	RTS		 ; Return


ObjHit_Koopaling:
	LDA Objects_Frame,X
	CMP #$04
	BLT PRG001_B158	 ; If Koopaling's current animation frame < 4 (not in a spinning shell mode), jump to PRG001_B158

	; Koopaling is spinning in his shell...

	JSR Object_CalcCoarseYDiff	 ; Calculate Y difference between Koopaling and Player

	LDY <Temp_Var15
	CPY #$04	
	BGS PRG001_B07B	 ; If the Y difference value > +4, jump to PRG001_B137 (RTS)

	DEY		 ; Y--
	BMI PRG001_B158	 ; If the difference was 0 (because now it just turned negative), jump to PRG001_B158

	; This gives the Player a semi-random rebound X Velocity after hitting the Koopaling
	; that is in his spinning shell mode
	LDA <Counter_1
	LSR A		 ; Bit 0 of Counter_1 -> carry
	LDA #$30	 ; A = $30
	BCS PRG001_B154	 ; If carry set from Counter_1 (i.e. every other tick), jump to PRG001_B154

	LDA #-$30	 ; A = -$30 instead

PRG001_B154:
	STA <Player_XVel ; Set Player's rebound velocity
	BNE PRG001_B160	 ; Jump (technically always) to PRG001_B160

PRG001_B158:

	; From Object_HitTestRespond:
	; Temp_Var12 holds specific info:
	;	Bit 0 - Set if Player's bbox bottom is HIGHER than object's bbox bottom
	;	Bit 1 - Set if Player's bbox left edge is to the LEFT of object's bbox left edge

	LDA <Temp_Var12	
	LSR A		
	BCS PRG001_B160	 ; If Player is above the Koopaling, jump to PRG001_B160

	JMP Player_GetHurt ; Hurt Player! (and don't come back

PRG001_B160:

	; Bounce Player off Koopaling!
	LDA #-$30
	STA <Player_YVel

	LDA Objects_Timer2,X
	BNE PRG001_B1C9	 ; If timer 2 is not expired, jump to PRG001_B1C9 (RTS)

	; Squish sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM	
	STA Sound_QPlayer

	LDA KoopaKidType
	CMP #$05
	BNE PRG001_B17B	 ; If World_Num = 5 (World 6, Lemmy), jump to PRG001_B17B

	; Lemmy pops out another ball if hit
	JSR Lemmy_SpawnBall

PRG001_B17B:

	; Stop Koopaling's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDY <Objects_YVel,X
	BPL PRG001_B185	 ; If Koopaling's Y velocity >= 0 (not moving upward), jump to PRG001_B185

	; If Koopaling was moving upward when stomped, stop him!
	STA <Objects_YVel,X

PRG001_B185:

	; Hit Koopaling!
	INC <Objects_Var4,X	; Increment the hit count
	LDA <Objects_Var4,X
	CMP #$03
	BGE PRG001_B193	 ; If Objects_Var4 >= 3 (Koopaling's last hit), jump to PRG001_B193

	LDA #$80
	STA Objects_Timer2,X	 ; Timer 2 set to $80

	RTS		 ; Return

PRG001_B193:

	; Koopaling defeated!

	; Set all objects besides the Koopaling to "Dying" state!
	LDY #$04	 ; Y = 4
PRG001_B195:
	CPY <SlotIndexBackup
	BEQ PRG001_B1A8	 ; If this is the Koopaling's object index, jump to PRG001_B1A8 (do nothing)

	LDA Objects_State,Y
	BEQ PRG001_B1A8	 ; If this object slot is already dead/empty, jmp to PRG001_B1A8

	; There's an object here; set state to Poof Death
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,Y

	; Set object's timer to $1F
	LDA #$1f	 
	STA Objects_Timer,Y

PRG001_B1A8:
	DEY		 ; Y--
	BPL PRG001_B195	 ; While Y >= 0, loop!

	INC Level_GetWandState	 ; Level_GetWandState = 1

	; Lock the clock
	LDA #$81
	STA Level_TimerEn

	; Shoot him all you want >:(
	LDA #$7f
	STA Objects_HitCount,X	 

	; Set a velocity that moves Koopaling somewhere towards center
	; Not really precise though!
	LDA #$80
	SUB <Objects_X,X
	STA <Objects_XVel,X
	ASL A
	ROR <Objects_XVel,X

	LDA #$a0
	STA Objects_Timer2,X	 ; Set timer 2 to $A0

	; Do not return to caller!!
	PLA
	PLA

PRG001_B1C9:
	RTS		 ; Return

Koopaling_PowerUp:
	;.byte $OBJ_POWERUP_NINJASHROOM, $OBJ_POWERUP_FIREFLOWER, $OBJ_POWERUP_SUPERLEAF, $OBJ_POWERUP_ICEFLOWER, $OBJ_POWERUP_FOXLEAF, $OBJ_POWERUP_STARMAN, $OBJ_POWERUP_STARMAN, $OBJ_POWERUP_STARMAN

;Koopaling_StarFlash:
;	.byte
	RTS

	; End and start frames of animation loop for Koopaling
Koopaling_FrameLoopEnd:
	.byte $0A	; Wand State 0: Normal operation
	.byte $12	; Wand State 1: when Koopa Kid gets last hit

Koopaling_FrameLoopStart:
	.byte $04	; Wand State 0: Normal operation
	.byte $0A	; Wand State 1: when Koopa Kid gets last hit

	; Objects_FlipBits setting by Object_Frame
Koopaling_LRByFrame:
	.byte $00, SPR_HFLIP, $00, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP
	.byte $00, $00


Koopaling_PatLookup:

	; Koopaling patterns; for some reason the origin is behind the array by 17 bytes?
KPatTable = Koopaling_PatLookup - 17

	; There are 18 bytes per Koopaling for their 6 sprites arranged 3x2
KPATS .func ((\1 - KPatTable) / 6)

	.byte KPATS(KoopalingPats_Larry)	; World 1
	.byte KPATS(KoopalingPats_Morton)	; World 2
	.byte KPATS(KoopalingPats_Wendy)	; World 3
	.byte KPATS(KoopalingPats_Iggy)		; World 4
	.byte KPATS(KoopalingPats_Roy)		; World 5
	.byte KPATS(KoopalingPats_Lemmy)	; World 6
	.byte KPATS(KoopalingPats_Ludwig)	; World 7

	; Each Koopaling uses six 8x16 sprite chunks arranged 3x2

	; Koopaling neutral frames
	.byte $B9, $31, $B9, $A1, $A3, $A5	; 4: Spinning shell 1
	.byte $BB, $31, $BB, $AD, $AF, $B1	; 5: Spinning shell 2
	.byte $BD, $31, $BD, $A1, $A3, $A5	; 6: Spinning shell 3
	.byte $B9, $31, $B9, $A7, $A9, $AB	; 7: Spinning shell 4
	.byte $BB, $31, $BB, $B3, $B5, $B7	; 8: Spinning shell 5
	.byte $BD, $31, $BD, $A7, $A9, $AB	; 9: Spinning shell 6
	.byte $8D, $8F, $31, $91, $93, $31	; 10: Exiting shell 1
	.byte $85, $87, $31, $89, $8B, $31	; 11: Exiting shell 2
	.byte $81, $81, $31, $83, $83, $31	; 12: Exiting shell 3
	.byte $31, $85, $87, $31, $89, $8B	; 13: Exiting shell 4
	.byte $31, $8D, $8F, $31, $91, $93	; 14: Exiting shell 5
	.byte $31, $95, $97, $31, $99, $9B	; 15: Exiting shell 6
	.byte $9D, $9D, $31, $9F, $9F, $31	; 16: Exiting shell 7
	.byte $95, $97, $31, $99, $9B, $31	; 17: Exiting shell 8

	; Larry
KoopalingPats_Larry:
	.byte $81, $83, $85, $87, $89, $8B	; Walk 1
	.byte $81, $83, $85, $87, $8D, $8F	; Walk 2
	.byte $81, $91, $85, $93, $95, $8B	; Wand swing

	; Morton
KoopalingPats_Morton:
	.byte $81, $83, $85, $87, $89, $8B	; Walk 1
	.byte $81, $83, $85, $8D, $8F, $91	; Walk 2
	.byte $81, $93, $85, $95, $A7, $8B	; Wand swing

	; Wendy
KoopalingPats_Wendy:
	.byte $9F, $A1, $A3, $B5, $A5, $A7	; Walk 1
	.byte $9F, $A1, $A3, $B5, $A9, $AB	; Walk 2
	.byte $9F, $AD, $A3, $AF, $B1, $A7	; Wand swing

	; Iggy
KoopalingPats_Iggy:
	.byte $9D, $9F, $A1, $87, $89, $8B	; Walk 1
	.byte $9D, $9F, $A1, $87, $8D, $8F	; Walk 2
	.byte $9D, $A3, $A1, $93, $95, $8B	; Wand swing

	; Roy
KoopalingPats_Roy:
	.byte $9F, $A1, $85, $87, $89, $8B	; Walk 1
	.byte $9F, $A1, $85, $8D, $8F, $91	; Walk 2
	.byte $9F, $A3, $85, $95, $A7, $8B	; Wand swing

	; Lemmy
KoopalingPats_Lemmy:
	.byte $A7, $AD, $71, $AF, $B1, $AB	; Walk 1
	.byte $A7, $AD, $71, $AF, $B3, $B5	; Walk 2
	.byte $A7, $A5, $71, $71, $A9, $AB	; Wand swing

	; Ludwig
KoopalingPats_Ludwig:
	.byte $81, $83, $85, $87, $89, $8B	; Walk 1
	.byte $81, $83, $85, $8D, $8F, $91	; Walk 2
	.byte $81, $93, $85, $95, $B7, $8B	; Wand swing

Koopaling_WandFrame:
	.byte $49, $49, $4B, $4D

Koopaling_OffYLo:
	.byte $05, $05, $FB, $0A, $0A, $0A, $FF, $0F, $08, $08, $FB, $0D

Koopaling_OffXLo:
	.byte $F4, $F4, $0C, $F2, $FA, $FA, $0A, $F8, $F5, $F5, $0C, $F3

	.byte $14, $14, $FC, $16, $0E, $0E, $FE, $10, $13, $13, $FC, $15

Koopaling_OffXHi:
	.byte $FF, $FF, $00, $FF, $FF, $FF, $00, $FF, $FF, $FF, $00, $FF

Koopaling_OffYHi:
	.byte $00, $00, $FF, $00, $00, $00, $FF, $00, $00, $00, $FF, $00

	; Offset to Koopaling_OffYLo/Hi by World
Koopaling_OffYOff:
	.byte $04	; World 1
	.byte $00	; World 2
	.byte $04	; World 3
	.byte $04	; World 4
	.byte $00	; World 5
	.byte $04	; World 6
	.byte $08	; World 7

Koopaling_DrawAndAnimate:
	LDA <Player_HaltGame
	BNE PRG001_B336	 ; If game is halted, jump to PRG001_B336

	LDA Objects_Timer2,X
	BEQ PRG001_B336	 ; If object timer 2 is zero, jump to PRG001_B336

	AND #$03
	BNE PRG001_B328	 ; 3:4 ticks, jump to PRG001_B328

	LDY Level_GetWandState	 ; Y = Level_GetWandState

	INC Objects_Frame,X	 ; Increment object's frame

	LDA Objects_Frame,X	; Get frame
	CMP Koopaling_FrameLoopEnd,Y	
	BLT PRG001_B321	 	; If frame is not at the end of the loop, jump to PRG001_B321

	LDA Koopaling_FrameLoopStart,Y
	STA Objects_Frame,X	 ; Set back to first frame of animation loop

PRG001_B321:
	TAY		 ; Frame -> 'Y'

	; Set the Objects_FlipBits setting for this frame
	LDA Koopaling_LRByFrame,Y
	STA Objects_FlipBits,X

PRG001_B328:

	; Every 15 ticks, play the shell rotation "swish" sound
	LDA <Counter_1
	AND #$0f
	BNE PRG001_B336

	; Play the shell rotation "swish" sound
	LDA Sound_QLevel2
	ORA #SND_LEVELMARCH
	STA Sound_QLevel2

PRG001_B336:
	JSR Object_DeleteOffScreen	; Delete object if it falls off screen
	JSR Draw_KoopalingWand		; Draw the Koopaling's wand
	JSR Object_ShakeAndCalcSprite	; Calculate sprite info

	LDX <SlotIndexBackup		; X = object's slot index

	LDA Objects_Frame,X
	CMP #$04	 
	BLT PRG001_B35C	 	; If object's frame < 4, jump to PRG001_B35C

	; Koopaling spinning shell frames here... (frame 4 - 9)

	; Force pattern table bank 4 to $4B
	LDY #$4b
	STY PatTable_BankSel+5

	CMP #$0a
	BLT PRG001_B368	 	; If object's frame < 10, jump to PRG001_B368

	; Koopaling exiting shell frames here... (frame 10 - 17)

	TAY		 	; Backup the frame -> 'Y'

	; Temp_Var2 += 4 (Sprite_X from Object_ShakeAndCalcSprite)
	LDA <Temp_Var2
	ADD #$04
	STA <Temp_Var2

	TYA		 	; Restore Frame
	BNE PRG001_B368	 	; Jump (most likely always) to PRG001_B368

PRG001_B35C:
	CMP #$03	 
	BNE PRG001_B362	 	; If object's frame <> 3, jump to PRG001_B362

	LDA #$00	 	; Otherwise, A = 0

PRG001_B362:
	LDY KoopaKidType	 	; Y = World number
	ADC Koopaling_PatLookup,Y	; Get index into the Koopaling pattern table (divided by 6)

PRG001_B368:

	; A = frame value with offset

	; Multiply by 6
	ASL A	
	STA <Temp_Var16
	ASL A	
	ADC <Temp_Var16
	TAX		 	; -> 'X' (offset into Koopaling_PatLookup)

	LDY <Temp_Var7		 ; Y = Sprite_RAM offset

	JSR Draw_KoopalingBody	 ; Draw upper half Koopaling

	; Second row sprites
	LDA <Temp_Var1
	ADD #$10
	STA <Temp_Var1

	; Sprite_RAM offset += 12 (next three sprites)
	TYA
	ADD #$0c
	TAY

	; X += 3 (next sprite pattern set)
	INX
	INX
	INX

	JSR Draw_KoopalingBody	 ; Draw lower half Koopaling

	LDX <SlotIndexBackup	 ; X = object slot index

	LDY <Temp_Var7		 ; Y = starting Sprite_RAM offset

	LDA Objects_Frame,X
	CMP #$0c	 
	BEQ PRG001_B395	 ; If sprite frame = $C, jump to PRG001_B395

	CMP #$10	 
	BNE PRG001_B3A1	 ; If sprite frame <> $10, jump to PRG001_B3A1

PRG001_B395:

	; Set horizontal flip on some shell flip frames
	LDA Sprite_RAM+6,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+6,Y

	STA Sprite_RAM+$12,Y
	RTS		 ; Return

PRG001_B3A1:
	CMP #$04
	BLT PRG001_B3D0	 ; If frame < 4 (not shell frame), jump to PRG001_B3D0 (RTS)

	CMP #$0a
	BGE PRG001_B3D0	 ; If frame >= 10 (exiting shell frame), jump to PRG001_B3D0 (RTS)

	; Spinning shell frames only...

	; Offset Y +6
	LDA Sprite_RAM,Y
	ADC #$06
	STA Sprite_RAM,Y
	STA Sprite_RAM+8,Y

	; Clear horizontal/vertical flip bit on first half
	LDA Sprite_RAM+2,Y
	AND #$3f
	STA Sprite_RAM+2,Y

	; Set horizontal flip on second half
	ORA #SPR_HFLIP
	STA Sprite_RAM+10,Y

	LDA Objects_Timer2,X
	CMP #$60
	BGE PRG001_B3D0	 ; If Timer 2 >= $60, jump to PRG001_B3D0 (RTS)

	; Otherwise, set pattern $71
	LDA #$71
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+9,Y

PRG001_B3D0:
	RTS		 ; Return

Draw_KoopalingWand:
	LDA Objects_Frame,X
	CMP #$04
	BGE PRG001_B3D0	 ; If frame >= 4, jump to PRG001_B3D0 (RTS)

	LDY KoopaKidType	 ; Y = World number

	LDA Objects_Frame,X	; Get current frame
	ADD Koopaling_OffYOff,Y	; Add respective base index
	TAY		 	; Result -> 'Y'

	; Add offset to object Y and store previous value
	LDA <Objects_Y,X
	PHA		
	ADD Koopaling_OffYLo,Y
	STA <Objects_Y,X

	LDA <Objects_YHi,X
	PHA
	ADC Koopaling_OffYHi,Y
	STA <Objects_YHi,X

	LDA Objects_FlipBits,X
	ASL A
	BPL PRG001_B3FF	 ; If Player is not right of object, jump to PRG001_B3FF

	; Add 12 to offset index
	TYA
	ADD #$0c
	TAY

PRG001_B3FF:

	; Add offset to object X and store previous value
	LDA <Objects_X,X
	PHA
	ADD Koopaling_OffXLo,Y
	STA <Objects_X,X

	LDA <Objects_XHi,X
	PHA	
	ADC Koopaling_OffXHi,Y
	STA <Objects_XHi,X

	JSR Object_DetermineHorzVis	; Set flags based on which sprites of this object are horizontally visible
	JSR Object_DetermineVertVis	; Set flags based on which sprites of this object are vertically visible
	JSR Object_ShakeAndCalcSprite	; Calculate sprite info

	LDX <SlotIndexBackup		; Restore 'X' as object index

	LDY #$02	 ; Y = 2

	LDA Objects_Timer,X
	BEQ PRG001_B425	 ; If first object timer = 0, jump to PRG001_B425
 
	AND #$03	; Cap 0 - 3
	TAY		; -> 'Y'

PRG001_B425:
	STY <Temp_Var4	; Store value -> Temp_Var4

	; Draw Koopaling's wand
	LDY Objects_Frame,X	; Y = current frame
	LDX Koopaling_WandFrame,Y
	LDY #$20
	JSR Object_Draw16x16Sprite

	BIT <Temp_Var3
	BVS PRG001_B43A	 ; If wand is horizontally flipped, jump to PRG001_B43A

	; Y += 4 (offset to next sprite because wand second half occurred second)
	INY
	INY
	INY
	INY

PRG001_B43A:

	; Horizontally flips the "staff" part of the wand sprite
	LDA Sprite_RAM+2,Y
	EOR #SPR_HFLIP
	STA Sprite_RAM+2,Y

	LDX <SlotIndexBackup	; X = Object's index 

	PLA		 	; Restore pre-offset X Hi
	STA <Objects_XHi,X	; Store as object's X Hi

	PLA		 	; Restore pre-offset X
	STA <Objects_X,X	; Store as object's X

	PLA		 	; Restore pre-offset Y Hi
	STA <Objects_YHi,X	; Store as object's Y Hi

	PLA		 	; Restore pre-offset Y
	STA <Objects_Y,X	; Store as object's Y

	JSR Object_DetermineHorzVis	; Set flags based on which sprites of this object are horizontally visible
	JMP Object_DetermineVertVis	; Set flags based on which sprites of this object are vertically visible (and do not return...)

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Draw_KoopalingBody:

	; Shift Temp_Var5; if bit set, skip this sprite
	LSR <Temp_Var5
	BCS PRG001_B4B4	 ; If carry set, jump to PRG001_B4B4 (RTS)

	LDA <Temp_Var8	 ; Holds Object's Flags1 (sprites horizontally off-screen)
	ASL A		 ; Shift value to the left
	STA <Temp_Var16	 ; -> Temp_Var16

	LDA <Temp_Var1	 ; Object's Y

	BCS PRG001_B466	 	; If sprite is not visible, jump to PRG001_B466

	STA Sprite_RAM,Y 	; Otherwise, store sprite Y

PRG001_B466:
	BIT <Temp_Var16	 
	BMI PRG001_B46D	 	; If next sprite is not visible, jump to PRG001_B46D

	STA Sprite_RAM+4,Y	; Otherwise, store next sprite Y

PRG001_B46D:
	BVS PRG001_B472	 	; If next sprite is not visible, jump to PRG001_B472

	STA Sprite_RAM+8,Y	; Otherwise, store next sprite Y

PRG001_B472:

	; Store all sprites' Xs
	LDA <Temp_Var2
	STA Sprite_RAM+3,Y
	ADD #$08
	STA Sprite_RAM+7,Y
	ADD #$08
	STA Sprite_RAM+11,Y

	LDA KPatTable,X
	ADD #$40
	STA Sprite_RAM+1,Y
	LDA KPatTable+1,X
	ADD #$40
	STA Sprite_RAM+5,Y
	LDA KPatTable+2,X
	ADD #$40
	STA Sprite_RAM+9,Y

	LDA <Temp_Var3
	ORA <Temp_Var4

	; Store combined attributes
	STA Sprite_RAM+2,Y 
	STA Sprite_RAM+6,Y
	STA Sprite_RAM+10,Y 

	BIT <Temp_Var3 
	BVC PRG001_B4B4	 ; If not horizontally flipped, jump to PRG001_B4B4 

	; Otherwise, reverse the sprites...
	LDA Sprite_RAM+1,Y 
	PHA	 
	LDA Sprite_RAM+9,Y 
	STA Sprite_RAM+1,Y 
	PLA	 
	STA Sprite_RAM+9,Y 

PRG001_B4B4:
	RTS		 ; Return

PRG001_B4B5:
	.byte $AF, $BF, $81, $41
	
Koopaling_WandGrab: 

	; Do the wand flashy colors effect!
	LDA #$9e	 
	STA RotatingColor_Cnt

PRG001_B4BE:
	INC Level_GetWandState	 ; Level_GetWandState = 4, 5, 6, or 7 depending how we got here

Koopaling_WandFall:
	RTS		 ; Return


Koopaling_TimeBonus:
	BNE Koopaling_WandFall	 ; Not done running down time bonus, jump to Koopaling_WandFall (RTS)

	; All time depleted...

	LDA #$c0
	STA Objects_Timer,X	 ; Object timer = $C0

	BNE PRG001_B4BE	 ; Jump (technically always) to PRG001_B4BE

	; Defeated Koopaling vanishing air ship timer mask; smaller the timer,
	; the smaller the mask, and the faster it flickers
KDefeat_VanishMask:	.byte $01, $02, $04, $08

Koopaling_AirshipVanish:
	LDA Objects_Timer,X	 
	BNE PRG001_B4E6	 ; If timer is not expired, jump to PRG001_B4E6

	; Timer expired!

	; Play "King's Room" music (as Mario begins to fall)
	LDA #MUS2A_THRONEROOM
	STA Sound_QMusic2

	; Position all the clouds visible after airship vanishes semi-randomly
	JSR KDefeat_PositionClouds

	LDA #$ff
	STA Objects_Timer,X	 ; Set timer to $FF

	BNE PRG001_B4BE	 ; Jump (technically always) to PRG001_B4BE (next wand state)

PRG001_B4E6:
	CMP #$80
	BGE Koopaling_WandFall	 ; If timer < $80, jump to Koopaling_WandFall (RTS)

	; Could have just done this with right shifts?
	ASL A		; Bit 7 lost
	ASL A		; Bit 6 lost
	ROL A		; Bit 5 -> 0
	ROL A		; Bit 5 -> 1, Bit 4 -> 0 (Effectively, timer is divided by 16)
	AND #$03	; Cap 0 - 3

	TAY			 	; Y = 0 to 3
	LDA KDefeat_VanishMask,Y	; A = 1, 2, 4, or 8

	; The "flicker away" effect just takes advantage of forcing the scroll 
	; to the absolute top or absolute bottom, back and forth
	LDY #$00	 	; Y = 0 (scroll top)
	AND Objects_Timer,X	; Mask timer to control flicker rate
	BEQ PRG001_B4FD	 	; If masked value is zero, jump to PRG001_B4FD

	LDY #$ef	 ; Y = $EF (scroll bottom)

PRG001_B4FD:
	STY <Vert_Scroll ; Set scroll as appropriate!

	RTS		 ; Return


Koopaling_DoPlayerFall:
	LDA Objects_Timer,X	  
	BEQ PRG001_B4BE	 ; If timer expired, jump to PRG001_B4BE (next wand state)

PRG001_B505:
	JSR KDefeat_MoveClouds	; Move the clouds in the background

	; I suspect that there was an idea to have your time bonus
	; counted up as Mario fell instead of doing it beforehand...

 Koopaling_FallOff:
	JSR PRG001_B505	 ; Keep doing stuff from Koopaling_DoPlayerFall
	BNE PRG001_B525	 ; If time bonus hasn't finished counting down, jump to PRG001_B525 (RTS) (not used!)

	LDA <Player_YHi
	CMP #$02
	BLT PRG001_B525	 ; If Player's Y Hi < 2, jump to PRG001_B525 (RTS)

	LDY Player_Current	; Y = Player_Current

	; When Level_ExitToMap goes non-zero, fall to king's room, not exit to map
	LDA #$01
	STA Player_FallToKing,Y

	LSR A
	STA Map_ReturnStatus	 ; Map status = 0 (level cleared)
	INC Level_ExitToMap	 ; Fall into king's room (in this context)

PRG001_B525:
	RTS		 ; Return


	; Initialized semi-random position of clouds shown after airship vanishes
KDefeat_CloudXs:	
KDefeat_CloudYs:	
	
	; Positions the post-airship-vanishing clouds semi-randomly
KDefeat_PositionClouds:

	RTS		 ; Return

PRG001_B556:	

KDefeat_MoveClouds:
	RTS		 ; Return

	; Widths of the different clouds
KDefeat_CloudWidths:

	; Clouds are drawn manually, not actual objects of their own free will!
KDefeat_DrawClouds:
	RTS		 ; Return

	; Different impact counts for the heavy Koopalings Roy and Ludwig, sets Level_Vibration
	; Basically larger vibrations based on more hits to the Koopaling
KoopalingImpact_Count:
	.byte $20, $30, $40


	; Koopaling hits solid tiles and also causes the paralyzing Player
	; floor vibration, if it's the right Koopaling to do so..
Koopaling_DetectWorld:

	; Apply velocities and detect against world
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoLimit
	JSR Object_WorldDetectN1

	LDA KoopaKidType
	CMP #$04	
	BEQ PRG001_B617	 ; If World = 4 (World 5, Roy), jump to PRG001_B617

	CMP #$06	 
	BEQ PRG001_B617	 ; If World = 6 (World 7, Ludwig), jump to PRG001_B617

	; Not World 5 (Roy) or World 7 (Ludwig) ...

	; Object Y velocity += 2 (fall)
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	JSR Object_HitGroundAlign	 ; Hit ground and align
	JMP PRG001_B654	 		; Jump to PRG001_B654

PRG001_B617:

	; World 5 (Roy) or World 7 (Ludwig) ...

	LDA <Objects_YVel,X
	BMI PRG001_B621	 ; If Y velocity < 0 (moving upward), jump to PRG001_B621

	CMP #$78	 
	BGE PRG001_B62E	 ; If Y velocity >= $78, jump to PRG001_B62E
	BLT PRG001_B624	 ; If Y velocity < $78, jump to PRG001_B624

PRG001_B621:
	JSR Negate	 ; Get absolute value of Y velocity

PRG001_B624:
	; Absolute value of Y velocity < $78

	; Basically add 1/8 current velocity to the Y velocity (Roy and Ludwig's fast fall rate)
	LSR A
	LSR A
	LSR A	
	ADD #$01
	ADC <Objects_YVel,X
	STA <Objects_YVel,X

PRG001_B62E:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_B654	 ; If Roy/Ludwig hasn't hit ground, jump to PRG001_B654

	LDA <Objects_YVel,X
	CMP #$20
	BLT PRG001_B651	 ; If Y velocity < $20, jump to PRG001_B651 (cutoff for shaking floor)

	; Slam floor sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDY <Objects_Var4,X	 ; Y = current Koopaling hit count

	LDA KoopalingImpact_Count,Y
	STA Level_Vibration	 	; Shake floor!

	LDY <Player_InAir
	BNE PRG001_B651	 	; If Player is mid-air, jump to PRG001_B651

	STA Objects_Var1,X	 ; If Player's on the ground, set Variable 1 to the same as the shake (used to paralyze Player)

PRG001_B651:
	JSR Object_HitGround	 ; Hit ground, align to floor

PRG001_B654:
	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG001_B65C	 ; If Koopaling did not hit ceiling, jump to PRG001_B65C

	STA <Objects_YVel,X	 ; Otherwise, Y vel = 0

PRG001_B65C:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG001_B668	 ; If Koopaling did not hit left or right wall, jump to PRG001_B668

	; Hit wall, turn around...
	JSR Object_AboutFace
	JSR Object_FlipFace

PRG001_B668:
	RTS		 ; Return

Lemmy_XLimits:		.byte 208, 32	; Lemmy's X coordinate limits (does not take "X Hi" into account)
Lemmy_XVelLimits:	.byte $18, -$18	; Lemmy's X velocity limits
Lemmy_XVelAccel:	.byte 1, -1	; Lemmy's X velocity acceleration

	; Converts the "0 if Player is to the right of object, 1 if to the left" 
	; to an appropriate horizontal flip
Koopaling_FacePlayerBit:	.byte SPR_HFLIP, $00

PRG001_B671:

	; World 6 (Lemmy)

	JSR DrawLemmyBall_AndHit	; Draw Lemmy and his ball, also detect Player touching his ball
	JSR Object_HitTestRespond	; Perform normal hit test and response 
	JSR Koopaling_DieByFire		; If hit by enough fireballs, battle ends

	LDA <Player_HaltGame
	ORA Objects_Timer2,X
	BNE PRG001_B6F1	 	; If game is halted or timer 2 is non-zero, jump to PRG001_B6F1

	; Get absolute value of X velocity
	LDA <Objects_XVel,X
	BPL PRG001_B688	
	JSR Negate
PRG001_B688:

	LSR A
	LSR A
	LSR A

	AND #$07	 ; A = (absolute value of X velocity) / 8, capped 0 - 7
	TAY		 ; -> 'Y'

	LDA KoopalingAnimSpd,Y
	ADD Objects_Var7,X
	STA Objects_Var7,X	 ; Koopaling's animation timer += KoopalingAnimSpd[Y]
	BCC PRG001_B6A0	 	; If no overflow, jump PRG001_B6A0

	INC Objects_Var6,X 	; Animation counter 
	INC Objects_Frame,X	; If overflow, Koopaling stepped, so go to next frame

PRG001_B6A0:

	; Alternate between frame 0 and 1 when "walking"
	LDA Objects_Frame,X
	AND #$01
	STA Objects_Frame,X

	LDA <Counter_1
	AND #$7f	
	BNE PRG001_B6B7	 ; 127 ticks, jump to PRG001_B6B7

	; Every 128 ticks...
	JSR Level_ObjCalcXDiffs	 ; Determine which side Player is on

	; 'Y' is set to 0 if Player is to the right of object, 1 if to the left
	LDA Koopaling_FacePlayerBit,Y	 ; Get appropriate flip bit
	STA Objects_FlipBits,X	 	; Set it!

PRG001_B6B7:
	LDA <Counter_1
	LSR A		
	BCS PRG001_B6D1	 ; Every other tick, jump to PRG001_B6D1

	DEC Objects_Var3,X	; Objects_Var3-- 
	BNE PRG001_B6D1	 	; If Objects_Var3[X] <> 0, jump to PRG001_B6D1

	INC Objects_TargetingXVal,X	 ; Objects_TargetingXVal++ 

	LDA RandomN,X
	AND #$3f	
	ORA #$80	
	STA Objects_Var3,X	 ; Random value $80-$BF -> Objects_Var3 

	JSR Lemmy_SpawnBall	 ; Lemmy will spawn another ball, if available

PRG001_B6D1:
	LDA Objects_TargetingXVal,X
	AND #$01
	TAY			; Y = 0 or 1
	LDA Lemmy_XLimits,Y
	CMP <Objects_X,X
	LDY #$00		; Y = 0
	BGE PRG001_B6E1		; If Lemmy is beyond his limit, jump to PRG001_B6E1

	INY			; Y = 1

PRG001_B6E1:
	LDA <Objects_XVel,X
	CMP Lemmy_XVelLimits,Y
	BEQ PRG001_B6EE	 	; If Lemmy is at his limit, jump to PRG001_B6EE

	ADD Lemmy_XVelAccel,Y
	STA <Objects_XVel,X	; Otherwise, apply acceleration

PRG001_B6EE:
	JSR Object_ApplyXVel	; Apply X Velocity

PRG001_B6F1:
	RTS		 ; Return

KoopalingAnimSpd:
	.byte $00, $20, $40, $50, $60, $70, $80, $A0

	; Lemmy's ball components, four frames
LemmyBall_Left:		.byte $DB, $F7, $F7, $DB
LemmyBall_Right:	.byte $F7, $DB, $DB, $F7 
LemmyBall_Attrs:	.byte $02, $42, $C2, $82

	; Lemmy has a special routine to draw his ball and detect getting hit by it
DrawLemmyBall_AndHit:
	LDY #$00	 ; Y = 0

	LDA Objects_Frame,X
	CMP #$02	 
	BGE PRG001_B710	 ; If frame >= 2, jump to PRG001_B710

	TAY		 ; Y = 1

PRG001_B710:
	STY <Temp_Var1	 ; Temp_Var1 = 0 or 1

	LDA <Objects_Y,X	; Get object's Y
	PHA		 	; Save it
	SUB <Temp_Var1		; Subtract 0 or 1
	STA <Objects_Y,X	; Store into object's Y

	LDA <Objects_YHi,X	; Get object's Y Hi
	PHA		 	; Save it
	SBC #$00	 	; Apply carry
	STA <Objects_YHi,X	; Store into object's Y Hi

	JSR Koopaling_DrawAndAnimate	 ; Draw and animate the Koopaling

	PLA		 	; Restore object's Y Hi
	STA <Objects_YHi,X	; Save it

	PLA		 	; Restore object's Y
	STA <Objects_Y,X	; Save it

	JSR Object_CalcSpriteXY_NoHi	 ; Calculate Sprite X and Y

	LDA <Objects_XVel,X
	ASL A		 ; A = X velocity << 1

	LDA Objects_Var6,X	 ; Get animation frame counter for Lemmy's ball
	BCC PRG001_B737	 ; If velocity negative, jump to PRG001_B737

	EOR #$03	 ; Invert part of Objects_Var6 we care about

PRG001_B737:
	AND #$03	 ; Mask lower 2 bits of Objects_Var6 (0-3)
	TAY		 ; -> 'Y'

	; Stores patterns for Lemmy's ball
	LDA LemmyBall_Left,Y
	STA Sprite_RAM+$19

	LDA LemmyBall_Right,Y
	STA Sprite_RAM+$1D

	; Store attributes for Lemmy's ball
	LDA LemmyBall_Attrs,Y
	STA Sprite_RAM+$1A
	STA Sprite_RAM+$1E

	LDA #$04	 ; A = 4

	LDY Objects_Timer2,X	; Y = timer 2
	BNE PRG001_B761	 	; If timer 2 is zero, jump to PRG001_B761

	; Non-zero timer...

	; Pushes horizontal flip bit into carry
	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA #$00	 ; A = 0
	BCS PRG001_B761	 ; If horizontally flipped, jump to PRG001_B761

	LDA #$08	 ; A = 8

PRG001_B761:
	ADD <Objects_SpriteX,X	 ; Add the Sprite X factor
	STA Sprite_RAM+$1B	 ; Store into sprite X
	STA <Temp_Var2		 ; -> Temp_Var2

	ADD #$08	 
	STA Sprite_RAM+$1F	 ; Store into second sprite X

	; Set sprite Y with +$20 offset
	LDA <Objects_SpriteY,X
	ADD #$20
	STA Sprite_RAM+$18
	STA Sprite_RAM+$1C


	; Check if Player is touching Lemmy's ball

	; X bound
	LDA <Player_SpriteX
	SBC <Temp_Var2
	ADD #$0c
	CMP #$18
	BGE PRG001_B799

	; Y bound
	LDA <Player_SpriteY
	SBC Sprite_RAM+$18
	ADD #$20
	CMP #$20
	BGE PRG001_B799

	; Offscreen
	LDA Player_OffScreen
	BNE PRG001_B799	 ; If Player is offscreen, jump to PRG001_B799 (RTS)

	JSR Player_GetHurt	 ; Hurt Player!

PRG001_B799:
	RTS		 ; Return

	; Set X velocity of Lemmy ball
LemmyBall_XVel:
	.byte -8, 8

Lemmy_SpawnBall:

	LDY #$02	; Y = 2
PRG001_B79E:
	LDA Objects_State,Y
	BEQ PRG001_B7A7	 ; If this object slot is dead/empty, jump to PRG001_B7A7

	DEY		 ; Y--
	BPL PRG001_B79E	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG001_B7A7:
	TYA		 ; A = Y
	TAX		 ; X = A (slot index for new object)

	JSR Level_PrepareNewObject	 ; Prepare new object!

	LDX <SlotIndexBackup	 ; X = original object slot index

	; New object in state 2 (normal operation)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,Y

	; New object ID 
	LDA #OBJ_WATERFILLER
	STA Level_ObjectID,Y

	; New object Y -- Koopaling Y + 32
	LDA <Objects_Y,X
	ADD #$20
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA Objects_YHi,Y

	; New object X -- Koopaling X + 4
	LDA <Objects_X,X
	ADD #$04
	STA Objects_X,Y
	LDA <Objects_XHi,X
	ADC #$00
	STA Objects_XHi,Y

	LDA Objects_TargetingXVal,X
	AND #$01
	TAX		; X = 0 or 1
	LDA LemmyBall_XVel,X
	STA Objects_XVel,Y	; Set X velocity

	LDA #$02
	STA Objects_SprAttr,Y	 ; Set sprite priority

	LDX <SlotIndexBackup		 ; Restore 'X' as object slot index yet again
	RTS		 ; Return


	; Wendy's ring thing X velocity (by facing direction)
Wendy_RingXVel: .byte $10, -$10

PRG001_B7EC:
	; World 3, Wendy ...
	JSR Lemmy_SpawnBall
	BMI PRG001_B819	 ; If unable to spawn, jump to PRG001_B819 (RTS)

	; Not sure what this is for?
	LDA #$01
	STA Objects_Var5,Y

	; Change spawned object Y to match Wendy
	LDA <Objects_Y,X
	STA Objects_Y,Y

	; Change spawned object Y Hi to match Wendy
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	; Set Y velocity to -$10
	LDA #-$10
	STA Objects_YVel,Y

	STY <Temp_Var1	 ; Save 'Y'

	; Y = 0 or 1, depending on facing direction
	LDY #$00
	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BNE PRG001_B811
	INY	

PRG001_B811:
	LDA Wendy_RingXVel,Y

	LDY <Temp_Var1	 ; Restore 'Y'

	; Set ring X velocity as appropriate!
	STA Objects_XVel,Y

PRG001_B819:
	RTS		 ; Return


	; Hmm, unused space?
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF


ObjInit_Bowser:

	; Bowser takes 34 fireball hits!
	LDA #34
	STA Objects_HitCount,X

	; Bowser is giant!
	INC Objects_IsGiant,X

	RTS		 ; Return


	; X Velocity applied to Player when bouncing off Bowser's head
Bowser_HeadBounceXVel:	.byte $10, -$10

ObjNorm_Bowser:

	; Set Bowser's pattern table selections
	LDA #$3a
	STA PatTable_BankSel+4
	LDA #$3b
	STA PatTable_BankSel+5

	LDA <Player_HaltGame
	BNE PRG001_B8D3	 ; If gameplay is halted, jump to PRG001_B8D3

	LDA Bowser_Counter1
	BEQ PRG001_B8A1	 ; If Bowser_Counter1 = 0, jump to PRG001_B8A1

	DEC Bowser_Counter1	 ; Bowser_Counter1--

PRG001_B8A1:
	LDA Bowser_Counter2
	AND #%00011111	 
	BEQ PRG001_B8AB	 ; Every 32 ticks of Bowser's second counter, jump to PRG001_B8AB

	DEC Bowser_Counter2	 ; Bowser_Counter2--

PRG001_B8AB:
	JSR Bowser_DoVar5Action	; Do Bowser's internal state action
	JSR Bowser_HopAndBreatheFire	; Bowser hops and breathes fireballs
	JSR Player_HitEnemy	 	; Do hit detection

	LDA Objects_PlayerHitStat,X
	BEQ PRG001_B8D3		; If Player hasn't hit Bowser, jump to PRG001_B8D3

	; Player hit Bowser...

	; Set timer 2 to 8
	LDA #$08
	STA Objects_Timer2,X

	LDA <Player_YVel
	BMI PRG001_B8D3	 ; If Player is moving upward, jump to PRG001_B8D3

	; Player bounces off Bowser's head!
	LDA #-$30
	STA <Player_YVel

	JSR Bowser_CalcPlayersSide	 ; Calculate the side of his head Player bounced off of

	; Apply an X Velocity when bouncing off Bowser's head
	LDA Bowser_HeadBounceXVel,Y
	STA <Player_XVel

	; Bounce sound
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

PRG001_B8D3:
	LDA <Objects_Var5,X
	BEQ PRG001_B8E0	 ; If the internal state = 0 (waiting to meet Player), jump to PRG001_B8E0

	JSR Bowser_Draw	 ; Draw Bowser!

	LDA <Objects_Var5,X	
	CMP #$01	 
	BEQ PRG001_B8E5	 ; If internal state = 1, jump to PRG001_B8E5 (RTS)

PRG001_B8E0:

	; Otherwise, mark Bowser as totally invisible horizontally (??)
	LDA #$ff
	STA Objects_SprHVis,X

PRG001_B8E5:
	RTS		 ; Return

Bowser_DoVar5Action:
	LDA <Objects_Var5,X
	JSR DynJump	 ; Jump dynamically by Objects_Var5

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_WaitForPlayer	; Internal state 0: Bowser waiting for Mario/Luigi to show up...
	.word Bowser_DoMovements	; Internal state 1: Bowser movements (jumping, busting floor, etc.)
	.word Bowser_FallAndSplat	; Internal state 2: Bowser fall (until he hits bottom, ba-bam! Only if dead, though)
	.word Bowser_WaitAndVictory	; Internal state 3: Wait until timer expires, then play victory song
	.word Bowser_DoTimeBonus	; Internal state 4: Convert remaining time to score
	.word Bowser_DoorAppear		; Internal state 5: Final door appears

Bowser_WaitForPlayer:
	LDA Objects_SprHVis,X
	BNE PRG001_B928	 ; If any of Bowser's sprites are horizontally off-screen, jump to PRG001_B928 (RTS)

	LDA <Horz_Scroll
	CMP #$07
	BGE PRG001_B928	 ; If Horz_Scroll >= 7, jump to PRG001_B928 (RTS)

	; Player got close enough; lock horizontal scroll and stop Player from moving
	LDA #$00
	STA <Horz_Scroll
	STA <Player_XVel

	; Player must land first
	LDA <Player_InAir
	BNE PRG001_B928	 ; If Player is midair, jump to PRG001_B928 (RTS)

	; Vert_Scroll = $EF (lowest scroll point)
	LDA #$ef
	STA <Vert_Scroll

	; Play Bowser's Theme
	LDA #MUS2B_BOWSER
	STA Sound_QMusic2

	INC LevelVertJct	 ; LevelVertJct = 1 (set like in a Big Question block area, i.e. no horizontal scrolling)

	; Lock vertical scroll
	LDA #$02
	STA Level_FreeVertScroll

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

	; Timer 3 = $30
	LDA #$30	 
	STA Objects_Timer3,X

	; Internal state = 1
	INC <Objects_Var5,X

PRG001_B928:
	RTS		 ; Return


Bowser_DoMovements:
	JSR Bowser_HandleIfDead	 ; Handle Bowser if he got killed

	LDA Level_NoStopCnt
	AND #%00011111
	ORA Bowser_Counter1
	BNE PRG001_B948	 ; If Bowser Counter 1 > 0 and except every 32nd tick, jump to PRG001_B948

	; Only when Bowser Counter 1 is expired and every 32 ticks of the no stop counter...

	LDA Objects_FlipBits,X

	PHA		 ; Save Bowser's flip bits

	JSR Bowser_FacePlayer	 ; Bowser face Player

	PLA		 ; Restore Bowser's flip bits

	CMP Objects_FlipBits,X
	BEQ PRG001_B948	 ; If Bowser has NOT changed facing direction, jump to PRG001_B948

	; Bowser changed facing direction

	; Set some bits on Bowser's Counter 2
	ORA #$13
	STA Bowser_Counter2

PRG001_B948:
	LDA <Objects_Var4,X
	JSR DynJump	 ; Jump dynamically by var 4

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_FallToFloor	; 0: Fall to floor
	.word Bowser_JumpAndLandOnFloor	; 1: Jump and land on floor
	.word Bowser_AlignAndFall	; 2: Align to tile on the way down (will also use part of Bowser_JumpAndLandOnFloor)
	.word Bowser_BustFloorLookAround; 3: Bowser busts floor and looks around

PRG001_B955:	.byte $08, $05, $04, $05, $08
PRG001_B95A:	.byte $40, $40, $00, $00, $00


Bowser_FallToFloor:
	JSR Bowser_Counter3Do	 ; Update Bowser_Counter3

	LDA Bowser_Counter2
	AND #$1f	 
	BEQ PRG001_B97C	 ; Every 32 ticks of Bowser_Counter2, jump to PRG001_B97C

	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, slower rate than Bowser_Counter2

	LDA Bowser_Counter2
	AND #SPR_HFLIP
	EOR PRG001_B95A,Y
	STA Objects_FlipBits,X

	LDA PRG001_B955,Y

PRG001_B97C:
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BNE PRG001_B9B5	 ; If timer is not expired, jump to PRG001_B9B5

	JSR Bowser_DetectTiles	 ; Detect the tiles under Bowser

	; Bowser fall up to $40 Y Velocity...
	LDA <Objects_YVel,X
	CMP #$40	 
	BGS PRG001_B98F	 ; If Bowser's Y Velocity >= $40, jump to PRG001_B98F

	INC <Objects_YVel,X	 ; Bowser's gravity

PRG001_B98F:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_B9A4	 ; If Bowser has NOT hit floor, jump to PRG001_B9A4 (RTS)

	JSR Object_HitGround	 ; Align to floor

	LDA #$10	; A = $10

	LDY Objects_Timer3,X
	BNE PRG001_B9A1	 ; If Timer 3 is not expired, jump to PRG001_B9A1

	LDA #$b0	 ; A = $B0

PRG001_B9A1:
	; Set Timer as appropriate
	STA Objects_Timer,X

PRG001_B9A4:
	RTS		 ; Return

	; Base X velocities by Player's distance away from Bowser when he attempts to jump and land on you
Bowser_XVelByDist:
	.byte $08, $10, $18, $20, $28, $30, $38, $40, $48, $50, $50, $50, $50, $50, $50, $50

PRG001_B9B5:
	LDA Bowser_Counter2 
	AND #$1f 
	BNE PRG001_B9BF	 ; Only continue 1:32 ticks, otherwise jump to PRG001_B9BF
 
	INC Objects_Frame,X	 ; Bowser's frame++

PRG001_B9BF:
	LDA Objects_Timer,X 
	CMP #$01 
	BEQ PRG001_B9F3	 ; If timer expired, jump to PRG001_B9F3

	CMP #$80 
	BNE PRG001_B9F2	 ; If timer <> $80, jump to PRG001_B9F2 (RTS) 

	; Jump and land on floor mode
	LDA #$01 
	STA <Objects_Var4,X
 
	; Bowser jump!
	LDA #-$60 
	STA <Objects_YVel,X
 
	JSR Bowser_CalcPlayersSide 
	STY <Temp_Var1		 ; Temp_Var1 = 0 or 1, depending on side Player is on
 
	; Get absolute value of X difference
	LDA <Temp_Var16 
	BPL PRG001_B9DE 
	JSR Negate 
PRG001_B9DE:

	LSR A 
	LSR A 
	LSR A 
	LSR A 
	AND #$0f 
	TAY		 ; Y = 0 to 15, number of tiles away Player is
 
 
	; Calculate Bowser's X velocity to target Player!
	LDA Bowser_XVelByDist,Y
	LDY <Temp_Var1 
	DEY	
	BNE PRG001_B9F0 
	JSR Negate
PRG001_B9F0: 
	STA <Objects_XVel,X 

PRG001_B9F2:
	RTS		 ; Return

PRG001_B9F3:
	; Little hop
	LDA #-$10 
	STA <Objects_YVel,X
 
	RTS		 ; Return

	; Used as a bit 7 invert to determine if Bowser is moving 
	; away from or towards the Player
Bowser_VsPlayerXVelNegBit:
	.byte $00, $80


Bowser_JumpAndLandOnFloor:
	LDA <Objects_YVel,X	 
	BPL PRG001_BA01	 ; If Bowser is on floor or falling, jump to PRG001_BA01

	JSR Bowser_Counter3Do	 ; Update Bowser's Counter 3

PRG001_BA01:

	; Bowser frame 0
	LDA #$00
	STA Objects_Frame,X

	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	BMI PRG001_BA11	 ; If Bowser is moving upward (jumping), jump to PRG001_BA11

	CMP #$50	 
	BGE PRG001_BA17	 ; If Bowser Y velocity >= $50, jump to PRG001_BA17

PRG001_BA11:

	; Bowser fall rate Y Vel += 3
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BA17:

	LDA <Objects_YVel,X
	BPL PRG001_BA1F	 ; If Bowser is not moving upward, jump to PRG001_BA1F

	CMP #-$20
	BLT PRG001_BA4B	 ; If Bowser is moving upward faster than -$20, jump to PRG001_BA4B

PRG001_BA1F:

	; Bowser not moving upward... or not moving upward fast enough

	JSR Bowser_CalcPlayersSide	 ; Figure out which side Player is on

	LDA Bowser_VsPlayerXVelNegBit,Y
	EOR <Objects_XVel,X
	BPL PRG001_BA4B	 ; If Bowser's velocity is moving away from Player, jump to PRG001_BA4B

	JSR Level_ObjCalcYDiffs	 

	DEY		 ; Y--
	BEQ PRG001_BA4B	 ; If Y was 1, jump to PRG001_BA4B

	; Var4 = 2
	LDA #$02
	STA <Objects_Var4,X

	; Timer = $0A
	LDA #$0a
	STA Objects_Timer,X

	; Calculate an X position that targets Player and aligned to tile
	LDA <Objects_X,X
	ADD #$08
	AND #$f0
	STA Objects_TargetingXVal,X

	; Bowser jump!
	LDA #-$20
	STA <Objects_YVel,X

	; Stop Bowser's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG001_BA4B:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BA76	 ; If Bowser has NOT hit floor, jump to PRG001_BA76

	; Bowser has hit floor...

	JSR Object_HitGround	 ; Align to floor ('A' = 0 at the end of this, hence the following assignment)

	STA <Objects_XVel,X	 ; Stop Bowser's horizontal movement

	; Vibrate floor from impact
	LDA #$2c
	STA Level_Vibration

	; Ba-bam sound!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Object timer = $35
	LDA #$35
	STA Objects_Timer,X

	LDA RandomN,X
	AND #$1f	
	ADC #$67	
	STA Objects_Timer3,X	 ; Timer 3 = Random $67 to $86
	STA Objects_Var7,X	 ; -> Var7

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

PRG001_BA76:
	RTS		 ; Return


Bowser_AlignAndFall:
	; Reset Bowser Counter 1
	LDA #$00
	STA Bowser_Counter1

	; Set Bowser to frame 6 (Bowser's falling frame)
	LDA #$06
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ PRG001_BA96	; If timer expired, jump to PRG001_BA96

	LDA <Objects_X,X
	CMP Objects_TargetingXVal,X
	BEQ PRG001_BA95	; If Bowser reached the alignment X, jump to PRG001_BA95

	; Bowser moves towards the tile alignment
	INC <Objects_X,X
	BCC PRG001_BA95	; If carry clear, jump to PRG001_BA95

	; Don't let Bowser's X wrap around!
	DEC <Objects_X,X
	DEC <Objects_X,X

PRG001_BA95:
	RTS		 ; Return

PRG001_BA96:
	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser

	LDA <Objects_YVel,X
	BMI PRG001_BAA1	 ; If Bowser is moving upward, jump to PRG001_BAA1

	CMP #$70
	BGE PRG001_BAA6	 ; If Bowser's Y Velocity >= $70, jump to PRG001_BAA6 (RTS)

PRG001_BAA1:

	; Bowser's rapid stomp fall!
	ADD #$06
	STA <Objects_YVel,X

PRG001_BAA6:
	JMP PRG001_BA4B	 ; Jump to PRG001_BA4B 


Bowser_BustFloorLookAround:
	JSR Bowser_DetectTiles	  ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	CMP #$40
	BGS PRG001_BAB6	 ; If Bowser's Y Velocity >= $40, jump to PRG001_BAB6

	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BAB6:
	JSR Bowser_BustFloor	 ; Bust any bricks Bowser has hit

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BAC2	 ; If Bowser has not hit floor, jump to PRG001_BAC2

	JSR Object_HitGround	 ; Align to floor

PRG001_BAC2;
	LDA Objects_Timer,X
	BEQ PRG001_BACD		; If timer expired, jump to PRG001_BACD

	; Bowser slam frame
	LDA #$07
	STA Objects_Frame,X

	RTS		 ; Return

PRG001_BACD:
	LDA Objects_Timer3,X
	BNE PRG001_BAF1	 ; If timer 3 is not expired, jump to PRG001_BAF1

	; Var 4 back to zero
	LDA #$00
	STA <Objects_Var4,X

	LDA RandomN,X
	AND #$7f
	ORA #$80
	STA Objects_Timer3,X	 ; Timer 3 = $7F to $FF

	RTS		 ; Return

	; Bowser look around frame
Bowser_LookAroundFrames:	.byte $04, $05, $05, $05, $04, $05, $05, $05

	; Bowser look around flip bits
Bowser_LookAroundFlipBits:	.byte $00, $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP

PRG001_BAF1:
	CMP #$20
	BLT PRG001_BB0B	 ; If timer 3 < $20, jump to PRG001_BB0B

	; When Bowser lands, he looks around a bit for a second

	LSR A
	LSR A
	ADD Objects_Var7,X	; ?? Not used in anything else Bowser does?
	AND #$07
	TAY		 ; Y = 0 to 7 

	; Set frame
	LDA Bowser_LookAroundFrames,Y
	STA Objects_Frame,X

	; Set flip bits
	LDA Bowser_LookAroundFlipBits,Y
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG001_BB0B:
	CMP #$0c
	LDA #$05	 ; A = 5
	BGE PRG001_BB13	 ; If timer 3 >= 5, jump to PRG001_BB13

	LDA #$08	 ; Otherwise, A = 8

PRG001_BB13:
	STA Objects_Frame,X	 ; Set Bowser frame

Bowser_FacePlayer:
	JSR Bowser_CalcPlayersSide

	; Bowser face Player!
	LDA Bowser_FlipToFace,Y
	STA Objects_FlipBits,X

	RTS		 ; Return


	; Set proper flip bit for Bowser to face Player
Bowser_FlipToFace:
	.byte SPR_HFLIP, $00

Bowser_HoppingFrames:
	.byte $00, $00, $03, $02, $00, $00, $00, $00

Bowser_HopAndBreatheFire:
	LDA Bowser_Counter1
	BEQ PRG001_BB46	 ; If Bowser_Counter1 = 0, jump to PRG001_BB46 (RTS)

	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	; Bowser's little hopping animation
	LDA Bowser_HoppingFrames,Y
	STA Objects_Frame,X

	LDA Bowser_Counter1
	CMP #$10	 
	BNE PRG001_BB46	 ; If Bowser_Counter1 <> $10, jump to PRG001_BB46 (RTS)

	JSR Bowser_BreatheFire	 ; Bowser breathe's a fireball!

PRG001_BB46:
	RTS		 ; Return

	; Bowser's fireball X velocity and offset by direction
Bowser_FireballXVel:	.byte -$10, $10
Bowser_FireballXOff:	.byte -$08, $18

PRG001_BB4B:	.byte $00, $08, $10, $18, $08, $00, $00, $10
	
Bowser_BreatheFire:
	LDY #$04	; Y = 4
PRG001_BB55:
	LDA Objects_State,Y
	BEQ PRG001_BB5E	 ; If object is dead/empty, jump to PRG001_BB5E

	DEY		 ; Y--
	BPL PRG001_BB55	 ; While Y >= 0, loop

	RTS		 ; Return

PRG001_BB5E:
	TYA
	TAX		 ; X = new object's index

	JSR Level_PrepareNewObject	 ; Set up the new flame to be spawned 

	; Set object state to normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser's fireball
	LDA #OBJ_WATERFILLER
	STA Level_ObjectID,X

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Bowser fall
	LDA #$10
	STA Objects_YVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; Set fireball Y to Bowser's +16
	LDA <Objects_Y,X
	ADD #16
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA Objects_YHi,Y

	LDA Objects_FlipBits,X
	ASL A
	ASL A
	ROL A
	AND #$01
	TAX	
	STX <Temp_Var1		; X = 0 or 1, depending on if Bowser's horizontally flipped

	; Set X Velocity as appropriate
	LDA Bowser_FireballXVel,X
	STA Objects_XVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; X Hi is just copied
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set X appropriately offset from Bowser
	LDA <Objects_X,X
	LDX <Temp_Var1		
	ADD Bowser_FireballXOff,X
	STA Objects_X,Y	

	LDA RandomN,Y
	AND #$07	
	TAX		 ; X = random 0 to 7

	; A bit random how the fireball moves
	LDA PRG001_BB4B,X
	STA Objects_TargetingYVal,Y

	; Set fireball palette
	LDA #SPR_PAL1
	STA Objects_SprAttr,Y

	; Reset timer
	ASL A			; A = 0
	STA Objects_Timer,Y	

	; Fire breathing sound
	LDA #SND_LEVELFLAME
	STA Sound_QLevel2

	LDX <SlotIndexBackup	; Restore 'X' to Bowser's object slot index

	RTS		 ; Return


Bowser_Counter3Do:
	; If Bowser_Counter3 > 0, just decrement it.  Otherwise,
	; set it to some value $60 to $9F and set Bowser_Counter1 to $3F

	LDA Bowser_Counter3	  
	BNE PRG001_BBDC	 ; If Bowser_Counter3 <> 0, jump to PRG001_BBDC

	LDA RandomN,X
	AND #$3f
	ADC #$60
	STA Bowser_Counter3	 ; Bowser_Counter3 = $60 + (Random $00 to $3F)

	; Bowser Counter 1 = $3F
	LDA #$3f
	STA Bowser_Counter1

	RTS		 ; Return

PRG001_BBDC:
	DEC Bowser_Counter3	; Bowser_Counter3--
	RTS		 ; Return


	; Detect the left and right tiles underneath Bowser
Bowser_DetectTiles:
	; Apply Bowser's X and Y Velocities
	JSR Object_ApplyXVel	 
	JSR Object_ApplyYVel_NoLimit

	LDY <Objects_X,X	 ; Y = Bowser's X

	LDA <Objects_XVel,X
	BEQ PRG001_BBFC	 ; If Bowser is stopped horizontally, jump to PRG001_BBFC
	BMI PRG001_BBF4	 ; If Bowser is moving to the left, jump to PRG001_BBF4

	; Bowser moving to the right...

	; Prevent Bowser from moving off the right edge
	CPY #224
	BGE PRG001_BBF8	 ; If Bowser's X >= 224, jump to PRG001_BBF8
	BLT PRG001_BBFC	 ; Otherwise, jump to PRG001_BBFC

PRG001_BBF4:

	; Bowser moving to the left...

	; Prevent Bowser from moving off the left edge
	CPY #8
	BGE PRG001_BBFC	 ; If Bowser's X >= 8, jump to PRG001_BBFC

PRG001_BBF8:

	; Bowser could move off left or right edge, so stop him!
	LDA #$00
	STA <Objects_XVel,X

PRG001_BBFC:
	
	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC0B	; If var 4 <> 2, jump to PRG001_BC0B

	; Store tile detected under Bowser's left
	LDA Object_TileFeet2
	STA Bowser_Tiles	 ; Store detected tile -> Bowser_Tiles

PRG001_BC0B:
	LDA <Objects_DetStat,X	; Get Bowser's detection status bits
	PHA		 	; Save them

	LDA <Objects_X,X	; Get Bowser's X
	PHA		 	; Save it

	; Detect the right tile under Bowser's feet
	ADD #16
	STA <Objects_X,X
	JSR Object_WorldDetectN1

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	PLA		 ; Restore Bowser's detection bits
	ORA <Objects_DetStat,X	 ; OR in the ones detected by the right tile check
	STA <Objects_DetStat,X	 ; Save the unified set (in case only one foot is actually on the floor)

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC2D	; If var 4 <> 2, jump to PRG001_BC2D

	; Store tile detected under Bowser's right
	LDA Object_TileFeet2
	STA Bowser_Tiles+1

PRG001_BC2D:
	RTS		 ; Return


	; X offsets to Bowser's tile under each side of him
Bowser_TileOffsets:	.byte 8, 24


	; Busts any breakable floor that Bowser has hit
Bowser_BustFloor:
	LDY #$01	 ; Y = 1 (two tiles to potentially smash)
PRG001_BC32:
	LDA Bowser_Tiles,Y	; Get this tile
	CMP #TILE2_SOLIDBRICK
	BNE PRG001_BC69	 	; If this tile is not the solid brick tile, jump to PRG001_BC69

	; Bowser hit brick!
	LDA #$00
	STA Bowser_Tiles,Y	; Clear this tile

	; Queue a block change to erase to background!
	LDA #$80
	STA Level_ChgTileEvent

	; Aligned Bowser impact Y
	LDA <Objects_Y,X
	ADD #$30
	AND #$f0
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	; Aligned Bowser impact X
	LDA <Objects_X,X
	ADD Bowser_TileOffsets, Y
	AND #$f0
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	ADC #$00
	STA Level_BlockChgXHi

	JMP PRG001_BC6D	 ; Jump to PRG001_BC6D

PRG001_BC69:
	DEY		; Y--
	BPL PRG001_BC32	; While Y >= 0, loop!

	RTS		 ; Return


PRG001_BC6D:

	; Smash block sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA Level_BlockChgYLo
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA Level_BlockChgXLo
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

	RTS		 ; Return


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
	; These are the patterns for every column of every row, by frame 
	; (12 sprites total per frame, last four values for padding?)
Bowser_SprPats:
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 0
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $97, $99, $9B, $9D, $00, $00, $00, $00 ; Bowser frame 1
	.byte $9F, $A1, $A3, $A5, $A7, $A9, $AB, $AD, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 2
	.byte $9F, $A1, $B1, $A5, $B3, $B5, $B7, $AD, $B9, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 3
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $C9, $CB, $CB, $C9, $00, $00, $00, $FF ; Bowser frame 4
	.byte $71, $CF, $D1, $71, $D3, $D5, $F7, $D9, $DB, $DD, $DF, $E1, $00, $00, $00, $00 ; Bowser frame 5
	.byte $E3, $E5, $E5, $E3, $E7, $E9, $E9, $E7, $EB, $ED, $ED, $EB, $00, $00, $00, $FF ; Bowser frame 6
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $EF, $F1, $F1, $EF, $00, $00, $00, $FF ; Bowser frame 7
	.byte $71, $CF, $D1, $71, $D3, $D5, $C1, $CD, $F9, $FB, $FD, $FF, $00, $00, $00, $00 ; Bowser frame 8

	; Sprite X offsets per sprite, horizontally flipped or not horizontally flipped
Bowser_SprXNotHFlipped:	.byte $00, $08, $10, $18, $00, $08, $10, $18, $00, $08, $10, $18
Bowser_SprXHFlipped:	.byte $18, $10, $08, $00, $18, $10, $08, $00, $18, $10, $08, $00

	; Sprite Y offsets per sprite, vertically flipped or not vertically flipped
Bowser_SprYNotVFlipped:	.byte $00, $00, $00, $00, $10, $10, $10, $10, $20, $20, $20, $20
Bowser_SprYVFlipped:	.byte $20, $20, $20, $20, $10, $10, $10, $10, $00, $00, $00, $00

	; Similar to Bowser_SprVVisLUT, marks sprite that should be
	; invisible if marked horizontally invisible
Bowser_SprHVisLUT:
	.byte $80, $40, $20, $10

	; Bowser's sprites are drawn straight through; this marks the
	; ones that should not be handled if vertically invisible
Bowser_SprVVisLUT:
	.byte $01, $01, $01, $01	; Top sprites
	.byte $02, $02, $02, $02	; Middle sprites
	.byte $04, $04, $04, $04	; Bottom sprites

	; Bowser uses fixed Sprite_RAM offsets, alternating which set he used every other tick
Bowser_SprRAMOff:
	.byte $50, $54, $58, $5C	; Top sprites
	.byte $60, $64, $68, $6C	; Middle sprites
	.byte $70, $74, $78, $7C	; Bottom sprites

	.byte $00, $00, $00, $00	; Unused, for alignment only (switches between these sets via 4 ASLs)

	.byte $DC, $D8, $D4, $D0	; Top sprites
	.byte $EC, $E8, $E4, $E0	; Middle sprites
	.byte $FC, $F8, $F4, $F0	; Bottom sprites


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
Bowser_Draw:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the Sprite X and Y Low parts	 

	; Temp_Var1 = Bowser's Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Temp_Var2 = Bowser's Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	; Temp_Var3 and Temp_Var4 = Bowser's FlipBits
	LDA Objects_FlipBits,X
	STA <Temp_Var3		
	STA <Temp_Var4		

	; Temp_Var5 = Bowser's horizontal visibility flags
	LDA Objects_SprHVis,X
	STA <Temp_Var5	

	; Temp_Var6 = Bowser's vertical visibility flags
	LDA Objects_SprVVis,X
	STA <Temp_Var6

	LDY Objects_Frame,X
	CPY #$01
	BEQ PRG001_BDB4		; If Bowser's frame = 1, jump to PRG001_BDB4

	CPY #$07
	BNE PRG001_BDBB	 	; If Bowser's frame <> 7, jump to PRG001_BDBB

PRG001_BDB4:

	; Frame 7 is slightly lower than the others

	LDA <Temp_Var1
	ADD #$04
	STA <Temp_Var1

PRG001_BDBB:
	CPY #$08
	BEQ PRG001_BDD2	 ; If Bowser's frame = 8, jump to PRG001_BDD2

	CPY #$04
	BEQ PRG001_BDC7	 ; If Bowser's frame = 4, jump to PRG001_BDC7

	CPY #$06	 
	BLT PRG001_BDD2	 ; If Bowser's frame < 6, jump to PRG001_BDD2

PRG001_BDC7:

	; Bowser frame 4

	LDA Objects_FlipBits,X
	AND #SPR_VFLIP
	STA <Temp_Var3	 ; Temp_Var3 = $00 or SPR_VFLIP, depending whether Bowser is flipped vertically

	ORA #SPR_HFLIP
	STA <Temp_Var4	 ; Always set horizontal flip in Temp_Var4

PRG001_BDD2:
	LDA Objects_Frame,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var15	 ; Temp_Var15 = frame * 16

	LDA #$00
	STA <Temp_Var16

PRG001_BDDF:

	; This determines which Sprite_RAM offset table set we use.
	; Either 0 or 16, alternating every other frame.
	LDA <Counter_1
	AND #$01
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ADD <Temp_Var16	 ; Temp_Var16 = current sprite we're on
	TAY		 ; -> 'Y'

	LDA Bowser_SprRAMOff,Y
	TAY		 ; Index -> 'Y'

	LDX <Temp_Var16	 ; X = current sprite

	LDA <Temp_Var6	 	; Get Bowser's vertical visibility flags
	AND Bowser_SprVVisLUT,X	
	BNE PRG001_BE49	 	; If this sprite should not be drawn due to vertically being off-screen, jump to PRG001_BE49

	; Sprites are 0 through 12, so each horizontal sprite is by modulus 4
	TXA
	AND #$03	; Essentially mod 4
	TAX
	LDA <Temp_Var5	 ; Temp_Var5 = 0 to 3 based on which horizontal sprite we're doing

	AND Bowser_SprHVisLUT,X
	BNE PRG001_BE49	 ; If this sprite should not be drawn due to beging horizontally off-screen, jump to PRG001_BE49

	LDA <Temp_Var15	
	ADD <Temp_Var16	 ; Temp_Var16 = (Bowser's frame * 16 [Temp_Var15]) + (which sprite we're on)
	TAX		 ; -> 'X'

	; Store pattern of this Bowser sprite
	LDA Bowser_SprPats,X
	STA Sprite_RAM+1,Y

	LDX <Temp_Var16	 ; X = Temp_Var16

	LDA <Temp_Var3
	BPL PRG001_BE1A	 ; If Bowser is not vertically flipped, jump to PRG001_BE1A

	; Otherwise, use the vertically flipped lookups
	TXA
	ADD #(Bowser_SprYVFlipped - Bowser_SprYNotVFlipped)
	TAX

PRG001_BE1A:
	LDA <Temp_Var1	 	; A = Temp_Var1 (Bowser's Sprite Y)
	ADD Bowser_SprYNotVFlipped,X	; Offset Y as appropriate for this sprite
	STA Sprite_RAM,Y	; Set sprite Y

	LDX <Temp_Var16		; X = Temp_Var16
	TXA		 	
	AND #$03	 	; Get which horizontal sprite (of 4) we're on
	CMP #$02	 	; Horizontal sprite 2 would be the beginning of the "right half" of Bowser

	LDA <Temp_Var3		; A = Temp_Var3 (Bowser's flip bits)
	BLT PRG001_BE30	 	; If we are on the left half of Bowser, jump to PRG001_BE30

	LDA <Temp_Var4		; A = Temp_Var4 (Bowser's flip bits alternate)

PRG001_BE30:
	ORA #SPR_PAL3	 	; Lock in palette 3
	STA Sprite_RAM+2,Y	; Store sprite attributes

	LDA <Temp_Var3
	AND #SPR_HFLIP
	BEQ PRG001_BE40	 ; If Bowser is not horizontally flipped, jump to PRG001_BE40

	; Otherwise, use the horizontally flipped lookups
	TXA		 
	ADD #(Bowser_SprXHFlipped - Bowser_SprXNotHFlipped)
	TAX

PRG001_BE40:
	LDA <Temp_Var2		 ; A = Temp_Var2 (Bowser's Sprite X)
	ADD Bowser_SprXNotHFlipped,X	 ; Offset X as appropriate for this sprite
	STA Sprite_RAM+3,Y	 ; Set sprite X

PRG001_BE49:
	INC <Temp_Var16		 ; Temp_Var16++ (next sprite)

	; Bowser is made of a total of 12 sprites (4x3)
	LDA <Temp_Var16
	CMP #12	 
	BNE PRG001_BDDF	 ; If Temp_Var16 <> 12, loop!

	LDX <SlotIndexBackup	 ; Restore 'X' as Bowser's object slot index

	RTS		 ; Return

Bowser_CalcPlayersSide:

	; Backup Bowser's X
	LDA <Objects_X,X
	PHA

	; +8 Bowser's X; calculation of which side the Player is on is offset
	ADD #$08
	STA <Objects_X,X
	JSR Level_ObjCalcXDiffs

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	RTS		 ; Return


Bowser_HandleIfDead:
	; Handle Bowser if he's dead either from falling or weapon

	LDA <Objects_YHi,X	 
	CMP #$01
	BLS PRG001_BE6F	 ; If Bowser is way up high, jump to PRG001_BE6F

	; Bowser's not too high...

	LDA <Objects_SpriteY,X
	CMP #$88
	BGE PRG001_BE7F	 ; If Bowser's Y >= $88, jump to PRG001_BE7F

	; Bowser's not too low yet

PRG001_BE6F:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG001_BE98	 ; If Bowser's state is Normal, jump to PRG001_BE98 (RTS)

	; Bowser's state not Normal, now set it to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser got killed by weapon, set Bowser's Y velocity to -$30
	LDA #-$30
	STA <Objects_YVel,X

PRG001_BE7F:

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Disable timer
	LSR A	; A = 1
	STA Level_TimerEn

	; Set Bowser's frame to 6
	LDA #$06
	STA Objects_Frame,X

	; Clear Bowser's X Velocity and counter 1
	LDA #$00
	STA <Objects_XVel,X
	STA Bowser_Counter1

	; Set timer 3 to $30 (Delay until dramatic drop "song" begins)
	LDA #$30
	STA Objects_Timer3,X

PRG001_BE98:
	RTS		 ; Return


Bowser_FallAndSplat:
	LDY Objects_Timer3,X
	DEY		 ; Y--
	BNE PRG001_BEA4	 ; If timer 3 not expired, jump to PRG001_BEA4

	; Play dramatic Bowser fall
	LDA #MUS1_BOWSERFALL
	STA Sound_QMusic1

PRG001_BEA4:
	LDA Objects_HitCount,X
	CMP #$01
	BGS PRG001_BEB2	 ; If Bowser has at least one hit left, jump to PRG001_BEB2

	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

PRG001_BEB2:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	CMP #$25
	BGS PRG001_BEBD	 ; If Y velocity >= $25, jump to PRG001_BEBD

	INC <Objects_YVel,X	 ; Gravity while falling 

PRG001_BEBD:
	LDA <Objects_YHi,X
	CMP #$04	 
	BLS PRG001_BEDE	 ; If Bowser hasn't fallen down about 4 screens yet, jump to PRG001_BEDE

	; Bowser hits bottom...

	INC <Objects_Var5,X	 ; Objects_Var5 = 3

	; Set timer to $D0
	LDA #$d0
	STA Objects_Timer,X

	; Vibrate the floor 
	LDA #$80
	STA Level_Vibration

	; Ba-bam!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA <Player_InAir
	BNE PRG001_BEDE		; If Player is mid-air, jump to PRG001_BEDE

	; Bounce Player if he's on the ground
	LDA #-$40
	STA <Player_YVel

	; Mark Player as mid-air
	INC <Player_InAir

PRG001_BEDE:
	LDA <Objects_Y,X	; Get Bowser's Y
	PHA			; Save it
	ADD #16			; +16
	STA <Objects_Y,X	; -> Bowser's Y

	LDA <Objects_YHi,X	; Get Bowser's Y Hi
	PHA		 	; Save it
	ADC #$00	 	; Apply carry
	STA <Objects_YHi,X	; -> Bowser's Y Hi

	JSR Object_DetermineVertVis	; Check if Bowser is vertically invisible

	; Restore Y and Y Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	RTS		 ; Return

DoorAppear_YUpr:	.byte $60, $70
DoorAppear_X:	.byte $E8, $E8

PRG001_BEFB:	.byte $80, $88

Bowser_WaitAndVictory:
	LDA Objects_Timer,X	  
	BNE PRG001_BF09	 ; If timer hasn't expired, jump to PRG001_BF09 (RTS)

	; Play victory fanfare
	LDA #MUS1_WORLDVICTORY
	STA Sound_QMusic1

	INC <Objects_Var5,X	 ; Objects_Var5 = 3

PRG001_BF09:
	RTS		 ; Return

Bowser_DoTimeBonus:

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

	INC <Objects_Var5,X	 ; Objects_Var5 = 4

PRG001_BF16:
	RTS		 ; Return


Bowser_DoorAppear:
	LDA Objects_Timer,X	  
	BEQ PRG001_BF45	 ; If timer expired, jump to PRG001_BF45

	; Otherwise...

	CMP #$10
	BNE PRG001_BF40	 ; If timer <> $10, jump to PRG001_BF40

	; Door appearance sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

	LDY #$01	 ; Y = 1 (two tiles for the final door)
PRG001_BF27:

	; Using brick bust for door change
	LDA #$01
	STA BrickBust_En,Y

	; Door appearance coordinates
	LDA DoorAppear_YUpr,Y
	STA BrickBust_YUpr,Y
	LDA DoorAppear_X,Y
	STA BrickBust_X,Y

	LDA #$1f
	STA BrickBust_HEn,Y

	DEY		 ; Y--
	BPL PRG001_BF27	; While Y >= 0, loop

PRG001_BF40:
	RTS		 ; Return

	; Different palette colors applied to door
Bowser_FinalDoorColorCycle:
	.byte $21, $2A, $31, $26

PRG001_BF45:
	; Patterns for door
	LDA #$3e 
	STA PatTable_BankSel+4 

	LDY #$01	 ; Y = 1 
PRG001_BF4C:
	LDX Object_SprRAM,Y	 ; X = Sprite RAM Offset
 
	; Store Y parts where door appears
	LDA DoorAppear_YUpr,Y 
	STA Sprite_RAM,X 
	STA Sprite_RAM+4,X
 
	; Door patterns
	LDA #$a1 
	STA Sprite_RAM+1,X 
	STA Sprite_RAM+5,X
 
	; Door attributes
	LDA #$01 
	STA Sprite_RAM+2,X 
	STA Sprite_RAM+6,X
 
	; Store X parts of door
	LDA DoorAppear_X,Y 
	STA Sprite_RAM+3,X 
	ADD #$08 
	STA Sprite_RAM+7,X 

	DEY		 ; Y-- 
	BPL PRG001_BF4C	 ; While Y >= 0, loop!
 
	LDA <Player_YHi 
	BEQ PRG001_BF9B	 ; If Player is not low, jump to PRG001_BF9B
 
	LDA <Player_X 
	SUB #$e4 
	CMP #$08 
	BGE PRG001_BF9B	 ; If Player is way to the right, jump to PRG001_BF9B

	LDA <Player_Y 
	CMP #$48 
	BLT PRG001_BF9B	 ; If Player is higher than Y 48, jump to PRG001_BF9B

	; Player is low enough and not way to the right
	LDA <Pad_Holding 
	AND #PAD_UP
	BEQ PRG001_BF9B	 ; If Player is not pressing UP, jump to PRG001_BF9B
 
	; Jump to princess rescue scene
	STA Player_RescuePrincess	; Flag for princess rescue! 
	LDA #$00 
	STA Map_ReturnStatus 
	INC Level_ExitToMap 

PRG001_BF9B:
	LDA <Counter_1 
	LSR A	 
	LSR A	 
	AND #$03	 ; A = 0 to 3 
	TAY		 ; -> 'Y'

	; Store cycle color into palette buffer
	LDA Bowser_FinalDoorColorCycle,Y 
	STA Palette_Buffer+$15 

	; Queue palette update!
	LDA #$06
	STA Graphics_Queue 

	LDX <SlotIndexBackup	; X = object slot index 
	RTS		 ; Return

; Rest of ROM bank was empty

Try_PUp_Reserve:
	LDA Player_Ability
	CMP #$07
	BNE Cant_Reserve
	JSR Get_Normalized_Suit
	STA PowerUp_Reserve
Cant_Reserve:
	RTS

Do_PUp_Poof_Collect:
	STA Player_QueueSuit
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1
	LDA #$17
	STA Player_SuitLost
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State + 5
	RTS

Do_PUp_Pallete_Collect:
	STA Player_QueueSuit
	LDA #$1f
	STA Player_StarOff
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State + 5
	RTS
	

ObjInit_Snow:
	LDA #$01
	STA Objects_Var1, X


ObjInit_Rain:
	LDY #$05

KeepRandomizing:
	LDA Objects_Y, X
	LSR A
	LSR A
	LSR A
	LSR A
	STA TempA
	LDA Objects_X, X
	AND #$10
	BNE DontReverseWind
	LDA TempA
	EOR #$FF
	ADD #$01
	STA TempA
	
DontReverseWind:
	LDA TempA
	STA Wind
	JSR Randomize_Weather
	LDA RandomN
	STA Weather_YPos, Y
	DEY
	BPL KeepRandomizing
	RTS

WeatherDrawOffset:	
	.byte $00, $80

ObjNorm_Weather:
	LDA <Counter_1
	TAY
	LDA WeatherDrawOffset, Y
	STA <Temp_Var7
	LDA Object_SprRAM, X
	STA TempX
	LDY #$05

DoNextParticle:
	JSR MoveSingleParticle
	LDX TempX
	JSR DrawSingleParticle
	LDA TempX
	ADD #$04
	STA TempX
	DEY
	BPL DoNextParticle
	LDX <SlotIndexBackup
	RTS

MoveSingleParticle:
	LDA Weather_YPos, Y
	ADD Weather_YVel, Y
	CMP #$D0
	BCS Randomize_Weather

SetPosition:
	STA Weather_YPos, Y
	LDA Weather_XPos, Y
	ADD Weather_XVel, Y
	STA Weather_XPos, Y
	RTS

Randomize_Weather:
	STY TempY
	JSR Randomize
	LDY TempY
	LDX <SlotIndexBackup
	LDA RandomN
	STA Weather_XPos, Y
	LDA #$00
	STA Weather_YPos, Y
	LDA RandomN + 1
	AND #$07
	LDY Objects_Var1, X
	BEQ RainVel1
	ORA #$08

RainVel1:
	TAY
	LDA Rain_XVel, Y
	LDY TempY
	STA Weather_XVel, Y
	LDA RandomN + 2
	AND #$07
	LDY Objects_Var1, X
	BEQ RainVel2
	ORA #$08

RainVel2:
	TAY
	LDA Rain_YVel, Y
	LDY TempY
	STA Weather_YVel, Y
	LDA Objects_X, X
	AND #$10
	BNE DoNotReverse

	LDA Weather_XVel, Y
	EOR #$FF
	ADD #$01
	STA Weather_XVel, Y

DoNotReverse: 
	LDA RandomN + 3
	AND #$01
	LDY Objects_Var1, X
	BEQ RainPattern
	ORA #$02

RainPattern:
	TAY
	LDA Weather_Patterns, Y
	LDY TempY
	STA Weather_Pattern, Y
	RTS

DrawSingleParticle:
	LDA Weather_YPos, Y
	;ADD <Temp_Var7
	STA Sprite_RAM, X
	LDA Weather_XPos, Y
	;ADD <Temp_Var7
	STA Sprite_RAM + 3, X
	LDA Weather_Pattern, Y
	STA Sprite_RAM + 1, X
	LDA #$02
	STA TempA
	LDA Weather_XVel, Y
	BMI DontFlipParticle
	LDA #SPR_HFLIP
	ORA TempA
	STA TempA

DontFlipParticle:
	LDA TempA
	STA Sprite_RAM + 2, X
	RTS
	
Weather_Patterns: .byte $7B, $7B, $75, $75
Rain_XVel: .byte $04, $05, $06, $07, $04, $05, $06, $06
Snow_XVel: .byte $01, $01, $01, $01, $01, $01, $01, $01
Rain_YVel: .byte $03, $04, $03, $04, $03, $04, $03, $04
Snow_YVel: .byte $01, $01, $01, $01, $02, $02, $02, $02

ObjInit_GiantChomp:
	LDA #$00
	STA Objects_Var1, X
	RTS

ObjNorm_GiantChomp:
	LDA <Player_HaltGame
	BNE ChompDoneEating

	JSR Object_DeleteOffScreen
	JSR Object_Move
	JSR Level_ObjCalcXDiffs
	LDA <Temp_Var16
	CMP #$10
	BCS DoGCRoutine


DoGCRoutine:
	LDY #(SuperGiantOffsets1 - Object_TileDetectOffsets)
	JSR Object_DetectTile
	AND #TILE_PROP_SOLID_TOP
	BEQ TryEatRightBlock
	JSR ChompEatBlock
	JMP ChompDoneEating

TryEatRightBlock:
	LDY #(SuperGiantOffsets1  - Object_TileDetectOffsets)
	INY
	INY
	JSR Object_DetectTile
	AND #TILE_PROP_SOLID_TOP
	BEQ ChompDoneEating
	JSR ChompEatBlock

ChompDoneEating:
	LDA #LOW(GiantChompFrames)
	STA <Temp_Var10
	LDA #HIGH(GiantChompFrames)
	STA <Temp_Var11
	LDA <Counter_1
	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame, X
	JSR DrawGiantObject

DoneGC:
	RTS

GiantChompFrames:
	.byte $81, $83, $85, $87, $A1, $A3, $A5, $A7
	.byte $89, $8B, $8D, $8F, $A9, $AB, $AD, $AF

	
ChompEatBlock:
	LDA #$00
	STA <Objects_YVel, X
	LDA #$81
	STA Level_ChgTileEvent
	LDA ObjTile_DetYLo
	AND #$F0
	STA Level_BlockChgYLo
	LDA ObjTile_DetYHi
	STA Level_BlockChgYHi
	
	LDA ObjTile_DetXLo
	AND #$F0
	STA Level_BlockChgXLo
	LDA ObjTile_DetXHi
	STA Level_BlockChgXHi
	JSR PRG001_BC6D
	RTS

ObjInit_Brick:
	RTS

ObjNorm_Brick:
	LDA <Player_HaltGame
	BNE ObjNorm_BrickDraw

	JSR Object_Move
	JSR Object_HitTestRespond
	JSR Object_WorldDetect4

	LDA <Objects_DetStat,X
	BEQ ObjNorm_BrickDraw

	LDA #OBJ_STONEBLOCK
	STA Level_ObjectID, X
	RTS

ObjNorm_BrickDraw:
	LDA #$00
	STA Objects_Frame, X
	JSR Object_ShakeAndDrawMirrored
	RTS

ObjNorm_Boss:
	JSR DoBossFights
	RTS

KeyPieceGet:
	.byte $01, $02, $04, $08, $10

KeyPieceXOffset:
	.byte $10, $18, $20, $28, $30

ObjNorm_KeyPieces:
	INC Objects_Var2, X
	LDA Objects_Var2, X
	AND #$01
	STA TempA

	LDY Object_SprRAM, X
	LDA Objects_Var1, X
	STA <Temp_Var5
	LDA Objects_Property, X
	STA <Temp_Var6
	TAX

CheckNextPiece:
	
	LDA #$10
	STA Sprite_RAM, Y
	LDA #SPR_PAL3
	STA Sprite_RAM + 2, Y
	LDA <Temp_Var5
	AND KeyPieceGet, X
	BNE UseFilledKey

	LDA TempA
	BEQ UseFilledKey1

	LDA #$71
	BNE DrawKeyPiece

UseFilledKey:
	DEC <Temp_Var6

UseFilledKey1:
	LDA #$75

DrawKeyPiece:
	STA Sprite_RAM + 1, Y
	LDA KeyPieceXOffset, X
	STA Sprite_RAM + 3, Y
	INY
	INY
	INY
	INY

NextCheck:
	DEX
	BPL CheckNextPiece
	LDA <Temp_Var6
	BPL KeyPieceRTS

	JSR FindEmptyEnemySlot
	LDA #OBJ_KEY
	STA Level_ObjectID, X
	LDA #OBJSTATE_INIT
	STA Objects_State, X
	LDY <SlotIndexBackup
	LDA Objects_X, Y
	STA Objects_X, X
	LDA Objects_XHi, Y
	STA Objects_XHi, X
	LDA Objects_Y, Y
	STA Objects_Y, X
	LDA Objects_YHi, Y
	STA Objects_YHi, X
	LDX <SlotIndexBackup
	JMP Object_PoofDie
	

KeyPieceRTS:
	RTS


ObjNormal_KeyPiece:
	LDA <Player_HaltGame
	BNE DrawKeyPieceAnim

	JSR Object_DeleteOffScreen
	JSR Object_GetAttrAndMoveTiles
	JSR Object_HitTestRespond
	INC Objects_Var5, X
	LDA Objects_Var5, X
	AND #$01
	STA Objects_Frame, X

DrawKeyPieceAnim:
	JMP Object_ShakeAndDraw	


ObjHit_KeyPiece:
	LDY #$04

FindKeyTracker:
	LDA Level_ObjectID,Y
	CMP #OBJ_KEYPIECES
	BEQ SetKeyField
	DEY
	BPL FindKeyTracker
	RTS

SetKeyField:
	LDA Objects_Property, X
	TAX
	LDA Objects_Var1, Y
	ORA KeyPieceGet, X
	STA Objects_Var1, Y
	LDA #SND_MAPINVENTORYFLIP	 
	STA Sound_QMap	
	LDX <SlotIndexBackup
	LDA Objects_X, X
	STA Objects_X, Y
	LDA Objects_XHi, X
	STA Objects_XHi, Y
	LDA Objects_Y, X
	STA Objects_Y, Y
	LDA Objects_YHi, X
	STA Objects_YHi, Y
	JMP Object_SetDeadEmpty

CheckKeyAgainstLock:
	LDA Objects_LastProp,X
	CMP #TILE_ITEM_COIN
	BCS RemainLocked

	AND #$0F
	CMP #TILE_PROP_LOCK
	BNE RemainLocked

	LDA Level_ChgTileEvent
	BNE RemainLocked

	LDA Object_LevelTile
	EOR #$01
	STA Level_ChgTileEvent
	
	JSR SetObjectTileCoordAlignObj

	LDA #OBJSTATE_POOFDEATH
	LDX <SlotIndexBackup
	STA Objects_State, X

	LDA #$20
	STA Objects_Timer,X
	PLA
	PLA

RemainLocked:
	RTS
